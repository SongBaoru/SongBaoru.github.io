<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis | SBR Blog</title><meta name="author" content="Song Baoru"><meta name="copyright" content="Song Baoru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据类型5种基础数据类型string（字符串）Redis的string类似于Java的ArrayList，是动态字符串，可以被修改，采用预分配冗余空间的方式来减少内存的频繁分配。 空间分配规则：如果字符串长度小于1MB，扩容方式是加倍现有的空间，如果字符串长度超过1MB，扩容方式是只多扩1MB的空间。 支持的命令。  mset、mget命令可以实现对多个字符串进行批量读写。 ex后缀可以在set的">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis">
<meta property="og:url" content="https://songbaoru.github.io/2023/05/06/Redis/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:description" content="数据类型5种基础数据类型string（字符串）Redis的string类似于Java的ArrayList，是动态字符串，可以被修改，采用预分配冗余空间的方式来减少内存的频繁分配。 空间分配规则：如果字符串长度小于1MB，扩容方式是加倍现有的空间，如果字符串长度超过1MB，扩容方式是只多扩1MB的空间。 支持的命令。  mset、mget命令可以实现对多个字符串进行批量读写。 ex后缀可以在set的">
<meta property="og:locale">
<meta property="og:image" content="https://th.bing.com/th/id/OIP.wCDX4W_Glr7-BSlavnG2uAHaFj?pid=ImgDet&rs=1">
<meta property="article:published_time" content="2023-05-06T03:03:01.000Z">
<meta property="article:modified_time" content="2023-08-14T10:41:59.700Z">
<meta property="article:author" content="Song Baoru">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://th.bing.com/th/id/OIP.wCDX4W_Glr7-BSlavnG2uAHaFj?pid=ImgDet&rs=1"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://songbaoru.github.io/2023/05/06/Redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-14 18:41:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SBR Blog"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">SBR Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-06T03:03:01.000Z" title="Created 2023-05-06 11:03:01">2023-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-14T10:41:59.700Z" title="Updated 2023-08-14 18:41:59">2023-08-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/IT/">IT</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">12.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>40min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Redis"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="5种基础数据类型"><a href="#5种基础数据类型" class="headerlink" title="5种基础数据类型"></a>5种基础数据类型</h2><h3 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h3><p>Redis的string类似于Java的<code>ArrayList</code>，是动态字符串，可以被修改，采用预分配冗余空间的方式来减少内存的频繁分配。</p>
<p>空间分配规则：如果字符串长度小于1MB，扩容方式是加倍现有的空间，如果字符串长度超过1MB，扩容方式是只多扩1MB的空间。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/?group=string">支持的命令</a>。</p>
<ul>
<li><p>mset、mget命令可以实现对多个字符串进行批量读写。</p>
<p>ex后缀可以在set的时候指定过期时间。</p>
<p>nx后缀可以在set的时候如果key不存在才set。</p>
</li>
</ul>
<p><strong>用途示例</strong>：</p>
<ul>
<li>缓存用户信息，将用户信息序列化成字符串，存入Redis缓存，取出用户信息的时候会经过一次反序列化的过程。</li>
<li>Redis中所有数据结构都以唯一的字符串key作为名称。</li>
</ul>
<h3 id="list（列表）"><a href="#list（列表）" class="headerlink" title="list（列表）"></a>list（列表）</h3><p>Redis的list类似于Java的<code>LinkedList</code>，是双向链表，不是数组。</p>
<p>当 List 中的元素数量较少且元素都比较短时，Redis 通常会采用 ziplist 来存储；多个ziplist之间使用双向指针串联起来（避免在插入或删除数据时产生大量的内存拷贝），这种结构叫做quicklist（快速链表）。</p>
<p><a target="_blank" rel="noopener" href="https://redis.com/glossary/redis-ziplist/#:~:text=What%20is%20a%20ziplist%3F,%2C%20or%20floating%2Dpoint%20numbers.">ziplist</a> （压缩列表）是一个特殊的双向链表（本质上是一个字节数组）。<strong>ziplist的优点是节省内存</strong>，原因是使用了紧凑的内存布局，具体表现在：</p>
<ol>
<li>ziplist中的元素是连续存储的（内存分配是连续的），只需要对整个ziplist（整个ziplist包含了多个数据）进行内存对齐。</li>
<li>没有使用双向指针，而是使用了Prevlen（前一个entry的长度，entry是存储数据的节点）和Entrylen（当前姐节点的长度），通过长度推算元素位置。使用Prevlen和Entrylen的内存消耗通常比使用双向指针要小，因为一个listNode指针固定占用4字节（32位操作系统下）或8字节（64位操作系统下）。</li>
<li>没有使用ListNode作为存储实际数据的节点，除了Prevlen、Entrylen和Content（实际数据）外，没有其它组成部分（如内存对齐）会消耗内存。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/?group=list">支持的命令</a>有：rpush、rpop、lpush、lpop、lindex、lrange、ltrim等。</p>
<p><strong>用途示例</strong>：</p>
<ul>
<li>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。</li>
</ul>
<h3 id="hash（字典）"><a href="#hash（字典）" class="headerlink" title="hash（字典）"></a>hash（字典）</h3><p>Redis的hash类似于Java中的<code>HashMap</code>，底层也是数组+链表的实现方式。不同的是<strong>Redis的hash的值只能是字符串，且rehash的方式也不一样</strong>。rehash 是指在哈希表发生扩容时进行的重新哈希操作。</p>
<p>redis采用了<strong>渐进式哈希扩容</strong>的策略，通过分多次操作逐步完成整个扩容过程，避免服务阻塞的问题。具体来说，<strong>Redis 的哈希表扩容过程</strong>如下：</p>
<ol>
<li><p>创建新哈希表：系统会根据当前数据库的元素数量和设置的负载因子计算出扩容所需的最小桶数，然后创建一个新的哈希表，将其指针保存在旧哈希表的 rehashidx 属性中。</p>
</li>
<li><p>逐步 rehash 元素：从旧哈希表中取出一个桶（或一个链表），并将其中的元素 rehash 到新哈希表中，如果新哈希表中的相应桶为空，则直接插入元素；如果不为空，则使用链表结构将其作为链表头插入。这个过程需要遍历旧哈希表中所有的非空桶，每次操作都只处理一个桶中的元素，避免一次性处理过多数据。</p>
</li>
<li><p>完成 rehash：当旧哈希表中的所有元素都被 rehash 到新哈希表后，会释放旧哈希表占用的内存。</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/?group=hash">支持的命令</a>有：hset、hget、hlen、hgetall等。</p>
<p><strong>用途示例</strong>：</p>
<ul>
<li><p>缓存用户购物车信息，用户 id 为 key，商品 id 为 field，商品数量为 value。</p>
<p><img src="/2023/05/06/Redis/.././Redis/hash-shopping-cart.png" alt="使用hash缓存用户购物车信息|https://oss.javaguide.cn/github/javaguide/database/redis/hash-shopping-cart.png"></p>
</li>
</ul>
<h3 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h3><p>Redis的set类似于Java的<code>HashSet</code>，是无序的。set的底层有两种实现，hash和intset，通常使用hash保存set数据，hash中所有的value都是NULL，如果一个set全是整数，则使用字典过于浪费内存，为此Redis设计了insert数据结构，专门用来保存整数集合数据。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/?group=set">支持的命令</a>有：sadd、scard、sismember等，scard用于获取计数值。</p>
<p><strong>用途示例</strong>：</p>
<ul>
<li>需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等</li>
</ul>
<h3 id="zset（sorted-set，有序集合）"><a href="#zset（sorted-set，有序集合）" class="headerlink" title="zset（sorted-set，有序集合）"></a>zset（sorted-set，有序集合）</h3><p>Redis中的zset类似于Java中的<code>LinkedHashSet</code>，底层实现使用的是<strong>跳表（skiplist）</strong>。</p>
<p>zset相比set给每个元素增加了一个score参数，按照score进行排序。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/?group=sorted-set">支持的操作</a>：</p>
<ul>
<li>zadd：向有序集合添加一个或多个成员，并指定对应的分数。</li>
<li>zrank：获取成员在有序集合中的排名（从小到大）。</li>
<li>zrevrank：获取成员在有序集合中的倒序排名（从大到小）。</li>
<li>zrange：按照排名范围获取有序集合中的成员。</li>
<li>zrevrange：按照倒序排名范围获取有序集合中的成员。</li>
<li>zscore：获取成员的分数。</li>
<li>zincrby：增加成员的分数。</li>
<li>zrem：从有序集合中移除一个或多个成员。</li>
<li>zcard：获取有序集合元素的总和</li>
</ul>
<p><strong>用途示例</strong>：</p>
<ul>
<li>用在各种排行榜的场景，比如朋友圈的微信步数排行榜（value是用户id，score是步数，按照score排序），直播间送礼物的排行榜，王者荣耀中的段位排行榜，话题热度排行榜。</li>
</ul>
<h3 id="容器型数据结构的创建和删除规则"><a href="#容器型数据结构的创建和删除规则" class="headerlink" title="容器型数据结构的创建和删除规则"></a>容器型数据结构的创建和删除规则</h3><p>list、set、hash、zset这四种数据结构都是容器型数据结构，容器型数据结构遵从以下两条规则创建和删除规则：</p>
<ol>
<li>create if not exists：如果添加元素时容器不存在，就创建。</li>
<li>drop if no elements：如果容器里没有元素，那么立即删除容器释放内存。</li>
</ol>
<h2 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h2><h3 id="Bitmap（位图）"><a href="#Bitmap（位图）" class="headerlink" title="Bitmap（位图）"></a>Bitmap（位图）</h3><p>Redis提供了位图数据结构（不是全新的数据结构，底层其实是string字符串）。位图的最小单位是比特（0或1）。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/?group=bitmap">支持的命令</a>有：getbit、setbit、bitcount、bitpos、bitfield等。</p>
<p>bitcount用来统计指定范围内1的个数。</p>
<p>bitops用来查找指定范围内出现的第一个0或1的位置。</p>
<p>bitfield命令可以实现一次性对指定位片段进行多位操作，bitfield有三个子命令，get、set、incrby。如果使用incrby命令时出现了溢出，Redis默认的处理方式是折返（wrap），即不对溢出进行特殊处理，溢出之后是什么值就取什么值。Redis的bitfield命令选择溢出策略的子命令是overflow，用户可以选择溢出行为，包括折返、失败（fail，报错并不予执行）、饱和截断（sat，超过了范围就停留在最大或最小值）。</p>
<p><strong>用途示例</strong>：</p>
<ul>
<li>对于一些需要存储大量bool（布尔类型，只需要使用一位比特）型数据的情况（比如一年内的签到数据），如果使用普通的key-value，存储空间消耗极大。为解决这个问题，可以使用位图。</li>
</ul>
<h3 id="Geospatial（地理空间）"><a href="#Geospatial（地理空间）" class="headerlink" title="Geospatial（地理空间）"></a>Geospatial（地理空间）</h3><p>Redis的Geospatial可以实现存储和搜索坐标，适用于查找给定半径或边界框内的附近点，存在于Geo模块（处理地理位置信息的模块）中，底层使用的是zset。</p>
<p>Geospatial底层使用了GeoHash算法，<strong>GeoHash算法将二维的经纬度数据映射到一维的整数</strong>（使用二刀法等刀法实现），要寻找二维空间下的附近点时，只需要找映射后的一维坐标下的附近点。计算后的地图元素的坐标都会变为整数，通过这个整数可以还原出元素的坐标，<strong>整数越长，坐标值的损失程度越小</strong>。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/?group=geo">支持的命令</a>有：geoadd、geosearch等。</p>
<p><strong>用途示例</strong>：</p>
<ul>
<li>可以用于实现“附近的单车”、“附近的餐馆”这样的需要对地理位置距离进行搜索的功能。</li>
</ul>
<h3 id="HyperLogLog（基数概率计数）"><a href="#HyperLogLog（基数概率计数）" class="headerlink" title="HyperLogLog（基数概率计数）"></a>HyperLogLog（基数概率计数）</h3><p><strong><a target="_blank" rel="noopener" href="https://redis.io/docs/data-types/probabilistic/hyperloglogs/#:~:text=of%20a%20set.-,HyperLogLog%20is%20a%20probabilistic%20data%20structure%20that%20estimates%20the%20cardinality,a%20standard%20error%20of%200.81%25.">HyperLogLog</a> 是一种概率数据结构，用于估计集合的基数</strong>。作为一种概率数据结构。 <strong>Redis的HyperLogLog 实现最多使用 12 KB，并提供 0.81% 的标准错误。</strong></p>
<p>HyperLogLog之所以内存消耗如此之小，是因为HyperLogLog的存储算法具备这一特点：</p>
<ol>
<li>当计数比较小时，它的存储空间采用<strong>稀疏矩阵</strong>存储。</li>
<li><strong>计数值增大到稀疏矩阵占用空间超过阈值后，才会一次性转变为稠密矩阵，占用12KB</strong>。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/?group=hyperloglog">支持的命令</a>有：pfadd、pfcount、pfmerge等。pfadd用来添加数据，pfcount用来获取计数值，pfmerge用来合并HyperLogLog。</p>
<p><strong>用途示例</strong>：</p>
<ul>
<li><p>统计UV，由于统计UV需要去重，所以简单的方案是使用set，但是如果页面访问量很大，就存在浪费存储空间的问题。要统计网站上每个网页每天的UV数据总数，数据不需要太精确。更好的解决方案是使用提供了不精确的去重计数方案HyperLogLog。HyperLogLog的标准误差是0.81%，这样的精确度可以满足UV统计需求，并且，HyperLogLog 使用的内存消耗最多是12 KB，无论估算的基数有多大，它始终只占用 12 KB 的内存空间。</p>
<p>补充：</p>
<ul>
<li><p>UV（Unique Visitor）数据指的是<strong>网站或应用程序的独立访问者数量</strong>。UV数据用于衡量网站或应用程序的受众规模和用户活跃度。<strong>UV数据通常基于用户的唯一标识符（如用户ID、Cookie、设备ID等）进行统计，以便区分不同的访问者</strong>。它可以帮助网站或应用程序的管理者了解其用户群体的规模、用户活跃度、用户留存率等重要指标，从而做出相应的优化和决策。</p>
</li>
<li><p>PV（Page View）数据指的是网站或应用程序的<strong>页面访问次数</strong>。PV数据记录了每个页面被访问的次数，无论是同一个用户多次访问同一个页面，还是不同用户访问同一个页面，每一次访问都计算为一次PV。PV数据可以帮助评估网站或应用程序的流量、页面热度以及用户行为。</p>
</li>
</ul>
</li>
</ul>
<h3 id="Bloom-Filter（布隆过滤器）"><a href="#Bloom-Filter（布隆过滤器）" class="headerlink" title="Bloom Filter（布隆过滤器）"></a>Bloom Filter（布隆过滤器）</h3><p>布隆过滤器是一种概率数据结构，用于检查集合中是否存在元素。</p>
<p>Redis的布隆过滤器是从Redis4.0开始以插件的形式添加到Redis中的，要使用Redis的布隆过滤器，需要安装对应插件。</p>
<p>虽然HyperLogLog能够对数据进行去重计数，但是不能用来判断数据是否已存在。Bloom Filter就是主要用来判断对象是否存在的，相比set能够节省90%的空间，唯一不足是不精确，有一定的误判概率。在使用时，布隆过滤器的initial_size（预计放入的元素数量）参数越大，error_rate（误判率）越小。</p>
<p><strong>布隆过滤器的原理：</strong></p>
<p>布隆过滤器底层的数据结构是一个大型的位数组，添加key时，使用几个不同的无偏hash函数（所谓无偏就是能够把元素的hash值算得比较均匀，让key被hash映射到位数组中的位值比较随机），对添加到布隆过滤器的key进行hash，分别算出索引值，然后将索引值位置的值置为1。判断key是否存在时，对添加到布隆过滤器的key进行hash，分别算出索引值，然后看位数组中这几个位的值是否都是1，如果都是1，说明极有可能存在，如果不都是1，说明一定不存在。</p>
<p><strong>布隆过滤器判断结果的真实性的规则</strong>：</p>
<ol>
<li>如果布隆过滤器输出某个值存在，这个值可能不存在</li>
<li>如果布隆过滤器输出某个值不存在，这个值一定不存在</li>
</ol>
<p><strong>布隆过滤器的空间占用估计：</strong></p>
<p>使用布隆过滤器需要提供两个参数，位数组的长度和hash函数的数量，要计算出这两个参数合适的取值，需要进行空间占用估计，设定预计的元素的数量和错误率。</p>
<p>元素的数量（设为n），错误率（设为p），位数组的长度（设为m）和hash函数的数量（设为k）之间的关系是：</p>
<ul>
<li><p>k &#x3D; 0.7 * (m &#x2F; n)</p>
</li>
<li><p>p &#x3D; 0.6185 ^ (m &#x2F; n)</p>
</li>
</ul>
<p>可见，hash函数的最佳数量和（位数组的长度&#x2F;元素的数量）成正比，错误率和（位数组的长度&#x2F;元素的数量）成反比。</p>
<p><strong>当实际元素数量超过设置的预计元素的数量，错误率会有陡峭的增大</strong>，设实际元素数量和设置的预计元素的数量比值为T，使用的hash函数的数量是K，错误率（设为F）的计算公式是：</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs matlab">F = (<span class="hljs-number">1</span> - <span class="hljs-number">0.5</span>^T) ^ K;<br></code></pre></td></tr></table></figure>

<p>要计算这两个参数，可以使用<a target="_blank" rel="noopener" href="https://krisives.github.io/bloom-calculator">在线计算布隆过滤器计算器</a>，使用示例如下：</p>
<p><img src="/2023/05/06/Redis/.././Redis/image-20230522110209728.png" alt="在线计算布隆过滤器计算器"></p>
<p><strong>用途示例</strong>：</p>
<ul>
<li>在爬虫系统中对URL进行去重。</li>
<li>在NoSQL数据库中通过内存中的布隆过滤器过滤掉不存在的row的请求。</li>
<li>邮箱系统的垃圾邮件过滤。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/?group=bf">支持的命令</a>有：bf.add（一次添加一个元素）、bf.madd（一次添加多个元素）、bf.exists等。</p>
<h3 id="Stream（流）"><a href="#Stream（流）" class="headerlink" title="Stream（流）"></a>Stream（流）</h3><p>Redis Stream是Redis 5.0版本中新增的数据类型，可用于实现支持多播、可持久化的消息队列。</p>
<p><a target="_blank" rel="noopener" href="https://redis.io/commands/?group=stream">支持的操作</a>有：xadd、xdel、xrange、xread、xreadgroup等。</p>
<p>Stream由以下三部分构成：</p>
<ul>
<li><p>消费组</p>
<ul>
<li><p>每个Stream都可以挂载多个消费组（Consumer Group），每个消费组会有一个游标（last_delivered_id），用于表示当前消费组以及消费到哪条消息。</p>
<p>消费组之间是独立的。</p>
<p>一个消费组可以挂载多个消费者，任意一个消费者读取了消息都会使游标向前移动。</p>
</li>
<li><p>创建消费组</p>
<p>创建消费组的命令是xgroup create，创建消费组需要提供起始消息 ID 参数用来初始化 last_delivered_id 变量。</p>
</li>
<li><p>独立消费</p>
<p>可以不定义消费组，将 Stream 当成普通的消息队列（list）来使用。</p>
</li>
</ul>
</li>
<li><p>消息</p>
<ul>
<li><p>消息ID</p>
<p>消息 ID 的形式是 TimestampInMillis-sequence，例如 1527846880572-5，它表示当前的消息在毫秒时间戳 1527846880572 时产生，并且是该毫秒内产生的第 5 条消息。消息 ID 可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是 “整数-整数”，而且后面加入的消息的 ID 必须要大于前面的消息 ID。</p>
</li>
<li><p>消息内容</p>
<p>消息内容的形式的键值对。</p>
<p>Stream的消息有定长的功能，在 xadd 的指令中提供了一个长度参数 maxlen，就可以实现清除旧有超长的消息。</p>
</li>
</ul>
</li>
<li><p>消费者</p>
<ul>
<li><p>pending_ids</p>
<p>每个消费者中维持一个状态变量pending_ids，简称为PEL(Pending Entries List)，记录了当前已经被客户端读取的但尚未被ACK的消息。</p>
</li>
<li><p>消息ID可以指定读取的起始位置，如<code>0</code>表示从最早的消息开始读取，或者使用特殊符号<code>&gt;</code>表示从当前最新的消息开始读取。</p>
</li>
<li><p>处理完消息后，消费者需要使用<code>XACK</code>命令确认消息的处理完成。</p>
</li>
</ul>
</li>
</ul>
<p>在Stream出现之前，Redis中<strong>支持消息多播</strong>的模块是PubSub（PublisherSubscriber，发布者-订阅者）。</p>
<p>消息多播允许生产者只生产一次消息，由中间件负责将消息复制到多个消息队列，每个消费队列由对应的消费组进行消费。这是分布式系统常用的一种解耦方式，用于将多个消费组的逻辑进行拆分。</p>
<p>PubSub的缺点是当生产者发送消息时，如果消费者下线没有收到消息，那么该消息对于该消费者来说就是彻底丢失了正式因为PubSub有这个缺点，在消息队列的领域几乎找不到合适的应用场景。Redis5.0新增了Stream数据结构，给Redis带来了持久化的消息队列，从此PubSub退出作为消息队列的技术方案选项。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="info指令"><a href="#info指令" class="headerlink" title="info指令"></a>info指令</h2><ul>
<li>info stats：查看Redis 每秒执行多少次指令。</li>
<li>info clients：查看Redis 连接了多少客户端。</li>
<li>rejected_connections：查看因为超出大量连接限制而被拒接的客户端连接次数。如果这个数字很大意味着服务器的最大连接数设置的过低，需要调整 maxclients 参数。其默认值为 1w。</li>
<li>info memory：查看Redis 内存占用多大、使用的内存分配库等信息</li>
<li>info replication：查看复制积压缓冲区大小</li>
</ul>
<h2 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h2><p>scan是一个Redis命令，用于从海量的key中找出满足特定key（特定前缀的key、大key等）列表。相比Redis之前提供的keys命令（也可以完成这一功能）scan具备以下特点：</p>
<ul>
<li>虽然复杂度也是O(n)，但它是通过游标分步进行的，不会阻塞线程</li>
<li>提供了limit参数，可以控制服务器单次遍历的最大条数</li>
<li>返回的结果可能有重复（key存储在hash中，hash缩容时会重复遍历正在遍历的槽），需要客户端去重</li>
</ul>
<p>scan指令返回的游标就是第一维数组的位置索引（槽，slot），limit参数就表示需要遍历的槽位数</p>
<p>scan的遍历顺序是高进位加法，高进位加法从左边加，进位往右边移动。</p>
<p>对于rehash中的字典，scan会同时访问新旧两个数据结构</p>
<p>除了有可以遍历key的scan指令外，还有针对其它容器集合的遍历操作：</p>
<ul>
<li>sscan：遍历set集合</li>
<li>zscan：遍历zset集合</li>
<li>hscan：遍历hash字典中的元素</li>
</ul>
<p>scan查找大key的方法是对于每个扫描出来的key，使用type指令获得key的类型，然后使用相应数据结构的size或len方法来得到value的大小，对于每一种类型，将大小排名的前若干名作为扫描结果输出。要编写上面过程的脚本比较繁琐，不过Redis官方已经在<a target="_blank" rel="noopener" href="https://redis.io/docs/ui/cli/">redis-cli指令</a>中提供了这样的扫描功能。</p>
<p>示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 127.0.0.1 -p 6379 --bigkeys<br></code></pre></td></tr></table></figure>

<p>还可以限制扫描的执行时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.1<br></code></pre></td></tr></table></figure>

<p>上面这条指令使用-i选项限制每个<code>SCAN</code>命令的延迟时间应不超过0.1秒。</p>
<p>补充：</p>
<p>大key：指的是key对应的value值大，在实际业务中要尽量避免大key的产生，原因是大key会带来如下坏处：</p>
<ul>
<li>请求阻塞：redis为单线程，读、写或删除大key需要较长的处理时间，会阻塞后续的请求处理。</li>
<li>网络阻塞：大key会明显需要更长的传输时间，在整个传输时间内，占用大量的带宽，导致网络阻塞。</li>
<li>占用内存：大 key 在 Redis 内部通常会占用较多的内存空间，导致 Redis 的整体内存使用率变高，可能会引起内存溢出等问题。</li>
</ul>
<h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><p>Redis中所有<strong>对象</strong>都可以设置<strong>过期时间</strong>。例如，<strong>可以对一个hash对象设置过期时间，但是不能只对某一个key-value设置过期时间</strong>。需要注意的是，如果一个对象已经设置了过期时间，然后调用set修改了这个对象，那么之前设置的过期时间就会失效。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h3 id="RDB日志（内存快照）"><a href="#RDB日志（内存快照）" class="headerlink" title="RDB日志（内存快照）"></a>RDB日志（内存快照）</h3><p>RDB（Redis DataBase）日志（内存快照）是内存数据的二进制序列化，是<strong>全量备份</strong>。</p>
<p>内存快照要求Redis必须进行文件IO操作，而Redis是单线程程序，如果一边处理业务请求，一边进行文件IO操作，会降低处理业务请求的性能，还有个问题是，这种操作下，内存数据一边被持久化一边被修改，快照就不是对一个时间点的记录，而是成了多个时间点交错的记录，无法使用。</p>
<p>Redis使用操作系统多进程COW（Copy On Write）机制来实现快照持久化。</p>
<p>Copy-On-Write（COW）是一种操作系统中常用的技术，其基本思想是：当多个进程需要访问同一块内存地址时，操作系统会将这块内存标识为只读，并且在任何进程试图写入该内存前，都会复制一份副本供该进程使用。这样就能够保证每个进程都拥有自己的独立内存空间，而不会互相干扰。</p>
<h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p>AOF（Append Only File）日志是内存数据修改的指令记录文本，是<strong>增量备份</strong>。</p>
<p>Redis收到客户端的修改命令后，进行参数校验、逻辑处理，如果没问题，就执行该指令，然后将该指令文本存储到AOF日志中，即先执行指令再将指令存储到AOF日志。</p>
<p>AOF日志在长期的运行过程中会变得十分庞大，数据库重启时需要加载AOF日志进行指令重放，这个过程就会很漫长，所以需要定期进行<strong>AOF重写</strong>，给AOF日志进行瘦身。Redis提供了bgrewriteaof命令用于对AOF日志进行瘦身，其原理是开辟一个子进程对内存进行遍历，转换成一系列Redis的操作命令，序列化到一个新的AOF日志文件中，序列化完成后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，追加完毕后就可以替代旧的AOF日志文件了。</p>
<p>当程序对AOF日志文件进行写操作时，实际上是将内容写到了以内核为文件描述符分配的一个内存缓存中，然后内核会异步地将脏数据刷回到磁盘。这就意味着，如果突然宕机，AOF日志还没有完全刷新到磁盘中，就会出现日志丢失。Linux的glibc提供的fsync(int fd)函数可以将指定文件的内容<strong>强制从内核缓存刷新到磁盘</strong>，只要Redis进行实时调用fsync函数就可以保证AOF日志不丢失。但是fsync是一个磁盘IO操作，很慢，如果Redis执行一条指令就要fsync一次，那么会严重降低Redis的性能。所以在生产环境的服务器中，Redis通常是每隔1s左右执行一次fsync操作，这个1s的周期是可以配置的，是在<strong>安全性和性能间做的折中</strong>。</p>
<p>因为RDB和AOF都会加重系统的负担，所以通常Redis的主节点不会进行持久化操作，持久化操作主要在从节点进行，这是因为从节点没有来自客户端请求的压力，系统资源充足。</p>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>使用RDB恢复内存状态会丢失备份后修改的数据，而使用AOF日志的全量文件重放又相对RDB慢很多，Redis为解决这个问题，从Redis4.0开始，引入了一个新的持久化选项，混合持久化。</p>
<p><strong>混合持久化的持久化方式是指生成RDB全量日志和该RDB的AOF增量日志，在Redis重启的时候，先加载RDB日志，再加载AOF日志。</strong></p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><p>Redis在内存分配方面，直接使用了<strong>第三方的内存分配库</strong>，目前Redis使用jemalloc（是Facebook开发的）库来管理内存，也可以切换到tcmalloc（是Google开发的），因为jemalloc比tcmalloc性能稍好，所以<strong>Redis默认使用jemalloc进行内存分配</strong>。</p>
<p>通过<code>info memory</code>可以查看Redis使用的是哪个第三方的内存分配库。</p>
<h2 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>EXPIRE命令可以为指定的键设置过期时间，<strong>时间到达后，这些建会被自动删除</strong>。</p>
<p>serverCron函数会定时触发expire.c下的activeExpireCycle函数，该函数会清除数据库中的过期数据，该函数可以设置最长执行时间和每次删除操作删除的最大的key数量。以避免删除操作延时过长。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p><strong>惰性删除是当用户查询键时</strong>，检测键是否过期，如果键已经过期，则删除该键。该操作由expireIfNeeded函数完成。</p>
<h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>被删除的key分散在很多页面中，这个页面可能还有其它正在使用的key，<strong>操作系统是以页为单位进行内存回收的</strong>，这个页上只要还有一个key在使用，那这个页就不能回收。</p>
<p>Redis虽然无法保证立即回收已经删除key的内存，但是它会<strong>重新使用那些尚未回收的空闲内存</strong>。</p>
<h2 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h2><p><a target="_blank" rel="noopener" href="https://redis.io/docs/reference/eviction/">Redis官方给出的数据淘汰策略（Eviction policies）文档</a>给出Redis支持的数据淘汰策略包括：</p>
<ul>
<li><strong>noeviction</strong>: New values aren’t saved when memory limit is reached. When a database uses replication, this applies to the primary database</li>
<li><strong>allkeys-lru</strong>: Keeps most recently used keys; removes least recently used (LRU) keys</li>
<li><strong>allkeys-lfu</strong>: Keeps frequently used keys; removes least frequently used (LFU) keys</li>
<li><strong>volatile-lru</strong>: Removes least recently used keys with the <code>expire</code> field set to <code>true</code>.</li>
<li><strong>volatile-lfu</strong>: Removes least frequently used keys with the <code>expire</code> field set to <code>true</code>.</li>
<li><strong>allkeys-random</strong>: Randomly removes keys to make space for the new data added.</li>
<li><strong>volatile-random</strong>: Randomly removes keys with <code>expire</code> field set to <code>true</code>.</li>
<li><strong>volatile-ttl</strong>: Removes keys with <code>expire</code> field set to <code>true</code> and the shortest remaining time-to-live (TTL) value.</li>
</ul>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>LRU（Least Recently Used）：如果一个数据在<strong>最近一段时间内（LRU记录的是时间戳）没有被访问</strong>，那么可以认为它未来被访问的概率很小。当空间满时，最久没有访问的数据会最先被淘汰。</p>
<p><strong>Redis中使用的LRU算法是一种近似LRU算法</strong>，没有维护key的被访问时间顺序，而是采用随机采样出N个（比如5个，可以设置），然后淘汰掉最旧的key，为能够识别出key的访问时间，Redis给每个key增加了一个额外的字段，最后一次被访问的时间戳。</p>
<h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>LFU（Least Frequently Used）：如果一个数据在<strong>最近一段时间内很少（LFU记录的是使用次数）被访问</strong>，那么认为将来它被访问的可能性很小。当空间满时，最小频率访问的数据最先被淘汰。<strong>Redis中使用的LFU算法是一种近似LFU算法</strong>。</p>
<p>Redis会根据键的空闲时间对LFU计数进行衰减。</p>
<h1 id="三种并发读写场景中的缓存模式"><a href="#三种并发读写场景中的缓存模式" class="headerlink" title="三种并发读写场景中的缓存模式"></a>三种并发读写场景中的缓存模式</h1><h2 id="旁路缓存（Cache-Aside）模式"><a href="#旁路缓存（Cache-Aside）模式" class="headerlink" title="旁路缓存（Cache-Aside）模式"></a>旁路缓存（Cache-Aside）模式</h2><p>读写缓存或数据库的操作都在应用程序中完成。是业务系统最常用的缓存模式。</p>
<p>读操作的流程：</p>
<ol>
<li>先从缓存中查找数据。</li>
<li>如果数据存在，则返回数据。</li>
<li>如果数据不存在，则从数据库中查找数据，并存入缓存中，然后返回数据。</li>
</ol>
<p>写操作的流程：</p>
<ol>
<li>先写入数据库。</li>
<li>再删除缓存。</li>
</ol>
<p>旁路缓存模式在写入的时候，为什么是先写入数据库再删除缓存，为什么是删除缓存而不是更新缓存？要回答这些问题，需要就不同的策略逐个进行分析，寻找不足。</p>
<ol>
<li><p><strong>先删除缓存再更新数据库（解答为什么是先写入数据库再删除缓存）</strong></p>
<p>如果按照先删除缓存，再更新数据库的策略，会出现如下操作顺序（A，B是两台微服务，A执行更新操作，B执行读取操作）：</p>
<ol>
<li>A删除缓存</li>
<li>B从数据库读取数据</li>
<li>B更新缓存（缓存中的数据最终是A更新数据库前的数据）</li>
<li>A更新数据库（数据库中的数据是A更新的数据）</li>
</ol>
<p><strong>出现数据库和缓存数据不一致的问题</strong>，且问题会一直持续下去，直到不再出现这种操作顺序。</p>
</li>
<li><p>先更新数据库，再<strong>更新缓存而不是删除缓存（解答为什么是删除缓存而不是更新缓存）</strong></p>
<p>如果按照更新缓存而不是删除缓存的策略，会出现如下操作顺序（A，B是两台微服务，A和B都执行更新操作）：</p>
<ol>
<li>A更新数据库</li>
<li>B更新数据库（数据库中的数据最终是B更新的数据）</li>
<li>B更新缓存</li>
<li>A更新缓存（缓存中的数据最终是A更新的数据）</li>
</ol>
<p><strong>出现数据库和缓存数据不一致的问题</strong>，且问题会一直持续下去，直到不再出现这种操作顺序。</p>
</li>
<li><p>先更新数据库再删除缓存（<strong>旁路缓存模式</strong>）</p>
<p>先更新数据库再删除缓存，基本上可以解决并发读写场景中缓存和数据库中的数据不一致的问题。但是，在一些特殊场景中，还是会存在数据不一致的问题。这种特殊的场景就是，更新完数据库后，删除缓存的操作出现卡顿，导致其它服务读取到的数据不是数据库中最新的数据。</p>
<p>如果出现这种特殊场景，那么操作顺序如下（A，B是两台微服务，A执行更新操作，B执行读取操作）：</p>
<ol>
<li>A更新数据库</li>
<li>B从缓存中查询数据（<strong>仅仅可能出现短暂的不一致</strong>，下一步A删除缓存后又能重新保证数据库和缓存中数据的一致）</li>
<li>A删除缓存</li>
</ol>
<p>出现数据不一致的时间仅仅是执行更新数据库和删除数据库之间短暂的时间长度，这种数据不一致不会一致持续下去，删除缓存执行完毕后又会重新保证数据的一致性。</p>
</li>
</ol>
<h2 id="读-x2F-写穿透（Read-x2F-Write-Through）模式"><a href="#读-x2F-写穿透（Read-x2F-Write-Through）模式" class="headerlink" title="读&#x2F;写穿透（Read&#x2F;Write Through）模式"></a>读&#x2F;写穿透（Read&#x2F;Write Through）模式</h2><p>读写缓存或数据库的操作不在应用程序中完成，而是在一层独立的缓存程序Cache Provider中完成。能够让应用程序代码更简洁，同时也减少了数据库的负载。适合写操作多，数据一致性要求高的场景，在银行系统中应用较多。</p>
<p>读操作的流程：</p>
<ol>
<li>应用程序向Cache Provider查询数据。</li>
<li>由Cache Provider按照和旁路缓存模式的读操作流程一样的流程读取数据。</li>
</ol>
<p>写操作的流程：</p>
<ol>
<li>应用程序向Cache Provider写入数据。</li>
<li>Cache Provider先写入缓存，再写入数据库。</li>
</ol>
<h2 id="异步回写（Write-Behind）模式"><a href="#异步回写（Write-Behind）模式" class="headerlink" title="异步回写（Write Behind）模式"></a>异步回写（Write Behind）模式</h2><p>在写入时，异步回写模式只更新缓存，不同步更新数据库，而是异步批量写入数据库，读&#x2F;写穿透模式是同步更新缓存和数据库。所以异步回写模式性能高，但是可能会丢失数据，数据可靠度低，非常适合一些数据变化频繁，又对数据一致性要求没那么高的场景，如浏览量、点赞量。</p>
<h1 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h1><h2 id="Redis序列化协议（RESP）"><a href="#Redis序列化协议（RESP）" class="headerlink" title="Redis序列化协议（RESP）"></a>Redis序列化协议（RESP）</h2><p>RESP是Redis序列化协议（Redis Serialization Protocal）的简写，是一种直观的文本协议。</p>
<p>RESP将传输的数据分为5种最小单元类型，单元结束时统一加上回车换行符号\r\n。<a target="_blank" rel="noopener" href="https://redis.io/docs/reference/protocol-spec/">单元开始时使用符号标识不太的数据类型</a>：</p>
<ul>
<li>For <strong>Simple Strings</strong>, the first byte of the reply is “+”</li>
<li>For <strong>Errors</strong>, the first byte of the reply is “-“</li>
<li>For <strong>Integers</strong>, the first byte of the reply is “:”</li>
<li>For <strong>Bulk Strings</strong>（批量字符串）, the first byte of the reply is “$”. A “$” byte followed by the number of bytes composing the string (a prefixed length), terminated by CRLF.</li>
<li>For <strong>Arrays</strong>, the first byte of the reply is “<code>*</code>“</li>
</ul>
<p>NULL用多行字符串表示，不过长度要写成-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$-1\r\n<br></code></pre></td></tr></table></figure>

<p>客户端向服务端发送的指令只有一种格式，多行字符串数组。比如指令<code>set author codehole</code>会被序列化为下面的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*3\r\n$3\r\nset\r\n$6\r\nauthor\r\n$8\r\ncodehole\r\n<br></code></pre></td></tr></table></figure>

<p>服务端向客户端返回的数据结构有的比较复杂，不过也是以上五种基本类型的组合。例如scan命令的返回给客户端的结果，scan命令返回的是一个嵌套数组，数组的第一个值表示游标的值，如果这个值为零，说明已经遍历完毕。scan返回结果示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*2\r\n$1\r\n0\r\n*3\r\n$4\r\ninfo\r\n$5\r\nbooks\r\n$6author\r\n<br></code></pre></td></tr></table></figure>

<p>里面嵌套了一个数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*3\r\n$4\r\ninfo\r\n$5\r\nbooks\r\n$6author\r\n<br></code></pre></td></tr></table></figure>

<p>虽然RESP协议里面有大量冗余的回车换行符，但是依然是非常受欢迎的一个文本协议。</p>
<h2 id="管道（Pipeline）"><a href="#管道（Pipeline）" class="headerlink" title="管道（Pipeline）"></a>管道（Pipeline）</h2><p><strong>Redis管道通过将多个命令打包在一起，然后一次性发送给Redis服务器，在一次通信中获得多个命令的执行结果。这样就可以减少通信次数，提高性能。</strong></p>
<p>Redis的管道不是由Redis服务器提供的技术，而是由客户端提供的。</p>
<p>使用Redis自带的压力测试工具redis-benchmark,，可以测试出设置不同的单个管道内并行的请求数量所带来的QPS（Queries Per Second，每秒查询率）的改变。</p>
<h2 id="I-x2F-O模型"><a href="#I-x2F-O模型" class="headerlink" title="I&#x2F;O模型"></a>I&#x2F;O模型</h2><h3 id="5种常见的IO模型"><a href="#5种常见的IO模型" class="headerlink" title="5种常见的IO模型"></a>5种常见的IO模型</h3><ul>
<li><p><strong>阻塞IO模型</strong></p>
<p> 当我们调用套接字的读写放方法，默认是阻塞的，read操作是在没有读取到字节时线程阻塞，write操作是在写缓冲区已满时阻塞。</p>
<p> 典型应用：BIO（Blocking I&#x2F;O）</p>
</li>
<li><p><strong>非阻塞IO模型</strong></p>
<p> 非阻塞IO在套接字对象上设置了non_blocking，读写方法不会阻塞，会<strong>反复地发起读&#x2F;写请求</strong>，对于read操作，当内核准备好数据之后就进行读，对于写操作，当写缓冲区的有空闲空间就进行写。</p>
<p> 典型应用：Java NIO（Non-blocking I&#x2F;O，New I&#x2F;O）</p>
</li>
<li><p><strong>多路复用IO模型</strong></p>
<p> 一种简单的多路复用API是select，多个的进程的IO注册到一个复用器（select）上，然后用一个进程调用该select，select会监听所有注册进来的IO。</p>
<p> 如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；</p>
<p> 典型应用：epoll（linux系统的性能最好的多路复用API）。</p>
</li>
<li><p><strong>信号驱动IO模型</strong></p>
<p> 当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，<strong>进程便在信号处理函数中调用IO读取数据</strong>。</p>
</li>
<li><p><strong>异步IO模型</strong></p>
<p> 当进程发起一个IO操作，<strong>进程返回（不阻塞），但也不能返回结果</strong>；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则<strong>进程直接获取到数据</strong>。</p>
<ul>
<li>同步指的是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做，等前一件做完了才能做下一件事。</li>
<li>异步的概念和同步相对，当一个异步过程调用发出后，调用者不需要立刻得到结果。调用被执行完成后，会通知调用者。</li>
</ul>
<p> 典型应用：Java AIO（Asynchronous I&#x2F;O）</p>
</li>
</ul>
<p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/77752ed5.jpg" alt="常见I/O模型对比"></p>
<h3 id="Redis使用的IO模型"><a href="#Redis使用的IO模型" class="headerlink" title="Redis使用的IO模型"></a>Redis使用的IO模型</h3><p>Redis使用的是多路复用IO模型，在Linux环境下具体使用的API是epoll。<code>epoll</code> 可以高效地管理大量的文件描述符上的事件，获取事件的时候，<strong>不需要遍历整个文件描述符集合，只是遍历那些被内核IO事件异步唤醒而加入Ready队列的文件描述符集合</strong>。epoll没有最大文件描述符的限制，上限是最大可以打开文件的数目。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>Redis的事务<strong>不具备原子性</strong>，仅仅实现了事务的“串行化”，当前执行的事务不被其它的事务打断。Redis的事务通常会结合pipeline一起使用，可以将多次IO操作合并为一次。在Python的Redis客户端，Redis执行事务时要强制使用pipeline。</p>
<p>Redis事务的操作指令有multi、exec、discard、watch。分别表示事务的开始、提交、丢弃、监视变量。所有指令在exec之前不会执行，而是缓存在服务器的事务队列中。执行完毕后一次性返回所有指令的运行结果。</p>
<p>在 Redis 中，watch命令用来监视某个键，在服务器收到exec命令将要执行缓存的事务队列时，<strong>Redis会检查自变量被watch之后是否被改过</strong>。如果该键watch之后和exec之前被修改过，exec就会返回 NULL告诉客户端事务执行失败，这个时候客户端一般会选择重试。需要注意的是，Redis禁止在multi和exec之间执行watch命令，必须在multi之前watch变量。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WatchUsage</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">keyFor</span><span class="hljs-params">(String userId)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;account_%s&quot;</span>, userId);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doubleAccount</span><span class="hljs-params">(Jedis jedis, String userId)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyFor(userId);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//监视变量key</span><br>            jedis.watch(key);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Integer.parseInt(jedis.get(key));<br>            value &lt;&lt;= <span class="hljs-number">1</span>; <span class="hljs-comment">//乘以2</span><br>            <span class="hljs-comment">//事务开始</span><br>            <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> jedis.multi();<br>            transaction.set(key, String.valueOf(value));<br>            <span class="hljs-comment">//事务提交</span><br>            List&lt;Object&gt; result = transaction.exec();<br>            <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(jedis.get(key));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyFor(userId);<br>        jedis.setnx(key, String.valueOf(<span class="hljs-number">5</span>));<br>        System.out.println(doubleAccount(jedis, userId));<br>        jedis.close();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        输出结果：</span><br><span class="hljs-comment">        	10</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="主从同步（主从复制）"><a href="#主从同步（主从复制）" class="headerlink" title="主从同步（主从复制）"></a>主从同步（主从复制）</h2><h3 id="异步复制和同步复制"><a href="#异步复制和同步复制" class="headerlink" title="异步复制和同步复制"></a>异步复制和同步复制</h3><p>异步复制下的分布式Redis系统不满足CAP理论中的一致性（C，Consistency）。</p>
<p>同步复制：Redis3.0之后增加了wait指令，可以将主从复制由异步改为同步，可以设置需要同步的从节点的数量和最长等待时间（-1表示无限等待）。</p>
<p>Redis支持主从同步和从从同步（用以减轻主节点同步的负担）。</p>
<h3 id="快照（RDB）同步"><a href="#快照（RDB）同步" class="headerlink" title="快照（RDB）同步"></a>快照（RDB）同步</h3><p>快照同步是在主节点上进行一次bgsave，将当前内存的数据快照存储到磁盘，再将快照文件传输到从节点，从节点接收完毕后，执行全量加载，加载完毕后通知主节点进行增量同步。</p>
<p>进行快照同步时，文件IO操作十分耗时，且会影响fsync的执行，所以从Redis2.8.18开始支持<strong>无盘复制</strong>，主服务器通过套接字直接将内存中的快照发送给从节点，由从节点将接收到的快照存储到硬盘文件。</p>
<h3 id="增量（AOF）同步"><a href="#增量（AOF）同步" class="headerlink" title="增量（AOF）同步"></a>增量（AOF）同步</h3><p>Redis增量同步同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存buffer中，然后异步地将buffer中的指令同步到从节点。</p>
<p>Redis的buffer是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容，如果因为网络状况不好等原因没有及时的同步，那么没有同步的指令可能会被后续的指令覆盖，此时就需要使用快照同步。如果进行快照同步的过程中，buffer又发生了覆盖，就会引发又一次的快照同步，所以如果buffer大小设置不当，可能引起快照同步的死循环。</p>
<h3 id="增加节点后的同步方式"><a href="#增加节点后的同步方式" class="headerlink" title="增加节点后的同步方式"></a>增加节点后的同步方式</h3><p>当节点添加到集群，会先进行一次快照同步，完成后再继续进行增量同步。</p>
<h2 id="哨兵模式的主从复制集群"><a href="#哨兵模式的主从复制集群" class="headerlink" title="哨兵模式的主从复制集群"></a>哨兵模式的主从复制集群</h2><h3 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>Redis提供的Sentinel（哨兵）具体作用如下：</p>
<ol>
<li><strong>监控节点状况</strong>：持续监控主、从节点的在线状况。</li>
<li><strong>故障转移</strong>，主节点发生故障后。如果主节点下线，则选举新的主节点，并自动进行主从切换。</li>
<li><strong>向客户端提供节点信息</strong>：客户端连接集群时，会首先连接Sentinel，通过Sentinel查询主节点的地址，当主节点发生故障时，Sentinel会将最新的节点地址告诉客户端。主从切换后，为使客户端“知道”地址变更了，Sentinel会关闭所有的客户端连接，在重连时使客户端使用新的地址。</li>
<li><strong>限制主从延迟</strong>：可以通过设置参数<code>min-slaves-to-write</code>和<code>min-slaves-max-lag</code>来限制主从延迟，其中，<code>min-slaves-to-write</code>参数表示主节点至少需要有多少个从节点进行正常复制，如果不满足条件，则停止写服务。而<code>min-slaves-max-lag</code>参数表示在多少秒内没有收到从节点的反馈时，认为从节点的同步不正常。</li>
</ol>
<h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><p><strong>哨兵模式</strong>虽然解决了主从模式存在的一些问题，但其本身也存在一些弊端，比如数据在每个Redis实例中都是<strong>全量存储</strong>，极大地浪费了资源，为了解决这个问题，Redis提供了Redis Cluster，实现了<strong>数据分片存储</strong>。</p>
<h2 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h2><h3 id="Codis"><a href="#Codis" class="headerlink" title="Codis"></a>Codis</h3><p>Codis是Redis的集群代理中间件，当客户端向Codis发送指令时，Codis负责将指令转发到后面的Redis实例执行，并将返回结构转回给客户端。Code上挂接的所有Redis实例构成一个Redis集群，当集群空间不足时，可以通过动态增加Redis实例来实现扩容。</p>
<p>因为单个Codis代理能支撑的QPS有限，可以启动多个Codis代理增加QPS，还可以起到容灾的功能。</p>
<p><strong>Codis的槽位定位算法：</strong></p>
<p>Codis将key转发到对应Redis实例的定位机制是通过划分槽位实现的。Codis默认将所有的key划分为1024个槽位（slot），对客户端传入的key进行crc32运算计算hash值，然后用这个hash值对1024取余，这个余数就是key所属的槽位。</p>
<p>每个槽位都会映射到多个Redis实例。Codis会维护槽位和Redis实例的对应关系。当使用到多个Codis实例，就需要对不同Codis实例的槽位信息进行同步，需要使用一个分布式配置存储库如zookeeper，Codis会监听到槽位信息的变化并同步槽位信息。</p>
<p><strong>Codis处理Redis扩容：</strong></p>
<p>当Redis扩容（增加Redis实例）时，会对槽位关系进行调整，并进行自动均衡。</p>
<p><strong>使用Codis的缺点：</strong></p>
<p>由于key分散在不同的Redis实例中，所以不再支持事务。</p>
<p>客户端需要多走一个网络节点（Codis节点）才能到达Redis，性能上比直接访问Redis性能有所下降。</p>
<p><strong>Codis的优点：</strong></p>
<p>Codis在设计上比Redis Cluster简单，将分布式配置问题交给了第三方（zookeeper或etcd）负责，省去了编写和维护分布式一致性的工作。而Redis Cluster自己实现了这一点，混合使用了Raft和Gossip协议，有大量需要调优的配置参数，集群出现故障时不容易排查。</p>
<h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>与Codis不同，Redis Cluster是去中心化的，该集群由多个Redis节点组成，每个节点负责整个集群的一部分数据，它们之间使用一种特殊的二进制协议交互集群信息。</p>
<p>Redis Cluster将所有key划分为16382个槽位，每个节点负责存储其中一部分槽位映射信息。客户端连接集群时会得到一份集群的槽位配置信息，客户端可以直接根据该信息定位到目标节点（Redis实例）。</p>
<p><strong>Redis Cluster的槽位定位算法：</strong></p>
<p>Redis Cluster默认对key使用crs16算法进行hash，得到一个整数值，然后对16382取余得到具体的槽位。</p>
<p>Redis Cluster还允许用户强制把指定key挂在特定的槽位上，实现方法是在key字符串上添加tag标记。</p>
<p><strong>Redis Cluster的槽位纠错机制：</strong></p>
<p>当客户端向一个错误节点发出了指令，该节点会发现指令的key所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳跃指令（MOVED指令）携带目标操作的节点地址，告诉客户端去连接这个节点以获取数据。</p>
<p><strong>Redis Cluster的数据迁移策略：</strong></p>
<p>Redis Cluster的数据迁移的单位是槽，提供的迁移工具是redis-trib，redis-trib首先会在源节点和目标节点设置好中间过渡状态，然后再一次性获取源节点槽位的所有key列表，再逐个key进行迁移。每个key迁移的过程是，源节点对当前key执行dump指令得到序列化内容，然后向目标节点发送restore指令携带序列化的内容作为参数，目标节点再反序列化就可以把内容恢复到目标节点的内存中。然后返回给源节点OK信息，源节点收到后把当前节点的key删除。</p>
<p>当源节点正在进行对key的数据迁移，源节点的主线程就会处于阻塞状态，直到key被成功删除。在迁移过程中如果每个key都很小，migrate迁移指令会执行的很快，而如果key比较大，就会导致阻塞源节点的正常服务。</p>
<p>因为migrate命令是同步阻塞的，因此不会存在一个key正在被迁移又同时被读写的情况，但由于一个slot下可能有部分key被迁移完成，部分key正在等待迁移的情况，因此如果读写的key所属的slot正在被迁移，redis-cluster做如下处理：</p>
<ol>
<li>客户端根据本地slots缓存发送命令到源节点，如果存在键对象则直接指向并返回结果给客户端。</li>
<li>如果key对象不存在，但key所在的slot属于本节点，则可能存在于目标节点，这时源节点会回复ASK重定向异常<code>-ASK targetNodeAddr</code>，ASK中携带了目标节点的地址信息。</li>
<li>客户端从ASK重定向异常提取出目标节点的地址信息（targetNodeAddr），发送asking命令到目标节点。目标节点如果key存在则执行，不存在则返回不存在信息。</li>
</ol>
<p><strong>Redis Cluster处理网络抖动：</strong></p>
<p>网络抖动是突然间部分连接不可访问，然后很快又恢复正常的一种现象。</p>
<p>为解决网络抖动的问题，Redis Cluster提供了配置参数cluster-node-timeout，表示当前某个节点持续timeout的时间失联时，才认定该节点出现故障。如果没有这一配置选项，网络抖动会导致频繁的主从切换。</p>
<p><strong>Gossip协议：</strong></p>
<p>可能下线（PFail）和确定下线（Fail）：因为Redis Cluster是去中心化的，一个节点认为某个节点失联了并不代表所有节点都认为它失联了，所以集群需要进行一次协商，只有当大多数节点都认为某节点失联了，集群才做出节点已经下线的判断。</p>
<p>Redis Cluster采用Gossip协议来广播自己的状态以及改变对整个集群节点的在线状态。</p>
<h3 id="Codis和Redis-Cluster的不同"><a href="#Codis和Redis-Cluster的不同" class="headerlink" title="Codis和Redis Cluster的不同"></a>Codis和Redis Cluster的不同</h3><ol>
<li>Codis是中心化的（需要使用如zookeeper维护配置信息），<strong>Redis Cluster是去中心化的</strong>（通过Raft和Gossip协议自行维护配置信息）。</li>
<li>客户端访问Codis维护的Redis集群每次都需要经过Codis节点，而<strong>客户端访问Redis Cluster维护的Redis集群可以直接根据获取到的配置信息定位到Redis实例</strong>。</li>
<li>Codis的默认槽位数是1024，而<strong>Redis Cluster的默认槽位数是16382。</strong></li>
<li>Codis默认使用crc32算法计算key的hash值，Redis Cluster默认使用的是<strong>crc16</strong>。</li>
</ol>
<h1 id="Redis的特点"><a href="#Redis的特点" class="headerlink" title="Redis的特点"></a>Redis的特点</h1><ul>
<li>是单线程程序。除Redis外，Node.js和Nginx也都是单线程。</li>
<li>数据存储在内存中。</li>
<li>I&#x2F;O多路复用，是Redis能够处理大量客户端连接的原因。</li>
<li>速度快。</li>
</ul>
<p>Redis 速度快的原因主要包括以下几点：</p>
<ol>
<li><strong>内存存储</strong>：Redis 将数据存放在内存中，而不是硬盘上。因为内存访问速度比硬盘快得多，所以 Redis 能够达到非常快的读写速度，这也是 Redis 被称为高性能数据库的重要原因之一。</li>
<li><strong>单线程模型</strong>：Redis 使用单线程模型，即使用一个线程来处理所有的客户端请求，这使得 Redis 可以避免锁竞争、多线程切换等问题，从而提高了效率。</li>
<li><strong>高效的网络 IO 模型（ I&#x2F;O 多路复用）</strong>：Redis 使用了高效的网络 IO 模型， I&#x2F;O 多路复用的最大优势是系统开销小，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</li>
<li><strong>高效的数据结构</strong>：Redis 支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等，这些数据结构经过优化和精简，能够快速地进行插入、删除、查询等操作，从而提高了性能。比如rehash就是优化的一个例子。</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>钱文品. Redis深度历险:核心原理与应用实践. 北京: 电子工业出版社, 2019.1.</li>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">https://javaguide.cn/database/redis/redis-questions-01.html#redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84</a></li>
<li><a target="_blank" rel="noopener" href="https://redis.io/docs/data-types/">https://redis.io/docs/data-types/</a></li>
<li>梁国斌. Redis核心原理与实践. 北京: 电子工业出版社, 2021.8.</li>
<li>尼恩等. Java高并发核心编程:加强版. 卷3, 亿级用户Web应用架构与实战. 北京: 清华大学出版社, 2022.11.</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io">Song Baoru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io/2023/05/06/Redis/">https://songbaoru.github.io/2023/05/06/Redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post_share"><div class="social-share" data-image="https://th.bing.com/th/id/OIP.wCDX4W_Glr7-BSlavnG2uAHaFj?pid=ImgDet&amp;rs=1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="https://th.bing.com/th/id/R.826fae185d03cd7935cc5haf1cd1844c3?rik=9ONAxF3s06zoPg&amp;riu=http%3a%2f%2fpic5.bbzhi.com%2ffengjingbizhi%2fgaoqingziranfengjingbizhi%2fgaoqingziranfengjingbizhi_415690_15.jpg&amp;ehk=BbD3V6XWzCc5AJ7yXlMt4j5AU09Nk56syRdeDXFSvYY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">计算机网络</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/06/MySQL/" title="MySQL"><img class="cover" src="https://th.bing.com/th/id/R.3c9b5429b970ae83fb4ded208ce9c807?rik=VPifCoJ%2fpjqETw&amp;riu=http%3a%2f%2fpic16.nipic.com%2f20110906%2f128199_105134374000_2.jpg&amp;ehk=t%2f%2bs8eNL6%2b%2fAVJexV4GQnR77FSc2ZGNsU9v2lHWEueA%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">MySQL</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Song Baoru</div><div class="author-info__description">锲而不舍，金石可镂</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SongBaoru"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E7%A7%8D%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">5种基础数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string%EF%BC%88%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">string（字符串）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">list（列表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hash%EF%BC%88%E5%AD%97%E5%85%B8%EF%BC%89"><span class="toc-number">1.1.3.</span> <span class="toc-text">hash（字典）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#set%EF%BC%88%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">set（集合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zset%EF%BC%88sorted-set%EF%BC%8C%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">zset（sorted-set，有序集合）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%88%A0%E9%99%A4%E8%A7%84%E5%88%99"><span class="toc-number">1.1.6.</span> <span class="toc-text">容器型数据结构的创建和删除规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">高级数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmap%EF%BC%88%E4%BD%8D%E5%9B%BE%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">Bitmap（位图）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geospatial%EF%BC%88%E5%9C%B0%E7%90%86%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">Geospatial（地理空间）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLogLog%EF%BC%88%E5%9F%BA%E6%95%B0%E6%A6%82%E7%8E%87%E8%AE%A1%E6%95%B0%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">HyperLogLog（基数概率计数）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bloom-Filter%EF%BC%88%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%89"><span class="toc-number">1.2.4.</span> <span class="toc-text">Bloom Filter（布隆过滤器）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream%EF%BC%88%E6%B5%81%EF%BC%89"><span class="toc-number">1.2.5.</span> <span class="toc-text">Stream（流）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">2.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#info%E6%8C%87%E4%BB%A4"><span class="toc-number">2.1.</span> <span class="toc-text">info指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scan"><span class="toc-number">2.2.</span> <span class="toc-text">scan</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">2.3.</span> <span class="toc-text">过期时间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E6%97%A5%E5%BF%97%EF%BC%88%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7%EF%BC%89"><span class="toc-number">3.0.1.</span> <span class="toc-text">RDB日志（内存快照）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF%E6%97%A5%E5%BF%97"><span class="toc-number">3.0.2.</span> <span class="toc-text">AOF日志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">3.0.3.</span> <span class="toc-text">混合持久化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">4.1.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%88%A0%E9%99%A4"><span class="toc-number">4.2.</span> <span class="toc-text">数据删除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E5%88%A0%E9%99%A4"><span class="toc-number">4.2.1.</span> <span class="toc-text">定时删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="toc-number">4.2.2.</span> <span class="toc-text">惰性删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="toc-number">4.3.</span> <span class="toc-text">内存回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">4.4.</span> <span class="toc-text">数据淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU"><span class="toc-number">4.4.1.</span> <span class="toc-text">LRU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LFU"><span class="toc-number">4.4.2.</span> <span class="toc-text">LFU</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E7%BC%93%E5%AD%98%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">三种并发读写场景中的缓存模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98%EF%BC%88Cache-Aside%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.1.</span> <span class="toc-text">旁路缓存（Cache-Aside）模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB-x2F-%E5%86%99%E7%A9%BF%E9%80%8F%EF%BC%88Read-x2F-Write-Through%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">读&#x2F;写穿透（Read&#x2F;Write Through）模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%9B%9E%E5%86%99%EF%BC%88Write-Behind%EF%BC%89%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">异步回写（Write Behind）模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-number">6.</span> <span class="toc-text">数据传输</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%BA%8F%E5%88%97%E5%8C%96%E5%8D%8F%E8%AE%AE%EF%BC%88RESP%EF%BC%89"><span class="toc-number">6.1.</span> <span class="toc-text">Redis序列化协议（RESP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%EF%BC%88Pipeline%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">管道（Pipeline）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-x2F-O%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.</span> <span class="toc-text">I&#x2F;O模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%9A%84IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.1.</span> <span class="toc-text">5种常见的IO模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E4%BD%BF%E7%94%A8%E7%9A%84IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.3.2.</span> <span class="toc-text">Redis使用的IO模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">7.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">8.</span> <span class="toc-text">集群</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%EF%BC%88%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">主从同步（主从复制）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%E5%92%8C%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6"><span class="toc-number">8.1.1.</span> <span class="toc-text">异步复制和同步复制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E7%85%A7%EF%BC%88RDB%EF%BC%89%E5%90%8C%E6%AD%A5"><span class="toc-number">8.1.2.</span> <span class="toc-text">快照（RDB）同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%EF%BC%88AOF%EF%BC%89%E5%90%8C%E6%AD%A5"><span class="toc-number">8.1.3.</span> <span class="toc-text">增量（AOF）同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E8%8A%82%E7%82%B9%E5%90%8E%E7%9A%84%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">8.1.4.</span> <span class="toc-text">增加节点后的同步方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E9%9B%86%E7%BE%A4"><span class="toc-number">8.2.</span> <span class="toc-text">哨兵模式的主从复制集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Sentinel"><span class="toc-number">8.2.1.</span> <span class="toc-text">Sentinel</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.2.1.2.</span> <span class="toc-text">存在的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="toc-number">8.3.</span> <span class="toc-text">分片集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Codis"><span class="toc-number">8.3.1.</span> <span class="toc-text">Codis</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-Cluster"><span class="toc-number">8.3.2.</span> <span class="toc-text">Redis Cluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Codis%E5%92%8CRedis-Cluster%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-number">8.3.3.</span> <span class="toc-text">Codis和Redis Cluster的不同</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">9.</span> <span class="toc-text">Redis的特点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">10.</span> <span class="toc-text">References</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法二刷（更新中）"><img src="https://th.bing.com/th/id/R.ee995d98e687b0896c006b16980e126b?rik=ZPHZfBPZDznIiw&amp;riu=http%3a%2f%2fimg.sj33.cn%2fuploads%2fallimg%2f200912%2f20091223150352964.jpg&amp;ehk=ETvV5eN%2fU0LZJE9ZbDxQN%2btQkl3ZWmIGnhIp8GzKzZs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法二刷（更新中）"/></a><div class="content"><a class="title" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法二刷（更新中）">数据结构和算法二刷（更新中）</a><time datetime="2023-07-10T00:32:48.000Z" title="Created 2023-07-10 08:32:48">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/RocketMQ/" title="RocketMQ"><img src="https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJlbKx9CIKZ-qABs7mJV2aP0AALH5ALBgd0AGzuw770.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/2023/05/24/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2023-05-24T08:13:44.000Z" title="Created 2023-05-24 16:13:44">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img src="https://th.bing.com/th/id/OIP.fekfR1FWtn_EXSMaueufagHaEK?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud">Spring Cloud</a><time datetime="2023-05-24T08:08:42.000Z" title="Created 2023-05-24 16:08:42">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程"><img src="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&amp;riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&amp;ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程"/></a><div class="content"><a class="title" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程">Java并发编程</a><time datetime="2023-05-07T13:39:13.000Z" title="Created 2023-05-07 21:39:13">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://th.bing.com/th/id/R.826fae185d03cd7935cc5haf1cd1844c3?rik=9ONAxF3s06zoPg&amp;riu=http%3a%2f%2fpic5.bbzhi.com%2ffengjingbizhi%2fgaoqingziranfengjingbizhi%2fgaoqingziranfengjingbizhi_415690_15.jpg&amp;ehk=BbD3V6XWzCc5AJ7yXlMt4j5AU09Nk56syRdeDXFSvYY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-05-07T13:37:05.000Z" title="Created 2023-05-07 21:37:05">2023-05-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Song Baoru</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>