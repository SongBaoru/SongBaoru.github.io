<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL | SBR Blog</title><meta name="author" content="Song Baoru"><meta name="copyright" content="Song Baoru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL配置MySQL采用客户端-服务器架构，用户通过客户端程序发送增删改查请求，服务器程序收到请求后处理，并把处理结果返回给客户端。 启动选项MySQL安装目录的bin目录下的执行文件中，有一些是服务器程序（如mysqld），有一些是客户端程序（如mysql）。在命令行中指定启动选项时需要在选项名前加上–前缀，对于有选项值的启动选项，选项名、&#x3D;、选项值之间不能有空白字符。部分选项名有">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="https://songbaoru.github.io/2023/05/06/MySQL/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:description" content="MySQL配置MySQL采用客户端-服务器架构，用户通过客户端程序发送增删改查请求，服务器程序收到请求后处理，并把处理结果返回给客户端。 启动选项MySQL安装目录的bin目录下的执行文件中，有一些是服务器程序（如mysqld），有一些是客户端程序（如mysql）。在命令行中指定启动选项时需要在选项名前加上–前缀，对于有选项值的启动选项，选项名、&#x3D;、选项值之间不能有空白字符。部分选项名有">
<meta property="og:locale">
<meta property="og:image" content="https://th.bing.com/th/id/R.3c9b5429b970ae83fb4ded208ce9c807?rik=VPifCoJ%2fpjqETw&riu=http%3a%2f%2fpic16.nipic.com%2f20110906%2f128199_105134374000_2.jpg&ehk=t%2f%2bs8eNL6%2b%2fAVJexV4GQnR77FSc2ZGNsU9v2lHWEueA%3d&risl=&pid=ImgRaw&r=0">
<meta property="article:published_time" content="2023-05-06T03:02:46.000Z">
<meta property="article:modified_time" content="2023-08-29T13:02:05.637Z">
<meta property="article:author" content="Song Baoru">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://th.bing.com/th/id/R.3c9b5429b970ae83fb4ded208ce9c807?rik=VPifCoJ%2fpjqETw&riu=http%3a%2f%2fpic16.nipic.com%2f20110906%2f128199_105134374000_2.jpg&ehk=t%2f%2bs8eNL6%2b%2fAVJexV4GQnR77FSc2ZGNsU9v2lHWEueA%3d&risl=&pid=ImgRaw&r=0"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://songbaoru.github.io/2023/05/06/MySQL/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-29 21:02:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SBR Blog"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">SBR Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">MySQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-06T03:02:46.000Z" title="Created 2023-05-06 11:02:46">2023-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-29T13:02:05.637Z" title="Updated 2023-08-29 21:02:05">2023-08-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/IT/">IT</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">32.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>107min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="MySQL配置"><a href="#MySQL配置" class="headerlink" title="MySQL配置"></a>MySQL配置</h1><p>MySQL采用客户端-服务器架构，用户通过客户端程序发送增删改查请求，服务器程序收到请求后处理，并把处理结果返回给客户端。</p>
<h2 id="启动选项"><a href="#启动选项" class="headerlink" title="启动选项"></a>启动选项</h2><p>MySQL安装目录的bin目录下的执行文件中，有一些是服务器程序（如mysqld），有一些是客户端程序（如mysql）。在命令行中指定启动选项时需要在选项名前加上–前缀，对于有选项值的启动选项，选项名、&#x3D;、选项值之间不能有空白字符。部分选项名有短形式，使用短形式时，选项名前只加上一个-前缀，选项名和选项值之间<strong>可以</strong>没有间隙，部分短形式的选项名和选项值之间必须没有间隙，短形式的选项名是区分大小写的。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>大部分启动选项可以在配置文件中进行配置，MySQL程序启动时会在多个路径下寻找配置文件，不同的操作系统下，寻找配置文件的路径和路径的顺序也有所不同，如果在多个配置文件中设置了相同的启动选项，则以最后一个配置文件为准。</p>
<p>如果不想让MySQL在默认的路径中搜索配置文件，可以在命令行中指定使用default-file选项指定配置文件的位置。</p>
<p>使用配置文件进行配置时，等号两边可以有空白字符。</p>
<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>如允许同时连入的客户端的数量、查询缓存的大小等都是MySQL的系统变量。</p>
<p>查看系统变量的命令的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW VARIABLES [LIKE 匹配的模式]<br></code></pre></td></tr></table></figure>

<p>系统变量的作用范围分下面两种：</p>
<ol>
<li><p>GLOBAL（全局范围）：影响服务器的整体操作。</p>
<p>具有GLOBAL作用范围的系统变量可以称为全面变量。</p>
</li>
<li><p>SESSION（会话范围）：影响某个客户端连接的操作。</p>
<p>具有SESSION作用范围的系统变量可以称为会话变量。</p>
</li>
</ol>
<p>部分（有的系统变量是不能修改的，如MySQL的版本）系统变量可以在服务器运行过程中设置（即可设置全面变量，又可设置会话变量），且无需重启服务器；部分只能以启动选项的方式（在命令行中添加启动选项，或在配置文件中进行配置）进行设置（全面变量），如InnDB的页大小。</p>
<p>设置系统变量的命令的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET [GLOBAL|SESSION] 系统变量名 = 值;<br></code></pre></td></tr></table></figure>

<h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><h2 id="打开MySQL监视器"><a href="#打开MySQL监视器" class="headerlink" title="打开MySQL监视器"></a>打开MySQL监视器</h2><p>打开MySQL监视器的命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -u 用户名 -p密码<br></code></pre></td></tr></table></figure>

<p>或者使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -u 用户名 -p<br></code></pre></td></tr></table></figure>

<p>然后输入密码即可</p>
<h2 id="查看字符编码"><a href="#查看字符编码" class="headerlink" title="查看字符编码"></a>查看字符编码</h2><p>在监视器中查看MySQL中字符编码等的设置情况的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">status<br></code></pre></td></tr></table></figure>

<p>或者使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;char%&#x27;<br></code></pre></td></tr></table></figure>

<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>修改密码的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PASSWORD FOR root@localhost=PASSWORD(&#x27;新密码&#x27;)<br></code></pre></td></tr></table></figure>

<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>创建用户的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER 新用户名 IDENTIFIED BY ‘新用户的密码’<br></code></pre></td></tr></table></figure>

<p>用户名需要按照“用户名@主机名”的方式写</p>
<h2 id="设置用户权限"><a href="#设置用户权限" class="headerlink" title="设置用户权限"></a>设置用户权限</h2><p>设置用户权限的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CRANT 赋予的权限 ON 数据库名.表名 TO 用户名<br></code></pre></td></tr></table></figure>

<p>“赋予的权限”如果是所有权限就设为“ALL”，如果仅允许SELECL和UPDATE就设置为“SELECT,UPDATE”</p>
<p>如果是所有数据库的所有数据表，就设置为“*.*”</p>
<h2 id="退出监视器"><a href="#退出监视器" class="headerlink" title="退出监视器"></a>退出监视器</h2><p>退出监视器的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">exit<br></code></pre></td></tr></table></figure>

<p>或者使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">quit<br></code></pre></td></tr></table></figure>

<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><p>MySQL的SQL语句后面需要加分号。</p>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>创建数据库的命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE 数据库名;<br></code></pre></td></tr></table></figure>

<h2 id="指定使用的数据库"><a href="#指定使用的数据库" class="headerlink" title="指定使用的数据库"></a>指定使用的数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use 数据库名<br></code></pre></td></tr></table></figure>

<p>use不是SQL语句，所以不需要输入“;”</p>
<p>在使用use选择数据库的状态下也能够操作其他数据库的表，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM db2.table;<br></code></pre></td></tr></table></figure>

<p>在没有use db2的情况下也可以执行</p>
<h2 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h2><h3 id="显示当前已有的数据库"><a href="#显示当前已有的数据库" class="headerlink" title="显示当前已有的数据库"></a>显示当前已有的数据库</h3><p>显示当前已有的数据库的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASES;<br></code></pre></td></tr></table></figure>

<h3 id="显示当前使用的数据库"><a href="#显示当前使用的数据库" class="headerlink" title="显示当前使用的数据库"></a>显示当前使用的数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATABASE();<br></code></pre></td></tr></table></figure>

<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>在MySQL中，可以使用<code>DROP DATABASE</code>语句来删除已经存在的数据库。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE database_name;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>database_name</code>是想要删除的数据库的名称。例如，如果想删除名为<code>my_database</code>的数据库，可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE my_database;<br></code></pre></td></tr></table></figure>

<p>这将删除<code>my_database</code>数据库以及其中的所有表和数据。</p>
<p>类似地，也可以使用<code>IF EXISTS</code>子句来避免在尝试删除不存在的数据库时出现错误，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE IF <span class="hljs-keyword">EXISTS</span> database_name;<br></code></pre></td></tr></table></figure>

<p>如果<code>database_name</code>存在，那么它将被删除。如果它不存在，MySQL将发出一条警告，而不是一个错误，并允许查询继续。这对于自动化脚本或者不确定数据库是否存在时非常有用，因为它可以防止因尝试删除不存在的数据库而导致的错误。</p>
<h2 id="备份和恢复数据库"><a href="#备份和恢复数据库" class="headerlink" title="备份和恢复数据库"></a>备份和恢复数据库</h2><p>MySQL有多种备份数据库的方式，包括物理备份和逻辑备份，在备份时，需要根据实际情况选择最合适的备份方式，并保证备份数据的一致性、完整性和安全性。</p>
<ol>
<li>物理备份</li>
</ol>
<p>物理备份是指直接备份MySQL服务器中数据文件的一种方式。这种备份方式直接将数据文件复制到指定的备份目录下，并保持与原始数据文件的完全一致，因此恢复时也很快速。</p>
<p>物理备份包括两种主要类型：</p>
<ul>
<li>冷备份：停止MySQL服务后备份数据文件，优点是备份数据的一致性好，缺点是在备份期间无法进行数据库操作。</li>
<li>热备份：不停止MySQL服务进行备份，优点是可以在备份时继续对数据库进行操作，缺点是备份数据可能会因为正在执行的事务而不完整或不一致。</li>
</ul>
<p>物理备份的命令可以使用Linux中的cp、rsync等命令，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> -a /var/lib/mysql /backup/mysql_backup</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>逻辑备份</li>
</ol>
<p>逻辑备份是指通过SQL语句来生成备份文件，备份数据以可读性较好的文本格式保存，因此备份数据相对于物理备份较大，但可以进行较为精细的筛选和处理。</p>
<p>逻辑备份包括以下主要类型：</p>
<ul>
<li>mysqldump：可以备份指定的数据库或表，甚至可以备份数据库中的指定数据，生成.sql格式的备份文件。</li>
<li>mydumper：适用于大型数据库，生成多个文件来备份数据。</li>
<li>mysqlpump：在MySQL8.0及以上版本中提供了mysqlpump命令，该命令比mysqldump更快，也支持多线程和压缩。</li>
</ul>
<p>例如，使用mysqldump备份一个名为mydatabase的数据库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysqldump -u root -p mydatabase &gt; mydatabase_backup.sql</span><br></code></pre></td></tr></table></figure>

<p>在备份时，需要注意一些重要的问题：</p>
<ol>
<li>备份文件应当保存在安全的位置，并进行良好的加密措施。</li>
<li>常规的备份操作应当建立合理的时间间隔。</li>
<li>对于生产环境的数据库，建议还使用主从复制等业务高可用方案来增加数据可靠性。</li>
</ol>
<p>恢复MySQL备份文件则相对较简单，可以使用以下命令进行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysql -u root -p mydatabase &lt; mydatabase_backup.sql</span><br></code></pre></td></tr></table></figure>

<p>其中，mydatabase是需要恢复的数据库的名称，mydatabase_backup.sql是备份文件的路径。执行后，MySQL会将备份文件中的数据导入到MySQL服务器中，并重新生成所有的索引和约束条件，以保证数据的正确性和完整性。</p>
<p>在MySQL中，如果备份文件中的数据字符编码与目标数据库不一致，恢复数据时可能会出现乱码等问题。为了避免这种情况，可以通过指定字符集参数来将备份文件中的数据以正确的字符编码导入到目标数据库中。</p>
<p>以下是根据备份文件的字符集来重新设置字符集的命令示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysql -u root -p mydatabase --default-character-set=utf8 &lt; backup.sql</span><br></code></pre></td></tr></table></figure>

<p>其中，mydatabase是需要恢复的数据库的名称，backup.sql是备份文件的路径。–default-character-set选项用于指定字符集，可以根据实际情况设置编码类型和字符集。如果备份文件的字符编码为GBK，则可以将上述命令修改如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysql -u root -p mydatabase --default-character-set=gbk &lt; backup.sql</span><br></code></pre></td></tr></table></figure>

<p>在MySQL 5.5及以上版本中，默认的字符集为utf8mb4，因此如果备份文件中使用的是utf8或gbk等字符集，也需要显式地指定字符集参数。</p>
<p>另外，在备份时也应当考虑到字符编码的问题，建议在备份时同时备份字符集相关的信息。例如，在进行逻辑备份时，可以添加–set-charset选项来确保备份数据使用与数据库相同的字符集。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysqldump -u root -p mydatabase --set-charset &gt; mydatabase_backup.sql</span><br></code></pre></td></tr></table></figure>

<p>这样，在恢复数据时就无需再指定字符集，MySQL会自动使用与备份时相同的字符集导入数据。</p>
<h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>在MySQL中，可以使用<code>CREATE TABLE</code>语句来创建一个新的表。在<code>CREATE TABLE</code>语句中，可以指定表名，列名，列的数据类型以及任何附加的约束。</p>
<p>以下是一个创建新表的基本示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name (<br>    column1 datatype <span class="hljs-keyword">constraint</span>,<br>    column2 datatype <span class="hljs-keyword">constraint</span>,<br>    column3 datatype <span class="hljs-keyword">constraint</span>,<br>    ....<br>);<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>table_name</code>是要创建的表的名称，<code>column1</code>、<code>column2</code>和<code>column3</code>是列的名称，<code>datatype</code>是列的数据类型，<code>constraint</code>是任何想在列上应用的约束。</p>
<p>例如，假设想创建一个名为<code>students</code>的表，其中有<code>id</code>、<code>name</code>、<code>age</code>和<code>email</code>四个字段。可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> students (<br>    id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    age <span class="hljs-type">INT</span>,<br>    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>id</code>是一个整数类型的列，它自动递增并且是表的主键。</li>
<li><code>name</code>和<code>email</code>都是变长字符类型的列，最大长度为100。</li>
<li><code>age</code>是一个整数类型的列。</li>
</ul>
<p>注意，每一行都需要以逗号结束，但是最后一行除外。最后，整个语句需要以分号结束。</p>
<p>数据库名、表名、列名可以使用&#96;&#96;（反引号）括起来</p>
<p>输入到列中字符串的值需要用’’（单引号）或者””（双引号）括起来</p>
<p>创建表时指定字符编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名 (列名1 数据类型1, 列名2 数据库类型2...) CHARSET=utf8;<br></code></pre></td></tr></table></figure>

<h3 id="设置主键"><a href="#设置主键" class="headerlink" title="设置主键"></a>设置主键</h3><p>主键的特点：</p>
<ul>
<li>没有重复的值</li>
<li>不允许输入空值（NULL）</li>
</ul>
<p>命令格式：</p>
<p>在创建表时给主键字段后添加PRIMARY KEY</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">CREATE TABLE 表名 (列名1 数据类型1 PRIMARY KEY, 列名2 数据库类型2...);<br></code></pre></td></tr></table></figure>

<h3 id="设置唯一键"><a href="#设置唯一键" class="headerlink" title="设置唯一键"></a>设置唯一键</h3><p>唯一键（unique key）的特点</p>
<ul>
<li><p>不允许重复</p>
</li>
<li><p>允许输入NULL</p>
</li>
</ul>
<p>在创建表时定义唯一键：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name (<br>  column1 data_type,<br>  column2 data_type,<br>  <span class="hljs-keyword">UNIQUE</span> (column1)<br>);<br></code></pre></td></tr></table></figure>

<p>在已存在的表上添加唯一键：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> (column1);<br></code></pre></td></tr></table></figure>

<h3 id="设置列可以自动递增"><a href="#设置列可以自动递增" class="headerlink" title="设置列可以自动递增"></a>设置列可以自动递增</h3><p>自动递增（AUTO_INCREMENT）可以应用于任何整数类型的列。<code>AUTO_INCREMENT</code>属性允许数据库自动为新记录生成一个唯一的数字。通常用于主键。</p>
<p>使用<code>AUTO_INCREMENT</code>属性，需要满足以下几个条件：</p>
<ul>
<li>列必须被定义为<code>NOT NULL</code>，因为它必须有值。</li>
<li>列必须被定义为整数类型（例如，<code>INT</code>，<code>SMALLINT</code>，<code>MEDIUMINT</code>，<code>BIGINT</code>）。</li>
<li>每个表只能有一个<code>AUTO_INCREMENT</code>列。</li>
</ul>
<p>示例，将<code>id</code>列定义为<code>AUTO_INCREMENT</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE employees (<br>    id INT NOT NULL AUTO_INCREMENT,<br>    name VARCHAR(100),<br>    PRIMARY KEY(id)<br>);<br></code></pre></td></tr></table></figure>

<p>MySQL如何设置连续递增字段的初始值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tablename (<br>    id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id)<br>) AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure>

<p>如果已经创建了表，并且想改变AUTO_INCREMENT的值，可以使用ALTER TABLE命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tablename AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure>

<p>注意，不能将AUTO_INCREMENT的值设置为比当前最大值小的数，因如果这样做，MySQL将忽略此次设置并保持当前最大值。</p>
<h3 id="设置列的默认值"><a href="#设置列的默认值" class="headerlink" title="设置列的默认值"></a>设置列的默认值</h3><p>在MySQL中，可以在创建表或修改表的时候设置字段的默认值。这个默认值将被用于任何未指定该列值的新行。</p>
<ol>
<li>在创建表的时候设置默认值：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tablename (<br>    columnname1 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,<br>    columnname2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default_value&#x27;</span><br>);<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个名为”tablename”的表，它有两个字段，”columnname1”和”columnname2”。对于”columnname1”，如果在插入新的行时没有指定它的值，那么它的值将默认为1。对于”columnname2”，如果在插入新的行时没有指定它的值，那么它的值将默认为’default_value’。</p>
<ol start="2">
<li>修改已经存在的表，为字段设置默认值：</li>
</ol>
<p><code>MODIFY</code>关键字用于修改表的列定义。它可以用来更改列的数据类型、长度、约束等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tablename <br>MODIFY columnname1 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,<br>MODIFY columnname2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default_value&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们更改了”tablename”表中”columnname1”和”columnname2”字段的默认值。</p>
<p>注意，不能为NOT NULL的字段设置默认值为NULL。对于字符串类型的字段，默认值需要用引号引起来。对于日期和时间类型的字段，可以将默认值设置为CURRENT_TIMESTAMP。</p>
<h3 id="索引（创建、删除、查看、主键索引、唯一索引、全局索引）"><a href="#索引（创建、删除、查看、主键索引、唯一索引、全局索引）" class="headerlink" title="索引（创建、删除、查看、主键索引、唯一索引、全局索引）"></a>索引（创建、删除、查看、主键索引、唯一索引、全局索引）</h3><p>在MySQL中，索引是用来加速查询操作的一种数据结构。它们可以让数据库引擎快速找到表中的特定记录。如果事先在表上创建了索引，查找时就不需要对全表进行扫描，而是利用索引进行扫描。</p>
<p>下面是一些关于MySQL索引的基础知识：</p>
<ol>
<li><p><strong>创建索引：</strong> 创建索引可以使用 <code>CREATE INDEX</code> （关键字INDEX可以替换为关键字KEY）命令。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name (column1, column2);<br></code></pre></td></tr></table></figure>

<p>在上面的命令中，<code>index_name</code> 是索引的名称，<code>table_name</code> 是要在其上创建索引的表的名称，<code>column1</code> 和 <code>column2</code> 是想在其中创建索引的列。</p>
</li>
<li><p><strong>删除索引：</strong> 删除索引可以使用 <code>DROP INDEX</code> 命令。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>查看索引：</strong> 如果想看一个表的所有索引，可以使用 <code>SHOW INDEX</code> 命令。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>主键索引：</strong> 主键（PRIMARY KEY）自动创建唯一索引。每个MySQL表只能有一个主键。</p>
</li>
<li><p><strong>唯一索引：</strong> 唯一索引（UNIQUE INDEX）不允许任何重复值。它们可以是主键，也可以不是。</p>
<p>唯一索引（Unique Index）的设置：</p>
<ul>
<li><p>在创建表时定义唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name (<br>  column1 data_type,<br>  column2 data_type,<br>  <span class="hljs-keyword">UNIQUE</span> INDEX index_name (column1)<br>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>在已存在的表上添加唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name (column1);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>全文索引：</strong> 全文索引（FULLTEXT INDEX）用于全文搜索。只有CHAR、VARCHAR和TEXT列可以创建全文索引。</p>
</li>
</ol>
<p>使用索引的缺点：</p>
<ol>
<li>会占用额外的磁盘空间</li>
<li>在执行插入、更新或删除操作时，索引也需要被更新，有耗时</li>
<li>如果被创建索引的列中重复值较多，即使在该列上创建索引也不会提高处理速度</li>
</ol>
<h2 id="显示表结构"><a href="#显示表结构" class="headerlink" title="显示表结构"></a>显示表结构</h2><p>DESC或者DESCRIBE，用于显示指定表的列结构，包括列名、数据类型、是否允许NULL，以及其他关于列的信息。</p>
<p>运行这个命令会返回以下信息：</p>
<ul>
<li><strong>Field</strong>：列的名称。</li>
<li><strong>Type</strong>：列的数据类型和长度。</li>
<li><strong>Null</strong>：如果列可以包含NULL值，这个字段会显示”YES”，否则显示”NO”。</li>
<li><strong>Key</strong>：如果列是某种键，这个字段会显示键的类型。”PRI”表示主键，”UNI”表示唯一键，”MUL”表示这个列是一个非唯一索引，或者这个列是多个列的一部分，这些列作为复合主键或复合索引，也可能是外键。</li>
<li><strong>Default</strong>：列的默认值。如果没有指定默认值，这个字段会显示NULL。</li>
<li><strong>Extra</strong>：其他的额外信息，例如，如果列被定义为AUTO_INCREMENT，这个字段就会显示”AUTO_INCREMENT”。</li>
</ul>
<p>命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC 表名;<br></code></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------------+------+-----+---------+----------------+</span><br><span class="hljs-operator">|</span> Field <span class="hljs-operator">|</span> Type         <span class="hljs-operator">|</span> <span class="hljs-keyword">Null</span> <span class="hljs-operator">|</span> Key <span class="hljs-operator">|</span> <span class="hljs-keyword">Default</span> <span class="hljs-operator">|</span> Extra          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------------+------+-----+---------+----------------+</span><br><span class="hljs-operator">|</span> id    <span class="hljs-operator">|</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>)      <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span>   <span class="hljs-operator">|</span> PRI <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> auto_increment <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> name  <span class="hljs-operator">|</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-operator">|</span> YES  <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span>                <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------------+------+-----+---------+----------------+</span><br></code></pre></td></tr></table></figure>

<h2 id="查看创建表的SQL语句"><a href="#查看创建表的SQL语句" class="headerlink" title="查看创建表的SQL语句"></a>查看创建表的SQL语句</h2><ol>
<li>SHOW CREATE TABLE语句</li>
</ol>
<p>SHOW CREATE TABLE语句可用于查看创建表的SQL语句，包括所有列、键和约束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE TABLE table_name;<br></code></pre></td></tr></table></figure>

<p>返回结果示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `employee` (<br>  `id` int NOT NULL,<br>  `emp_id` char(10) DEFAULT NULL,<br>  `emp_name` varchar(10) DEFAULT NULL,<br>  `manager_id` char(10) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci<br></code></pre></td></tr></table></figure>

<h2 id="显示数据库中的所有表"><a href="#显示数据库中的所有表" class="headerlink" title="显示数据库中的所有表"></a>显示数据库中的所有表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;<br></code></pre></td></tr></table></figure>

<h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>在MySQL中，可以使用<code>ALTER TABLE</code>语句来修改已经存在的表。使用ALTER TABLE命令修改列的结构，根据修改类型，可以使用带有CHANGE、MODIFY、ADD、DROP的语句。</p>
<p>以下是一些常见的表修改操作：</p>
<ol>
<li><p><strong>添加列：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> column_name datatype;<br></code></pre></td></tr></table></figure>

<p>例如，如果想在<code>students</code>表中添加一个名为<code>address</code>的新列，可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br><span class="hljs-keyword">ADD</span> address <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>);<br></code></pre></td></tr></table></figure>

<p>把列添加到指定位置的命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD 列名 数据类型 AFTER 放在这个列之后;<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE tb1 ADD birth DATETIME AFTER employeeId;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>删除列：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> column_name;<br></code></pre></td></tr></table></figure>

<p>例如，如果想从<code>students</code>表中删除<code>address</code>列，可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> address;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>修改列的数据类型：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br>MODIFY <span class="hljs-keyword">COLUMN</span> column_name datatype;<br></code></pre></td></tr></table></figure>

<p>即使数据类型不变，也依然需要指定修改后的数据类型</p>
<p>例如，如果想修改<code>students</code>表中<code>age</code>列的数据类型为<code>SMALLINT</code>，可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br>MODIFY <span class="hljs-keyword">COLUMN</span> age <span class="hljs-type">SMALLINT</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>重命名列：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br>CHANGE <span class="hljs-keyword">COLUMN</span> old_column_name new_column_name datatype;<br></code></pre></td></tr></table></figure>

<p>例如，如果想将<code>students</code>表中的<code>email</code>列重命名为<code>email_address</code>，可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br>CHANGE <span class="hljs-keyword">COLUMN</span> email email_address <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<p>即使数据类型不变，也依然需要指定修改后的数据类型</p>
</li>
<li><p><strong>添加唯一键、主键或索引：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> (column_name);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (column_name);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> INDEX index_name (column_name);<br></code></pre></td></tr></table></figure>

<p><code>ALTER TABLE</code>语句会锁定表，直到操作完成。</p>
</li>
</ol>
<h2 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h2><h3 id="复制整张表"><a href="#复制整张表" class="headerlink" title="复制整张表"></a>复制整张表</h3><p>在MySQL中，可以通过创建新表并从现有表中复制数据来复制表。下面是一种方法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> new_table <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> existing_table;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>new_table</code>是想要创建的新表的名称，<code>existing_table</code>是想要复制数据的现有表的名称。这个操作将创建一个新表，并将现有表中的所有数据复制到新表中。</p>
<p>需要注意的是，使用这种方法创建的新表不会包含现有表的索引、主键、唯一键和其他约束。如果需要复制这些属性，需要使用其他方法，例如先使用<code>CREATE TABLE</code>语句创建表和相应的约束，然后使用<code>INSERT INTO ... SELECT</code>语句复制数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> new_table <span class="hljs-keyword">LIKE</span> existing_table; <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> new_table <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> existing_table;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>CREATE TABLE new_table LIKE existing_table;</code>语句创建一个与现有表结构（包括索引和约束）完全相同的新表，但不包含任何数据。然后，<code>INSERT INTO new_table SELECT * FROM existing_table;</code>语句将现有表中的所有数据复制到新表中。</p>
<h3 id="复制符合条件的记录"><a href="#复制符合条件的记录" class="headerlink" title="复制符合条件的记录"></a>复制符合条件的记录</h3><p>当另一个表已经存在时，可以使用 <code>INSERT INTO SELECT</code> 语句来从一个表复制符合条件的记录到另一个表中。具体来说，<code>INSERT INTO SELECT</code> 语句会将一个查询结果插入到指定的表中。</p>
<p>以下是一个使用 <code>INSERT INTO SELECT</code> 语句复制符合条件的记录的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO newtable (col1, col2, ...)<br>	SELECT col1, col2, ...<br>FROM oldtable<br>	WHERE condition;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们把符合查询条件的列数据从旧表 oldtable 复制到新表 newtable。选择需要复制的列，并通过 WHERE 子句指定要复制的特定行。</p>
<p>需要注意的是，在执行 INSERT INTO SELECT 语句之前，我们必须先创建新表，并保证它与旧表拥有相同的结构。此外，也可以为新表添加索引或其他约束，以确保数据完整性和查询性能。</p>
<p>还可以在 <code>SELECT</code> 语句中使用 JOIN、GROUP BY、HAVING 等功能来实现更加复杂的查询操作。例如，我们可以使用 <code>JOIN</code> 连接多个表，并根据多个条件对记录进行筛选，最终将满足条件的记录插入到新表中。</p>
<p>如果需要将一个表中符合条件的记录复制到一个新表中，并且该表不存在，可以使用以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE newtable<br>	SELECT col1, col2, ...<br>FROM oldtable<br>	WHERE condition;<br></code></pre></td></tr></table></figure>

<p>这条 <code>CREATE TABLE AS</code> 语句会首先创建一个名为 newtable 的新表，然后将满足 WHERE 子句指定的条件的所有行从 oldtable 复制到新表中。</p>
<p>需要注意的是，新表的列会自动继承 SELECT 列出的列的名称和数据类型。如果需要重新命名列或更改其数据类型，则可以使用 <code>AS</code> 或其他列定义语法来修改列属性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE newtable<br>	SELECT id AS new_id, name, CAST(age AS VARCHAR(10)) AS age_str<br>FROM oldtable<br>	WHERE condition;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们在 SELECT 语句中为新表定义了新的列名和数据类型，并将旧表的 id 列重命名为 new_id。最终，MySQL 将会根据 SELECT 语句的结果集自动创建新表的结构，并将所有符合条件的记录插入到新表中。</p>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><h3 id="删除整张表"><a href="#删除整张表" class="headerlink" title="删除整张表"></a>删除整张表</h3><p>在MySQL中，可以使用 <code>DROP TABLE</code> 语句来删除已经存在的表。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> table_name;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>table_name</code> 是想要删除的表的名称。例如，如果想删除名为 <code>students</code> 的表，可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> students;<br></code></pre></td></tr></table></figure>

<p>此外，在目标表不存在的情况下执行DROP命令会发生错误，如果和<code>IF EXISTS</code>子句一起使用，就可以避免在试图删除不存在的表时出现错误。下面是如何使用它的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> table_name;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>table_name</code>是想要删除的表的名称。例如，如果想删除名为<code>students</code>的表，可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> students;<br></code></pre></td></tr></table></figure>

<p>如果<code>students</code>表存在，上述语句将删除它。如果<code>students</code>表不存在，MySQL将发出一条警告，而不是一个错误，并允许查询继续。</p>
<h3 id="删除表内所有记录"><a href="#删除表内所有记录" class="headerlink" title="删除表内所有记录"></a>删除表内所有记录</h3><p>请注意，<code>DROP TABLE</code> 语句会永久删除表以及表中的所有数据，如果只是想删除表中的所有数据，但是想保留表的结构（例如列的定义和约束），应该使用 <code>TRUNCATE TABLE</code> 语句，在MySQL中，<code>TRUNCATE</code>是一个DDL（数据定义语言）语句，用于删除表中的所有记录如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> table_name;<br></code></pre></td></tr></table></figure>

<p>或者使用如下命令也可以达到同样的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP FROM table_name;<br></code></pre></td></tr></table></figure>

<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 列名1, 列名2... FROM 表名;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM 表名;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT &#x27;会将这段文字输出&#x27;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT (1+2)*3;<br></code></pre></td></tr></table></figure>

<h2 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h2><p>在MySQL中，可以使用<code>INSERT INTO</code>语句向表中插入数据。以下是几个例子：</p>
<ol>
<li><p><strong>插入完整的行数据：</strong></p>
<p>在这种情况下，需要提供表中每个列的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2, column3, ...)<br><span class="hljs-keyword">VALUES</span> (value1, value2, value3, ...);<br></code></pre></td></tr></table></figure>

<p>例如，如果有一个名为<code>students</code>的表，它有<code>id</code>, <code>name</code>, <code>age</code>, <code>email</code>四个列，可以这样插入数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> students (id, name, age, email)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;John Doe&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;johndoe@example.com&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>对于设置了<code>AUTO_INCREMENT</code>的列（如<code>id</code>列），如果在插入数据时省略该列，MySQL会自动为它分配一个值。</p>
</li>
<li><p><strong>插入特定列的数据：</strong></p>
<p>在这种情况下，只需要提供想插入的列的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2, ...)<br><span class="hljs-keyword">VALUES</span> (value1, value2, ...);<br></code></pre></td></tr></table></figure>

<p>例如，如果只想插入<code>students</code>表中的<code>name</code>和<code>email</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> students (name, email)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;John Doe&#x27;</span>, <span class="hljs-string">&#x27;johndoe@example.com&#x27;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>插入多行数据：</strong></p>
<p>可以一次插入多行数据，只需在<code>VALUES</code>关键字后面列出所有的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2, ...)<br><span class="hljs-keyword">VALUES</span> <br>(value1, value2, ...),<br>(value1, value2, ...),<br>...<br>;<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> students (name, email)<br><span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;John Doe&#x27;</span>, <span class="hljs-string">&#x27;johndoe@example.com&#x27;</span>),<br>(<span class="hljs-string">&#x27;Jane Doe&#x27;</span>, <span class="hljs-string">&#x27;janedoe@example.com&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>在MySQL中，可以使用<code>UPDATE</code>语句来更新已经存在的记录。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table_name<br><span class="hljs-keyword">SET</span> column1 <span class="hljs-operator">=</span> value1, column2 <span class="hljs-operator">=</span> value2, ...<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>table_name</code>是想要更新记录的表的名称，<code>column1</code>, <code>column2</code>, … 是想要更新的列的名称，<code>value1</code>, <code>value2</code>, … 是想设置的新值，<code>condition</code>是用于确定哪些记录应该被更新的条件。如果没有使用WHERE设置条件，列中的所有记录都会被替换掉，为防止这种情况发生，在启动MySQL监视器的时候，可以加上–safe-update选项，使用此选项后，如果没有WHERE条件就无法执行UPDATE或DELETE。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> students<br><span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">21</span>, email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;newemail@example.com&#x27;</span><br><span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John Doe&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这个语句会在<code>students</code>表中找到所有名字为<code>John Doe</code>的记录，并将它们的<code>age</code>列设置为21，<code>email</code>列设置为<code>newemail@example.com</code>。</p>
<p>如果省略了<code>WHERE</code>子句，<code>UPDATE</code>语句将更新表中的所有记录。</p>
<h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p>在 MySQL 中，可以使用 <code>DELETE</code> 语句删除表中的记录。以下是一些常见的用法和语法：</p>
<ol>
<li>删除整个表中的所有记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM table_name;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>删除符合条件的记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM table_name WHERE condition;<br></code></pre></td></tr></table></figure>

<p>这条语句将会从表 <code>table_name</code> 中删除满足指定条件的记录。例如，下面的语句能够删除年龄大于 30 岁的人员信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM person WHERE age &gt; 30;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>删除部分符合条件的记录</li>
</ol>
<p>有时候，我们可能只想删除表中的前几行数据，或者只删除满足某些条件的前几行数据。可以使用 <code>LIMIT</code> 子句来限制待删除的记录数。</p>
<p>例如，以下语句将会删除表 <code>person</code> 中前 10 行记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM person LIMIT 10;<br></code></pre></td></tr></table></figure>

<p>如果要删除符合条件的前 10 行数据，则可以如下写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM person WHERE age &gt; 30 ORDER BY id LIMIT 10;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们选择指定了 <code>WHERE</code> 条件和排序方式，并使用 <code>LIMIT</code> 限制了最多删除 10 行记录。</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>将SELECT结果像表一样保存下来的虚表就是视图。视图可以帮助简化复杂查询，提高查询性能。</p>
<p>视图也可以和表一样进行SELECT、INSERT、UPDATE、DELETE……，操作结果会同步到基本表。任何更改基本表的操作（如INSERT、UPDATE或DELETE）也都会影响到视图的结果。</p>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>使用CREATE VIEW语句可以在MySQL中创建视图。例如，以下是创建一个简单视图的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW my_view AS<br>SELECT column1, column2, ...<br>FROM my_table<br>WHERE condition;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，my_view是视图的名称，my_table是视图所依赖的基本表，SELECT查询表示视图的内容，并使用WHERE子句进行条件过滤。</p>
<h2 id="可更新视图"><a href="#可更新视图" class="headerlink" title="可更新视图"></a>可更新视图</h2><p>在MySQL中，只有可更新视图（updatable view）才能使用UPDATE、INSERT或DELETE语句来更改基本表的行数据。</p>
<p>当满足以下条件之一时，视图将被标记为不可更新：</p>
<ol>
<li>视图包含聚合函数（如SUM或AVG）。</li>
<li>视图中使用了DISTINCT、GROUP BY或HAVING子句。</li>
<li>视图中的SELECT语句包含UNION或UNION ALL操作符。</li>
<li>视图定义中存在子查询，而且子查询引用了与SELECT语句所引用的不同表。</li>
<li>视图定义中存在常量或表达式，而不是列名。</li>
</ol>
<p>对视图执行INSERT操作时，即使与创建视图时的WHERE条件不匹配，数据也会插入到基表中。</p>
<p>比如创建视图时指定了sales的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW v1 AS<br>SELECT empid, sales<br>FROM tb<br>WHERE sales &gt;= 100;<br></code></pre></td></tr></table></figure>

<p>INSERT数据时不在这个范围内：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO v1 VALUES(&#x27;new_empid&#x27;, 15);<br></code></pre></td></tr></table></figure>

<p>执行之后，虽然视图v1中没有(‘new_empid’, 15)这条数据，但是基本表中已经INSERT成功，存在了这条数据。</p>
<p>为避免这种情况发生，可以将视图设置为”不接受与条件不匹配的记录“，在CREATE VIEW时，添加WITH CHECK OPTION：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW v1 AS<br>SELECT empid, sales<br>FROM tb<br>WHERE sales &gt;= 100<br>WITH CHECK OPTION;<br></code></pre></td></tr></table></figure>

<p>这样就无法插入不符合条件的记录了。</p>
<h2 id="显示视图"><a href="#显示视图" class="headerlink" title="显示视图"></a>显示视图</h2><p>视图在显示上的操作和表是相同的，也是通过SHOW TABLES命令操作，视图会与表一起显示出来。</p>
<p>要查看视图的列结构也是和表一样的操作。显示视图view_name的列结构示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC view_name;<br></code></pre></td></tr></table></figure>

<p>显示创建语句视图的SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE VIEW view_name<br></code></pre></td></tr></table></figure>

<h2 id="替换视图"><a href="#替换视图" class="headerlink" title="替换视图"></a>替换视图</h2><p>这里的替换视图的含义是删除已经存在的同名视图并创建新视图，操作方法是加上OR REPLACE：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE OR REPLACE VIEW v1 AS<br>SELECT NOW();<br></code></pre></td></tr></table></figure>

<h2 id="修改视图结构"><a href="#修改视图结构" class="headerlink" title="修改视图结构"></a>修改视图结构</h2><p>修改视图结构使用的也是ALTER命令，命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER VIEW view_name AS (SELECT语句);<br></code></pre></td></tr></table></figure>

<h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><p>如果存在就删除视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP VIEW IF EXISTS v1;<br></code></pre></td></tr></table></figure>

<p>IF EXISTS的作用参见删除数据库。</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>MySQL存储过程（Stored Procedure）是一组预编译的SQL语句集合，可以在数据库中重复运行使用。将多个SQL语句组合成一个只需要使用命令<code>CALL </code>能执行的集合，该集合就称为存储过程（stored process）。</p>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>存储过程由以下部分组成：</p>
<ol>
<li><p>存储过程名称：唯一标识存储过程的名称。</p>
</li>
<li><p>参数列表：定义存储过程需要的输入或输出参数。</p>
</li>
<li><p>SQL语句集合：实际执行的SQL语句集合。</p>
</li>
<li><p>控制流程：定义存储过程如何处理条件、循环和异常等情况。</p>
</li>
</ol>
<p>以下是创建和使用MySQL存储过程的基本步骤：</p>
<ol>
<li>使用CREATE PROCEDURE语句创建存储过程：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE procedure_name (IN input_parameter1 data_type1, IN input_parameter2 data_type2, OUT output_parameter data_type)<br>BEGIN<br>  -- SQL statements here<br>END;<br></code></pre></td></tr></table></figure>

<p>其中，procedure_name为存储过程名称，input_parameter和output_parameter是存储过程的输入和输出参数，data_type指定了参数的数据类型。在BEGIN和END之间是定义的存储过程的SQL语句集合和控制流程。</p>
<p>在MySQL中，创建存储过程需要使用DELIMITER语句指定分隔符。默认情况下，MySQL使用分号（;）作为SQL语句和命令的分隔符。如果没有修改分隔符，MySQL会第一个分号视为存储过程定义语句的结束符，会导致错误。</p>
<p>可以使用DELIMITER语句定义新的分隔符，例如“$$”，然后在存储过程结束时再将分隔符重置为默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE PROCEDURE my_procedure()<br>BEGIN<br>  -- SQL statements here<br>END $$<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>注意，在上面的示例中，我们将分隔符从默认的分号设置为两个美元符号“$$”。当存储过程定义完毕后，我们需要将分隔符重置成分号以便后续操作。</p>
<h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CALL procedure_name(input_value1, input_value2, @output_value);<br></code></pre></td></tr></table></figure>

<p>其中，input_value1和input_value2是存储过程的传入参数值，@output_value是存储过程的输出参数。可以用SELECT语句检索@output_value的值。</p>
<p>需要注意的是，MySQL存储过程支持条件、循环和异常处理等复杂的控制流程结构。存储过程可以将这些结构与SQL语句组合在一起，以完成特定的任务或操作。</p>
<p> 存储过程的输出参数有个@的原因： </p>
<p>在MySQL中，存储过程参数分为输入参数和输出参数。与输入参数不同，输出参数必须使用@前缀来声明。</p>
<p>这是因为MySQL中的@符号表示用户定义变量（User-Defined Variables），可以在多个SQL语句之间传递值。当在存储过程中声明一个输出参数时，实际上是在创建一个用户定义变量，以便将结果从存储过程传递出去。</p>
<p>例如，下面是一个简单的存储过程示例，它将两个整数相加，并将结果存储在输出参数中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE add_numbers(IN num1 INT, IN num2 INT, OUT result INT)<br>BEGIN<br>  SET result = num1 + num2;<br>END;<br></code></pre></td></tr></table></figure>

<p>在执行该存储过程时，需要声明一个用户定义变量，并在调用存储过程时将其传递给输出参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @output_value = 0;<br>CALL add_numbers(10, 20, @output_value);<br>SELECT @output_value;<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，我们首先使用SET语句创建了一个名为@output_value的用户定义变量，并将其初始化为0。然后，我们调用了add_numbers存储过程，并将10和20作为输入参数传递给它。最后，我们使用SELECT语句检索输出参数的值。注意，我们使用了@前缀来引用输出参数。</p>
<p>需要注意的是，在MySQL中，用户定义变量的作用域仅限于当前会话（Session）。这意味着在存储过程内部定义的用户定义变量不能在存储过程外部使用，反之亦然。</p>
<h2 id="显示存储过程"><a href="#显示存储过程" class="headerlink" title="显示存储过程"></a>显示存储过程</h2><p>要在MySQL中查看存储过程的定义，可以使用SHOW CREATE PROCEDURE语句。该语句将显示与存储过程相关的详细信息，包括存储过程名称、参数列表和SQL语句。</p>
<p>以下是一个示例存储过程，它返回员工的姓名和薪水：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE get_employee(IN employee_id INT, OUT employee_name VARCHAR(50), OUT employee_salary DECIMAL(10,2))<br>BEGIN<br>  SELECT name, salary INTO employee_name, employee_salary FROM employees WHERE id = employee_id;<br>END;<br></code></pre></td></tr></table></figure>

<p>要查看该存储过程的定义，请执行以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE PROCEDURE get_employee;<br></code></pre></td></tr></table></figure>

<p>执行结果类似于下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Procedure: get_employee<br>Create Procedure: CREATE PROCEDURE `get_employee`(IN employee_id INT, OUT employee_name VARCHAR(50), OUT employee_salary DECIMAL(10,2))<br>BEGIN<br>  SELECT name, salary INTO employee_name, employee_salary FROM employees WHERE id = employee_id;<br>END<br></code></pre></td></tr></table></figure>

<p>其中，第一行显示了存储过程的名称（Procedure: get_employee），而第二行则显示了完整的CREATE PROCEDURE语句，包括存储过程的定义。</p>
<p>需要注意的是，如果没有对存储过程具有足够的权限，SHOW CREATE PROCEDURE语句可能会返回“Access denied”错误。在这种情况下，需要确保已经授予了足够的权限，并且使用正确的MySQL用户来执行该语句。</p>
<h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><p>在MySQL中删除存储过程非常简单。可以使用DROP PROCEDURE语句来删除一个或多个存储过程。</p>
<p>以下是删除名为get_employee的存储过程的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP PROCEDURE IF EXISTS get_employee;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了DROP PROCEDURE语句来删除名称为get_employee的存储过程。如果该存储过程不存在，它将不会产生任何影响。如果存在同名的存储过程，则该命令将永久删除该存储过程，而无法撤消操作。</p>
<p>IF EXISTS的作用参见前面章节的删除数据库。</p>
<h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><p>MySQL有许多函数，但使用存储函数可以创建自定义的函数，所以存储函数也称为用户定义函数。</p>
<p>存储函数（stored function）的操作方法和存储过程基本相同，与存储过程的唯一不同是，<strong>存储函数在执行后只会返回一个值</strong>。如果需要在SQL查询中计算一些复杂的表达式或逻辑，则可以使用存储函数来简化查询语句。</p>
<p><strong>存储函数可以接受零个或多个输入参数，并返回一个标量值（例如整数、字符串、日期等）</strong>。</p>
<h2 id="启用存储函数日志"><a href="#启用存储函数日志" class="headerlink" title="启用存储函数日志"></a>启用存储函数日志</h2><p>当log_bin_trust_function_creators为0时，用户不能创建或更新存储函数。log_bin_trust_function_creators是一个系统变量，用于控制是否记录创建存储函数（CREATE FUNCTION语句）的操作到二进制日志中。</p>
<p>这个变量的默认值为0（关闭，OFF），这意味着MySQL不会将CREATE FUNCTION语句记录到二进制日志中。把log_bin_trust_function_creators设置为1，将允许用户创建和修改存储函数，并且这些操作也将被记录到二进制日志中。</p>
<p>需要注意的是，即使log_bin_trust_function_creators被设置为1，用户也需要适当的权限才能够创建、修改或删除存储函数。这包括CREATE ROUTINE、ALTER ROUTINE和DROP ROUTINE等权限。如果用户没有这些权限，则无法执行相关操作。</p>
<p>要启用log_bin_trust_function_creators，可以采用以下方法：</p>
<ol>
<li><p>使用SET</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET GLOBAL log_bin_trust_function_creators = 1;<br></code></pre></td></tr></table></figure>


</li>
<li><p>修改my.cnf</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">log_bin_trust_function_creators</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>要查看log_bin_trust_function_creators，可以采用以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;log_bin_trust_function_creators&#x27;;<br></code></pre></td></tr></table></figure>

<h2 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h2><p>以下是一个计算两个整数之和的示例存储函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE FUNCTION add_numbers(num1 INT, num2 INT) RETURNS INT<br>BEGIN<br>  DECLARE result INT; -- 语法是 DECLARE 变量名 数据类型<br>  SET result = num1 + num2; <br>  -- 或者使用SELECT INTO，示例：SELECT AVG(sales) INTO result FROM tb;<br>  RETURN result;<br>END;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为add_numbers的存储函数，它接受两个整数作为输入参数，并返回它们的和。在存储函数内部，我们使用DECLARE语句声明了一个名为result的局部变量，并将num1和num2的和赋值给它。最后，我们使用RETURN语句返回result的值。</p>
<p>要调用该存储函数，请使用SELECT语句进行查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT add_numbers(10, 20);<br></code></pre></td></tr></table></figure>

<p>在此查询中，我们调用了add_numbers函数，并传递了10和20作为两个输入参数。该函数将返回它们的和，即30。</p>
<p>需要注意的是，在MySQL中，存储函数应该具有确定性，也就是说，对于相同的输入参数，它应该始终返回相同的结果。此外，存储函数还应该具有不产生副作用的性质，也就是说，它不应该修改数据库中的数据。如果存储函数违反了这些规则，可能会导致不可预测的结果或安全问题。</p>
<h2 id="显示存储函数"><a href="#显示存储函数" class="headerlink" title="显示存储函数"></a>显示存储函数</h2><h3 id="显示数据库中所有的存储函数"><a href="#显示数据库中所有的存储函数" class="headerlink" title="显示数据库中所有的存储函数"></a>显示数据库中所有的存储函数</h3><p>可以使用MySQL的SHOW FUNCTION STATUS语句来显示所有定义在数据库中的存储函数。</p>
<p>具体来说，该语句的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW FUNCTION STATUS;<br></code></pre></td></tr></table></figure>

<p>执行该语句将返回包含以下列的结果集：</p>
<ol>
<li>Db：与存储函数相关联的数据库名称。</li>
<li>Name：存储函数的名称。</li>
<li>Type：函数类型（标量函数 [SCALAR FUNCTION]、聚合函数 [AGGREGATE FUNCTION]、窗口函数 [WINDOW FUNCTION]）。</li>
<li>Definer：函数创建者。</li>
<li>Modified：最近一次修改时间。</li>
<li>Created：创建时间。</li>
<li>Security_type：安全模式。</li>
</ol>
<p>此外，还有其他可选的列，例如Comment和character_set_client。</p>
<p>如果想查看特定的存储函数，需要在SHOW FUNCTION STATUS语句后面添加LIKE子句来指定要查询的模式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW FUNCTION STATUS LIKE &#x27;myfunction%&#x27;;<br></code></pre></td></tr></table></figure>

<p>上面的示例将返回名称以“myfunction”开头的所有存储函数。</p>
<h3 id="显示指定存储函数"><a href="#显示指定存储函数" class="headerlink" title="显示指定存储函数"></a>显示指定存储函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE FUNCTION function_name;<br></code></pre></td></tr></table></figure>

<h2 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h2><p>删除存储函数的语法格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP FUNCTION 存储函数名;<br></code></pre></td></tr></table></figure>

<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>MySQL触发器（trigger）是一种数据库对象，它允许在特定的表上定义自动执行的操作，当<strong>满足触发器定义的条件时，该操作将自动触发</strong>。</p>
<p>常见的使用场景包括：</p>
<ul>
<li>在记录插入&#x2F;更新&#x2F;删除操作时自动生成日志记录。</li>
<li>在记录插入&#x2F;更新&#x2F;删除操作时同步到其他相关的表。</li>
<li>在记录插入&#x2F;更新时进行验证或格式化等操作。</li>
</ul>
<p>需要注意的是，MySQL触发器在处理大量数据时可能会显著减慢数据库性能，因此应谨慎使用。</p>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><p>一个MySQL触发器包含以下几个部分：</p>
<ol>
<li>触发器名称：用于标识触发器的名称。</li>
<li>关联表名称：需要关联到触发器的表名。</li>
<li>事件类型：可以是INSERT、UPDATE或DELETE，表示在关联表中执行的操作类型。</li>
<li>触发时间：可以是BEFORE或AFTER，指定何时执行触发操作。</li>
<li>条件：指定触发操作的条件，可以使SQL语句中的WHERE子句。</li>
<li>触发操作：在满足触发器条件时要执行的操作，可以是一条或多条SQL语句。</li>
</ol>
<p>下面是一个创建MySQL触发器的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER my_trigger<br>AFTER INSERT ON my_table<br>FOR EACH ROW<br>BEGIN<br>    -- 触发操作<br>END;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，创建了一个名为my_trigger的触发器，设置为在my_table表中进行插入操作之后自动调用。FOR EACH ROW关键字表示该操作针对每个插入的行都会执行一次。在BEGIN和END之间的代码块则是要执行的SQL语句操作。</p>
<h2 id="OLD、NEW关键字"><a href="#OLD、NEW关键字" class="headerlink" title="OLD、NEW关键字"></a>OLD、NEW关键字</h2><p>在MySQL触发器中，可以使用<code>OLD</code>和<code>NEW</code>关键字来获取一个操作（如 INSERT、UPDATE 或 DELETE）的旧值和新值。</p>
<ul>
<li><p>OLD.列名</p>
<p>OLD.列名是对表处理前的列值</p>
<p>INSERT事件类型没有OLD.列名</p>
</li>
<li><p>NEW.列名</p>
<p>NEW.列名是对表处理后的列值</p>
<p>DELETE事件类型没有NEW.列名</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER delete_trigger<br>BEFORE DELETE ON employee<br>FOR EACH ROW<br>BEGIN<br>    INSERT INTO log_table (id_log_table, emp_id_log_table) VALUES (OLD.id, OLD.emp_id);<br>END;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>OLD</code>关键字被用于访问将要被删除信息的行（旧行）。在此案例中，每次将要删除一行之前，都会将此行的ID和列1插入一个名为log_table的表中。</p>
<h2 id="显示触发器"><a href="#显示触发器" class="headerlink" title="显示触发器"></a>显示触发器</h2><p>如果想要显示MySQL数据库中的触发器，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TRIGGERS;<br></code></pre></td></tr></table></figure>

<p>当执行上述命令时，将返回包含所有已创建触发器的结果集。该结果集包括每个触发器的名称、关联表、事件类型、触发时间和触发语句。</p>
<p>如果只想检索指定表的触发器，则可以使用以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TRIGGERS FROM your_database_name LIKE &#x27;your_table_name&#x27;;<br></code></pre></td></tr></table></figure>

<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>要删除一个已经存在的MySQL触发器，可以使用以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TRIGGER [IF EXISTS] trigger_name;<br></code></pre></td></tr></table></figure>

<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>将多个操作作为单个逻辑工作单元处理的功能称为事务（transaction）。</p>
<p>将事务在内存中的处理结果反映到数据库磁盘的操作称为提交（commit）。不反映到数据库磁盘中而是保持为原来状态的操作称为回滚（rollback）。</p>
<h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><p>如果多个操作需要一起进行，可以将其放在一个事务中，以保证所有操作都要么全部成功，要么全部失败。</p>
<p>在MySQL中，使用以下语句来开始一个事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">START TRANSACTION;<br>-- 或者 BEGIN;<br>-- 或者 BEGIN WORK;<br></code></pre></td></tr></table></figure>

<p><code>BEGIN</code>和<code>BEGIN WORK</code>命令也可以用于开启一个新的事务。它们与<code>START TRANSACTION</code>命令作用相同，都可以开启一个新的事务，让后续的SQL语句在这个事务内执行。</p>
<h2 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h2><p>如果所有的操作都成功了，则使用以下语句来提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">COMMIT;<br></code></pre></td></tr></table></figure>

<p>在MySQL中，有一个自动提交（autocommit）功能，默认情况下开启。当执行单个SQL语句时，会自动将该语句的修改内容提交到数据库，即将其作为一个事务进行处理。</p>
<p>如果需要关闭自动提交功能，则可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET autocommit = 0;<br></code></pre></td></tr></table></figure>

<p>这样，在执行多个SQL语句时，就需要手动调用START TRANSACTION或BEGIN、BEGIN WORK命令开始一个新的事务，再通过COMMIT日提交事务。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET autocommit = 0;<br><br>-- 开始一个新的事务<br>BEGIN;<br><br>-- 执行一些SQL语句<br>INSERT INTO table1 (column1, column2) VALUES (value1, value2);<br><br>-- 判断是否发生错误<br>IF some_error_occured THEN<br>    -- 回滚事务<br>    ROLLBACK;<br>ELSE<br>    -- 提交事务<br>    COMMIT;<br>END IF;<br></code></pre></td></tr></table></figure>

<p>以上代码首先关闭了自动提交功能，然后使用BEGIN命令开始了一个新的事务，在其中执行了一些SQL语句，并根据情况选择了提交或回滚事务。</p>
<h2 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h2><p>在MySQL中，使用ROLLBACK命令回滚事务，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 开始一个事务<br>START TRANSACTION;<br><br>-- 在事务中执行一系列的数据库操作<br><br>-- 判断是否需要回滚事务<br>IF some_condition THEN<br>  -- 回滚事务<br>  ROLLBACK;<br>ELSE<br>  -- 提交事务<br>  COMMIT;<br>END IF;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，使用ROLLBACK回滚事务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN WORK;<br>-- 或者 BEGIN;<br>-- 或者 START TRANSACTION;<br><br>-- 执行一些SQL操作<br><br>SAVEPOINT sp1;<br><br>-- 执行一些SQL操作<br><br>ROLLBACK TO SAVEPOINT sp1;<br><br>-- 执行一些SQL操作<br><br>COMMIT;<br></code></pre></td></tr></table></figure>

<p>以上示例中，除了使用ROLLBACK命令回滚事务之外，还涉及到了MySQL事务中的保存点（SAVEPOINT）概念。保存点是指在事务内定义的一个标记，用于标识事务内某个时刻的状态。当事务遇到错误并进行回滚时，可以将事务恢复到保存点所标识的状态。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/data-types.html">数据类型</a></h1><p>MySQL数据库表列中的数据的种类称为MySQL的数据类型。</p>
<h2 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>含义</th>
<th>对应范围</th>
</tr>
</thead>
<tbody><tr>
<td>BLOB</td>
<td>存储二进制大型对象的数据类型</td>
<td>最多可以存储65535个字节</td>
</tr>
</tbody></table>
<h2 id="数值型数据类型"><a href="#数值型数据类型" class="headerlink" title="数值型数据类型"></a>数值型数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">含义</th>
<th align="center">对应范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TINYINT</td>
<td align="center">极小整数值</td>
<td align="center">-128 到 127（有符号），0 到 255（无符号）</td>
</tr>
<tr>
<td align="center">SMALLINT</td>
<td align="center">小整数值</td>
<td align="center">-32,768 到 32,767（有符号），0 到 65,535（无符号）</td>
</tr>
<tr>
<td align="center">MEDIUMINT</td>
<td align="center">中等大小的整数值</td>
<td align="center">-8,388,608 到 8,388,607（有符号），0 到 16,777,215（无符号）</td>
</tr>
<tr>
<td align="center">INT</td>
<td align="center">常规大小的整数值</td>
<td align="center">-2,147,483,648 到 2,147,483,647（有符号），0 到 4,294,967,295（无符号）</td>
</tr>
<tr>
<td align="center">BIGINT</td>
<td align="center">非常大的整数值</td>
<td align="center">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807（有符号），0 到 18,446,744,073,709,551,615（无符号）</td>
</tr>
<tr>
<td align="center">FLOAT</td>
<td align="center">单精度浮点数</td>
<td align="center">精度（决定了能够存储的总位数，包括小数点左边和右边的数）是 7 位</td>
</tr>
<tr>
<td align="center">DOUBLE</td>
<td align="center">双精度浮点数</td>
<td align="center">精度是 15 位</td>
</tr>
<tr>
<td align="center">DECIMAL</td>
<td align="center">精确的小数值，用于存储精确的数值，如货币</td>
<td align="center">精度是 65 位</td>
</tr>
</tbody></table>
<p>输入的数值型数据可以采用指数表示法输入，在指数表示法输入的情况下，“AEB”表示“A乘以10的B次方”，B可以为任何整数（负数、零、正数），例如“6.02*10的23次方”可以表示为“6.02E+23”。</p>
<h2 id="字符串型数据类型"><a href="#字符串型数据类型" class="headerlink" title="字符串型数据类型"></a>字符串型数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">含义</th>
<th align="center">对应范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CHAR</td>
<td align="center">定长字符串，长度固定</td>
<td align="center">0 到 255 字节</td>
</tr>
<tr>
<td align="center">VARCHAR</td>
<td align="center">变长字符串，长度可变</td>
<td align="center">0 到 65,535 字节</td>
</tr>
<tr>
<td align="center">TINYTEXT</td>
<td align="center">很小的文本字符串</td>
<td align="center">0 到 255 字节</td>
</tr>
<tr>
<td align="center">TEXT</td>
<td align="center">小到中等大小的文本字符串</td>
<td align="center">0 到 65,535 字节</td>
</tr>
<tr>
<td align="center">MEDIUMTEXT</td>
<td align="center">中等大小的文本字符串</td>
<td align="center">0 到 16,777,215 字节</td>
</tr>
<tr>
<td align="center">LONGTEXT</td>
<td align="center">大文本字符串</td>
<td align="center">0 到 4,294,967,295 字节</td>
</tr>
<tr>
<td align="center">ENUM</td>
<td align="center">字符串对象，只能有一组预定义的值，并且值的数量不能超过 65535</td>
<td align="center">1 或 2 字节，根据枚举值的数量</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">字符串对象，可以有多个值，值的数量不能超过 64</td>
<td align="center">1、2、3、4 或 8 字节，根据集合值的数量</td>
</tr>
</tbody></table>
<p>输入的字符串如果有“’”，需要转义处理，改为“\‘”</p>
<p>MySQL4.1版本之后，VARCHAR和CHAR的()中指定的位数单位变为“字符”，以VARCHAR(10)为例，不管输入的是中文还是英文还是数字，最多只能保留10个字符</p>
<p><strong>VARCHAR的字符范围：</strong></p>
<p>在MySQL 5.0.3及更高版本中，<code>VARCHAR</code>可以存储最多65535字节的数据，这包括存储长度的1到2个字节。实际的最大字符串长度由最大行大小（默认为65535字节）和使用的字符集决定。</p>
<p>例如，如果使用utf8字符集（最多需要3字节来存储一个字符），则<code>VARCHAR</code>可以存储最多21845个字符（65535&#x2F;3，舍去小数）。如果使用utf8mb4字符集（最多需要4字节来存储一个字符），则<code>VARCHAR</code>可以存储最多16383个字符（65535&#x2F;4，舍去小数）。</p>
<p>在MySQL 5.0.2及更低版本中，<code>VARCHAR</code>最多只能存储255个字符。</p>
<h2 id="日期和时间型数据类型"><a href="#日期和时间型数据类型" class="headerlink" title="日期和时间型数据类型"></a>日期和时间型数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">含义</th>
<th align="center">对应范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">YEAR</td>
<td align="center">年份</td>
<td align="center">1901 到 2155（4位时），以及1970<del>2069（2位时，70</del>69）</td>
</tr>
<tr>
<td align="center">DATE</td>
<td align="center">日期</td>
<td align="center">‘1000-01-01’ 到 ‘9999-12-31’</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">时间</td>
<td align="center">‘-838:59:59’ 到 ‘838:59:59’</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">日期和时间组合</td>
<td align="center">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td>
</tr>
<tr>
<td align="center">TIMESTAMP</td>
<td align="center">时间戳</td>
<td align="center">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC</td>
</tr>
</tbody></table>
<p>MySQL中的时间类型还支持小数秒，例如 <code>DATETIME(3)</code>、<code>TIME(3)</code> 或 <code>TIMESTAMP(3)</code> 可以存储精确到毫秒的时间。在括号中的数字表示小数秒的精度。</p>
<p>在MySQL中，TIMESTAMP和DATETIME数据类型共享相同的格式来存储和显示日期和时间值（YYYY-MM-DD HH:MM:SS）。然而，这两种数据类型在处理时区信息的方式上存在根本差异：</p>
<ul>
<li><p>TIMESTAMP：</p>
<p>TIMESTAMP数据类型存储带有时区信息的日期和时间值。</p>
<ul>
<li>当在TIMESTAMP列中插入一个值时，MySQL会将给定的日期和时间转换为UTC（协调世界时）并存储它。</li>
<li>当从TIMESTAMP列检索数据时，MySQL会将存储的UTC时间转换回会话时区（或为服务器设置的时区），因此可能会看到根据当前时区调整的值。</li>
</ul>
</li>
<li><p>DATETIME：<br>DATETIME数据类型不包括时区信息。</p>
<ul>
<li>当在DATETIME列中插入一个值时，MySQL会存储提供的确切日期和时间，而不会进行任何时区转换。</li>
<li>当从DATETIME列检索数据时，数据保持不变，并且不会进行时区转换。原始值在存储时返回。</li>
</ul>
</li>
</ul>
<h1 id="字符集和比较规则"><a href="#字符集和比较规则" class="headerlink" title="字符集和比较规则"></a>字符集和比较规则</h1><p>MySQL的字符集和比较规则有四个级别，分别是服务器级别、数据库（schema）级别、表（table）级别、列级别。</p>
<p>查看字符集的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW (CHARACTER SET|CHARSET) [LIKE 匹配的模式];<br></code></pre></td></tr></table></figure>

<p>查看比较规则的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW COLLATION [LIKE 匹配的模式];<br></code></pre></td></tr></table></figure>

<p>比较规则名称后缀，及其英文释义和描述：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>英文释义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_cs</td>
<td>case sensitive</td>
<td>区分大小写</td>
</tr>
<tr>
<td>_ci</td>
<td>case insensitive</td>
<td>不区分大小写</td>
</tr>
<tr>
<td>_as</td>
<td>accent sensitive</td>
<td>区分重音</td>
</tr>
<tr>
<td>_ai</td>
<td>accent insensitive</td>
<td>不区分重音</td>
</tr>
<tr>
<td>_bin</td>
<td>binary</td>
<td>以二进制方式比较</td>
</tr>
</tbody></table>
<p>从客户端发送请求给服务器到服务器接收请求并返回结果的过程中发生的字符转换包括：</p>
<ol>
<li><p>客户端发送的请求字节序列是采用哪种字符集进行编码。</p>
<p>与启动选项default-character-set有关。</p>
</li>
<li><p>服务器收到客户端的请求后认为客户端是采用哪种字符集进行编码的。</p>
<p>与系统变量character-set-client有关。</p>
</li>
<li><p>服务器在运行过程中会把请求的字节序列转化为以哪种字符集编码的字节序列。</p>
<p>与系统变量character-set-connection有关。</p>
</li>
<li><p>服务器向客户端返回字节序列时会采用哪种字符集进行编码。</p>
<p>与系统变量character-set-result有关。</p>
</li>
<li><p>客户端在收到字节序列的响应后的怎样将字节序列写到控制台中。</p>
<p>与启动选项default-character-set有关。</p>
</li>
</ol>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="聚合函数（部分）"><a href="#聚合函数（部分）" class="headerlink" title="聚合函数（部分）"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/aggregate-functions.html">聚合函数</a>（部分）</h2><ol>
<li><p>SUM：计算某个字段的总和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUM(column_name) FROM table_name;<br></code></pre></td></tr></table></figure>
</li>
<li><p>COUNT：返回某个字段的行数，可以用于计算某个列或整个表中行的数量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT COUNT(column_name) FROM table_name;<br></code></pre></td></tr></table></figure>
</li>
<li><p>AVG：计算某个字段的平均值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT AVG(column_name) FROM table_name;<br></code></pre></td></tr></table></figure>
</li>
<li><p>MIN：找出某个字段的最小值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MIN(column_name) FROM table_name;<br></code></pre></td></tr></table></figure>
</li>
<li><p>MAX：找出某个字段的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MAX(column_name) FROM table_name;<br></code></pre></td></tr></table></figure>
</li>
<li><p>GROUP_CONCAT：将某个字段的值连接成一个字符串。可以指定<code>SEPARATOR</code>来指定连接字符串的分隔符，如果没有指定，默认使用逗号作为分隔符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT GROUP_CONCAT(column_name SEPARATOR &#x27;,&#x27;) FROM table_name;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="字符串操作函数（部分）"><a href="#字符串操作函数（部分）" class="headerlink" title="字符串操作函数（部分）"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html">字符串操作函数</a>（部分）</h2><ol>
<li><p>CONCAT()：用于连接字符串。</p>
<p>语法：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_concat"><code>CONCAT(*</code>str1<code>*,*</code>str2<code>*,...)</code></a>，str是要拼接的字符串。</p>
<p>例如，下面的语句会查询<code>users</code>表中的<code>first_name</code>和<code>last_name</code>字段，并将这两个字段的值用空格连接起来，作为新的列<code>full_name</code>的值进行返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CONCAT(first_name, &#x27; &#x27;, last_name) AS full_name FROM users;<br></code></pre></td></tr></table></figure>
</li>
<li><p>RIGHT()：返回字符串的右侧指定长度的子字符串。</p>
<p>语法：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_right"><code>RIGHT(*</code>str<code>*,*</code>len<code>*)</code></a>，str是要截取的字符串，len是需要返回的字符长度。</p>
<p>例如，下面的语句会查询<code>users</code>表中的<code>username</code>字段，并返回该字段后两个字符组成的新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT RIGHT(username, 2) AS last_two_chars FROM users;<br></code></pre></td></tr></table></figure>
</li>
<li><p>SUBSTRING()：从字符串中截取指定位置和长度的子字符串。</p>
<p>语法：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_substring"><code>SUBSTRING(*</code>str<code>*,*</code>pos<code>*,*</code>len<code>*)</code></a>，str是要截取的字符串，pos是开始的位置（从1开始计数，pos值为0将返回空字符串），len是需要返回的字符长度。</p>
<p>例如，下面的语句会查询<code>users</code>表中的<code>phone_number</code>字段，并返回该字段第4个字符开始的3个字符组成的新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUBSTRING(phone_number, 4, 3) AS area_code FROM users;<br></code></pre></td></tr></table></figure>
</li>
<li><p>REPEAT()：返回一个重复指定次数的字符串。</p>
<p>语法：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_repeat"><code>REPEAT(*</code>str<code>*,*</code>count<code>*)</code></a>，str是需要重复的字符串，count是需要重复的次数。</p>
<p>例如，下面的语句会返回一个由5个“-”字符组成的新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT REPEAT(&#x27;-&#x27;, 5) AS line FROM users;<br></code></pre></td></tr></table></figure>
</li>
<li><p>REVERSE()：返回一个字符串的反转字符串。</p>
<p>语法：<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_reverse"><code>REVERSE(*</code>str<code>*)</code></a>，str是要翻转的字符串。</p>
<p>例如，下面的语句会查询<code>users</code>表中的<code>username</code>字段，并返回<code>username</code>字段的字符顺序全部颠倒后的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT REVERSE(username) AS reversed_name FROM users;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="日期和时间函数（部分）"><a href="#日期和时间函数（部分）" class="headerlink" title="日期和时间函数（部分）"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html">日期和时间函数</a>（部分）</h2><p>MySQL提供了很多日期和时间函数，可以方便地对日期和时间进行处理和计算。以下是一些常用的MySQL日期和时间函数：</p>
<ol>
<li><p>NOW()：返回当前日期和时间。</p>
<p>例如，下面的语句会查询当前日期和时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT NOW();<br></code></pre></td></tr></table></figure>
</li>
<li><p>DATE()：从一个日期或日期时间表达式中提取日期部分。</p>
<p>例如，下面的语句会返回当前日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATE(NOW());<br></code></pre></td></tr></table></figure>
</li>
<li><p>DATE_FORMAT()：将给定日期格式化成指定的字符串形式。</p>
<p>语法是<code>DATE_FORMAT(date, format) </code>，其中 <code>date</code> 为待格式化的日期，<code>format</code> 为日期格式串（如 ‘%Y-%m-%d’ 表示以年、月、日的格式显示日期）。</p>
<p>例如，以下查询语句将会格式化出当前日期并输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATE_FORMAT(CURDATE(), &#x27;%Y-%m-%d&#x27;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>DATE_SUB()：对日期执行减法操作。</p>
<p>可以使用 DATE_SUB() 函数和 INTERVAL 子句来查询一个日期字段 c 为五年前的记录。具体语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM table<br>WHERE c = DATE_SUB(NOW(), INTERVAL 5 YEAR);<br></code></pre></td></tr></table></figure>

<p>这个查询语句中，<code>NOW()</code> 函数返回当前时间，<code>DATE_SUB()</code> 函数将当前时间减去 5 年，然后查询满足条件的所有记录。</p>
</li>
<li><p>DATE_ADD()：对给定日期增加或减去一定的时长。</p>
<p>语法是<code>DATE_ADD(date, INTERVAL value unit)</code> ，其中 <code>date</code> 为基准日期，<code>value</code> 为增加或减少的数值，<code>unit</code> 为时间单位（如 DAY、WEEK、MONTH、YEAR 等）。</p>
<p>例如，以下查询语句将会计算出五年前的日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATE_ADD(CURDATE(), INTERVAL -5 YEAR);<br></code></pre></td></tr></table></figure>
</li>
<li><p>CURDATE()：返回系统当前日期。</p>
<p>例如，以下查询语句将会返回当前日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CURDATE();<br></code></pre></td></tr></table></figure>
</li>
<li><p>DATEDIFF()：返回两个日期之间的天数差值</p>
<p>例如，以下查询语句将会计算出今天与指定日期之间的天数差值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATEDIFF(CURDATE(), &#x27;2022-01-01&#x27;);<br></code></pre></td></tr></table></figure>
</li>
<li><p>TIME()：从一个日期或日期时间表达式中提取时间部分</p>
<p>例如，下面的语句会返回当前时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT TIME(NOW());<br></code></pre></td></tr></table></figure>
</li>
<li><p>YEAR()：从一个日期或日期时间表达式中提取年份部分</p>
<p>例如，下面的语句会返回当前年份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT YEAR(NOW());<br></code></pre></td></tr></table></figure>
</li>
<li><p>MONTH()：从一个日期或日期时间表达式中提取月份部分。</p>
<p>例如，下面的语句会返回当前月份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MONTH(NOW());<br></code></pre></td></tr></table></figure>
</li>
<li><p>DAY()：从一个日期或日期时间表达式中提取日份部分。</p>
<p>例如，下面的语句会返回当前日期中的天数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DAY(NOW());<br></code></pre></td></tr></table></figure>
</li>
<li><p>HOUR()：从一个日期或日期时间表达式中提取小时部分。</p>
<p>例如，下面的语句会返回当前时间中的小时数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT HOUR(NOW());<br></code></pre></td></tr></table></figure>
</li>
<li><p>MINUTE()：从一个日期或日期时间表达式中提取分钟部分。</p>
<p>例如，下面的语句会返回当前时间中的分钟数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MINUTE(NOW());<br></code></pre></td></tr></table></figure>
</li>
<li><p>SECOND()：从一个日期或日期时间表达式中提取秒部分。</p>
<p>例如，下面的语句会返回当前时间中的秒数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SECOND(NOW());<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="比较函数和运算符"><a href="#比较函数和运算符" class="headerlink" title="比较函数和运算符"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html">比较函数和运算符</a></h2><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than"><code>&gt;</code></a></td>
<td align="left">Greater than operator</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_greater-than-or-equal"><code>&gt;=</code></a></td>
<td align="left">Greater than or equal operator</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than"><code>&lt;</code></a></td>
<td align="left">Less than operator</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-equal"><code>&lt;&gt;</code>, <code>!=</code></a></td>
<td align="left">Not equal operator</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_less-than-or-equal"><code>&lt;=</code></a></td>
<td align="left">Less than or equal operator</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal-to"><code>&lt;=&gt;</code></a></td>
<td align="left">NULL-safe equal to operator</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_equal"><code>=</code></a></td>
<td align="left">Equal operator</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_between"><code>BETWEEN ... AND ...</code></a></td>
<td align="left">Whether a value is within a range of values</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#function_coalesce"><code>COALESCE()</code></a></td>
<td align="left">Return the first non-NULL argument</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#function_greatest"><code>GREATEST()</code></a></td>
<td align="left">Return the largest argument</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_in"><code>IN()</code></a></td>
<td align="left">Whether a value is within a set of values</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#function_interval"><code>INTERVAL()</code></a></td>
<td align="left">Return the index of the argument that is less than the first argument</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is"><code>IS</code></a></td>
<td align="left">Test a value against a boolean</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-not"><code>IS NOT</code></a></td>
<td align="left">Test a value against a boolean</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-not-null"><code>IS NOT NULL</code></a></td>
<td align="left">NOT NULL value test</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_is-null"><code>IS NULL</code></a></td>
<td align="left">NULL value test</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#function_isnull"><code>ISNULL()</code></a></td>
<td align="left">Test whether the argument is NULL</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#function_least"><code>LEAST()</code></a></td>
<td align="left">Return the smallest argument</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html#operator_like"><code>LIKE</code></a></td>
<td align="left">Simple pattern matching</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-between"><code>NOT BETWEEN ... AND ...</code></a></td>
<td align="left">Whether a value is not within a range of values</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/comparison-operators.html#operator_not-in"><code>NOT IN()</code></a></td>
<td align="left">Whether a value is not within a set of values</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html#operator_not-like"><code>NOT LIKE</code></a></td>
<td align="left">Negation of simple pattern matching</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/string-comparison-functions.html#function_strcmp"><code>STRCMP()</code></a></td>
<td align="left">Compare two strings</td>
</tr>
</tbody></table>
<h3 id="BETWEEN详解"><a href="#BETWEEN详解" class="headerlink" title="BETWEEN详解"></a>BETWEEN详解</h3><p>在MySQL中，BETWEEN是一个比较运算符，用于检查一个值是否在指定的一组或区间内，返回值是布尔类型。它能够用于数字，日期和时间等数据类型。</p>
<p>需要注意的是，在使用BETWEEN时，应该确保low和high的顺序正确，即low应该小于等于high。否则会导致结果不准确。同时也需要注意数据类型的匹配问题，避免类型不匹配的情况。</p>
<p>BETWEEN语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">value BETWEEN low AND high;<br></code></pre></td></tr></table></figure>

<p>其中，value是需要进行比较的值，low和high是指定的区间范围。</p>
<p>对于日期和时间类型的值来说，BETWEEN则会将这个值转换为一个日期&#x2F;时间对象后再进行比较。</p>
<p>例如，假设我们有一个名为<code>orders</code>的表格，其中包含了订单的信息，包括订单编号、下单日期和订单总额等。如果我们想要查询某一段时间内的订单，可以使用BETWEEN关键字来实现，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM orders WHERE order_date BETWEEN &#x27;2021-01-01&#x27; AND &#x27;2021-03-31&#x27;;<br></code></pre></td></tr></table></figure>

<p>这条语句查询了从2021年1月1日到2021年3月31日之间的订单信息。</p>
<h3 id="IN详解"><a href="#IN详解" class="headerlink" title="IN详解"></a>IN详解</h3><p>在MySQL中，<code>IN</code>是一个比较运算符，用于检查某个值是否包含在一个值集合内。</p>
<p><strong>“&#x3D;”不能代替IN</strong>，因为“&#x3D;”在返回结果多于一条的时候会报错，“Subquery returns more than 1 row”。</p>
<p> IN 不能对 NULL 进行匹配，不会返回NULL值匹配的字段。</p>
<p>NOT IN语句后面的范围不能出现NULL，否则执行无效，不会返回任何字段。</p>
<p>以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> column_name <span class="hljs-keyword">IN</span> (value1, value2, ...);<br></code></pre></td></tr></table></figure>

<p>在这个语句中，<code>column1</code>, <code>column2</code>, … 是想从表中选择的列的名称，<code>table_name</code>是想从中选择数据的表的名称，<code>column_name</code>是想要应用条件的列的名称，<code>value1</code>, <code>value2</code>, … 是想在列中查找的值。</p>
<p>例如，如果想从<code>students</code>表中选择名字为’John Doe’或’Jane Doe’的学生，可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;John Doe&#x27;</span>, <span class="hljs-string">&#x27;Jane Doe&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><code>IN</code>运算符不完全等价于多个<code>OR</code>条件。虽然上面的查询等价于以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John Doe&#x27;</span> <span class="hljs-keyword">OR</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Jane Doe&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>但是，因为 IN 不能对 NULL 进行处理，</p>
<p>所以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1<br>FROM table_name<br>WHERE column1 IN (1, 2, NULL);<br></code></pre></td></tr></table></figure>

<p>和</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1<br>FROM table_name<br>WHERE column1 IN (1, 2) OR column1 IS NULL;<br></code></pre></td></tr></table></figure>

<p>的处理逻辑是不一样的，对于前一个使用IN的SQL语句来说，只会返回column1为1、2的列值，不会对null值进行匹配，即查询不到NULL值记录。而对于后一个使用OR的SQL语句来说，能够返回column1为1、2或NULL的列值，即能够处理NULL。</p>
<p><strong>还可以在<code>IN</code>子句中使用子查询来动态生成值的列表</strong>。例如，以下查询会选择所有在<code>courses</code>表中有记录的学生：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> student_id <span class="hljs-keyword">FROM</span> courses);<br></code></pre></td></tr></table></figure>

<p>在这个例子中，子查询<code>SELECT student_id FROM courses</code>会返回所有在<code>courses</code>表中有记录的学生的ID，然后主查询会从<code>students</code>表中选择这些ID对应的学生。</p>
<h3 id="LIKE详解"><a href="#LIKE详解" class="headerlink" title="LIKE详解"></a>LIKE详解</h3><p>在MySQL中，<code>LIKE</code>是一个用于模式匹配的操作符，通常用于<code>WHERE</code>子句中以过滤符合特定模式的数据。</p>
<p><code>LIKE</code>匹配区分大小写，如果需要不区分大小写的匹配，可以使用<code>COLLATE</code>关键字指定不区分大小写的匹配规则，如 <code>WHERE column_name COLLATE utf8_general_ci LIKE pattern</code>。</p>
<p>以下是<code>LIKE</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> column_name <span class="hljs-keyword">LIKE</span> <span class="hljs-keyword">pattern</span>;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是想要从表中选择的列的名称，<code>table_name</code> 是想要查询的表的名称，<code>column_name</code> 是想要应用模式匹配的列的名称，<code>pattern</code> 是匹配模式。</p>
<p><code>LIKE</code>操作符使用通配符来匹配模式，常用的通配符有：</p>
<ul>
<li><code>%</code>：匹配任意字符（包括零个字符）。</li>
<li><code>_</code>：匹配任意单个字符。</li>
<li><code>[characters]</code>：匹配指定字符集中的任意单个字符。</li>
<li><code>[^characters]</code>：匹配不在指定字符集中的任意单个字符。</li>
</ul>
<p>以下是一些使用<code>LIKE</code>的例子：</p>
<ol>
<li><p><strong>以特定字符开头的匹配：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;J%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这个查询将返回名字以字母 ‘J’ 开头的所有学生记录。</p>
</li>
<li><p><strong>以特定字符结尾的匹配：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> email <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%example.com&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这个查询将返回邮箱以 ‘@example.com’ 结尾的所有学生记录。</p>
</li>
<li><p><strong>包含特定字符的匹配：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Doe%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这个查询将返回名字中包含 ‘Doe’ 的所有学生记录。</p>
</li>
<li><p><strong>指定单个字符的匹配：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_ohn&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这个查询将返回名字为四个字符并以 ‘ohn’ 结尾的所有学生记录，其中第二个字符可以是任意字符。</p>
</li>
</ol>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html">逻辑运算符</a></h2><table>
<thead>
<tr>
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_and"><code>AND</code>, <code>&amp;&amp;</code></a></td>
<td align="left">Logical AND</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_not"><code>NOT</code>, <code>!</code></a></td>
<td align="left">Negates value</td>
</tr>
<tr>
<td align="left">[<code>OR</code>, &#96;</td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/logical-operators.html#operator_xor"><code>XOR</code></a></td>
<td align="left">Logical XOR</td>
</tr>
</tbody></table>
<h1 id="关键字（部分）"><a href="#关键字（部分）" class="headerlink" title="关键字（部分）"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/keywords.html">关键字</a>（部分）</h1><h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><p>在MySQL中，<code>WHERE</code>子句用于在查询中指定条件，以过滤出满足特定条件的记录。以下是<code>WHERE</code>子句的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是想要从表中选择的列的名称，<code>table_name</code> 是想要查询的表的名称，<code>condition</code> 是用于确定哪些记录应该被返回的条件。</p>
<p>以下是一些使用<code>WHERE</code>子句的例子：</p>
<ol>
<li><p><strong>基于单个条件的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回年龄大于 20 的所有学生记录。</p>
</li>
<li><p><strong>基于多个条件的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Female&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回年龄大于 20 并且性别为女性的学生记录。</p>
</li>
<li><p><strong>使用比较运算符的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回年龄在 18 到 25 之间的学生记录。</p>
</li>
<li><p><strong>使用逻辑运算符的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span> <span class="hljs-keyword">OR</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Female&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回年龄大于 20 或性别为女性的学生记录。</p>
</li>
</ol>
<p>请注意，<code>WHERE</code>子句可以使用比较运算符（如 <code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>），逻辑运算符（如 <code>AND</code>, <code>OR</code>, <code>NOT</code>），以及其他条件表达式（如 <code>IN</code>, <code>LIKE</code>, <code>IS NULL</code> 等）来构建复杂的条件。</p>
<p><strong>WHERE可以对GROUP BY分组前的记录进行过滤，聚合函数不能放在WHERE子句中</strong>，即在如下语句中，WHERE在GROUP BY<strong>之前</strong>执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>	empid, AVG(sales)<br>FROM<br>	WHERE sales &gt;= 50<br>GROUP BY empid;<br></code></pre></td></tr></table></figure>

<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>在MySQL中，<code>GROUP BY</code>子句用于将查询结果按照一个或多个列进行分组。它常与聚合函数（如<code>SUM</code>、<code>COUNT</code>、<code>AVG</code>等）一起使用，以<strong>对每个组应用聚合函数并生成汇总结果</strong>。</p>
<p>以下是<code>GROUP BY</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="hljs-keyword">column</span>)<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2, ...;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是想要从表中选择的列的名称，<code>table_name</code> 是想要查询的表的名称，<code>aggregate_function</code> 是一个聚合函数（如 <code>SUM</code>, <code>COUNT</code>, <code>AVG</code> 等），<code>column</code> 是想要按照其进行分组的列。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department, gender, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> total_students<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department, gender;<br></code></pre></td></tr></table></figure>

<p>这个查询将根据<code>department</code>和<code>gender</code>两个列对记录进行分组，并计算每个部门、性别组合的学生人数。</p>
<h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p>在MySQL中，<code>HAVING</code>子句用于在<code>GROUP BY</code>子句后对分组结果进行筛选，而且可以对聚合函数进行过滤。</p>
<p><strong>HAVING子句只能和GROUP BY子句搭配使用</strong>，在执行GROUP BY子句之后，可以使用HAVING子句来进一步筛选符合条件的结果集。</p>
<p>以下是<code>HAVING</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="hljs-keyword">column</span>)<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2, ...<br><span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是想要从表中选择的列的名称，<code>table_name</code> 是想要查询的表的名称，<code>aggregate_function</code> 是一个聚合函数（如 <code>SUM</code>, <code>COUNT</code>, <code>AVG</code> 等），<code>column</code> 是想要按照其进行分组的列，<code>condition</code> 是用于筛选结果的条件。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> total_students<br><span class="hljs-keyword">FROM</span> students<br>	<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p>这个查询将根据学生表中的<code>department</code>列对记录进行分组，并计算每个部门的学生人数。然后，<code>HAVING</code>子句筛选出具有超过 10 名学生的部门。 </p>
<h2 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h2><p>在MySQL中，<code>EXISTS</code>用于检查一个子查询是否返回了任何行。<code>EXISTS</code>运算符返回布尔值（<code>TRUE</code>或<code>FALSE</code>），如果子查询返回至少一行，则为<code>TRUE</code>，否则为<code>FALSE</code>。它通常用于<code>WHERE</code>子句中作为一个条件来过滤查询结果。</p>
<p>以下是<code>EXISTS</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (subquery);<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是想要从表中选择的列的名称，<code>table_name</code> 是想要查询的表的名称，<code>subquery</code> 是一个子查询，它可以是一个完整的<code>SELECT</code>语句。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-keyword">FROM</span> courses<br>    <span class="hljs-keyword">WHERE</span> courses.student_id <span class="hljs-operator">=</span> students.id<br>);<br></code></pre></td></tr></table></figure>

<p>这个查询将返回在<code>students</code>表中存在对应课程的学生的姓名。子查询检查是否存在与<code>students</code>表中的学生关联的记录在<code>courses</code>表中。</p>
<h2 id="IN和EXISTS的区别"><a href="#IN和EXISTS的区别" class="headerlink" title="IN和EXISTS的区别"></a><a target="_blank" rel="noopener" href="https://learnku.com/articles/56782#:~:text=in%20%E5%92%8Cexists%20%E7%9A%84%E5%8C%BA%E5%88%AB,%E6%9C%89%E7%B4%A2%E5%BC%95%E6%97%B6%E4%BD%BF%E7%94%A8exists%E3%80%82">IN和EXISTS的区别</a></h2><p><code>IN</code>和<code>EXISTS</code>的区别：**如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用<code>IN</code>，反之如果外层的主查询记录较少，子查询中的表大且又有索引时使用<code>EXISTS</code>**。<code>IN</code>和<code>EXISTS</code>主要是造成了驱动顺序的改变 （这是性能变化的关键），如果是 <code>EXISTS</code>，那么以外层表为驱动表，先执行主查询，如果是<code>IN</code>，那么子查询的表是驱动表，先执行子查询。</p>
<h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>MySQL中的<code>DISTINCT</code>关键字适用于单个列的去重，若需要多列的去重，则需要使用<code>GROUP BY</code>语句来实现。</p>
<p>例如，当我们需要查询某张表中的所有员工身份证号码时，可能会出现一些员工重复的情况。此时可以使用<code>DISTINCT</code>关键字来消除重复项，确保查询结果唯一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT id_number FROM employee;<br></code></pre></td></tr></table></figure>

<p>上述语句将返回一张包含所有不重复身份证号码的数据表。</p>
<h2 id="ORDER-BY和ACS或DESC"><a href="#ORDER-BY和ACS或DESC" class="headerlink" title="ORDER BY和ACS或DESC"></a>ORDER BY和ACS或DESC</h2><p>在MySQL中，<code>ORDER BY</code>子句可以指定查询结果按照一个或多个列进行升序（默认）或降序排序。</p>
<p>以下是<code>ORDER BY</code>子句的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1, column2, ...<br>FROM table_name<br>ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是想要排序的列的名称，<code>ASC</code>表示升序（默认），<code>DESC</code>表示降序。</p>
<p>以下是一些例子：</p>
<ol>
<li><p><strong>按照单个列进行升序排序：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM students<br>ORDER BY name ASC;<br></code></pre></td></tr></table></figure>

<p> 这将按照<code>name</code>列的字母顺序对<code>students</code>表中的记录进行升序排序。</p>
</li>
<li><p><strong>按照单个列进行降序排序：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM students<br>ORDER BY age DESC;<br></code></pre></td></tr></table></figure>

<p> 这将按照<code>age</code>列的逆序（从高到低）对<code>students</code>表中的记录进行降序排序。</p>
</li>
<li><p><strong>按照多个列进行排序：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM students<br>ORDER BY age ASC, name ASC;<br></code></pre></td></tr></table></figure>

<p> 这将首先按照<code>age</code>列进行升序排序，然后对于具有相同<code>age</code>值的记录，按照<code>name</code>列的字母顺序进行升序排序。</p>
</li>
</ol>
<h2 id="LIMIT和OFFSET"><a href="#LIMIT和OFFSET" class="headerlink" title="LIMIT和OFFSET"></a>LIMIT和OFFSET</h2><p>在MySQL中，<code>LIMIT</code>用于限制查询结果的数量。它可以在<code>SELECT</code>语句中用于指定返回的行数。<code>OFFSET</code> 用于从查询结果的某个特定行开始返回数据，必须和 <code>LIMIT</code> 一起使用。</p>
<p>以下是<code>LIMIT</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br>LIMIT count;<br></code></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1, column2, ...<br>FROM table<br>WHERE condition<br>ORDER BY column1, column2, ...<br>LIMIT offset, count;<br></code></pre></td></tr></table></figure>

<p><code>OFFSET</code> 的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1, column2, ...<br>FROM table<br>WHERE condition<br>ORDER BY column1, column2, ...<br>LIMIT count OFFSET offset;<br></code></pre></td></tr></table></figure>

<p>其中，<code>column1</code>, <code>column2</code>, … 是想要从表中选择的列的名称，<code>table_name</code> 是想要查询的表的名称，<code>offset</code> 是要偏移的行数，<code>count</code> 是要返回的行数。</p>
<p>以下是一些使用<code>LIMIT</code>和<code>OFFSET</code>的例子：</p>
<ol>
<li><p><strong>限制结果集的行数：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students LIMIT <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回 <code>students</code> 表中的前 10 行记录。</p>
</li>
<li><p><strong>指定起始位置和行数：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students LIMIT <span class="hljs-number">5</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p> 或使用<code>OFFSET</code>写为：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM mytable<br>ORDER BY id<br>LIMIT 10 OFFSET 5;<br></code></pre></td></tr></table></figure>

<p> 这个查询将从 <code>students</code> 表中的第 6 行开始（偏移量为 5），返回后续的 10 行记录。这是通过使用两个参数来实现的，第一个参数是起始位置的偏移量，第二个参数是要返回的行数。</p>
</li>
<li><p>与<code>ORDER BY</code>子句一起使用：</p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将按照年龄降序排序，并返回年龄最大的前 5 条学生记录。</p>
</li>
</ol>
<h2 id="CASE-WHEN"><a href="#CASE-WHEN" class="headerlink" title="CASE WHEN"></a>CASE WHEN</h2><p>MySQL 的 CASE WHEN 是一种条件表达式，它类似于其他编程语言中的 switch 或 if-then-else 结构。它可以在 SELECT 语句中使用，根据一个或多个条件返回不同的值。</p>
<p>CASE WHEN 语法的基本结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CASE expression<br>WHEN value_1 THEN result_1<br>WHEN value_2 THEN result_2<br>...<br>ELSE default_result<br>END<br></code></pre></td></tr></table></figure>

<p>CASE 关键字后面的 expression 是要检查的值或表达式，value_x 是与 expression 进行比较的值，而 result_x 则是与 value_x 对应的结果。如果 expression 和某个 value_x 相匹配，则会返回对应的 result_x。如果都没有匹配，将会执行 ELSE 子句中指定的 default_result（可选的，如果没有 ELSE 子句，将返回 NULL）。</p>
<p>以下是一个简单的例子，演示了如何在 SELECT 语句中使用 CASE WHEN：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_name, <br>CASE department_id<br>	WHEN 1 THEN &#x27;Sales&#x27;<br>    WHEN 2 THEN &#x27;Marketing&#x27;<br>    ELSE &#x27;Other&#x27;<br>END as department<br>FROM employees;<br></code></pre></td></tr></table></figure>

<p>这条语句查询了一个名为 employees 的表格，其中包含员工信息，包括姓名、部门编号等。它使用 CASE WHEN 结构来把部门编号转换为对应的文本描述，最终会返回每个员工的名称和所在部门的文本标签。</p>
<p>需要注意的是，CASE WHEN 也支持复杂的判断逻辑和多个条件，可以使用嵌套和逻辑运算符来实现复杂的条件判断。</p>
<p>以下是CASE WHEN的另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id,<br>CASE<br>	WHEN sales &gt;= 100 THEN &#x27;高&#x27;<br>	WHEN sales &gt;= 50 THEN &#x27;中等&#x27;<br>    ELSE &#x27;低&#x27;<br>END AS &#x27;评价&#x27;<br>FROM tb;<br></code></pre></td></tr></table></figure>

<h2 id="IF-THEN-ELSE"><a href="#IF-THEN-ELSE" class="headerlink" title="IF-THEN-ELSE"></a>IF-THEN-ELSE</h2><p>在MySQL中，支持IF-THEN-ELSE条件语句。基本语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IF condition THEN<br>    statement(s);<br>ELSE<br>    statement(s);<br>END IF;<br></code></pre></td></tr></table></figure>

<p>其中，如果“condition”（条件）为真，则执行<code>THEN</code>子句中的一个或多个语句，否则执行<code>ELSE</code>子句中的一个或多个语句。ELSE&#96;块是可选的。</p>
<p>让我们看一个实际的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @score = 80;<br><br>IF @score &gt;= 60 THEN<br>    SELECT &#x27;Pass&#x27;;<br>ELSE<br>    SELECT &#x27;Fail&#x27;;<br>END IF;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，将变量<code>@score</code>设置为80分。然后，使用<code>IF</code>语句检查是否及格（分数大于等于60）。如果成立，则输出“Pass”，否则输出“Fail”。</p>
<h1 id="表查询"><a href="#表查询" class="headerlink" title="表查询"></a>表查询</h1><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>通俗的讲，在SELECT的记录中SELECT就是子查询。子查询是在查询中使用一个查询作为另一个查询的子集。使用子查询可以轻松地扩展查询功能并实现更复杂的条件过滤机制。</p>
<p>下面是一个示例，该示例演示如何使用子查询：</p>
<p>假设有两个表：Orders和Customers，分别存储订单和客户的信息。现在，假设想要查询所有来自某些城市的顾客的订单详细信息。可以使用以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM Orders<br>WHERE customer_id IN (<br>  SELECT customer_id<br>  FROM Customers<br>  WHERE city = &#x27;New York&#x27;<br>);<br></code></pre></td></tr></table></figure>

<p>这个查询中，内部SELECT语句是一个子查询，它返回所有位于“New York”城市的客户ID。外部SELECT语句使用WHERE子句来过滤Orders表中包含在子查询结果集中的customer_id值的行，并将行返回到结果集中。</p>
<p>下面是另一个示例：</p>
<p>提取大于等于平均值的记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM tb1<br>WHERE age &gt;= (<br>	SELECT AVG(age) FROM tb1<br>)<br></code></pre></td></tr></table></figure>

<p>下面是使用IN的子查询的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name1, column_name2... <br>FROM table_name<br>WHERE column_name IN (通过子查询SELECT语句提取的列)<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT empid, name<br>	FROM tb1<br>WHERE empid <br>	IN (SELECT empid FROM tb2);<br></code></pre></td></tr></table></figure>

<p>下面是使用EXISTS的子查询的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name1, column_name2... <br>FROM table_name<br>WHERE EXISTS (通过子查询SELECT语句提取的列);<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>	FROM tb1<br>WHERE EXISTS<br>	(SELECT * FROM tb2 WHERE tb1.empid=tb2.empid);<br></code></pre></td></tr></table></figure>

<h2 id="联合查询（UNION）"><a href="#联合查询（UNION）" class="headerlink" title="联合查询（UNION）"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/mysql/mysql-union-operation.html">联合查询（UNION）</a></h2><p>在 MySQL 中，<code>UNION</code> 关键字用于将两个或多个 <code>SELECT</code> 语句的结果集合并成一个结果集。</p>
<p>需要注意的是，在使用 <code>UNION</code> 或 <code>UNION ALL</code> 进行结果集合并时，被合并的列的类型必须相似或可隐式转换。</p>
<p> <code>UNION</code> 和 <code>UNION ALL</code> 的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT expression1, expression2, ... expression_n<br>FROM tables<br>[WHERE conditions]<br>UNION [ALL | DISTINCT]<br>SELECT expression1, expression2, ... expression_n<br>FROM tables<br>[WHERE conditions];<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>ALL</strong>：可选，返回所有结果集，<code>UNION</code> 可以去重，而 <code>UNION ALL</code> 则包含重复数据。</li>
<li><strong>DISTINCT</strong>：可选，删除结果集中重复的数据。默认情况下 UNION 操作符已经删除了重复数据，所以 DISTINCT 修饰符对结果没啥影响。</li>
</ul>
<h2 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h2><h3 id="自连接（Self-JOIN）"><a href="#自连接（Self-JOIN）" class="headerlink" title="自连接（Self JOIN）"></a>自连接（Self JOIN）</h3><p>在MySQL中，自连接是将表与其自身同名的表进行连接。使用自连接时需要使用别名（alias）来区分每个表实例。</p>
<p>以下是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT a.employee_name, b.employee_name<br>FROM employee a, employee b<br>WHERE a.manager_id = b.employee_id;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，我们查询了“employee”表中所有员工的名称和他们各自的经理的名称。为此，我们需要对“employee”表进行自连接，以将每个员工与其经理联系起来。这里我们使用a和b两个别名来表示同一个表中的两个不同实例。在上面的例子中，我们在WHERE子句中指定连接条件“a.manager_id &#x3D; b.employee_id”，这意味着我们正在连接的是一个员工和他的经理。</p>
<h3 id="内连接（INNER-JOIN）"><a href="#内连接（INNER-JOIN）" class="headerlink" title="内连接（INNER JOIN）"></a>内连接（INNER JOIN）</h3><p>INNER JOIN操作用于连接两个表并返回匹配的行，只有当在关联列中两个表<strong>都存在匹配时才会返回记录</strong>。</p>
<p>除此之外，还有一种相似的语法格式叫做“JOIN…ON…”，其效果与INNER JOIN完全相同。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name(s) FROM table1 <br>INNER JOIN table2 <br>ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT orders.id, orders.order_date, products.product_name<br>FROM orders<br>INNER JOIN products<br>ON orders.product_id = products.id;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，我们连接了“商品”表和“订单”表，并使用ON子句指定了连接条件（“product_id”），结果集包括了这两个表中符合连接条件的数据。</p>
<h3 id="左外连接（LEFT-JOIN）"><a href="#左外连接（LEFT-JOIN）" class="headerlink" title="左外连接（LEFT JOIN）"></a>左外连接（LEFT JOIN）</h3><p>LEFT JOIN操作连接左侧的表和右侧的表，并返回<strong>左侧表的所有记录以及满足连接条件的右侧表的记录</strong>，如果没有匹配的行，则该结果集中的右侧表的字段将被设置为NULL值。LEFT JOIN也可以写成LEFT OUTER JOIN。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name(s) FROM table1 <br>LEFT [OUTER] JOIN table2 <br>ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT departments.department_name, employees.first_name, employees.last_name<br>FROM departments<br>LEFT JOIN employees<br>ON departments.department_id = employees.department_id;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，我们连接了“部门”和“员工”两个表，并使用ON子句指定了共同字段（“department_id”），因此返回的结果集包括了所有的部门和符合连接条件的员工信息，即使某些部门没有员工也会显示出来。</p>
<h3 id="右外连接（RIGHT-JOIN）"><a href="#右外连接（RIGHT-JOIN）" class="headerlink" title="右外连接（RIGHT JOIN）"></a>右外连接（RIGHT JOIN）</h3><p>RIGHT JOIN操作连接右侧的表和左侧的表，并返回<strong>右侧表的所有记录以及满足连接条件的左侧表的记录</strong>。如果没有匹配的行，则该结果集中的左侧字段将被设置为NULL值。RIGHT JOIN也可以写成RIGHT OUTER JOIN。LEFT JOIN和RIGHT JOIN可以用于处理一对多、多对一的关系查询。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name(s) FROM table1 <br>RIGHT [OUTER] JOIN table2 <br>ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employees.first_name, employees.last_name, departments.department_name<br>FROM employees<br>RIGHT JOIN departments<br>ON employees.department_id = departments.department_id;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，我们连接了“员工”和“部门”两个表，并使用ON子句指定了共同字段（“department_id”），因此返回的结果集包括了所有的员工信息和与之相关的部门信息，即使某些员工没有分配到部门也会显示出来。</p>
<h3 id="ON和USING"><a href="#ON和USING" class="headerlink" title="ON和USING"></a>ON和USING</h3><p>MySQL ON是一种在两个表之间进行连接的常用方法，<strong>通过指定连接条件来连接两个表并返回符合条件的结果</strong>。<strong>与WHERE最大的区别是不符合WHERE子句的的记录不论是来自驱动表还是被驱动表，如果不匹配都不会加入结果集</strong>；而ON子句中驱动表的记录即使在被驱动表中找不到匹配的记录，也依然会被加入到结果集中。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name(s) FROM table1 JOIN table2 ON table1.column_name1 = table2.column_name2;<br></code></pre></td></tr></table></figure>

<p>其中，table1和table2是要连接的表，column_name1和column_name2是两个表的列名。</p>
<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT departments.department_name, employees.first_name, employees.last_name<br>FROM departments<br>JOIN employees ON departments.department_id = employees.department_id;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，在使用ON子句时，可以比较不同类型的数据，如数字、文本等。在连接多个表时，也可以在ON子句中使用逻辑运算符（例如AND和OR），以指定更复杂的连接条件。</p>
<p><strong>USING操作表示将在两个表之间使用共同的列进行连接</strong>。这样可以避免在ON子句的连接条件中重复指定相同列名，从而使查询更加简洁。</p>
<p>需要注意的是，USING只能用于比较两个表中具有相同名称的列。如果两个表的连接条件的列名称不同，则必须使用ON子句来指定要连接的列</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name(s) FROM table1 JOIN table2 USING (column_name);<br></code></pre></td></tr></table></figure>

<p>其中，table1和table2是要连接的表，column_name是连接两个表的共同列名。</p>
<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT departments.department_name, employees.first_name, employees.last_name<br>FROM departments<br>JOIN employees <br>USING (department_id);<br></code></pre></td></tr></table></figure>

<p>使用departments表和employees表中相同的列department_id进行表连接，返回满足departments.department_id&#x3D;employees.department_id条件的字段的列。</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><h2 id="MySQL的存储引擎"><a href="#MySQL的存储引擎" class="headerlink" title="MySQL的存储引擎"></a>MySQL的存储引擎</h2><p>输出MySQL支持的存储引擎：</p>
<p><img src="/2023/05/06/MySQL/.././MySQL/image-20230623083239364.png" alt="image-20230623083239364"></p>
<p>其中，Support列表示该存储引擎是否可用；Transactions列表示该存储是否支持事务，XA（eXtended Architecture）列代表该存储引擎是否支持分布式事务，SavePoints列代表该存储引擎是否支持事务的部分回滚。</p>
<ul>
<li>InnoDB：支持事务、分布式事务、行级锁、外键，其它存储引擎都不支持。</li>
<li>MYISAM：支持表级锁。</li>
<li>MEMORY：使用内存存储数据而不是磁盘。</li>
</ul>
<h2 id="设置存储引擎"><a href="#设置存储引擎" class="headerlink" title="设置存储引擎"></a>设置存储引擎</h2><p>存储引擎负责对表中的数据进行读取和写入、以及将数据存储到物理存储器上等功能。可以为不同的表设置不同的存储引擎，即不同的表可以有不同的物理存储结构、不同的读取和写入的方式。</p>
<p>设置表的存储引擎的方法：</p>
<ol>
<li><p>创建表时指定存储引擎</p>
<p>语法示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名 &#123;<br>	建表语句;<br>&#125; ENGINE = 存储引擎的名称;<br></code></pre></td></tr></table></figure>
</li>
<li><p>修改表的存储引擎</p>
<p>如果需要修改已有表的存储引擎，可以使用<code>ALTER TABLE</code>语句来实现.</p>
<p>语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ENGINE = 存储引擎的名称;<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name ENGINE=MyISAM;<br></code></pre></td></tr></table></figure>

<p>使用上述语句将会将名为<code>table_name</code>的表的存储引擎修改为<code>MyISAM</code>。</p>
</li>
</ol>
<h2 id="显示存储引擎"><a href="#显示存储引擎" class="headerlink" title="显示存储引擎"></a>显示存储引擎</h2><p>可以通过显示表的创建信息命令来查看使用的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE TABLE employee; <br></code></pre></td></tr></table></figure>

<p>输出结果示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `employee` (<br>  `id` int NOT NULL,<br>  `emp_id` char(10) DEFAULT NULL,<br>  `emp_name` varchar(10) DEFAULT NULL,<br>  `manager_id` char(10) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;<br></code></pre></td></tr></table></figure>

<h1 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h1><h2 id="查询过程"><a href="#查询过程" class="headerlink" title="查询过程"></a>查询过程</h2><p>MySQL数据查询的主要过程：</p>
<ol>
<li><p>查询缓存</p>
<p>MySQL会缓存查询结果，如果在缓存期间发生了数据更改，则缓存失效，会被删除。如果数据没有更改，则对于完全一致且不存在某些会改变查询含义的函数如NOW()，就会直接返回缓存中的内容。</p>
<p>但是维护缓存是需要开销的，包括查询缓存、添加缓存、删除缓存、维护缓存内存区域。<strong>所以MySQL从5.7.20开始不推荐使用MySQL查询缓存功能，在MySQL8.0中直接将其删除了</strong>。</p>
</li>
<li><p>语法解析</p>
<p>判断语法是否正确。</p>
<p>属于编译过程，涉及词法分析、语法分析、语义分析等。</p>
</li>
<li><p>查询优化</p>
<p>对语句进行优化，最终生成一个执行计划，可以使用EXPLAIN语句来查看某个语句的执行计划。</p>
</li>
<li><p>存储引擎执行查询语句</p>
</li>
</ol>
<h2 id="页结构"><a href="#页结构" class="headerlink" title="页结构"></a>页结构</h2><p>InnoDB中页的大小一般是16KB，由<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html">启动选项（也是系统变量）</a>innodb_page_size指定。InnoDB<strong>以页为基本单位进行磁盘和内存之间的数据交互，而不是以记录为单位</strong>。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头部</td>
<td>38 字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>页面头部</td>
<td>56字节</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td>Infimum + Supremum</td>
<td>页面中的最小记录和最大记录</td>
<td>26字节</td>
<td>两个虚拟的记录</td>
</tr>
<tr>
<td>User Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>用户存储的记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>页目录</td>
<td>不确定</td>
<td>页中某些记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>文件尾部</td>
<td>8字节</td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<p>其中，File Header是所有类型的页都使用的头部，Page Header是专门为数据页用的。</p>
<p>因为存在数据刷新一般还没有结束的时候断电的可能，所以为了便于检测一个页是否完整，InnoDB在每个页的尾部添加了一个File Trailer部分。</p>
<p>File Trailer的前四个字节代表页的校验和，File Header中也有页的校验和，没有发生异常的情况下，两个校验和应该相等。如果发生了数据还没刷新完（假设File Header已经先被刷新到磁盘）就断电，则如果校验File Trailer和File Header或发现两者的校验和不一致，则说明刷新期间出错。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d066e690d22484ebe33bbb4977c3cfb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="image.png"></p>
<h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html">记录格式</a></h3><p>数据库表中的每条数据可以被称为行或记录，InnoDB支持4种不同类型的<strong>行格式，分别是COMPACT、REDUNDANT、DYNAMIC、COMPRESSED</strong>。</p>
<p>指定行格式的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">(CREATE TABLE 表名 (列的信息))|(ALTER TABLE 表名 ROW_FORMAT) ROW_FORMAT=行格式;<br></code></pre></td></tr></table></figure>

<p>COMPACT行格式：</p>
<p>一条完整的记录包含：变长字段长度列表、NULL值列表、记录头信息、记录的数据。</p>
<p>变长字段长度列表、NULL值列表中的信息都是逆序存放。</p>
<p><strong>记录的数据</strong>中除了自定义的列数据外，MySQL还会为每个记录添加一些列（也称隐藏列），如ROW_ID, TRX_ID, ROLL_POINTER。InnoDB的主键生成策略是，优先使用用户自定义的主键，如果没有定义，则选用一个不存储NULL值的UNIQUE键作为主键，如果都没有，则为表添加一个名为如ROW_ID的隐藏列作为主键。 </p>
<p><strong>变长字段长度列表</strong>的每个字段长度的字节数根据变长字段的长度不同，可能是1字节也可能是2个字节（当变长字段长度的首位为0时表示当前长度是2字节，当首位为1表示当前是1字节），长度规则（M：字符的最大长度；W：字符集中字符的最大字节数；L：实际的字符串占用的字节长度）是：</p>
<ul>
<li>如果M * W &lt;&#x3D; 255，则使用1个字节表示真实的数据占用字节数。</li>
<li>如果M * W &gt; 255，则又分两种情况：<ul>
<li>如果L &lt;&#x3D; 127，则使用1字节表示真实数据占用的字节数。</li>
<li>如果L &gt; 127，则使用2字节表示真实数据占用的字节数。</li>
</ul>
</li>
</ul>
<p>其它行格式：</p>
<p>REDUNDANT的MySQL5.0版本之前的一种行格式。</p>
<p>DYNAMIC是MySQL5.7版本引入的，是MySQL5.7默认行格式。</p>
<p>COMPRESSED行格式会采用压缩算法对页面进行压缩。</p>
<p>除REDUNDANT是非紧凑的外，其它三种行格式都是紧凑的。</p>
<h3 id="记录溢出"><a href="#记录溢出" class="headerlink" title="记录溢出"></a>记录溢出</h3><p>一个页的大小一般是16KB，也就是16384字节，而一个VARCHAR(M)类型的列就最多可以存储65533个字节，这样就可能出现一个页存放不了一条记录。<br>在Compact和Reduntant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址(当然这20个字节中还包括这些分散在其他页面中的数据的占用的字节数），从而可以找到剩余数据所在的页。</p>
<p>Dynamic和Compressed行格式<br>这两种行格式类似于COMPACT行格式，只不过在处理行溢出数据时有点儿分歧，它们不会在记录的真实数据处存储一部分数据，而是把所有的数据都存储到其他页面中，只在记录的真实数据处存储其他页面的地址。另外，Compressed行格式会采用压缩算法对页面进行压缩。</p>
<h3 id="删除记录-1"><a href="#删除记录-1" class="headerlink" title="删除记录"></a>删除记录</h3><p>对于执行了删除操作的记录，并不是真正被删除，而是将deleted_flag设置为了1，所有被删除的记录会组成一个垃圾记录的链表，记录在这个链表中的空间称为<strong>可重用空间</strong>。之所以不真正删除，是因为移除字段需要重新排列其它记录，会消耗性能，之后如果有新记录插入到表中，它们就会覆盖掉被删除的记录占用的存储空间。</p>
<h3 id="查找指定主键值的记录"><a href="#查找指定主键值的记录" class="headerlink" title="查找指定主键值的记录"></a>查找指定主键值的记录</h3><p>查找指定主键值的记录的过程是，首先使用二分法在索引页的页目录中定位指定主键值的记录所在的数据页，然后依然使用二分法在数据页中定位指定主键值的记录。</p>
<h2 id="数据页"><a href="#数据页" class="headerlink" title="数据页"></a>数据页</h2><p>数据页存在于B+树的叶子节点上，内部存储了表记录。</p>
<p>B+树能够存储的记录数计算公式是：(M)^N * T。其中N是B+树的层数、M是每个页可以存储的目录页的数量、T是每个页可以存储的记录的数量。</p>
<h2 id="目录页（索引页）"><a href="#目录页（索引页）" class="headerlink" title="目录页（索引页）"></a>目录页（索引页）</h2><p>索引页中存储的<strong>记录是主键和页号指针</strong>，也会使用页目录，以能够支持使用二分查找。</p>
<h2 id="表空间、段、区、页之间的关系"><a href="#表空间、段、区、页之间的关系" class="headerlink" title="表空间、段、区、页之间的关系"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/blog-archive/innodb-tablespace-space-management/">表空间、段、区、页之间的关系</a></h2><p>表空间（Tablespace）、段（Segment）、区（Extend）、页（Page）是InnoDB中数据存储中的概念。</p>
<h3 id="表空间和页的关系"><a href="#表空间和页的关系" class="headerlink" title="表空间和页的关系"></a>表空间和页的关系</h3><p>表空间和页的关系是，表空间文件由许多固定大小的页组成。有不同类型的页面可用于不同的目的，示意图如下：</p>
<p><img src="https://dev.mysql.com/blog-archive/mysqlserverteam/wp-content/uploads/2019/04/image1.jpeg" alt="表空间和页的关系"></p>
<h3 id="表空间、区、页的关系"><a href="#表空间、区、页的关系" class="headerlink" title="表空间、区、页的关系"></a>表空间、区、页的关系</h3><p>表空间、区、页的关系是，区是表空间内连续页的集合。区是大小为 1 MB。因此，如果页面大小为 16Kb，则一个区段中有 64 个页面，示意图如下：</p>
<p><img src="https://dev.mysql.com/blog-archive/mysqlserverteam/wp-content/uploads/2019/04/image2.jpeg" alt="表空间、区、页的关系"></p>
<h3 id="段、页、区的关系"><a href="#段、页、区的关系" class="headerlink" title="段、页、区的关系"></a>段、页、区的关系</h3><p>段是逻辑上的概念，是页面和区的集合，示意图如下：</p>
<p><img src="https://dev.mysql.com/blog-archive/mysqlserverteam/wp-content/uploads/2019/04/image5.jpeg" alt="段、页、区的关系"></p>
<ul>
<li><p>FRAG ARRAY（碎片页数组）</p>
<p>分配给该段的页组成的数组（共32 个页）。</p>
</li>
<li><p>NOT FULL LIST（未满的区链表）</p>
<p>指向由未满的区（有至少一个空闲页的区，空闲页是未使用的数据页）组成的链表，即NOT FULL链表中的每个区都没有空闲页。</p>
</li>
<li><p>FULL LIST（满的区链表）</p>
<p>指向由满的区（没有空闲页的区）组成的链表，即FULL链表中的每个区都没有空闲页。</p>
</li>
<li><p>FREE LIST（空闲区链表）</p>
<p>指向由空闲区（每个页面都是空闲页的区）组成的链表，即FREE链表的所有页都是空闲页。</p>
</li>
</ul>
<p>段为索引段，数据段，回滚段等。其中索引段就是非叶子结点部分，而数据段就是叶子结点部分，回滚段用于数据的回滚和多版本控制。</p>
<h2 id="表的连接"><a href="#表的连接" class="headerlink" title="表的连接"></a>表的连接</h2><p>从本质上说，连接就是把各个表中的记录取出来进行匹配，并产生结果集，如果不加任何过滤条件，产生的结果集就是笛卡尔积。</p>
<p><strong><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/nested-loop-joins.html">嵌套循环连接算法和基于块的嵌套循环连接算法</a></strong></p>
<p>嵌套循环连接算法（Nested-Loop Join Algorithm，简称NLJ Algorithm）的基本思想是，每次从循环中的第一个表中读取一行，将每一行传递给一个嵌套循环，该嵌套循环处理连接中的下一个表。只要有剩余的表要连接，这个过程就会重复多次。</p>
<p>嵌套循环连接算法的原理示例：</p>
<p>假设对三个表t1，t2和t3使用了连接，且连接类型分别如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs none">Table   Join Type<br>t1      range<br>t2      ref<br>t3      ALL<br></code></pre></td></tr></table></figure>

<p>如果使用了嵌套循环连接算法，则连接过程如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clike">for each row in t1 matching range &#123;<br>  for each row in t2 matching reference key &#123;<br>    for each row in t3 &#123;<br>      if row satisfies join conditions, send to client<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因为嵌套循环连接算法每次只从外循环中向内循环传递一条记录，所以通常会多次读取在内循环中处理的表，可以为内循环表（被驱动表）建立合适的索引以加快查询速度。</p>
<p>如果驱动表的结果集中记录较多，导致读取被驱动表的次数很多，可以使用基于块的嵌套循环连接算法（Block Nested-Loop Join Algorithm，简称BNLJ Algorithm），该算法对外循环表（驱动表）中读取的行的进行缓存来减少必须读取内循环表的次数。例如，如果将驱动表的结果集中的N行读取到缓冲器中，并且将缓冲器传递到下一个内循环，则可以将内循环中读取的每一行与缓冲器中的所有N行进行比较。这将使必须读取内部表的次数减少N倍。</p>
<h2 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h2><h3 id="InnoDB中的索引方案"><a href="#InnoDB中的索引方案" class="headerlink" title="InnoDB中的索引方案"></a>InnoDB中的索引方案</h3><h3 id="B-树索引的类型"><a href="#B-树索引的类型" class="headerlink" title="B+树索引的类型"></a><strong>B+树索引的类型</strong></h3><p>B+树索引可以分为聚簇索引（也称聚集索引，clustered index）、辅助索引（有时也称非聚簇索引或二级索引，secondary index，non-clustered index），和联合索引（也称复合索引、多列索引）。</p>
<ul>
<li><p><strong>聚簇索引</strong></p>
<ol>
<li>使用记录的主键值大小进行记录和页的排序</li>
<li>叶子节点存储的是完整的用户记录</li>
</ol>
<p>具有以上两个特点的B+树称为聚簇索引。</p>
</li>
<li><p><strong>二级索引</strong></p>
<p>聚簇索引只能在搜索条件是主键时生效，原因是聚簇索引中的数据都是按照主键进行排序的。如果要以其它列为搜索条件，就需要额外建立二级索引。</p>
<ol>
<li>使用其它非主键（此处称之为，被排序列）的大小进行记录和页的排序</li>
<li>叶子节点存储的不是完整的用户记录，只是被排序列+主键两个列的值</li>
<li>目录页中的记录不再是主键+页号，而是被排序列+主键（保证目录页记录是唯一的）+页号</li>
</ol>
<p>具有以上三个特点的B+树称为二级索引。</p>
<p>如果需要其它（除索引和主键外的）列信息，需要执行回表操作。</p>
</li>
<li><p><strong>联合索引</strong></p>
<p>也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引。</p>
<ol>
<li>使用多个列（此处称之为，被排序的列，存在先后顺序）的大小进行记录和页的排序</li>
<li>同二级索引</li>
<li>同二级索引</li>
</ol>
<p>具有以上三个特点的B+树称为联合索引。</p>
</li>
</ul>
<h3 id="B树和B-树之间的主要区别"><a href="#B树和B-树之间的主要区别" class="headerlink" title="B树和B+树之间的主要区别"></a>B树和B+树之间的主要区别</h3><p>B树结构如下图：</p>
<p><img src="/2023/05/06/MySQL/.././MySQL/image-20230726213430146.png" alt="B树"></p>
<p>B+树结构如下图：</p>
<p><img src="/2023/05/06/MySQL/.././MySQL/image-20230726213113353.png" alt="B+树"></p>
<ol>
<li>结构：B树和B+树的结构略有不同。B树中的每个节点包含索引和对应的数据，而B+树中的非叶子节点只包含索引，而数据存储在叶子节点中。B+树的叶子节点之间通过链表连接，形成了一个有序的数据链表。</li>
<li>范围查询：由于B+树的叶子节点之间通过链表连接，可以方便地进行范围查询。而在B树中，由于数据分散在各个节点中，范围查询需要在树的不同层级进行搜索和合并，相对较慢。</li>
<li>插入和删除操作：在B+树中，由于数据只存在于叶子节点中，插入和删除操作只需要修改叶子节点，而在B树中，插入和删除可能需要修改多个节点。因此，B+树相对于B树来说，插入和删除操作更加高效。</li>
</ol>
<h3 id="Hash索引和B-树索引的区别"><a href="#Hash索引和B-树索引的区别" class="headerlink" title="Hash索引和B+树索引的区别"></a>Hash索引和B+树索引的区别</h3><ul>
<li>对索引的key进行一次hash计算就可以定位出数据存储的位置很多时候Hash索引要比B+树索引更高效。</li>
<li>Hash索引仅能支持“&#x3D;”，“IN”操作，不支持范围查询hash冲突问题。</li>
</ul>
<h3 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h3><ol>
<li>对于满足索引使用条件的语句，可以起到<strong>加速查询</strong>的作用。</li>
<li>如果ORDER BY子句中使用了索引列，且满足索引的使用条件（排序顺序和索引列的顺序一致，索引列左边的连续的列为常量就可以对右边的列进行排序，等），就会<strong>省去在内存或磁盘中（文件排序，filesort）建立临时表进行排序</strong>的操作。</li>
<li>如果GROUP BY子句中使用了索引列，且满足索引的使用条件，就可以直接使用索引进行分组，<strong>省去在内存或磁盘中建立临时表进行分组的操作</strong>。</li>
</ol>
<h3 id="索引的代价"><a href="#索引的代价" class="headerlink" title="索引的代价"></a>索引的代价</h3><ol>
<li>创建索引需要<strong>消耗存储空间</strong>。</li>
<li>每当对表中的数据进行增删改操作时，都需要修改各个B+树的索引，存在<strong>时间代价</strong>。</li>
<li><strong>生成执行计划时需要计算使用不同索引执行查询所需的成本</strong>，最后选择成本最低的那个索引执行查询，如果索引过多，可能会导致成本分析时间加长。</li>
</ol>
<h3 id="索引的正确、高效的使用方式"><a href="#索引的正确、高效的使用方式" class="headerlink" title="索引的正确、高效的使用方式"></a>索引的正确、高效的使用方式</h3><ol>
<li><strong>只为用于搜索、排序或分组的列创建索引</strong>：因为索引只在搜索、排序或分组三种操作下才发挥作用，所以只需要为这三种操作涉及到的列建立索引。</li>
<li><strong>避免对重复值占比高的字段建立索引</strong>：考虑索引列中<strong>重复值</strong>的个数占比，如果重复值太多，则需要大量的回表操作，不适合使用索引。</li>
<li><strong>索引列的类型占用的存储空间尽量小</strong>：因为索引占用的存储空间越小，在一个数据页内就可以存放更多的记录，磁盘I&#x2F;O带来的性能消耗也就越小。可以为列前缀建立索引，如果需要建立的索引类型需要很大的存储空间，则可以只对该类型的列的前几个字符建立索引。语法是在建立索引时，在建立索引的列后使用括号指定建立的索引的字符的长度。</li>
<li><strong>避免回表</strong>：尽量使用覆盖索引（covering index ，又称索引覆盖），即在查询时尽量使需要返回的内容最多只包含索引和主键，以避免回表，从而提高查询速度。</li>
<li><strong>让索引列以列名的形式在搜索条件中单独出现</strong>：例如对于<code>SELECT id FROM table_name WHERE index_column_name * 2 &lt; 4 ;</code>和<code>SELECT id FROM table_name WHERE index_column_name &lt; 4 / 2;</code>，这两个语句中，前一个语句不能使用索引，但是后一个可以。这个是因为在前一个查询语句中，index_column_name列不是单独以列名的形式出现的，而是以列名*2的表达式的形式出现的，MySQL会直接认为这个搜索条件不能使用索引。</li>
<li><strong>在新插入记录时尽量让记录的主键递增</strong>：如果新插入记录的主键是依次递增的话，则每插入一个数据页就会换到下一个数据页继续插入；如果新插入的记录的主键值忽大忽小，就会增大页面分裂的概率，在页面分裂时需要将页中的一些记录移动到新创建的页中，带来性能损耗。</li>
</ol>
<h2 id="建立合适的索引"><a href="#建立合适的索引" class="headerlink" title="建立合适的索引"></a>建立合适的索引</h2><h3 id="查询的成本"><a href="#查询的成本" class="headerlink" title="查询的成本"></a>查询的成本</h3><p>MySQL中查询语句的执行成本由两个方面组成，I&#x2F;O成本和CPU成本：</p>
<ul>
<li>I&#x2F;O成本：InnoDB存储引擎是将数据页存储在磁盘上，当查询表中的记录时，需要先把数据页加载到内存中，这个过程中消耗的时间称为I&#x2F;O成本。</li>
<li>CPU成本：检测记录是否满足对应的搜索条件、对结果集进行排序等操作消耗的时间称为CPU成本。</li>
</ul>
<p><strong>单表查询的成本</strong></p>
<p>在对单表查询生成执行计划前，MySQL的优化器会找出并对比不同的执行方案，从而找出成本最低的执行方案，这一过程的具体步骤是：</p>
<ol>
<li>根据搜索条件，找出所有可能使用的索引。</li>
<li>计算全表扫描的执行成本。</li>
<li>计算使用不同索引执行查询的执行成本。</li>
<li>对比不同执行方案的执行成本，找出成本最低的那个方案。</li>
</ol>
<p><strong>多表查询的成本</strong></p>
<h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><p>调优可以提高数据库的性能和吞吐量。以下是一些MySQL调优的方法：</p>
<ol>
<li><p><strong>优化查询语句</strong></p>
<ul>
<li><p>使用合适的索引：对于经常用于检索的列，创建索引可大幅提升查询效率；</p>
</li>
<li><p>避免使用SELECT ：只选取必要的列可以减少数据传输和磁盘I&#x2F;O；</p>
</li>
<li><p>使用EXPLAIN命令查看查询执行计划：通过观察查询计划，可以了解到查询过程中哪些步骤需要优化。</p>
</li>
</ul>
</li>
<li><p><strong>调整服务器参数</strong></p>
<ul>
<li><p>修改MySQL缓冲区大小：将innodb_buffer_pool_size设置为合理的大小，以便在缓存中保留更多的数据；</p>
</li>
<li><p>调整处理器缓存和线程池：根据服务器的硬件规格和应用程序类型，适当增加线程池大小和处理器缓存大小，以提高并发处理能力；</p>
</li>
<li><p>修改文件系统缓存大小：根据服务器的硬件和操作系统，可以修改磁盘缓存大小；</p>
</li>
</ul>
</li>
<li><p><strong>优化表结构设计</strong></p>
<ul>
<li><p>使用恰当的数据类型：为每个列选择最小、最合适的数据类型可以减少磁盘空间和内存开销，提高查询速度；</p>
</li>
<li><p>避免使用太多的JOIN：JOIN操作需要较多的CPU和内存资源，应尽可能减少其使用；</p>
</li>
<li><p>分解大的表：当一个表中包含大量数据时，可以考虑将其分解为多个较小的表，以提高查询和更新效率。</p>
</li>
</ul>
</li>
<li><p><strong>监控数据库性能</strong></p>
<ul>
<li><p>使用SHOW STATUS或SHOW GLOBAL STATUS命令查看MySQL性能统计信息；</p>
</li>
<li><p>采用监控工具进行实时监控，如Nagios、Zabbix等。</p>
</li>
</ul>
</li>
</ol>
<p>总而言之，在调优MySQL时需要综合考虑硬件、操作系统、数据库参数等各方面因素，对于常见的优化点进行一一梳理和测试，以找到最佳配置参数。</p>
<h3 id="InnoDB对查询的自动优化"><a href="#InnoDB对查询的自动优化" class="headerlink" title="InnoDB对查询的自动优化"></a>InnoDB对查询的自动优化</h3><p>查询优化器会对查询进行自动的优化，优化方法如下：</p>
<ul>
<li><p>条件简化</p>
<ul>
<li>移除不必要的括号</li>
<li>常量传递</li>
<li>替换永远为TRUE或FALSE条件</li>
<li>表达式计算</li>
<li>合并没有使用聚合函数及GROUP BY子句的SQL语句中的HAVING和WHERE子句</li>
<li>常量表检测，此处的常量表指的是表中没有或者只有一条记录、使用主键或唯一二级索引进行等值匹配作为搜素条件，因为这两种查询花费的时间很小，所以把通过这两种查询方式查询的表称为常量表（constant table）</li>
</ul>
</li>
<li><p>外连接消除</p>
<ul>
<li>在空值拒绝的条件下外连接可以转换为内连接，通过将外连接转换为内连接，就可以使用内连接的执行优化方法。空值拒绝（reject-NULL）指的是，在外连接查询中，WHERE子句中包含被驱动表中的列不为NULL值的条件。</li>
</ul>
</li>
<li><p>IN子查询优化</p>
<ul>
<li><p>对可以转化为内连接的查询的IN子查询的结果建立物化表，并使用内连接的执行优化方案。</p>
<p>物化表：对子查询的结果集建立基于内存临时表+哈希索引，或基于磁盘的临时表+B+树索引，此处的临时表被称为物化表，数据添加到物化表中时一般会去重。如果子查询的结果集过大导致超过了系统变量tmp_table_size或者max_heap_table_size的值，则基于内存的临时表会转换为基于磁盘的临时表，并转换索引类型。</p>
</li>
<li><p>如果IN子查询符合转换为半连接（SEMI JOIN）的条件，会将该子查询转换为半连接。</p>
<p>转换方法包括以下几种：</p>
<ul>
<li><p>子查询中的表上拉（Table pullout）</p>
<p>当子查询的查询列表中有主键或者唯一索引列的查询条件时，可以直接把子查询中的表上拉到外层查询的FROM子句中</p>
</li>
<li><p>松散扫描（LooseScan）</p>
<p>如果搜索条件中的某一列建立了索引，并且能够使用索引，那么只需要对该列的多个同样的值执行一次匹配即可。</p>
</li>
<li><p>……</p>
</li>
</ul>
<p>两种IN子查询优化方法的使用顺序是，优先使用转换为半连接的方法，如果IN子查询不符合转换为半连接的条件，才会使用将IN子查询物化的方法。</p>
</li>
</ul>
</li>
</ul>
<h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/using-explain.html">EXPLAIN</a></h2><p>使用EXPLAIN能够输出语句的执行信息，使用方法是在查询语句前加EXPLAIN关键字。</p>
<h3 id="EXPLAIN输出格式"><a href="#EXPLAIN输出格式" class="headerlink" title="EXPLAIN输出格式"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html">EXPLAIN输出格式</a></h3><p>在MySQL中，可以使用<code>EXPLAIN</code>关键字来分析SQL语句的执行计划，<code>EXPLAIN</code>会返回一张表格，其中包含了关于MySQL如何处理SQL语句的信息，例如表的读取顺序、使用的索引名及类型、是否需要临时表等等。通过检查这些信息，可以找到潜在的性能问题，并针对性地进行调整，从而优化查询性能。</p>
<p>如果查询语句（包括子查询语句）有多条，或在一个查询语句中使用了多张表，或执行计划中使用了临时表，EXPLAIN的输出结果就会有多条，在EXPLAIN输出的多行结果中，不同的id代表不同的查询语句，相同的id代表相同查询语句的不同表，id为NULL时代表临时表。</p>
<p><code>EXPLAIN</code>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM table_name WHERE condition;<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">Column</th>
<th align="left">JSON Name</th>
<th align="left">Meaning</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_id"><code>id</code></a></td>
<td align="left"><code>select_id</code></td>
<td align="left">The <code>SELECT</code> identifier</td>
<td>标识符</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_select_type"><code>select_type</code></a></td>
<td align="left">None</td>
<td align="left">The <code>SELECT</code> type</td>
<td>查询类型</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_table"><code>table</code></a></td>
<td align="left"><code>table_name</code></td>
<td align="left">The table for the output row</td>
<td>表名</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_partitions"><code>partitions</code></a></td>
<td align="left"><code>partitions</code></td>
<td align="left">The matching partitions</td>
<td>匹配的分区</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_type"><code>type</code></a></td>
<td align="left"><code>access_type</code></td>
<td align="left">The join type</td>
<td>访问方法</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_possible_keys"><code>possible_keys</code></a></td>
<td align="left"><code>possible_keys</code></td>
<td align="left">The possible indexes to choose</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key"><code>key</code></a></td>
<td align="left"><code>key</code></td>
<td align="left">The index actually chosen</td>
<td>实际用到的索引</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_key_len"><code>key_len</code></a></td>
<td align="left"><code>key_length</code></td>
<td align="left">The length of the chosen key</td>
<td>索引的长度</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_ref"><code>ref</code></a></td>
<td align="left"><code>ref</code></td>
<td align="left">The columns compared to the index</td>
<td>与索引进行等值匹配的列信息</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_rows"><code>rows</code></a></td>
<td align="left"><code>rows</code></td>
<td align="left">Estimate of rows to be examined</td>
<td>预计需要读取的记录条数</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_filtered"><code>filtered</code></a></td>
<td align="left"><code>filtered</code></td>
<td align="left">Percentage of rows filtered by table condition</td>
<td>经过搜索条件过滤后剩余记录条数占rows数量的百分比</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain_extra"><code>Extra</code></a></td>
<td align="left">None</td>
<td align="left">Additional information</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h3 id="查询类型"><a href="#查询类型" class="headerlink" title="查询类型"></a>查询类型</h3><table>
<thead>
<tr>
<th align="left"><code>select_type</code> Value</th>
<th align="left">Meaning</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>SIMPLE</code></td>
<td align="left">Simple <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT</code></a> (not using <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/union.html"><code>UNION</code></a> or subqueries)</td>
<td>查询语句中不包含UNION、UNION  ALL或子查询的查询都算是SIMPLE类型。</td>
</tr>
<tr>
<td align="left"><code>PRIMARY</code></td>
<td align="left">Outermost <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT</code></a></td>
<td>对于包含UNION、UNION  ALL或者子查询的查询来说，最左边的查询的查询类型就是PRIMARY。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/union.html"><code>UNION</code></a></td>
<td align="left">Second or later <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT</code></a> statement in a <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/union.html"><code>UNION</code></a></td>
<td>对于包含UNION或者UNION  ALL的查询来说，除最左边的查询之外的子查询的查询类型都是UNION。</td>
</tr>
<tr>
<td align="left"><code>UNION RESULT</code></td>
<td align="left">Result of a <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/union.html"><code>UNION</code></a>.</td>
<td>对于包含UNION的查询来说，被用来做去重的临时表的查询类型就是UNION RESULT。</td>
</tr>
<tr>
<td align="left"><code>DEPENDENT UNION</code></td>
<td align="left">Second or later <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT</code></a> statement in a <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/union.html"><code>UNION</code></a>, dependent on outer query</td>
<td>是使用了UNION或UNION  ALL，且依赖外部查询中的数据来执行其操作的子查询。</td>
</tr>
<tr>
<td align="left"><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-subquery"><code>SUBQUERY</code></a></td>
<td align="left">First <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT</code></a> in subquery</td>
<td>提示了子查询语句是否使用半连接转换以及允许使用哪些半连接策略，以及在不使用半连接时，是否使用子查询物化或IN到EXISTS转换。格式见官网。</td>
</tr>
<tr>
<td align="left"><code>DEPENDENT SUBQUERY</code></td>
<td align="left">First <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/select.html"><code>SELECT</code></a> in subquery, dependent on outer query</td>
<td>是依赖外部查询中的数据来执行其操作的子查询。</td>
</tr>
<tr>
<td align="left"><code>DERIVED</code></td>
<td align="left">Derived table</td>
<td>派生表，是指在查询语句中使用子查询生成的临时表。</td>
</tr>
<tr>
<td align="left"><code>DEPENDENT DERIVED</code></td>
<td align="left">Derived table dependent on another table</td>
<td>依赖外部查询中的数据来执行其操作的派生表。</td>
</tr>
<tr>
<td align="left"><code>MATERIALIZED</code></td>
<td align="left">Materialized subquery</td>
<td>物化表。</td>
</tr>
<tr>
<td align="left"><code>UNCACHEABLE SUBQUERY</code></td>
<td align="left">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
<td>不能缓存其结果的子查询，必须对外部查询的每条记录重新查询。</td>
</tr>
<tr>
<td align="left"><code>UNCACHEABLE UNION</code></td>
<td align="left">The second or later select in a <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/union.html"><code>UNION</code></a> that belongs to an uncacheable subquery (see <code>UNCACHEABLE SUBQUERY</code>)</td>
<td>使用了UNION或UNION  ALL，且不能缓存其结果的子查询，必须对外部查询的每条记录重新查询。</td>
</tr>
</tbody></table>
<h3 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#explain-join-types">访问方法</a></h3><table>
<thead>
<tr>
<th>访问方法名</th>
<th>常见的搜索条件</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>const</td>
<td>Utilize <code>PRIMARY KEY</code> or <code>UNIQUE</code> index to constant values using the <code>=</code> operator.</td>
<td>主键或唯一索引列与常数进行等值比较。</td>
</tr>
<tr>
<td>ref</td>
<td>The comparison value can be either a constant or an expression that utilizes the <code>PRIMARY KEY</code> or <code>UNIQUE</code> index when using the <code>=</code> or <code>&lt;=&gt;</code> operator.</td>
<td>使用主键和唯一索引列进行等值比较或&lt;&#x3D;&gt;比较</td>
</tr>
<tr>
<td>eq_ref</td>
<td>The comparison value can be either a constant or an expression that utilizes the <code>PRIMARY KEY</code> or <code>UNIQUE NOT NULL</code> index when using the <code>=</code> operator.</td>
<td>使用主键和唯一非NULL索引列进行等值比较或表达式比较</td>
</tr>
<tr>
<td>ref_or_null</td>
<td>This join type is like <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_ref"><code>ref</code></a>, but with the addition that MySQL does an extra search for rows that contain <code>NULL</code> values.</td>
<td>类似ref，但多了一个或IS NULL的比较</td>
</tr>
<tr>
<td>range</td>
<td><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_range"><code>range</code></a> can be used when a key column is compared to a constant using any of the <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal"><code>=</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_not-equal"><code>&lt;&gt;</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than"><code>&gt;</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_greater-than-or-equal"><code>&gt;=</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than"><code>&lt;</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_less-than-or-equal"><code>&lt;=</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_is-null"><code>IS NULL</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_equal-to"><code>&lt;=&gt;</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_between"><code>BETWEEN</code></a>, <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/string-comparison-functions.html#operator_like"><code>LIKE</code></a>, or <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#operator_in"><code>IN()</code></a> operators</td>
<td>当使用任何&#x3D;、&lt;&gt;、&gt;、&gt;&#x3D;、&lt;、&lt;&#x3D;、is NULL、&lt;&#x3D;&gt;、BETWEEN、LIKE或IN()运算符将键列与常量进行比较时，可以使用范围</td>
</tr>
<tr>
<td>index</td>
<td>The <code>index</code> join type is the same as <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_all"><code>ALL</code></a>, except that the index tree is scanned.</td>
<td>index扫描方法是扫描全部二级索引记录的访问方法。一般是在索引包含搜索条件和完整的返回结果的情况下使用，因为这种情况下扫描全部二级索引比扫描全部聚簇索引的耗时小。</td>
</tr>
<tr>
<td></td>
<td>This type replaces <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_eq_ref"><code>eq_ref</code></a> for some <code>IN</code> subqueries.</td>
<td>替换IN子查询下的eq_ref</td>
</tr>
<tr>
<td>index_subquery</td>
<td>This join type is similar to <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/explain-output.html#jointype_unique_subquery"><code>unique_subquery</code></a>. It replaces <code>IN</code> subqueries, but it works for nonunique indexes in subqueries.</td>
<td>类似unique_subquery，不同的是索引不是非唯一的</td>
</tr>
<tr>
<td>fulltext</td>
<td>The join is performed using a <code>FULLTEXT</code> index.</td>
<td>使用全文索引</td>
</tr>
<tr>
<td>index_merge</td>
<td>This join type indicates that the Index Merge optimization is used.</td>
<td>表示使用了索引合并</td>
</tr>
<tr>
<td>all</td>
<td>A full table scan is done for each combination of rows from the previous tables.</td>
<td>使用了全表扫描。</td>
</tr>
</tbody></table>
<p>索引合并分三种：</p>
<ol>
<li><p>Intersection</p>
<p>Intersection（交集）合并方式的应用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM table_name WHERE column_name1 = &#x27;a&#x27; AND column_name2 = &#x27;b&#x27;;<br></code></pre></td></tr></table></figure>

<p>其中column_name1和column_name2列都已建立索引。使用Intersection合并方式意味着使用column_name1和column_name2进行查询，得到有序的主键，再取交集，对交集中的主键执行回表操作。取交集的好处是，避免了对不满足条件的主键值执行回表操作。</p>
<p>使用Intersection的条件是，从每个索引中获取到的二级索引的主键值是有序的。</p>
<p>索引得到的主键值是有序的有两个好处：</p>
<ul>
<li>从两个有序集合中取交集比从两个无序集合中取交集要容易；</li>
<li>如果主键值是有序的，则根据这些主键值执行回表操作时就不再是进行单纯的随机I&#x2F;O，从而提高效率。</li>
</ul>
</li>
<li><p>Union</p>
<p>Union（并集）合并方式的应用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM table_name WHERE column_name1 = &#x27;a&#x27; OR column_name2 = &#x27;b&#x27;;<br></code></pre></td></tr></table></figure>

<p>其中column_name1和column_name2列都已建立索引。使用Union合并方式意味着使用column_name1和column_name2进行查询，得到有序的主键，再取并集，对并集中的主键执行回表操作。取并集的好处是，避免了对满足条件的主键值重复执行回表操作。</p>
<p>使用Union的条件是，从每个索引中获取到的二级索引的主键值是有序的。</p>
<p>索引得到的主键值是有序的有两个好处：</p>
<ul>
<li>对两个有序集合中去重比对两个无序集合中去重要容易；</li>
<li>同index_merge。</li>
</ul>
</li>
<li><p>Sort-Union</p>
<p>Sort-Union（排序后取并集）合并方式比Union多了一个对二级索引记录的主键值排序的操作。</p>
</li>
</ol>
<h3 id="key-len的计算"><a href="#key-len的计算" class="headerlink" title="key_len的计算"></a>key_len的计算</h3><ol>
<li>对于固定长度的类型来说，key_len就是就是数据类型的字节长度，如INT类型的索引的key_len的基础值是4。</li>
<li>对于变长的类型来说，是类型定义的最长长度乘以字符类型长度，如使用了utf8mb4的类型为VARCHAR(100)的列key_len的基础值是4*100&#x3D;400。</li>
</ol>
<p>之所以称为是key_len的基础值，是因为在部分情况下key_len会在基础值上加几个字节：</p>
<ol>
<li>对于可以存储NULL值的索引列，会在key_len的基础值上加1个字节。</li>
<li>对于变长类型，会在key_len的基础值上加2个字节。</li>
</ol>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>当访问方法是const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery中的一个时，ref展示的就是与索引进行等值匹配的列信息。如果不是这些访问方法中的一个，则ref显示NULL。</p>
<h3 id="JSON格式的执行计划"><a href="#JSON格式的执行计划" class="headerlink" title="JSON格式的执行计划"></a>JSON格式的执行计划</h3><p>EXPLAIN输出的信息中没有执行计划的成本，通过在EXPLAIN和查询语句之间添加<code>FORMAT=JSON</code>可以实现输出包含成本的执行计划。</p>
<h3 id="SHOW-WARNINGS"><a href="#SHOW-WARNINGS" class="headerlink" title="SHOW WARNINGS"></a>SHOW WARNINGS</h3><p>在使用EXPLAIN语句查看了某个查询的执行计划之后，紧接着还可以使用SHOW WARNINGS语句来查看查询的执行计划的扩展信息，其中包含查询优化器将查询语句重写后的语句，只是该语句不是标准的查询语句。</p>
<h3 id="optimizer-trace"><a href="#optimizer-trace" class="headerlink" title="optimizer trace"></a>optimizer trace</h3><p>如果打开optimizer trace功能，则执行查询语句，或使用EXPLAIN查看查询语句的执行计划后，就会在information_schema数据库下的OPTIMIZER_TRACE来查看完整的执行计划生成和执行的过程。optimizer trace输出的信息大致包含将优化过程分为了三个阶段，perpare阶段、optimize阶段、execute阶段。基于成本的优化集中在optimize阶段，对于单表查询来说，主要关注optimize阶段的rows_estimation过程，该过程写明了对各种不同的执行方案对应的成本；对于多表查询来说，主要关注optimize阶段的considered_execution_plans过程，该过程写明了各种不同的表连接顺序对应的成本。</p>
<h2 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h2><h3 id="缓冲页"><a href="#缓冲页" class="headerlink" title="缓冲页"></a>缓冲页</h3><p>Buffer Pool是MySQL向操作系统申请的在内存中的一块内存区域，可以通过启动选项<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size">buffer_pool_size</a>进行配置（单位是字节），默认大小是128MB。</p>
<p>Buffer Pool中的内存区域以页面为单位进行划分，页面大小和InnoDB表空间中使用的页面大小一致，默认都是16KB，Buffer Pool中的页称为缓冲页，每个缓冲页都有一个对应的控制块，存储了缓冲页的一些信息，如缓冲页的地址、表空间、页号。</p>
<h3 id="缓冲页哈希"><a href="#缓冲页哈希" class="headerlink" title="缓冲页哈希"></a>缓冲页哈希</h3><p>InnoDB中定位到指定表空间和页号的缓冲页所在的位置的实现方法是，以表空间+页号作为key，以缓冲页的控制块作为value，就可以通过先定位到控制块（如果内存中已经有缓冲页的话），然后再由控制块的缓冲页的地址信息定位到缓冲页。</p>
<h3 id="常见的链表类型及其管理方式"><a href="#常见的链表类型及其管理方式" class="headerlink" title="常见的链表类型及其管理方式"></a>常见的链表类型及其管理方式</h3><ol>
<li><p><strong>free链表</strong></p>
<p>free链表（空闲链表）是存放所有空闲的缓冲页对应的控制块的链表。</p>
<p>free链表有一个对应的基节点，里面包含了链表的头节点地址、尾节点地址，以及链表中节点的数量等信息。</p>
</li>
<li><p><strong>flush链表</strong></p>
<p>flush链表是存放了脏页（dirty page，被修改过的缓冲页）对应的控制块的链表。</p>
</li>
<li><p><strong>LRU链表</strong></p>
<p>LRU（Least Recently Used）链表管理了非空闲的缓冲页，当Buffer Pool中不再有空闲的缓冲页时，就会淘汰掉最近很少使用的部分缓冲页。</p>
<p>InnoDB中的LRU链表是按照一定比例分成两截的：一部分存储使用频率非常高的缓冲页，这一部分链表也被称为热数据，或者young区域；另一部分存储使用频率不高的缓冲页，这一部分链表也被称为冷数据，或者old区域。对于old区域，如果访问的间隔时间大于系统变量innodb_old_blocks_time的设定值就会被移动到young区域。</p>
</li>
</ol>
<h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h3><p>Redo Log（重做日志，Redo日志）是记录了已提交事务对数据库的修改的日志。</p>
<p>Redo日志的用途：事务在提交前，需要将相关修改操作记录到redo日志中的，系统因崩溃而重启时需要按照redo日志重新更新数据页。</p>
<p>之所以先写入Redo Log磁盘而不是将数据直接写入ibd磁盘，是因为写Redo Log是顺序写，而数据写入ibd磁盘是随机写。</p>
<h3 id="Undo-Log"><a href="#Undo-Log" class="headerlink" title="Undo Log"></a>Undo Log</h3><p>Undo Log（撤销日志，Undo日志）是记录了数据库中的数据被修改前的状态的日志。</p>
<p>Undo日志的用途：用于保证事务的原子性，如果事务在执行过程中被取消，就将数据库依照undo日志恢复到原来的状态，这个操作叫做回滚。</p>
<h3 id="Binary-Log"><a href="#Binary-Log" class="headerlink" title="Binary Log"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/binary-log.html">Binary Log</a></h3><p>Binary Log（二进制日志），也称为binlog，</p>
<p>binlog的用途：</p>
<ol>
<li>主从复制：数据库源服务器上将binlog发送给数据库副本服务器（下文简称副本），副本通过执行binlog复制源服务器上的数据。</li>
<li>数据备份和恢复：通过创建binlog对数据进行备份，在需要的时候通过执行binlog恢复备份。</li>
</ol>
<h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>事务的4个特性（ACID，acid（辅助记忆）：酸）：</p>
<ol>
<li><strong>原子性</strong>（Atomic）：要么全做，要么全不做</li>
<li><strong>隔离性</strong>（Isolation）：不同事务之间不会互相影响</li>
<li><strong>一致性</strong>（Consistency）：满足一致性需求，如转账前后总金额不变</li>
<li><strong>持久性</strong>（Durability）：事务的执行结果能够得到永久的保留（存储到了磁盘上）</li>
</ol>
<h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p>MySQL中根据操作的阶段把事务分为了以下几种状态：</p>
<ol>
<li>活动的（active）：事务正在执行。</li>
<li>部分提交的（partially committed）：事务操作执行完成，但是执行结果尚保留在内存中，还没有进行持久化。</li>
<li>失败的（failed）：事务在活动的和部分提交的两种状态下遇到了错误，并且无法继续执行或回滚。</li>
<li>中止的（aborted）：事务在执行到中途遇到了错误，并且执行了回滚操作。</li>
<li>提交的（committed）：如果事务处于部分提交状态，并且持久化成功。</li>
</ol>
<h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/mysql-questions-01.html#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E4%BA%86%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98">并发事务带来的问题</a></h3><ol>
<li>脏写（Dirty Write，丢失修改）：在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</li>
<li>脏读（Dirty Read）：一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</li>
<li>不可重复读（No-Repeatable Read）：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据并且修改了该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li>幻读（Phantom）：发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
</ol>
<h3 id="不可重复读和幻读有什么区别？"><a href="#不可重复读和幻读有什么区别？" class="headerlink" title="不可重复读和幻读有什么区别？"></a>不可重复读和幻读有什么区别？</h3><ul>
<li><p>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</p>
</li>
<li><p>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录条数发生了变化。</p>
<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p>
</li>
</ul>
<h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>对四种隔离问题按照导致的一致性问题的严重性排序：脏写&gt;脏读&gt;不可重复读&gt;幻读。</p>
<p>SQL标准中有针对这四种隔离问题的四种隔离级别（都能避免脏写）：</p>
<ol>
<li>READ UNCOMMITED（读取未提交的内容）：隔离级别最低，不能避免脏读、不可重复读、幻读。</li>
<li>READ COMMITED（读取已提交的内容）：不能避免不可重复读和幻读。</li>
<li>REPEATABLE READ（可重复读）：不能避免幻读。</li>
<li>SERIALIZABLE（可串行化）：隔离级别最高，四种隔离问题都能避免。</li>
</ol>
<p>MySQL支持这四种隔离级别，默认的隔离级别是REPEATABLE READ。</p>
<p>MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐级之间的区 别？</p>
<ol>
<li>Read Uncommitted（读取未提交内容）：在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应 用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称 之为脏读（Dirty Read）。</li>
<li>Read Committed（读取提交内容）：这是大多数数据库系统的默 认隔离级别（但不是 MySQL 默认的）。它满足了隔离的简单定义：一 个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的 不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该 实例处理其间可能会有新的 commit，所以同一 select 可能返回不同结 果。 </li>
<li>Repeatable Read（可重读）：这是 MySQL 的默认事务隔离级 别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读（PhantomRead）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事 务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现 有新的“幻影” 行。InnoDB 和 Falcon 存储引擎通过多版本并发控制 （MVCC，Multiversion Concurrency Control 间隙锁）机制解决了 该问题。注：其实多版本只是解决不可重复读问题，而加上间隙锁（也 就是它这里所谓的并发控制）才解决了幻读问题。 </li>
<li>Serializable（可串行化）：这是最高的隔离级别，它通过强制事务 排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个 读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁 竞争。</li>
</ol>
<h3 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h3><p><strong>版本链</strong>是由记录的roll_pointer隐藏列连接（指向之前版本的记录）而成的记录链，记录中的另一个隐藏列trx_id就是记录的版本。</p>
<p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是利用记录的版本链来控制并发事务访问相同记录时的行为。</p>
<p>InnoDB中使用MVCC实现读已提交和可重复读两种隔离级别，读已提交是操作版本链中最新的数据，可重复读是操作事务对应（绑定）的版本中的数据。</p>
<p>在允许读取记录的旧版本的情况下，读写和写读操作可以使用MVCC。</p>
<p><strong>ReadView</strong>（一致性视图）用于判断版本链中哪些版本是当前事务可见的（是否可以使用），ReadView包含4个重要的内容：</p>
<ol>
<li>m_ids：在生成ReadView时，当前系统中活跃的事务的事务id列表。</li>
<li>min_trx_id：在生成ReadView时，当前事务中活跃的事务中最小的事务id，即m_ids列表中的最小值。</li>
<li>max_trx_id：在生成ReadView时，下一个事务应该被分配的事务id（按照自增的规则生成事务id）。</li>
<li>creator_trx_id：生成ReadView的事务的事务id。</li>
</ol>
<p>使用ReadView并根据下列规则，判断当前事务是否可以使用某个版本的记录：</p>
<ol>
<li>如果被访问的记录的版本（trx_id值）等于ReadView中的creator_trx_id值，意味着当前事务访问自己修改过的记录，所以当前事务可以访问该版本的记录。</li>
<li>如果被访问的记录的版本小于ReadView中的min_trx_id值，意味着生成该版本记录的事务已经提交，所以当前事务可以访问该版本的记录。</li>
<li>如果被访问的记录的版本大于ReadView中的max_trx_id值，意味着生成该版本记录的事务还未提交，所以当前事务不能访问该版本的记录。</li>
<li>如果被访问的记录的版本介于min_trx_id和max_trx_id之间，则需要判断记录的版本trx_id值，是否在m_ids列表中。如果在，说明生成该版本记录的事务还未提交，则当前事务不能访问该版本的记录；如果不在，说明生成该版本记录的事务已经提交，则当前事务可以访问该版本的记录。</li>
</ol>
<p><strong>二级索引与MVCC</strong>：只有在聚簇索引记录中才有trx_id和roll_pointer隐藏列，如果查询语句是使用二级索引来执行查询，则判断可见性的方法是，首先跟二级索引页面的PAGE_MAX_TRX_ID（位于Page Header中，该参数记录了二级索引页面中的最大事务id）进行比较，如果当前事务id大于PAGE_MAX_TRX_ID，说明该页面中的所有记录都对当前事务可见，否则就需要执行回表，得到聚簇索引的记录之后再根据前述ReadView的判断规则判断是否可见。</p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><h4 id="行锁的类型"><a href="#行锁的类型" class="headerlink" title="行锁的类型"></a>行锁的类型</h4><ul>
<li>记录锁（Record Lock）：只给记录加锁</li>
<li>间隙锁（Gap Lock）：锁定数据范围的间隙，阻止其他事务在这个范围内插入新的数据，从而避免幻读</li>
<li>临键锁（Next-Key Lock）：给记录和记录前面的间隙加锁，相当于Record Lock和Gap Lock的结合</li>
<li>插入意图锁（Insert Intention Lock）：处于等待状态的需要在某个存在Gap Lock或Next-Key Lock的间隙插入记录的事务也会在内存中生成的，用来表明插入意图的锁</li>
<li>隐式锁：隐式锁就是不加锁。<a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2020/09/06/">隐式锁</a>主要用在插入场景中。在Insert语句执行过程中，必须检查两种情况，一种是如果记录之间加有间隙锁，为了避免幻读，此时是不能插入记录的，另一中情况如果Insert的记录和已有记录存在唯一键冲突，此时也不能插入记录。除此之外，Insert语句的锁都是隐式锁，但跟踪代码发现，Insert时并没有调用lock_rec_add_to_queue函数进行加锁， 其实所谓隐式锁就是在Insert过程中不加锁。</li>
</ul>
<h4 id="行锁的应用"><a href="#行锁的应用" class="headerlink" title="行锁的应用"></a>行锁的应用</h4><p>事务串行化隔离级别的实现方式就是加锁。</p>
<h4 id="行锁的类别"><a href="#行锁的类别" class="headerlink" title="行锁的类别"></a>行锁的类别</h4><p>MySQL中的行锁分共享锁（Shared Lock，S锁）和独占锁（Exclusive Lock，X锁）。</p>
<h4 id="加锁的语句"><a href="#加锁的语句" class="headerlink" title="加锁的语句"></a>加锁的语句</h4><ol>
<li><p>对读取的记录加S锁</p>
<p>在SELECT语句后面加上FOR SHARE：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ... FOR SHARE;<br></code></pre></td></tr></table></figure>
</li>
<li><p>对读取的记录加X锁</p>
<p>在SELECT语句后面加上FOR UPDATE：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT ... FOR UPDATE;<br></code></pre></td></tr></table></figure></li>
</ol>
<h4 id="写锁的原理"><a href="#写锁的原理" class="headerlink" title="写锁的原理"></a>写锁的原理</h4><ul>
<li><p>DELETE：</p>
<p>定位到记录的位置后，获取记录的X锁，最后执行删除操作（包括delete mark和添加到垃圾链表等操作）。</p>
</li>
<li><p>UPDATE：</p>
<ul>
<li>如果未修改记录的主键，且被更新的列占用的存储空间在修改前后未发生变化，则获取记录的X锁后直接在原记录的位置进行修改。</li>
<li>否则，先对原记录执行删除原记录（DELETE操作）和插入新纪录（INSERT操作）的操作。</li>
</ul>
</li>
<li><p>INSERT</p>
<p>插入新记录。</p>
</li>
</ul>
<h4 id="MySQL中哪些的隔离级别下会使用行锁"><a href="#MySQL中哪些的隔离级别下会使用行锁" class="headerlink" title="MySQL中哪些的隔离级别下会使用行锁"></a>MySQL中哪些的隔离级别下会使用行锁</h4><p>不是所有的隔离级别下都会使用行锁。MySQL的隔离级别和锁机制之间存在复杂的关系，不同的隔离级别使用不同的锁机制来实现事务的隔离性。行锁和表锁是两种常见的锁类型，而不同的隔离级别可能会使用不同的锁类型和粒度。</p>
<p>在MySQL中，隔离级别包括 READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ 和 SERIALIZABLE。下面是每个隔离级别在InnoDB存储引擎中的锁机制：</p>
<ol>
<li>READ UNCOMMITTED：SELECT语句以非锁定方式执行。</li>
<li>READ COMMITTED：InnoDB只为更新或删除的行保留锁。</li>
<li>REPEATABLE READ：对于具有唯一搜索条件的唯一索引，InnoDB只锁定找到的索引记录，而不锁定之前的间隙。对于其他搜索条件，InnoDB会锁定扫描的索引范围，使用间隙锁或下一个键锁来阻止其他会话插入到范围覆盖的间隙中。</li>
<li>SERIALIZABLE可序列化的：直接锁表，不使用行锁这个级别。但InnoDB隐式地将所有纯SELECT语句转换为SELECT…FOR SHARE（如果禁用了自动提交）。如果启用了自动提交，SELECT就是它自己的事务。因此，它是只读的，如果作为一致（非锁定）读取执行，则可以序列化，并且不需要为其他事务阻塞。（如果其他事务修改了所选行，要强制纯SELECT阻止，请禁用自动提交。）</li>
</ol>
<h3 id="MySQL-的隔离级别是怎样实现的"><a href="#MySQL-的隔离级别是怎样实现的" class="headerlink" title="MySQL 的隔离级别是怎样实现的"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html">MySQL 的隔离级别是怎样实现的</a></h3><p>SERIALIZABLE 隔离级别是通过锁定表来实现的。</p>
<p>READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于行锁和 MVCC 实现的。</p>
<h1 id="MySQL8-0新增的特性（部分）"><a href="#MySQL8-0新增的特性（部分）" class="headerlink" title="MySQL8.0新增的特性（部分）"></a><a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/mysql-nutshell.html#mysql-nutshell-additions">MySQL8.0新增的特性</a>（部分）</h1><ul>
<li><p><strong>Character set support.</strong> 默认字符集已从“latin1”更改为“utf8mb4”。“utf8mb4”字符集有几个新的排序规则，包括“utf8mb4_ja_0900_as_cs’”。</p>
</li>
<li><p><strong>Character sets: Language-specific collations.</strong></p>
</li>
<li><p><strong>Window functions.</strong> MySQL现在支持窗口函数，对于查询中的每一<strong>行</strong>，使用与该行相关的行执行计算。</p>
<p>窗口函数和聚集函数的区别：聚合函数用于将一组数据汇总成一个单一的结果，而窗口函数可以对每一行数据执行一些操作，同时还可以与其他行的数据进行比较，计算出每一行的上下文和关系。两种函数虽然有一定的重叠，但是它们的用途和功能是有所不同的。</p>
</li>
<li><p><strong>Common table expressions.</strong> <a target="_blank" rel="noopener" href="https://www.yiibai.com/mysql/cte.html">通用表达式</a>（Common Table Expressions，CTEs）是一种在 SQL 查询中定义临时结果集的方式，可以理解为可以复用的子查询结果集。</p>
</li>
<li><p><strong>Time zone support for TIMESTAMP and DATETIME.</strong> </p>
</li>
<li><p><strong>Generated invisible primary keys.</strong> </p>
</li>
<li><p><strong>JSON enhancements</strong>.</p>
</li>
<li><p><strong>Data dictionary</strong>.MySQL现在包含了一个事务数据字典，用于存储数据库对象的信息。在以前的MySQL版本中，字典数据存储在元数据文件和非事务表中。有关更多信息，请参阅<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/data-dictionary.html">第14章，<em>MySQL数据字典</em></a>。</p>
</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>西泽梦路. MySQL基础教程. 北京: 人民邮电出版社, 2020.1.</li>
<li>小孩子4919. MySQL是怎样运行的：从根上理解MySQL. 北京：人民邮电出版社, 2020.11.</li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Nt41177v5/?p=1&vd_source=e229b568d11ab1ec4d7f50fb619a17b6">https://www.bilibili.com/video/BV1Nt41177v5/?p=1&amp;vd_source=e229b568d11ab1ec4d7f50fb619a17b6</a></li>
<li><a target="_blank" rel="noopener" href="https://ke.qq.com/course/230866?flowToken=1031040#term_id=100272363">https://ke.qq.com/course/230866?flowToken=1031040#term_id=100272363</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io">Song Baoru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io/2023/05/06/MySQL/">https://songbaoru.github.io/2023/05/06/MySQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post_share"><div class="social-share" data-image="https://th.bing.com/th/id/R.3c9b5429b970ae83fb4ded208ce9c807?rik=VPifCoJ%2fpjqETw&amp;riu=http%3a%2f%2fpic16.nipic.com%2f20110906%2f128199_105134374000_2.jpg&amp;ehk=t%2f%2bs8eNL6%2b%2fAVJexV4GQnR77FSc2ZGNsU9v2lHWEueA%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/06/Redis/" title="Redis"><img class="cover" src="https://th.bing.com/th/id/OIP.wCDX4W_Glr7-BSlavnG2uAHaFj?pid=ImgDet&amp;rs=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Redis</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/05/Spring/" title="Spring"><img class="cover" src="https://www.tp88.net/uploads/allimg/200211/co200211105633-0.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Spring</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Song Baoru</div><div class="author-info__description">锲而不舍，金石可镂</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SongBaoru"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">MySQL配置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E9%80%89%E9%A1%B9"><span class="toc-number">1.1.</span> <span class="toc-text">启动选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">1.2.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">系统变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">监视器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%BC%80MySQL%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">2.1.</span> <span class="toc-text">打开MySQL监视器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">2.2.</span> <span class="toc-text">查看字符编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81"><span class="toc-number">2.3.</span> <span class="toc-text">修改密码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7"><span class="toc-number">2.4.</span> <span class="toc-text">创建用户</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90"><span class="toc-number">2.5.</span> <span class="toc-text">设置用户权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%80%E5%87%BA%E7%9B%91%E8%A7%86%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text">退出监视器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.1.</span> <span class="toc-text">创建数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.2.</span> <span class="toc-text">指定使用的数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.3.</span> <span class="toc-text">显示数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E5%B7%B2%E6%9C%89%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.3.1.</span> <span class="toc-text">显示当前已有的数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%BD%93%E5%89%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.3.2.</span> <span class="toc-text">显示当前使用的数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.4.</span> <span class="toc-text">删除数据库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">3.5.</span> <span class="toc-text">备份和恢复数据库</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">创建表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E4%B8%BB%E9%94%AE"><span class="toc-number">4.1.2.</span> <span class="toc-text">设置主键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%94%AF%E4%B8%80%E9%94%AE"><span class="toc-number">4.1.3.</span> <span class="toc-text">设置唯一键</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%88%97%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E9%80%92%E5%A2%9E"><span class="toc-number">4.1.4.</span> <span class="toc-text">设置列可以自动递增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%88%97%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-number">4.1.5.</span> <span class="toc-text">设置列的默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%EF%BC%88%E5%88%9B%E5%BB%BA%E3%80%81%E5%88%A0%E9%99%A4%E3%80%81%E6%9F%A5%E7%9C%8B%E3%80%81%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E3%80%81%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E3%80%81%E5%85%A8%E5%B1%80%E7%B4%A2%E5%BC%95%EF%BC%89"><span class="toc-number">4.1.6.</span> <span class="toc-text">索引（创建、删除、查看、主键索引、唯一索引、全局索引）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">显示表结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%A1%A8%E7%9A%84SQL%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">查看创建表的SQL语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E8%A1%A8"><span class="toc-number">4.4.</span> <span class="toc-text">显示数据库中的所有表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8"><span class="toc-number">4.5.</span> <span class="toc-text">修改表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E8%A1%A8"><span class="toc-number">4.6.</span> <span class="toc-text">复制表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E6%95%B4%E5%BC%A0%E8%A1%A8"><span class="toc-number">4.6.1.</span> <span class="toc-text">复制整张表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-number">4.6.2.</span> <span class="toc-text">复制符合条件的记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="toc-number">4.7.</span> <span class="toc-text">删除表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%95%B4%E5%BC%A0%E8%A1%A8"><span class="toc-number">4.7.1.</span> <span class="toc-text">删除整张表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A1%A8%E5%86%85%E6%89%80%E6%9C%89%E8%AE%B0%E5%BD%95"><span class="toc-number">4.7.2.</span> <span class="toc-text">删除表内所有记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">4.8.</span> <span class="toc-text">查询数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%AE%B0%E5%BD%95"><span class="toc-number">4.9.</span> <span class="toc-text">插入记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E8%AE%B0%E5%BD%95"><span class="toc-number">4.10.</span> <span class="toc-text">更新记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%AE%B0%E5%BD%95"><span class="toc-number">4.11.</span> <span class="toc-text">删除记录</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">5.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE"><span class="toc-number">5.1.</span> <span class="toc-text">创建视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="toc-number">5.2.</span> <span class="toc-text">可更新视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%A7%86%E5%9B%BE"><span class="toc-number">5.3.</span> <span class="toc-text">显示视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E8%A7%86%E5%9B%BE"><span class="toc-number">5.4.</span> <span class="toc-text">替换视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E8%A7%86%E5%9B%BE%E7%BB%93%E6%9E%84"><span class="toc-number">5.5.</span> <span class="toc-text">修改视图结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="toc-number">5.6.</span> <span class="toc-text">删除视图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">6.1.</span> <span class="toc-text">创建存储过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">6.2.</span> <span class="toc-text">调用存储过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">6.3.</span> <span class="toc-text">显示存储过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">6.4.</span> <span class="toc-text">删除存储过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">存储函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E7%94%A8%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E6%97%A5%E5%BF%97"><span class="toc-number">7.1.</span> <span class="toc-text">启用存储函数日志</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">创建存储函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.</span> <span class="toc-text">显示存储函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.1.</span> <span class="toc-text">显示数据库中所有的存储函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%8C%87%E5%AE%9A%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">7.3.2.</span> <span class="toc-text">显示指定存储函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0"><span class="toc-number">7.4.</span> <span class="toc-text">删除存储函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">8.1.</span> <span class="toc-text">创建触发器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OLD%E3%80%81NEW%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.2.</span> <span class="toc-text">OLD、NEW关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">显示触发器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">8.4.</span> <span class="toc-text">删除触发器</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">9.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">9.1.</span> <span class="toc-text">开启事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1"><span class="toc-number">9.2.</span> <span class="toc-text">提交事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%BB%9A%E4%BA%8B%E5%8A%A1"><span class="toc-number">9.3.</span> <span class="toc-text">回滚事务</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.1.</span> <span class="toc-text">二进制数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.2.</span> <span class="toc-text">数值型数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.3.</span> <span class="toc-text">字符串型数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.4.</span> <span class="toc-text">日期和时间型数据类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99"><span class="toc-number">11.</span> <span class="toc-text">字符集和比较规则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">12.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">聚合函数（部分）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">12.2.</span> <span class="toc-text">字符串操作函数（部分）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E5%87%BD%E6%95%B0%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">12.3.</span> <span class="toc-text">日期和时间函数（部分）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">13.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%87%BD%E6%95%B0%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">13.1.</span> <span class="toc-text">比较函数和运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BETWEEN%E8%AF%A6%E8%A7%A3"><span class="toc-number">13.1.1.</span> <span class="toc-text">BETWEEN详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IN%E8%AF%A6%E8%A7%A3"><span class="toc-number">13.1.2.</span> <span class="toc-text">IN详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LIKE%E8%AF%A6%E8%A7%A3"><span class="toc-number">13.1.3.</span> <span class="toc-text">LIKE详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">13.2.</span> <span class="toc-text">逻辑运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">14.</span> <span class="toc-text">关键字（部分）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#WHERE"><span class="toc-number">14.1.</span> <span class="toc-text">WHERE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GROUP-BY"><span class="toc-number">14.2.</span> <span class="toc-text">GROUP BY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HAVING"><span class="toc-number">14.3.</span> <span class="toc-text">HAVING</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXISTS"><span class="toc-number">14.4.</span> <span class="toc-text">EXISTS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IN%E5%92%8CEXISTS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.5.</span> <span class="toc-text">IN和EXISTS的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DISTINCT"><span class="toc-number">14.6.</span> <span class="toc-text">DISTINCT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORDER-BY%E5%92%8CACS%E6%88%96DESC"><span class="toc-number">14.7.</span> <span class="toc-text">ORDER BY和ACS或DESC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LIMIT%E5%92%8COFFSET"><span class="toc-number">14.8.</span> <span class="toc-text">LIMIT和OFFSET</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CASE-WHEN"><span class="toc-number">14.9.</span> <span class="toc-text">CASE WHEN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IF-THEN-ELSE"><span class="toc-number">14.10.</span> <span class="toc-text">IF-THEN-ELSE</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.</span> <span class="toc-text">表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.1.</span> <span class="toc-text">子查询</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%9F%A5%E8%AF%A2%EF%BC%88UNION%EF%BC%89"><span class="toc-number">15.2.</span> <span class="toc-text">联合查询（UNION）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2"><span class="toc-number">15.3.</span> <span class="toc-text">连接查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E8%BF%9E%E6%8E%A5%EF%BC%88Self-JOIN%EF%BC%89"><span class="toc-number">15.3.1.</span> <span class="toc-text">自连接（Self JOIN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%EF%BC%88INNER-JOIN%EF%BC%89"><span class="toc-number">15.3.2.</span> <span class="toc-text">内连接（INNER JOIN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%88LEFT-JOIN%EF%BC%89"><span class="toc-number">15.3.3.</span> <span class="toc-text">左外连接（LEFT JOIN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5%EF%BC%88RIGHT-JOIN%EF%BC%89"><span class="toc-number">15.3.4.</span> <span class="toc-text">右外连接（RIGHT JOIN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ON%E5%92%8CUSING"><span class="toc-number">15.3.5.</span> <span class="toc-text">ON和USING</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">16.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E7%9A%84%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">16.1.</span> <span class="toc-text">MySQL的存储引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">16.2.</span> <span class="toc-text">设置存储引擎</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">16.3.</span> <span class="toc-text">显示存储引擎</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#InnoDB"><span class="toc-number">17.</span> <span class="toc-text">InnoDB</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">17.1.</span> <span class="toc-text">查询过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="toc-number">17.2.</span> <span class="toc-text">页结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95"><span class="toc-number">17.3.</span> <span class="toc-text">记录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">17.3.1.</span> <span class="toc-text">记录格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%BA%A2%E5%87%BA"><span class="toc-number">17.3.2.</span> <span class="toc-text">记录溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E8%AE%B0%E5%BD%95-1"><span class="toc-number">17.3.3.</span> <span class="toc-text">删除记录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E4%B8%BB%E9%94%AE%E5%80%BC%E7%9A%84%E8%AE%B0%E5%BD%95"><span class="toc-number">17.3.4.</span> <span class="toc-text">查找指定主键值的记录</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B5"><span class="toc-number">17.4.</span> <span class="toc-text">数据页</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E9%A1%B5%EF%BC%88%E7%B4%A2%E5%BC%95%E9%A1%B5%EF%BC%89"><span class="toc-number">17.5.</span> <span class="toc-text">目录页（索引页）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4%E3%80%81%E6%AE%B5%E3%80%81%E5%8C%BA%E3%80%81%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">17.6.</span> <span class="toc-text">表空间、段、区、页之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4%E5%92%8C%E9%A1%B5%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">17.6.1.</span> <span class="toc-text">表空间和页的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4%E3%80%81%E5%8C%BA%E3%80%81%E9%A1%B5%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">17.6.2.</span> <span class="toc-text">表空间、区、页的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E3%80%81%E9%A1%B5%E3%80%81%E5%8C%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">17.6.3.</span> <span class="toc-text">段、页、区的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">17.7.</span> <span class="toc-text">表的连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="toc-number">17.8.</span> <span class="toc-text">B+树索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E4%B8%AD%E7%9A%84%E7%B4%A2%E5%BC%95%E6%96%B9%E6%A1%88"><span class="toc-number">17.8.1.</span> <span class="toc-text">InnoDB中的索引方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.8.2.</span> <span class="toc-text">B+树索引的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91%E4%B9%8B%E9%97%B4%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">17.8.3.</span> <span class="toc-text">B树和B+树之间的主要区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash%E7%B4%A2%E5%BC%95%E5%92%8CB-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.8.4.</span> <span class="toc-text">Hash索引和B+树索引的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">17.8.5.</span> <span class="toc-text">索引的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BB%A3%E4%BB%B7"><span class="toc-number">17.8.6.</span> <span class="toc-text">索引的代价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%AD%A3%E7%A1%AE%E3%80%81%E9%AB%98%E6%95%88%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">17.8.7.</span> <span class="toc-text">索引的正确、高效的使用方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%90%88%E9%80%82%E7%9A%84%E7%B4%A2%E5%BC%95"><span class="toc-number">17.9.</span> <span class="toc-text">建立合适的索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%9A%84%E6%88%90%E6%9C%AC"><span class="toc-number">17.9.1.</span> <span class="toc-text">查询的成本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="toc-number">17.9.2.</span> <span class="toc-text">性能调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E5%AF%B9%E6%9F%A5%E8%AF%A2%E7%9A%84%E8%87%AA%E5%8A%A8%E4%BC%98%E5%8C%96"><span class="toc-number">17.9.3.</span> <span class="toc-text">InnoDB对查询的自动优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXPLAIN"><span class="toc-number">17.10.</span> <span class="toc-text">EXPLAIN</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EXPLAIN%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">17.10.1.</span> <span class="toc-text">EXPLAIN输出格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.10.2.</span> <span class="toc-text">查询类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95"><span class="toc-number">17.10.3.</span> <span class="toc-text">访问方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#key-len%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">17.10.4.</span> <span class="toc-text">key_len的计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ref"><span class="toc-number">17.10.5.</span> <span class="toc-text">ref</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92"><span class="toc-number">17.10.6.</span> <span class="toc-text">JSON格式的执行计划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SHOW-WARNINGS"><span class="toc-number">17.10.7.</span> <span class="toc-text">SHOW WARNINGS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#optimizer-trace"><span class="toc-number">17.10.8.</span> <span class="toc-text">optimizer trace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Buffer-Pool"><span class="toc-number">17.11.</span> <span class="toc-text">Buffer Pool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E9%A1%B5"><span class="toc-number">17.11.1.</span> <span class="toc-text">缓冲页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E9%A1%B5%E5%93%88%E5%B8%8C"><span class="toc-number">17.11.2.</span> <span class="toc-text">缓冲页哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">17.11.3.</span> <span class="toc-text">常见的链表类型及其管理方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">17.12.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redo-Log"><span class="toc-number">17.12.1.</span> <span class="toc-text">Redo Log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Undo-Log"><span class="toc-number">17.12.2.</span> <span class="toc-text">Undo Log</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Log"><span class="toc-number">17.12.3.</span> <span class="toc-text">Binary Log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1-1"><span class="toc-number">17.13.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">17.13.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81"><span class="toc-number">17.13.2.</span> <span class="toc-text">状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">17.13.3.</span> <span class="toc-text">并发事务带来的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">17.13.4.</span> <span class="toc-text">不可重复读和幻读有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">17.13.5.</span> <span class="toc-text">隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC"><span class="toc-number">17.13.6.</span> <span class="toc-text">MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E9%94%81"><span class="toc-number">17.13.7.</span> <span class="toc-text">行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">17.13.7.1.</span> <span class="toc-text">行锁的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">17.13.7.2.</span> <span class="toc-text">行锁的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="toc-number">17.13.7.3.</span> <span class="toc-text">行锁的类别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81%E7%9A%84%E8%AF%AD%E5%8F%A5"><span class="toc-number">17.13.7.4.</span> <span class="toc-text">加锁的语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">17.13.7.5.</span> <span class="toc-text">写锁的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E4%B8%AD%E5%93%AA%E4%BA%9B%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E4%BC%9A%E4%BD%BF%E7%94%A8%E8%A1%8C%E9%94%81"><span class="toc-number">17.13.7.6.</span> <span class="toc-text">MySQL中哪些的隔离级别下会使用行锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E6%80%8E%E6%A0%B7%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">17.13.8.</span> <span class="toc-text">MySQL 的隔离级别是怎样实现的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL8-0%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">MySQL8.0新增的特性（部分）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">19.</span> <span class="toc-text">References</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="设计模式和设计原则（更新中）"><img src="https://th.bing.com/th/id/R.938bed6fc39fc253a7cd36e5481b79c0?rik=Y2Po9N8cpCfjDg&amp;riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_12064_1.jpg&amp;ehk=14nQEbT9IJH%2frqdvkztI9ztPhTEGaionf87iHCQxaz8%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="设计模式和设计原则（更新中）"/></a><div class="content"><a class="title" href="/2023/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" title="设计模式和设计原则（更新中）">设计模式和设计原则（更新中）</a><time datetime="2023-08-16T03:38:59.000Z" title="Created 2023-08-16 11:38:59">2023-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法二刷（更新中）"><img src="https://th.bing.com/th/id/R.ee995d98e687b0896c006b16980e126b?rik=ZPHZfBPZDznIiw&amp;riu=http%3a%2f%2fimg.sj33.cn%2fuploads%2fallimg%2f200912%2f20091223150352964.jpg&amp;ehk=ETvV5eN%2fU0LZJE9ZbDxQN%2btQkl3ZWmIGnhIp8GzKzZs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法二刷（更新中）"/></a><div class="content"><a class="title" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法二刷（更新中）">数据结构和算法二刷（更新中）</a><time datetime="2023-07-10T00:32:48.000Z" title="Created 2023-07-10 08:32:48">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/RocketMQ/" title="RocketMQ"><img src="https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJlbKx9CIKZ-qABs7mJV2aP0AALH5ALBgd0AGzuw770.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/2023/05/24/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2023-05-24T08:13:44.000Z" title="Created 2023-05-24 16:13:44">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img src="https://th.bing.com/th/id/OIP.fekfR1FWtn_EXSMaueufagHaEK?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud">Spring Cloud</a><time datetime="2023-05-24T08:08:42.000Z" title="Created 2023-05-24 16:08:42">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程"><img src="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&amp;riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&amp;ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程"/></a><div class="content"><a class="title" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程">Java并发编程</a><time datetime="2023-05-07T13:39:13.000Z" title="Created 2023-05-07 21:39:13">2023-05-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Song Baoru</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>