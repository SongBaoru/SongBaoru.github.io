<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | SBR Blog</title><meta name="author" content="Song Baoru"><meta name="copyright" content="Song Baoru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决 参考出处：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_38367575&#x2F;article&#x2F;details&#x2F;120420633  Scanner类用于扫描从控制台输入的数据，可以接收字符串和基本数据类型的数据。位于java.util.Scanner包中。 Scanner常用方法 String  next();">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://songbaoru.github.io/2023/05/02/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:description" content="JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决 参考出处：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_38367575&#x2F;article&#x2F;details&#x2F;120420633  Scanner类用于扫描从控制台输入的数据，可以接收字符串和基本数据类型的数据。位于java.util.Scanner包中。 Scanner常用方法 String  next();">
<meta property="og:locale">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/Java%E5%9F%BA%E7%A1%80.jpg">
<meta property="article:published_time" content="2023-05-02T13:23:04.000Z">
<meta property="article:modified_time" content="2023-09-16T10:09:45.827Z">
<meta property="article:author" content="Song Baoru">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/Java%E5%9F%BA%E7%A1%80.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://songbaoru.github.io/2023/05/02/Java%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-16 18:09:45'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SBR Blog"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">SBR Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-02T13:23:04.000Z" title="Created 2023-05-02 21:23:04">2023-05-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-09-16T10:09:45.827Z" title="Updated 2023-09-16 18:09:45">2023-09-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/IT/">IT</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">19.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>63min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决"><a href="#JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决" class="headerlink" title="JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决"></a>JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决</h1><blockquote>
<p>参考出处：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38367575/article/details/120420633">https://blog.csdn.net/qq_38367575/article/details/120420633</a></p>
</blockquote>
<p>Scanner类用于扫描从控制台输入的数据，可以接收字符串和基本数据类型的数据。位于java.util.Scanner包中。</p>
<h2 id="Scanner常用方法"><a href="#Scanner常用方法" class="headerlink" title="Scanner常用方法"></a>Scanner常用方法</h2><ol>
<li><p>String  next(); </p>
<p>作用：接收控制台输入的一个字符串。</p>
<p>结束符：以空格和回车为结束符</p>
<p>scanner.next() 方法会在读取输入后自动忽略输入中的空格和换行符，因此不会出现换行。如果需要读取包含空格或换行符的完整输入，可以使用 scanner.nextLine() 方法。</p>
</li>
<li><p>String  nextLine(); </p>
<p>作用：接收控制台输入的一个字符串。 </p>
<p>结束符：以回车为结束符</p>
</li>
<li><p>int  nextInt(); </p>
<p>作用：接收控制台输入的一个int类型的数据。</p>
<p>结束符：以空格和回车为结束符 </p>
</li>
<li><p>double  nextDouble(); </p>
<p>作用：接收控制台输入的一个double类型的数据。</p>
<p>结束符：以空格和回车为结束符  </p>
</li>
<li><p>boolean  nextBoolean(); </p>
<p>作用：接收控制台输入的一个boolean类型的数据。</p>
<p>结束符：以空格和回车为结束符 </p>
</li>
<li><p>boolean hasNext();</p>
<p>作用：检查输入流中是否还有下一个标记（token），标记是根据默认的分隔符（空格、制表符、换行符）来划分的。如果输入流中还有下一个标记，则返回 true，否则返回 false。、</p>
<p>hasNext() 和 hasNextLine() 方法都是用于判断输入流中是否还有更多的数据可供读取，如果没有，会一直等待。</p>
</li>
<li><p>boolean hasNextLine();</p>
<p>作用：检查输入流中是否还有下一行文本（以换行符为分隔符）。如果输入流中还有下一行文本，则返回 true，否则返回 false。</p>
</li>
</ol>
<p>示例1（获取一个字符串）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//步骤1、创建Scanner类的一个对象。 </span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in); 	 <br><span class="hljs-comment">//步骤2、通过scanner调用next等方法，接收控制台输入的数据。 </span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> scanner.next();<br>System.out.println(<span class="hljs-string">&quot;姓名：&quot;</span> + name);<br><br></code></pre></td></tr></table></figure>

<p>示例2（while循环中使用Scanner）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><span class="hljs-comment">//如果没有下一行，会一直等待</span><br><span class="hljs-keyword">while</span>(scanner.hasNextLine()) &#123;<br>	map.put(scanner.nextInt(), scanner.nextInt());<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p><img src="/2023/05/02/Java%E5%9F%BA%E7%A1%80/.././Java%E5%9F%BA%E7%A1%80/image-20230517204729870.png" alt="image-20230720175017238"></p>
<p>原因分析：原因是nextDouble()、nextInt()等方法，能够读出空格或者回车前的字符串或者数字，并且下次读时不会切换到空格或者回车之后（也就是还在age之后继续读，不会切换到下一行），而nextLine()则会读取本行且下次自动切换到下一行开头读。所以执行nextLine()之后实际上读取到的是age同一行后面的空字符和回车符，当执行nextDouble()时，读取的是name，而不是salary，所以无法解析出double类型的数据从而报错。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在nextDouble()、nextInt()等方法后面都要加上一句不需要赋值的nextLine()，把读的位置切换到下一行</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tess</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>		scanner.nextLine();<span class="hljs-comment">//消耗掉输入中的换行符，从而把读的位置切换到下一行</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>		<span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> scanner.nextDouble();<br>		scanner.nextLine();<span class="hljs-comment">//把读的位置切换到下一行</span><br>		System.out.println(<span class="hljs-string">&quot;age:&quot;</span> + age);<br>		System.out.println(<span class="hljs-string">&quot;name:&quot;</span> + name);<br>		System.out.println(<span class="hljs-string">&quot;salary:&quot;</span> + salary);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a><a target="_blank" rel="noopener" href="https://www.nowcoder.com/issue/tutorial?tutorialId=94&uuid=a028d353123b47e29fdfb6aba51fc72c">IO流</a></h1><h2 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h2><ul>
<li>按照数据流向，可以将流分为输入流和输出流</li>
<li>按照数据类型，可以将流分为字节流和字符流</li>
<li>按照处理功能，可以将流分为节点流和处理流</li>
</ul>
<h2 id="输入流和输出流"><a href="#输入流和输出流" class="headerlink" title="输入流和输出流"></a>输入流和输出流</h2><p>IO（Input Output）用于实现对数据的输入与输出操作，根据数据流向的方向不同，分为输入流和输出流。</p>
<p>IO流的输入\出源有控制台、文件、网络、数据库…，Java把不同的输入&#x2F;输出源（键盘、文件、网络等）抽象表述为流（Stream）。</p>
<h2 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h2><p>IO流分字节流（以字节，8bit为单位对数据进行读写操作）和字符流（以字符为单位，一个字符占2个字节）</p>
<p>Java提供了大量的类来支持IO操作，下表给大家整理了其中比较常用的一些类。</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>抽象基类</td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
<td></td>
</tr>
<tr>
<td>访问文件</td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
<td>FileReader</td>
<td>FileWriter</td>
<td>访问文件</td>
</tr>
<tr>
<td>访问数组</td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
<td>访问内存中的数组</td>
</tr>
<tr>
<td>访问管道</td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
<td>访问管道，实现进程之间的通信</td>
</tr>
<tr>
<td>缓冲流</td>
<td>BufferedInputstream</td>
<td>BufferedOutputstream</td>
<td>BufferedReader</td>
<td>Bufferedwriter</td>
<td>在读写数据时对数据进行缓存，以减少IO次数</td>
</tr>
<tr>
<td>过滤器流</td>
<td>FilterInputStream</td>
<td>FilterOutputStream</td>
<td>FilterReader</td>
<td>FilterWriter</td>
<td>对其他流进行转换数据或提供附加功能</td>
</tr>
<tr>
<td>对象流</td>
<td>ObjectInputstream</td>
<td>ObjectOutputstream</td>
<td></td>
<td></td>
<td>实现对象的序列化</td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
<td>简化打印操作</td>
</tr>
<tr>
<td>转换流</td>
<td></td>
<td></td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
<td>将字节流转换为字符流</td>
</tr>
<tr>
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>Stringwriter</td>
<td>访问内存中的字符串</td>
</tr>
<tr>
<td>推回输入流</td>
<td>PushbackInputstream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
<td>将已读入的数据推回到缓冲区，从而实现再次读取</td>
</tr>
<tr>
<td>特殊流</td>
<td>DataInputstream</td>
<td>DataOutputstream</td>
<td></td>
<td></td>
<td>读写Java基本类型的数据</td>
</tr>
</tbody></table>
<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><ul>
<li><p>节点流是低级流，直接从&#x2F;向IO设备（磁盘、网络等）读&#x2F;写数据，也称为低级流。</p>
</li>
<li><p>处理流是高级流，采用装饰器模式对节点流进行封装，也称为高级流。</p>
<p>处理流相比节点流提升的方面包括，增加缓存提高了数据输入和输出的效率、简化了数据读&#x2F;写操作等，</p>
</li>
</ul>
<p>节点流包含：FileInputStream、FileOutputStream、FileReader、FileWriter、ByteArrayInputStream、ByteArrayOutputStream、CharArrayReader、CharArrayWriter、PipedInputStream、PipedOutputStream等。</p>
<p>处理流包含：BufferInputStream（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/io/FilterInputStream.html">FilterInputStream</a>的实现类）、BufferOutputStream、BufferReader、BufferWriter、ObjectInputStream、ObjectOutputStream等。</p>
<h2 id="内存映射文件技术"><a href="#内存映射文件技术" class="headerlink" title="内存映射文件技术"></a>内存映射文件技术</h2><p>含义：操作系统利用虚拟内存将文件映射到内存中，然后，这个文件就可以被当作内存数据来访问。</p>
<p><strong>关键技术优势</strong>：</p>
<ul>
<li>让操作系统负责文件的读写，应用程序只需要处理内存数据，就可以实现IO操作；</li>
<li>大幅提升文件数据的输入输出速度</li>
<li>可以实现共享内存，内存映射文件可以被多个进程同时访问；内存映射文件技术涉及的内存在Java的堆空间之外；</li>
</ul>
<p>Java的NIO包支持内存映射技术，实现方式是通过<strong>MapperdByteBuffer</strong>读写内存</p>
<h2 id="NIO的实现原理"><a href="#NIO的实现原理" class="headerlink" title="NIO的实现原理"></a><a target="_blank" rel="noopener" href="https://gitee.com/SnailClimb/JavaGuide/blob/main/docs/java/io/nio-basis.md">NIO的实现原理</a></h2><p>NIO（New IO）是Java从1.4版本开始提供的一个IO包，为执行IO操作提供了传统Java IO API（以下简称OIO，Old IO）的替代方案。</p>
<p>NIO 主要包括以下三个核心组件：</p>
<ul>
<li><strong>Buffer（缓冲区）</strong>：NIO 读写数据都是通过缓冲区进行操作的。读操作的时候将 Channel 中的数据填充到 Buffer中，而写操作时将 Buffer中的数据写入到 Channel 中。</li>
<li><strong>Channel（通道）</strong>：Channel 是一个双向的、可读可写的数据传输通道，NIO 通过Channel来实现数据的输入输出。通道是一个抽象的概念，它可以代表文件、套接字或者其他数据源之间的连接。</li>
<li><strong>Selector（选择器）</strong>：允许一个线程处理多个 Channel，是基于事件驱动的 I&#x2F;O 多路复用模型。所有的 Channel 都可以注册到Selector上，由Selector来分配线程来处理事件。</li>
</ul>
<p>NIO和OIO对比：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2016/11/04/nio.html">OIO在socket读和写等阶段都是阻塞的（所以也称BIO），NIO在socket读和写等阶段是非阻塞的，NIO的IO操作是同步阻塞的，但性能非常高。</a></li>
<li>OIO严重依赖于线程，NIO支持使用单线程处理多个连接的非阻塞 I&#x2F;O 操作（多路复用特性）。</li>
<li>OIO 中，数据的读写是面向流的， 分为字节流和字符流。NIO 在读取数据时，它是直接读到缓冲区中的。在写入数据时，写入到缓冲区中。 使用 NIO在读写数据时，都是通过缓冲区进行操作。</li>
<li>OIO 中的流是单向的，分为输入流和输出流，数据只是在一个方向上传输；通道与流的不同之处在于通道是双向的，它可以用于读、写或者同时用于读写。</li>
</ol>
<p>Java 对零拷贝的支持：</p>
<ul>
<li><code>MappedByteBuffer</code> 是 NIO 基于内存映射（<code>mmap</code>）这种零拷⻉⽅式的提供的⼀种实现，底层实际是调用了 Linux 内核的 <code>mmap</code> 系统调用。它可以<strong>将一个文件或者文件的一部分映射到内存中，形成一个虚拟内存文件</strong>，这样就可以直接操作内存中的数据，而不需要通过系统调用来读写文件。</li>
<li><code>FileChannel</code> 的<code>transferTo()/transferFrom()</code>是 NIO 基于发送文件（<code>sendfile</code>）这种零拷贝方式的提供的一种实现，底层实际是调用了 Linux 内核的 <code>sendfile</code>系统调用。它可以<strong>直接将文件数据从磁盘发送到网络，而不需要经过用户空间的缓冲区</strong>。关于<code>FileChannel</code>的用法可以看看这篇文章：<a href="https://gitee.com/link?target=https://www.cnblogs.com/robothy/p/14235598.html">Java NIO 文件通道 FileChannel 用法</a>。</li>
</ul>
<h2 id="IO典型应用示例"><a href="#IO典型应用示例" class="headerlink" title="IO典型应用示例"></a>IO典型应用示例</h2><h3 id="打开大文件"><a href="#打开大文件" class="headerlink" title="打开大文件"></a>打开大文件</h3><p>打开大文件时，应避免直接将硬盘中的数据全部读取到内存中，可以采取的方法包括：</p>
<ol>
<li><p>使用缓冲流，分次读取</p>
<p>缓冲流内部维护了一个缓冲区，当缓冲区为空时，会读取数据到将缓冲区直至填满，当缓冲区填满时会自动刷入设备。</p>
</li>
<li><p>使用NIO的零拷贝实现，直接操作硬盘上的数据，避免读取数据到内存</p>
<p>NIO采用了<strong>内存映射文件技术</strong>来处理输入&#x2F;输出，不需要将数据读入内存，而是将文件或文件的一段区域<strong>映射</strong>到内存中，从而<strong>像访问内存一样来访问文件</strong>。</p>
</li>
</ol>
<h2 id="BIO、NIO、AIO"><a href="#BIO、NIO、AIO" class="headerlink" title="BIO、NIO、AIO"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000037714804">BIO、NIO、AIO</a></h2><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li><strong>序列化</strong>：将对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将序列化生成的二进制字节流转换成对象的过程</li>
</ul>
<h2 id="序列化的应用场景"><a href="#序列化的应用场景" class="headerlink" title="序列化的应用场景"></a>序列化的应用场景</h2><ol>
<li>持久化Java对象，比如将Java对象保存在文件、内存、数据库中</li>
<li>网络传输Java对象，比如远程方法调用</li>
</ol>
<h2 id="JDK中的序列化方法"><a href="#JDK中的序列化方法" class="headerlink" title="JDK中的序列化方法"></a>JDK中的序列化方法</h2><p>使用Java中提供的序列化方法的方式是实现 <code>java.io.Serializable</code>接口。</p>
<p>对于不想进行序列化的变量，可以使用 <code>transient</code> 关键字修饰。</p>
<p><strong>serialVersionUID的作用：</strong></p>
<p>serialVersionUID代表序列化的版本，用于版本控制。通过定义类的序列化版本，在反序列化时，只要对象中所存的版本和当前类的版本一致，就允许做恢复数据的操作，否则将会抛出 <code>InvalidClassException</code> 异常。</p>
<p>之所以几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：</p>
<ul>
<li><strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li>
<li><strong>性能差</strong>：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。</li>
<li><strong>存在安全问题</strong>：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。相关阅读：<a href="https://gitee.com/link?target=https://cryin.github.io/blog/secure-development-java-deserialization-vulnerability/">应用安全:JAVA 反序列化漏洞之殇 - Cryin</a>、<a href="https://gitee.com/link?target=https://www.zhihu.com/question/37562657/answer/1916596031">Java 反序列化安全漏洞怎么回事? - Monica</a>。</li>
</ul>
<h2 id="常用的序列化工具"><a href="#常用的序列化工具" class="headerlink" title="常用的序列化工具"></a>常用的序列化工具</h2><ul>
<li>JSON序列化工具：常用的JSON序列化工具有Jackson、Gson和Fastjson等。</li>
<li>二进制序列化工具：Protobuf、Kryo、Avro。protobuf是由Google开发的一种高效的二进制序列化框架，支持多种编程语言。Kryo是一个快速、高效的Java对象序列化工具，只支持Java语言。Avro默认使用二进制格式的序列化方式，也支持JSON格式的序列化方式，支持多种编程语言。</li>
<li>RPC框架内嵌的提供序列化工具：Thrift是Facebook开源提供的一个高性能，轻量级RPC服务框架。</li>
</ul>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="8种基本类型"><a href="#8种基本类型" class="headerlink" title="8种基本类型"></a>8种基本类型</h2><p>在Java中共有8种基本类型（primitive type），其中包含4种整型、2种浮点型、1种字符类型（用于表示Unicode编码）和1种真值类型。</p>
<ol>
<li><p>4种整型</p>
<p>byte：1字节；取值范围是从-128 (-2^7) 到 127 (2^7 - 1)</p>
<p>short：2字节；取值范围是从 -32,768 (-2^15) 到 32,767 (2^15 - 1)</p>
<p>int：4字节；取值范围是从 -2,147,483,648 (-2^31) 到 2,147,483,647 (2^31 - 1)</p>
<p>long：8字节；取值范围是从-9,223,372,036,854,775,808 (-2^63) 到 9,223,372,036,854,775,807 (2^63 - 1)</p>
<p>Java整型数值的表示方法：</p>
<ul>
<li><p>长整型（long）数值后面有一个后缀L或l</p>
</li>
<li><p>十六进制数值有一个前缀0X或0x</p>
</li>
<li><p>八进制有一个前缀0</p>
</li>
<li><p>二进制有一个前缀0B或0b</p>
</li>
<li><p>可以在整数类型的数字字面量上加下划线进行分组，以提高可读性</p>
</li>
</ul>
<blockquote>
<p>Java和C++的不同：</p>
<p>Java中整型的范围是平台无关的，而C++（C同样也是）中，是平台相关的。</p>
</blockquote>
</li>
<li><p>2种浮点型</p>
<p>float：4字节；取值范围是大约是正负3.4E+38（约7位有效数字）</p>
<p>double：8字节；取值范围大约是正负1.7E+308（约15位有效数字）</p>
<p>取值范围是由IEEE 754浮点数标准规定的，float类型的32位二进制数被划分为三个部分：1个符号位，8个指数位和23个尾数位。double类型的64位二进制数被划分为三个部分：1个符号位，11个指数位和52个尾数位。其中，指数位决定了浮点数的范围，尾数位决定了浮点数的精度。</p>
<p>double这种表示浮点数的类型数值精度是float类型的两倍，所以称为双精度浮点数。</p>
<p>Java整型数值的表示方法：</p>
<ul>
<li>float类型的数值有一个后缀F或f</li>
<li>double类型的数值既可以没有后缀，也可以有一个后缀D或d，所以Java中没有后缀的浮点数类型默认是double</li>
</ul>
<blockquote>
<p> 警告： </p>
<p>浮点数不适用于无法接受舍入误差的精确计算，如果需要精确的数值计算，不允许有舍入误差，应该使用BigDecimal类。</p>
</blockquote>
</li>
<li><p>1种字符类型</p>
<p>char：2字节；取值范围是从0到65535（包括0和65535）</p>
<p>char类型的作用主要有两个，表示单个字符，以及表示Unicode字符（目前，16位的char类型已经不足以描述所有Unicode字符了，部分Unicode字符需要两个char来表示）。</p>
<blockquote>
<p>备注：</p>
<p>Unicode字符是一种用于表示文本字符的国际标准编码系统。它为几乎所有的字符（包括字母、数字、标点符号、符号、表情符号等）分配了唯一的代码点，以便在计算机系统中进行存储和处理。</p>
<p>Unicode字符使用十六进制表示，前缀为”\u”，后跟四个十六进制数字。</p>
<p>Unicode转义序列会在解释代码之前处理。</p>
</blockquote>
</li>
<li><p>1种真值类型</p>
<p>boolean：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">“大小”并不是精确定义的</a>，通常是1字节；取值范围是true或false</p>
<blockquote>
<p>注意：</p>
<p>在Java8HotSpot虚拟机下，单个boolean数值和数组中的boolean数值都是占1个字节。</p>
<p>使用JOL对象布局分析工具，编写测试程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BooleanLength</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span>[] bArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[]&#123;<span class="hljs-literal">true</span>&#125;;<br>        System.out.println(ClassLayout.parseInstance(b).toPrintable());<br>        System.out.println(ClassLayout.parseInstance(bArr).toPrintable());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="/2023/05/02/Java%E5%9F%BA%E7%A1%80/.././Java%E5%9F%BA%E7%A1%80/image-20230602165516573.png" alt="image-20230602165516573"></p>
<p>可以看到无论是单个boolean对象还是数组中的boolean对象，其boolean数值都只占1个字节。</p>
</blockquote>
</li>
</ol>
<p>在Java中只有基本类型不是对象。</p>
<h3 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h3><p>所有基本类型都有一个与之对应的类，这些类被称为包装器（wrapper），分别是：<strong>Byte、Integer、Long、Float、Double、Boolean、Character</strong>（前6个类派生于父类Number）。</p>
<blockquote>
<p>由于每个值分别包装在一个对象中，所以ArrayList&lt;Integer&gt;的效率远远低于int[]数组。</p>
</blockquote>
<p><strong>自动装箱</strong></p>
<p>list.add(1);会自动转换为list.add(Integer.valueOf(1))，这种转换称为自动装箱（autoboxing）。</p>
<p><strong>自动拆箱</strong></p>
<p>当将Integer对象赋给一个int值时，会自动拆箱（unboxed）。例如，int n &#x3D; list.get(i)会转换成int n &#x3D; list.get(i).intValue()。</p>
<p>自动装箱和自动拆箱也适用于算术表达式。例如，对于Integer n &#x3D; 1; n++;编译器会自动地对n拆箱，将拆箱后的结果增1，最后再将其装箱。</p>
<p>装箱和拆箱由编译器完成，而不是虚拟机。编译器在生成类的字节码时会插入必要的方法调用，虚拟机只是执行这些字节码。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Java字符串（String类对象）是Unicode字符序列，每个字符char都对应一个Unicode码点。</p>
<p><strong>字符串不可变</strong></p>
<blockquote>
<p> <code>String</code> objects are <em>immutable</em>, which means that once created, their values cannot be changed. </p>
</blockquote>
<p>Java中字符串是不可变的（immutable），并且也没有提供任何方法来修改字符串中的某个字符。</p>
<p><strong>字符串共享</strong></p>
<p>字符串常量池是一块位于Java堆内存中的特殊存储区域，用于存储字符串字面量（直接以双引号括起来的字符串）和显式通过String类的<code>intern()</code>方法调用加入常量池的字符串。当创建字符串时，如果字符串常量池中已经存在相同内容的字符串，则不会创建新的字符串对象，而是直接返回常量池中的字符串引用。</p>
<p>需要注意的是，通过<code>new</code>关键字创建的字符串对象不会被共享，而是在堆内存中创建新的对象。只有使用字符串字面量或显式调用<code>intern()</code>方法将字符串加入常量池时才会进行共享。此外，+或substring等操作得到的字符串也不共享。</p>
<p><strong>检测字符串是否相等</strong></p>
<p>String类覆盖了equals方法。</p>
<p>可以使用equals方法检测两个字符串是否相等，不能使用&#x3D;&#x3D;运算符，因为&#x3D;&#x3D;运算符只能确定两个字符串是否存储在同一个位置上，而Java中的相等的字符串可以存储在不共享的位置，不能仅通过位置判断是否相等。</p>
<p><strong>文本块</strong></p>
<p>Java15新增了文本块（text block）特性，提供了跨多行的字符串字面量。</p>
<p>文本块特别适合包含用其它语言编写的代码，如SQL或HTML。</p>
<p>文本块示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">    	HTML...</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>文本块需要转义的情况：</p>
<ul>
<li><p>文本块以引号结尾</p>
</li>
<li><p>文本块中包含三个及以上的引号</p>
</li>
<li><p>文本块中有反斜杠（\）</p>
</li>
<li><p>文本块以空格结尾</p>
<p>文本块会删除末尾的空格，如果需要保留末尾的空格，可以把空格替换为\s。</p>
</li>
</ul>
<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><p>Java的<code>java.math</code>包中提供了两个重要的数值处理类，BigInteger和BigDecimal，用于处理大整数和高精度浮点数的运算。BigInteger类能够表示任意数值的整数。BigDecimal类能够实现任意精度的浮点数运算。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>for each循环的对象必须是一个数组或者是一个实现了Iterable接口的类对象。</p>
<p><strong>Arrays类</strong></p>
<ul>
<li><p><strong>数组打印</strong> </p>
<p>如果要打印数组中的所有值，可以使用另一种方法，使用Arrays类的<strong>toString</strong>方法，该方法会返回一个包含数组元素的字符串，这些元素包围在中括号内，并使用逗号分隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Arrays.toString(a));<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>数组拷贝</strong></p>
<p>如果要拷贝数组内的所有值，可以使用Arrays类的<strong>copyOf</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] copiedArray = Arrays.copyOf(a, length); <span class="hljs-comment">//第二个参数length是新数组的长度</span><br></code></pre></td></tr></table></figure>

<p>如果要拷贝数组内指定范围内的所有值，可以使用Arrays类的<strong>copyOfRange</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//还支持其它元素类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] copyOfRange(<span class="hljs-type">int</span>[] original, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to)<br></code></pre></td></tr></table></figure>

<p>如果要拷贝数组内指定范围内的所有值到目标数组指定范围内，可以使用System.arraycopy方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-type">int</span> srcPos,</span><br><span class="hljs-params">                                    Object dest, <span class="hljs-type">int</span> destPos,</span><br><span class="hljs-params">                                    <span class="hljs-type">int</span> length)</span><br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>数组排序</strong></p>
<p>如果要对数值型的数组进行排序，可以使用Arrays类中的<strong>sort</strong>方法。如果是其它类型的数组，也可以使用该方法，前提是数组元素的类实现了Comparator接口的compareTo方法（x小于y时返回负数）。</p>
<p>这个方法使用了优化的快速排序（QuickSort）算法。</p>
</li>
<li><p><strong>数组二分查找</strong></p>
<p>如果要使用二分查找算法在有序数组a中或a中的指定范围内查找值v，可以使用Arrays的binarySearch方法，如果找到v，该方法会返回值的索引，否则返回一个负数值r，-r-1是v在保持a有序的前提下可以插入的位置。</p>
</li>
<li><p><strong>数组填充</strong></p>
<p>如果要将数组所有元素设置为指定值，可以使用Arrays类的fill方法。</p>
</li>
<li><p><strong>数组元素比较</strong></p>
<p>Arrays类提供了一个equals()方法，用于比较两个数组是否相等。如果两个数组长度相同，并且相同索引对应的元素都相同，则返回true。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1911272"><strong>List集合转基本类型的数组</strong></a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;(); <br><span class="hljs-comment">//HashSet等类型的对象也适用如下方法</span><br><span class="hljs-type">int</span>[] array = list.stream().mapToInt(Integer::intValue).toArray();<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>基本类型的数组转List</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//基本类型也可以实现转换（依赖boxed的装箱操作）</span><br><span class="hljs-type">int</span>[] myArray =&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">List</span> <span class="hljs-variable">myList</span> <span class="hljs-operator">=</span> Arrays.stream(myArray2).boxed().collect(Collectors.toList());<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>包装器类型的数组转List</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-comment">//对于是Integer而不是int类型的数组，可以直接调用Arrays.asList方法转换到List&lt;Integer&gt;</span><br>List&lt;Integer&gt; list = Arrays.asList(array);<br></code></pre></td></tr></table></figure></li>
</ul>
<p><strong>不规则数组</strong></p>
<p>Java中的数组可以是不规则的数组，即数组的每一行有不同的长度。</p>
<blockquote>
<p>Java和C++的不同：</p>
<p>在Java中，赋值操作b&#x3D;a的操作结果是让a和b引用同一个数组列表；而C++的Vector是按值复制的，这条赋值语句是构造一个与a长度相同的新向量，并将所有元素从a复制到b。</p>
</blockquote>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Java的运算符包括&amp;（and）、|（or）、^（xor）、~（not）。</p>
<p>对于布尔值，&amp;和|运算符的返回结果也是布尔值，不过与<code>&amp;&amp;</code>和<code>||</code>不同的是，$和|运算符不是短路的，也就是说，计算结果之前两个操作数都需要计算。</p>
<h2 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h2><p>Java的位移运算符包括&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;，不存在&lt;&lt;&lt;。</p>
<ul>
<li>&gt;&gt;会用符号位填充高位</li>
<li>&gt;&gt;&gt;会用0填充高位</li>
</ul>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>Java14中引入switch，既可以作为语句，也可以做表达式。</p>
<p><strong>参数类型</strong></p>
<p>可以作为switch参数数据类型的有：int、bype、short、char、String、枚举、（int、bype、short、char）的包装类</p>
<p>不能作为switch参数的有：long、float、double、boolean、复杂的表达式、……</p>
<p>case的参数可以有多个。如<code>case &quot;Summer&quot;， &quot;Winter&quot; -&gt; 0;</code></p>
<p><strong>直通和非直通</strong></p>
<p>Java中switch语句的行为可以被描述为直通（能够继续执行，不会返回）和非直通：</p>
<ul>
<li><p>直通行为</p>
<ul>
<li>case以冒号（:）结尾，是有直通行为的。</li>
</ul>
</li>
<li><p>非直通行为</p>
<ul>
<li>case以箭头（-&gt;）结尾，是无直通行为的。</li>
<li>switch表达式中有yield关键字，yield关键字会返回表达式的值并终止执行。</li>
<li>switch表达式中有break关键字，break关键字会终止执行，switch表达式中不能使用return、break或continue语句。</li>
</ul>
</li>
</ul>
<p><strong>switch的使用方法</strong></p>
<ul>
<li><p>-&gt;</p>
<ul>
<li><p>switch表达式</p>
<ul>
<li><p>直接返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;<br><span class="hljs-type">Size</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Size.LARGE;<br><span class="hljs-comment">// switch表达式</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> SMALL -&gt; <span class="hljs-string">&quot;S&quot;</span>;<br>    <span class="hljs-keyword">case</span> MEDIUM -&gt; <span class="hljs-string">&quot;M&quot;</span>;<br>    <span class="hljs-keyword">case</span> LARGE -&gt; <span class="hljs-string">&quot;L&quot;</span>;<br>    <span class="hljs-keyword">case</span> EXTRA_LARGE -&gt; <span class="hljs-string">&quot;XL&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用yield返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;<br><span class="hljs-type">Size</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Size.LARGE;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> SMALL -&gt; &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;S&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> MEDIUM -&gt; &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;M&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> LARGE -&gt; &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;L&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> EXTRA_LARGE -&gt; &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;XL&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>switch语句</p>
<ul>
<li><p>直接赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;<br><span class="hljs-type">Size</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Size.LARGE;<br>String result;<br><span class="hljs-comment">// switch语句</span><br><span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> SMALL -&gt; result = <span class="hljs-string">&quot;S&quot;</span>;<br>    <span class="hljs-keyword">case</span> MEDIUM -&gt; result = <span class="hljs-string">&quot;M&quot;</span>;<br>    <span class="hljs-keyword">case</span> LARGE -&gt; result = <span class="hljs-string">&quot;L&quot;</span>;<br>    <span class="hljs-keyword">case</span> EXTRA_LARGE -&gt; result = <span class="hljs-string">&quot;XL&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>:</p>
<ul>
<li><p>switch表达式</p>
<ul>
<li><p>使用yield返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;<br><span class="hljs-type">Size</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Size.LARGE;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (size) &#123;<br>     <span class="hljs-keyword">case</span> SMALL:<br>         <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;S&quot;</span>;<br>     <span class="hljs-keyword">case</span> MEDIUM:<br>         <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;M&quot;</span>;<br>     <span class="hljs-keyword">case</span> LARGE:<br>         <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;L&quot;</span>;<br>     <span class="hljs-keyword">case</span> EXTRA_LARGE:<br>         <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;XL&quot;</span>;<br> &#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>switch语句</p>
<ul>
<li><p>赋值后使用break返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;<br><span class="hljs-type">Size</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Size.LARGE;<br>String result;<br><span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> SMALL:<br>        result = <span class="hljs-string">&quot;S&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> MEDIUM:<br>        result = <span class="hljs-string">&quot;M&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> LARGE:<br>        result = <span class="hljs-string">&quot;L&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> EXTRA_LARGE:<br>        result = <span class="hljs-string">&quot;XL&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h2><p>数值类型转换中int转float，long转double可能产生精度损失。</p>
<p><strong>自动类型转换</strong></p>
<p>二元运算符在计算前会先将两个操作数转换为同一类型，如果有一个操作数是double&#x2F;float&#x2F;long，另一个操作数是byte&#x2F;short&#x2F;char&#x2F;int，则另一个操作数就会被转换为double&#x2F;float&#x2F;long。double&#x2F;float&#x2F;long之间的自动类型转换的优先顺序是，long类型能自动转换为float或double类型，float类型能自动转换为double类型。</p>
<p><strong>强制类型转换</strong></p>
<p>对于可能丢失信息的转换需要通过强制类型转换完成。</p>
<p>浮点数转换为整数时会截断小数位。</p>
<h2 id="数学函数Math"><a href="#数学函数Math" class="headerlink" title="数学函数Math"></a>数学函数Math</h2><p>Math.pow方法：进行幂运算，Java中没有完成幂运算的运算符</p>
<p>Math.round方法：舍入（round）浮点数来得到最接近的整数</p>
<p>Math.ramdom方法：返回一个0到1（包含0，不包含1）之间的随机浮点数，用n乘以这个浮点数，可以得到从0到n-1之间的一个随机数。例如：<code>int result = (int) (Math.random() * n);</code></p>
<h1 id="面向对象编程的概念"><a href="#面向对象编程的概念" class="headerlink" title="面向对象编程的概念"></a>面向对象编程的概念</h1><p><strong>封装（encapsulation）</strong></p>
<p>从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现细节。</p>
<p>实现封装的关键在于，不能让其它类中的方法直接访问被封装的类的实例字段，程序只能通过对象的方法与对象的数据进行交互。这意味着一个类可以完全改变存储数据的方式，只要仍旧向外提供同样的方法，调用该方法的对象不需要关心这个类所发生的变化。</p>
<p><strong>继承（Inheritance）</strong></p>
<p>继承可以让实现Java类变得更容易，因为可以通过继承（extends、implements）其它类来构建新类。</p>
<p><strong>多态（Polymorphism）</strong></p>
<p>多态是指在父类或接口类型上使用不同的子类对象，以实现同一个方法的多种不同行为。一个父类变量既可以引用父类对象，也可以引用其任何一个子类的对象。多态的实现方式是，在继承的基础上，子类覆盖从父类中继承的方法。</p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p><strong>方法参数能否改变的规则</strong></p>
<ul>
<li>方法不能改变基本数据类型的参数</li>
<li>方法不能改变对象参数的引用对象</li>
<li>方法可以改变对象参数的状态，即方法可以改变传入的对象内部的变量。</li>
</ul>
<p><strong>变长参数</strong></p>
<p>在 Java 5 中提供了变长参数，允许在调用方法时传入不定长度的参数。变长参数是 Java 的一个语法糖，本质上还是基于数组的实现。</p>
<p>定义变长参数的方法是，在最后一个形参后加上三点 <strong>…</strong>，就表示该形参可以接受多个参数值，需要注意的是：</p>
<ul>
<li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数</li>
<li>由于可变参数必须是最后一个参数，所以一个函数最多只能有一个可变参数</li>
<li>Java的可变参数，会被编译器转型为一个数组</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载（orverloading）指的是一个类的多个方法有相同的参数名，但是有不同的参数。</p>
<h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>覆盖（override），又叫重写，指的是子类提供从父类中继承的方法的新的实现。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>继承的基本思想是基于已有的类创建新的类。</p>
<blockquote>
<p>Java和C++的不同：</p>
<p>Java中继承是使用关键字extends，而C++中是使用冒号（:）</p>
<p>Java中所有的继承都是公共继承，没有C++中的私有继承和保护继承。</p>
</blockquote>
<p>在<strong>覆盖</strong>一个方法的时候，子类的方法不能低于超类方法的可见性。</p>
<h3 id="final类和final方法"><a href="#final类和final方法" class="headerlink" title="final类和final方法"></a>final类和final方法</h3><p>final能够阻止类的继承，以及方法的覆盖。</p>
<h3 id="protected访问修饰符"><a href="#protected访问修饰符" class="headerlink" title="protected访问修饰符"></a>protected访问修饰符</h3><p>protected是Java的一个访问修饰符（access modifier）。</p>
<p>当一个类的成员被声明为 protected，意味着它只能被以下两种情况下的代码访问：</p>
<ol>
<li>在同一包内的其他类</li>
<li>所有（在同一包或不同包中）的子类</li>
</ol>
<blockquote>
<p>注意：</p>
<p>如果在Java中不指定类中某个方法的访问修饰符，则默认使用包级私有（package-private）修饰符，而不是protected修饰符。</p>
</blockquote>
<h1 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h1><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><table>
<thead>
<tr>
<th>关系</th>
<th>含义</th>
<th>UML（Unified Modeling Language）连接符</th>
<th>关系强弱</th>
</tr>
</thead>
<tbody><tr>
<td>实现（Implementation，is-a）</td>
<td>implements interface</td>
<td>虚线+三角实心箭头</td>
<td></td>
</tr>
<tr>
<td>继承（Inheritance，is-a）</td>
<td>inherits from</td>
<td>实线+三角实心箭头</td>
<td></td>
</tr>
<tr>
<td>依赖（Dependency，uses-a）</td>
<td>depend on</td>
<td>虚线+三线箭头</td>
<td>弱（如成员函数里的局部变量）</td>
</tr>
<tr>
<td>关联（Association，uses-a）</td>
<td>is associated with</td>
<td>实线+三线箭头</td>
<td>强（如成员变量）</td>
</tr>
<tr>
<td>聚合（Aggregation，has-a）</td>
<td>is an aggregate of</td>
<td>空心菱形箭头+实线</td>
<td>弱</td>
</tr>
<tr>
<td>组合（Composition，has-a）</td>
<td>is composed of</td>
<td>实心菱形箭头+实线</td>
<td>强</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><blockquote>
<p>Java和C++的不同：</p>
<p>在C++中，抽象方法称为纯虚函数（pure virtual function），要在末尾用&#x3D;0标记，没有用于表示抽象类的特殊关键字。</p>
</blockquote>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在比较枚举类的值时，不需要使用equals，可以之间使用&#x3D;&#x3D;来比较。</p>
<p>枚举类可以有构造器、方法和字段。</p>
<p>有构造器、方法和字段的枚举类示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;<br>    SMALL(<span class="hljs-string">&quot;S&quot;</span>), MEDIUM(<span class="hljs-string">&quot;M&quot;</span>), LARGE(<span class="hljs-string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="hljs-string">&quot;XL&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String abbreviation;<br><br>    Size(String abbreviation) &#123;<br>        <span class="hljs-built_in">this</span>.abbreviation = abbreviation;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAbbreviation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> abbreviation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所有枚举类型都是抽象类Enum的子类。</p>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>内部类（inner class）是定义在类中的类。</p>
<p>内部类的分类：</p>
<p><img src="https://www.tutorialspoint.com/java/images/inner_classes.jpg" alt="内部类的分类"></p>
<ul>
<li>非静态的<ul>
<li>Inner Classes：非静态内部类，又称成员内部类</li>
<li>Method Local Inner Classes：方法局部内部类</li>
<li>Annonymous Inner Classes：匿名内部类</li>
</ul>
</li>
<li>静态的（类的前面多了一个关键字static）<ul>
<li>Static Nested Classes：静态内部类</li>
</ul>
</li>
</ul>
<h3 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/java-inner-class-intro.html">非静态内部类</a></h3><p><strong>访问成员的规则</strong></p>
<ul>
<li><p>非静态内部类可以访问外部类的所有（包括private成员和静态成员）成员变量和方法，可以修改外部类的非final类型的成员变量。</p>
<p>当非静态内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是非静态内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.<span class="hljs-built_in">this</span>.成员变量<br>外部类.<span class="hljs-built_in">this</span>.成员方法<br></code></pre></td></tr></table></figure>
</li>
<li><p>在外部类中如果要访问非静态内部类的成员，必须先创建一个非静态内部类的对象，再通过指向这个对象的引用来访问。</p>
</li>
</ul>
<p><strong>创建的方法</strong></p>
<p>非静态内部类是依附外部类而存在的，也就是说，如果要创建非静态内部类的对象，只能使用外部类的对象来创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//必须先创建一个外部类的对象</span><br><span class="hljs-type">Outter</span> <span class="hljs-variable">outter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outter</span>();<br>Outter.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outter.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();  <span class="hljs-comment">//必须通过Outter对象来创建</span><br></code></pre></td></tr></table></figure>

<p><strong>访问权限修饰</strong></p>
<p>非静态内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果非静态内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。</p>
<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p><strong>访问成员的规则</strong></p>
<ul>
<li>静态内部类可以直接访问外部类的静态成员变量和静态方法，可以修改外部类的非final类型的静态成员变量。如果要访问外部类的实例成员，需要通过外部类的实例去访问。</li>
<li>外部类以外的其他类需要通过完整的类名访问静态内部类中的静态成员。如果要访问静态内部类中的实例成员，则需要通过静态内部类的实例。</li>
</ul>
<p><strong>创建的方法</strong></p>
<p>在创建静态内部类的实例时，不需要创建外部类的实例。</p>
<h3 id="方法局部内部类"><a href="#方法局部内部类" class="headerlink" title="方法局部内部类"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1028.html">方法局部内部类</a></h3><p>方法局部内部类是定义在一个方法或者一个作用域里面的类。方法局部内部类只在当前方法中有效。</p>
<p><strong>实现规则</strong></p>
<ol>
<li>方法局部内部类与局部变量一样，不能使用访问控制修饰符（public、private 和 protected）和 static 修饰符修饰。</li>
<li>方法局部内部类中还可以包含方法局部内部类，但是这些方法局部内部类也不能使用访问控制修饰符（public、private 和 protected）和 static 修饰符修饰。</li>
</ol>
<p><strong>访问成员的规则</strong></p>
<ul>
<li>方法局部内部类可以访问<strong>外部类的方法和final或等效于final类型的成员变量</strong>（所以不能修改外部类的成员变量）。如果内部类中的成员与外部类中的成员同名，则可以使用 &lt;OuterClassName&gt;.this.&lt;MemberName&gt; 的形式访问外部类中的成员。</li>
<li>方法局部内部类只能访问<strong>所属方法的final或等效于final类型的局部变量和形参</strong>。</li>
</ul>
<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1031.html">匿名内部类</a></h3><p>匿名内部类是指没有类名的内部类，通常用于只需要临时实现某个接口或抽象类的情况，从而避免编写额外的类定义。在创建匿名内部类时，必须使用 new 语句来声明类。其语法形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> [类名或接口名](/2023/05/02/Java%E5%9F%BA%E7%A1%80/) &#123;<br>    <span class="hljs-comment">// 类的主体</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>匿名内部类不能是静态的。</p>
<p><strong>实现方法</strong></p>
<p>匿名类有两种实现方式：</p>
<ul>
<li>继承一个父类，重写其方法。</li>
<li>实现一个接口，实现其方法。</li>
</ul>
<p><strong>访问成员的规则（和方法局部内部类一样）</strong></p>
<ul>
<li>匿名内部类可以访问<strong>外部类的方法和final或等效于final类型的成员变量</strong>（所以不能修改外部类的成员变量），如果内部类中的成员与外部类中的成员同名，则可以使用 &lt;OuterClassName&gt;.this.&lt;MemberName&gt; 的形式访问外部类中的成员。</li>
<li>如果匿名内部类位于一个方法中，则匿名内部类只能访问<strong>所属方法的final或等效于final类型的局部变量和形参</strong>。</li>
</ul>
<h2 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h2><p><code>Cloneable</code> 是一个标记接口（marker interface），用于指示一个类可以被克隆（clone）。</p>
<p>要让一个类可以被克隆，需要满足两个条件：</p>
<ol>
<li>类实现 <code>Cloneable</code> 接口。</li>
<li>重写 <code>clone()</code> 方法，实现对象的克隆逻辑。</li>
</ol>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>Object类中的equals方法的默认实现是比较两个对象的引用地址（即内存地址）是否相同。所以如果需要比较两个对象中参数是否一致，就需要覆盖该equals方法。</p>
<p>Java规范要求equals方法具有如下特性：</p>
<ol>
<li>自反性：对于非null的引用x，x.equals(x)应返回true。</li>
<li>对称性：对于非null的引用x、y，x.equals(y)返回true时，y.equals(x)也要返回true。</li>
<li>传递性：对于非null的引用x、y、z，x.equals(y)返回true且y.equals(z)返回true，则x.equals(z)返回true。</li>
<li>一致性：如果x，y引用的对象没有发送变化，则反复调用x.equals(y)应该返回相同的结果。</li>
<li>对于非null的引用x，x.equals(null)应返回false。</li>
</ol>
<h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><p>Java中，散列码（hash code）是由对象导出的一个整型值（可以是负数）。</p>
<p>内容相同的字符串有相同的散列码，这是因为字符串的散列码是由内容导出的。</p>
<p>如果一个类覆盖了equals方法，则该类必须也覆盖hashCode方法。如果两个对象通过 equals 方法比较相等，那么它们的 hashCode 必须相等。比如如果equals方法比较的是参数id，那么hashCode方法就需要对id计算散列值，且不考虑其它的参数。</p>
<p>equals方法和hashCode方法的结果值要一样，是因为在使用哈希表（如HashMap、HashSet等）进行查找和存储时，首先会根据对象的hashCode值确定其在哈希表中的位置（所以hashCode值相等的两个对象不一定相等，hashCode值不相等的两个对象一定不相等）；然后，如果该位置上已经存在其他对象，就再使用equals方法来比较这两个对象是否相等。</p>
<p>如果equals方法和hashCode方法的结果值不一致，相等的对象会被错误地判断为不相等。</p>
<blockquote>
<p>提示：</p>
<p>如果有数组类型的字段，那么可以使用静态的Arrays.hashCode方法计算一个散列码，该散列码有数组元素的散列码组成。</p>
</blockquote>
<h2 id="getClass方法"><a href="#getClass方法" class="headerlink" title="getClass方法"></a>getClass方法</h2><p>Object类提供了getClass方法，返回值是对象的运行时类的Class对象。</p>
<p>调用getClass().getName()可以得到对象的类名。</p>
<h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>反射（reflection）是在程序运行期间获取类的信息（如类名、类的方法、类的属性等信息）并进行操作（如创建对象、调用方法等操作）的技术。</p>
<h2 id="反射机制的核心类"><a href="#反射机制的核心类" class="headerlink" title="反射机制的核心类"></a>反射机制的核心类</h2><p>Java 反射机制的核心类包括“java.lang”包下的Class 类，以及“ java.lang.reflect”包下的Constructor类、Method类、Field类、Modifier类。这些类可以让我们在运行时动态地获取类的相关信息，并进行相应的操作。例如，我们可以使用Constructor类的newInstance()方法创建对象；使用Method 类中的 invoke() 方法来调用一个指定方法；使用 Field 类的 get() 和 set() 方法来读取或修改一个对象的属性值；使用Modifier类的isPublic()方法来判断类的修饰符是否是public。</p>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>虚拟机中每个类型只有唯一的Class对象，因此可以使用&#x3D;&#x3D;运算符比较两个类对象是否相等。</p>
<p>Class类的部分方法用法示例：</p>
<ul>
<li><p>getName方法，由Class类对象获取类的全限定名（fully qualified name）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">Class</span> <span class="hljs-variable">classObject</span> <span class="hljs-operator">=</span> object.getClass();<span class="hljs-comment">//获取Class类对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> classObject.getName();<br></code></pre></td></tr></table></figure>
</li>
<li><p>forName方法，由类的全限定名获取Class类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Class classObject;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java.lang.Integer&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>	classObject = Class.forName(name);<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>由类型获取Class类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">classObject1</span> <span class="hljs-operator">=</span> Integer.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">classObject2</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>.class; <span class="hljs-comment">//int不是类，但是int.Class是类对象</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>getConstructor方法，由Class类对象获取构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">classObject</span> <span class="hljs-operator">=</span> TestGetLClass.class;<br><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> classObject.getConstructor().newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) &#123;<br>	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h3><p>Constructor类的部分方法：</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>public T newInstance(Object … initargs)</td>
<td>根据传递的参数创建类的对象</td>
</tr>
</tbody></table>
<h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><p>Method类的部分方法：</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>public Object invoke(Object obj, Object… args)</td>
<td><code>invoke</code> 方法是 Java 反射 API 中 <code>Method</code> 类的一个重要方法，用于调用方法并执行其逻辑。通过 <code>invoke</code> 方法，可以在运行时动态地调用特定对象上的方法，并传递参数。</td>
</tr>
<tr>
<td>public String getName()</td>
<td>获取方法的名称</td>
</tr>
<tr>
<td>public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</td>
<td>获取指定类型的注解对象，如果存在的话</td>
</tr>
<tr>
<td>public Annotation[] getDeclaredAnnotations()</td>
<td>获取由所有注解对象组成的数组</td>
</tr>
</tbody></table>
<h3 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h3><p>Field类的部分方法：</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>public int getInt(Object obj)</td>
<td>获取对象中指定类型（此处为int类型）的变量值</td>
</tr>
<tr>
<td>public void setInt(Object obj, int i)</td>
<td>设置对象中指定类型（此处为int类型）的变量值</td>
</tr>
<tr>
<td>public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</td>
<td>获取指定注解类型的注解对象</td>
</tr>
</tbody></table>
<p>用法示例（使用反射设置final类型字段）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.Field;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ModifyFinalFieldExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>        <span class="hljs-comment">// 创建一个包含final字段的类的实例</span><br>        <span class="hljs-type">MyClass</span> <span class="hljs-variable">myObj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();<br>        System.out.println(<span class="hljs-string">&quot;Original value of finalField: &quot;</span> + myObj.finalField);<br><br>        <span class="hljs-comment">// 使用反射获取字段对象</span><br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> MyClass.class.getDeclaredField(<span class="hljs-string">&quot;finalField&quot;</span>);<br><br>        <span class="hljs-comment">// 设置字段的可访问性，使其可以被修改</span><br>        field.setAccessible(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 修改final字段的值</span><br>        field.set(myObj, <span class="hljs-string">&quot;ModifiedValue&quot;</span>);<br><br>        <span class="hljs-comment">// 打印修改后的值</span><br>        System.out.println(<span class="hljs-string">&quot;Modified value of finalField: &quot;</span> + myObj.finalField);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">finalField</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OriginalValue&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">Original value of finalField: OriginalValue</span><br><span class="hljs-comment">Modified value of finalField: OriginalValue</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>如果提前设置字段的可访问性为true，即<code>field.setAccessible(true);</code>，可以设置final类型的值，可以看到程序的输出结果显示，成功使用反射重置了final类型变量的值。但是如果不设置字段的可访问性为true，则不能直接通过反射设置final类型的值，此时<code>field.set(myObj, &quot;ModifiedValue&quot;);</code>，会报错，报错信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Exception in thread &quot;main&quot; java.lang.IllegalAccessException: Can not set final java.lang.String field MyClass.finalField to java.lang.String<br>	at java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:76)<br>	at java.base/jdk.internal.reflect.UnsafeFieldAccessorImpl.throwFinalFieldIllegalAccessException(UnsafeFieldAccessorImpl.java:80)<br>	at java.base/jdk.internal.reflect.UnsafeQualifiedObjectFieldAccessorImpl.set(UnsafeQualifiedObjectFieldAccessorImpl.java:79)<br>	at java.base/java.lang.reflect.Field.set(Field.java:799)<br>	at ModifyFinalFieldExample.main(ModifyFinalFieldExample.java:16)<br></code></pre></td></tr></table></figure>

<h3 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h3><p>Modifier类的部分方法：</p>
<table>
<thead>
<tr>
<th>方法签名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>public static boolean isPublic(int mod)</td>
<td>根据传递的参数判断是否包含public</td>
</tr>
</tbody></table>
<h2 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010162647">反射的应用</a></h2><h3 id="JDBC-的数据库的连接"><a href="#JDBC-的数据库的连接" class="headerlink" title="JDBC 的数据库的连接"></a>JDBC 的数据库的连接</h3><p>在JDBC 的操作中，如果要想进行数据库的连接，则必须按照以上的几步完成</p>
<ol>
<li>通过Class.forName()加载数据库的驱动程序 （通过<strong>反射</strong>加载，前提是引入了相关的Jar包）</li>
<li>通过 DriverManager 类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密码</li>
<li>通过Connection 接口接收连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionJDBC</span> &#123;  <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-comment">//驱动程序就是之前在classpath中配置的JDBC的驱动程序的JAR 包中  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DBDRIVER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>;  <br>    <span class="hljs-comment">//连接地址是由各个数据库生产商单独提供的 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DBURL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;  <br>    <span class="hljs-comment">//连接数据库的用户名  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DBUSER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;  <br>    <span class="hljs-comment">//连接数据库的密码  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DBPASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;  <br>      <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//表示数据库的连接对象  </span><br>        Class.forName(DBDRIVER); <span class="hljs-comment">//1、使用CLASS 类加载驱动程序 ,反射机制的体现 </span><br>        con = DriverManager.getConnection(DBURL,DBUSER,DBPASS); <span class="hljs-comment">//2、连接数据库  </span><br>        System.out.println(con);  <br>        con.close(); <span class="hljs-comment">// 3、关闭数据库  </span><br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    //还可以使用try-with-resources语句，来自动关闭数据库连接</span><br><span class="hljs-comment">    try (Connection con = DriverManager.getConnection(DBURL, DBUSER, DBPASS)) &#123;</span><br><span class="hljs-comment">        System.out.println(con);</span><br><span class="hljs-comment">    &#125; catch (Exception e) &#123;</span><br><span class="hljs-comment">        // 处理异常</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Spring-框架的IoC"><a href="#Spring-框架的IoC" class="headerlink" title="Spring 框架的IoC"></a>Spring 框架的IoC</h3><p>在 Java的反射机制在做基础框架的时候非常有用，行内有一句这样的老话：反射机制是Java框架的基石。一般应用层面很少用，不过这种东西，现在很多开源框架基本都已经封装好了，自己基本用不着写。除了JDBC之外，Spring框架的实现也用到很多反射机制。最经典的就是xml的配置模式。</p>
<p>Spring 通过 XML 配置模式装载 Bean 的过程：</p>
<ol>
<li>将程序内所有 XML 或 Properties 配置文件加载入内存中</li>
<li>Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li>
<li>使用<strong>反射</strong>机制，根据这个字符串获得某个类的Class实例</li>
<li>动态配置实例的属性</li>
</ol>
<p>Spring这样做的好处是：</p>
<ul>
<li>不用每一次都要在代码里面去new或者做其他的事情</li>
<li>以后要改的话直接改配置文件，代码维护起来就很方便了</li>
</ul>
<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/proxy.html#_3-1-jdk-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6">代理</a></h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>代理（proxy）是在运行时创建接口的代理类或代理对象的技术。</p>
<p>代理模式分为静态代理和动态代理两种。</p>
<p>静态代理和动态代理最主要的区别是：静态代理在<strong>代码运行之前</strong>，代理类的.class文件就已经存在，而动态代理则与静态代理相反，在代码运行之前不存在代理类的.class文件，<strong>在代码运行时</strong>才动态的生成代理类。</p>
<h2 id="代理和反射的关系"><a href="#代理和反射的关系" class="headerlink" title="代理和反射的关系"></a>代理和反射的关系</h2><p>反射和代理之间的关系是：通过反射可以创建动态代理对象。</p>
<p>Java中的<strong>动态代理是一种利用反射机制在运行时动态地创建代理对象的技术</strong>。通过动态代理，可以在运行时创建代理类和代理对象，并将方法的调用转发给代理对象的调用处理程序（如InvocationHandler的invoke方法）来处理，在方法调用前后执行一些额外的操作，例如记录日志、检查权限、实现缓存等。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="JDK动态代理机制"><a href="#JDK动态代理机制" class="headerlink" title="JDK动态代理机制"></a>JDK动态代理机制</h3><h4 id="核心类"><a href="#核心类" class="headerlink" title="核心类"></a>核心类</h4><p>Java代理机制的核心类包括<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口。<code>Proxy</code>类用于创建代理类和代理对象，而<code>InvocationHandler</code>接口定义了调用代理对象的处理程序。</p>
<p>创建代理对象的方法是调用Proxy类中的newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)方法，该方法的三个参数分别是类加载器（用于加载代理对象）、一组被代理类实现的接口、实现类InvocationHandler接口的对象（需要自定义InvocationHandler接口的实现类来自定义处理逻辑）。</p>
<p>在代理对象调用方法时，实际上是调用了InvocationHandler的invoke方法。</p>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li>定义一个接口及其实现类（被代理的类）；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<h3 id="CGLIB动态代理机制"><a href="#CGLIB动态代理机制" class="headerlink" title="CGLIB动态代理机制"></a>CGLIB动态代理机制</h3><p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong></p>
<p><strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a>(<em>Code Generation Library</em>)是一个基于ASM（Abstract Syntax Tree Manipulation，抽象语法树操作，是一个Java字节码操作框架，提供了一组API，用于读取、修改和生成Java字节码）的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。</p>
<p>CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a target="_blank" rel="noopener" href="https://github.com/cglib/cglib">CGLIB</a>， 例如 Spring 中的 AOP 模块（如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理）。</p>
<h4 id="核心类-1"><a href="#核心类-1" class="headerlink" title="核心类"></a>核心类</h4><p>CGLIB代理机制的核心类包括<code>Enhancer</code>类和<code>MethodInterceptor</code>接口。<code>Enhancer</code>类用于创建代理类和代理对象，而<code>MethodInterceptor</code>接口定义了调用代理对象的处理程序。</p>
<p>当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。需要自定义 <code>MethodInterceptor</code> 接口的实现类并实现 <code>intercept</code> 方法，<code>intercept</code>是用于拦截增强被代理类的方法。</p>
<h4 id="使用步骤-1"><a href="#使用步骤-1" class="headerlink" title="使用步骤"></a>使用步骤</h4><ol>
<li>添加CGLIB的依赖；</li>
<li>定义一个类（被代理的类）；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h2 id="代理的应用"><a href="#代理的应用" class="headerlink" title="代理的应用"></a>代理的应用</h2><ol>
<li>RPC框架：如Dubbo、gRPC等，通常<strong>使用动态代理来实现客户端的远程方法调用</strong>。客户端通过动态代理对象来调用远程方法，不需要直接关注底层的网络通信细节。还可以通过动态代理在方法调用的前后添加一些额外的逻辑，比如实现负载均衡、服务治理、日志记录等。</li>
<li>AOP（面向切面编程）：如Spring的AOP特性，就是利用代理机制实现对方法的增强。通过在程序运行期间动态地将额外的代码（称为切面）织入到现有的代码中，实现对系统的横切关注点（cross-cutting concerns）的管理。</li>
</ol>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="定位和特性"><a href="#定位和特性" class="headerlink" title="定位和特性"></a>定位和特性</h2><p>接口（interface）用来描述类应该做什么（一组需求），而不指定应该怎么做（静态方法除外，从Java8开始允许在接口中增加静态方法包括方法的实现）。接口中除了可以声明方法，还可以定义静态常量。</p>
<p>接口中的所有方法都默认是public方法，因此在接口中声明方法时，可以不提供关键字public，不过在实现接口时必须把方法声明为public；接口中的所有常量的类型默认是public static final类型，可以不提供关键字public static final。</p>
<p>每个类只能有一个父类，但可以有多个接口。</p>
<blockquote>
<p>Java和C++的不同：</p>
<p>Java只允许有一个父类，C++可以有多个父类。</p>
<p>Java和C++都有抽象类的概念，但是C++中没有接口的概念。</p>
</blockquote>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>可以为接口中的方法提供一个默认实现，方法是在方法上添加default修饰符。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是一种用来创建代码块的简洁的方法。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数列表) -&gt; 表达式<br></code></pre></td></tr></table></figure>

<p>即使Lambda表达式没有参数，仍然要带有括号。</p>
<p>Lambda表达式的用法示例：</p>
<ol>
<li>无参数的Lambda表达式： () -&gt; System.out.println(“Hello, Lambda!”);</li>
<li>单个参数的Lambda表达式： (x) -&gt; System.out.println(“The value is: “ + x);</li>
<li>多个参数的Lambda表达式： (x, y) -&gt; { int sum &#x3D; x + y; System.out.println(“The sum is: “ + sum); };</li>
<li>Lambda表达式作为方法的参数： Arrays.asList(1, 2, 3, 4, 5).forEach(n -&gt; System.out.println(n));</li>
</ol>
<p>Lambda表达式中的变量必须是final或等效于final的（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">final or effectively final</a>）。所谓“等效于 final”，指的是变量虽然没有被声明为 final，但它的值在整个 Lambda 表达式中没有被重新赋值。</p>
<h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><p>函数式接口是一种特殊的接口，接口内部除静态方法、默认方法、静态常量外只有一个抽象方法。</p>
<p>只有函数式接口才能使用Lambda表达式。</p>
<p>在Java中，使用@FunctionalInterface注解来标记一个接口为函数式接口，这样编译器就可以检查这个接口是否符合函数式接口的要求（即只有一个抽象方法）。</p>
<h3 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h3><p>Java方法引用是一种Lambda表达式的简化写法，它可以直接引用已有Java方法来作为Lambda表达式的实现。</p>
<p>使用方法是，通过::操作符将一个已有方法的引用赋值给一个函数式接口变量，从而创建一个方法引用。</p>
<p> Java 中 4 种不同方法的引用：</p>
<ol>
<li><p><strong>构造器引用：</strong>它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> Car.create( Car::<span class="hljs-keyword">new</span> ); <br><span class="hljs-keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>静态方法引用：</strong>它的语法是Class::static_method，实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cars.forEach( Car::collide );<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>特定类的任意对象的方法引用：</strong>它的语法是Class::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cars.forEach( Car::repair );<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>特定对象的方法引用：</strong>它的语法是instance::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Car</span> <span class="hljs-variable">police</span> <span class="hljs-operator">=</span> Car.create( Car::<span class="hljs-keyword">new</span> ); <br>cars.forEach( police::follow );<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-comment">//Supplier是jdk1.8的接口，这里和lamda一起使用了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Supplier&lt;Car&gt; supplier)</span> &#123;<br>        <span class="hljs-keyword">return</span> supplier.get();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">collide</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Car car)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Collided &quot;</span> + car.toString());<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Car another)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Following the &quot;</span> + another.toString());<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">repair</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Repaired &quot;</span> + <span class="hljs-built_in">this</span>.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包（Closure）指的是一个函数（或者方法），可以引用到自己作用域以外的变量。</p>
<p>Java中的Lambda表达式是闭包，Lambda表达式可以引用其作用域之外的变量，不过，Lambda表达式中引用的作用域外的变量不能被改变。</p>
<h1 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-03.html#%E5%BC%82%E5%B8%B8">异常和错误</a></h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>Java中所有的异常（Exception）类型和错误（Error）类型都是 Throwable 类的子类，继承关系见下图。</p>
<ul>
<li><p><code>Exception</code> ：<strong>程序可以处理</strong>的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p>
<ul>
<li><p>Checked Exception：受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过<strong>编译</strong>。</p>
<p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p>
</li>
<li><p>Unchecked Exception：即不受检查异常 ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html">RuntimeException</a>及其子类都统称为非受检查异常，常见的有<code>NullPointerException</code>(空指针错误)、<code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)、<code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）、<code>ArrayIndexOutOfBoundsException</code>（数组越界错误）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）、<code>SecurityException</code> （安全错误比如权限不够）、<code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)。</p>
</li>
</ul>
</li>
<li><p><code>Error</code>：<strong>程序无法处理</strong>的错误 ，不能通过 <code>catch</code> 来进行捕获。如果发生，Java 虚拟机（JVM）会选择终止进程。</p>
</li>
</ul>
<p><img src="/2023/05/02/Java%E5%9F%BA%E7%A1%80/.././Java%E5%9F%BA%E7%A1%80/types-of-exceptions-in-java.png" alt="Java异常类层次结构图概览https://oss.javaguide.cn/github/javaguide/java/basis/types-of-exceptions-in-java.png"></p>
<p> <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/Throwable.html">Throwable类常用方法</a>：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>printStackTrace</td>
<td>将Throwable的路径信息打印到标准错误流</td>
</tr>
<tr>
<td>toString</td>
<td>返回Throwable的类名和message</td>
</tr>
<tr>
<td>getMessage</td>
<td>返回Throwable的message（message是调用Exception时传入的参数）</td>
</tr>
<tr>
<td>getLocalizedMessage</td>
<td>返回Throwable的本地化message</td>
</tr>
</tbody></table>
<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><p>finally块里代码是<strong>在return前执行的</strong>。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，就会执行<code>finally</code> 语句块。</p>
<p>当 try 语句块和 finally 语句块中都有 return 语句时，try 语句块中的 return 语句会被忽略，因为在执行完finally 语句块后已经return，不会再回到try语句块。</p>
<p>在某些情况下，finally 中的代码不会被执行。比如如果finally之前虚拟机被终止运行，则finally中的代码就不会被执行。</p>
<h2 id="try-with-resource"><a href="#try-with-resource" class="headerlink" title="try-with-resource"></a>try-with-resource</h2><p>在 Java 中，可以使用 try-with-resources （Java7引入）语句来自动关闭实现了 <code>AutoCloseable</code> 或（两个中的任意一个即可） <code>Closeable</code> 接口（使用的前提条件）的资源。</p>
<p>关闭资源在try-with-resource中的执行顺序：在 <code>try-with-resources</code> 语句中，在 <code>try</code> 块的代码执行完毕后，会自动关闭在 <code>try</code> 声明中的资源。任何 catch 或 finally 块都会在声明的资源关闭后运行。</p>
<blockquote>
<p>《Effective Java》中明确指出：</p>
<p>面对必须要关闭的资源，我们总是应该优先使用 <code>try-with-resources</code> 而不是<code>try-finally</code>。随之产生的代码更简短，更清晰，产生的异常对我们也更有用。<code>try-with-resources</code>语句让我们更容易编写必须要关闭的资源的代码，若采用<code>try-finally</code>则几乎做不到这点。</p>
</blockquote>
<p>部分支持try-with-resource的类：</p>
<ul>
<li><p><strong>NIO 相关类</strong></p>
<ul>
<li><strong>Channel 相关类</strong><ul>
<li><code>AbstractInterruptibleChannel</code>: NIO 抽象通道的基类，提供了可中断的通道操作。</li>
<li><code>AbstractSelectableChannel</code>: NIO 抽象可选择通道的基类，提供了选择器注册和取消注册的功能。</li>
<li><code>AbstractSelector</code>: NIO 抽象选择器的基类，提供了选择通道的功能。</li>
<li><code>AsynchronousFileChannel</code>: 异步文件通道，提供了异步读写文件的能力。</li>
<li><code>AsynchronousServerSocketChannel</code>: 异步服务器套接字通道，用于异步处理客户端连接请求。</li>
<li><code>AsynchronousSocketChannel</code>: 异步套接字通道，用于异步进行套接字通信。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>IO 类</strong></p>
<ul>
<li><p><strong>字节流</strong></p>
<ul>
<li><code>FileInputStream</code>: 文件输入流，用于从文件中读取字节数据。</li>
<li><code>FileOutputStream</code>: 文件输出流，用于向文件中写入字节数据。</li>
<li><code>BufferedInputStream</code>: 带缓冲的输入流，提供了高效的读取功能。</li>
<li><code>BufferedOutputStream</code>: 带缓冲的输出流，提供了高效的写入功能。</li>
<li><code>ByteArrayInputStream</code>: 字节数组输入流，用于从字节数组中读取数据。</li>
<li><code>ByteArrayOutputStream</code>: 字节数组输出流，用于向字节数组中写入数据。</li>
<li><code>DataInputStream</code>: 数据输入流，用于读取基本数据类型。</li>
<li><code>DataOutputStream</code>: 数据输出流，用于写入基本数据类型。</li>
<li><code>ObjectInputStream</code>: 对象输入流，用于读取对象数据。</li>
<li><code>ObjectOutputStream</code>: 对象输出流，用于写入对象数据。</li>
<li><code>PipedInputStream</code>: 管道输入流，用于在多个线程之间进行字节数据的通信。</li>
<li><code>PipedOutputStream</code>: 管道输出流，用于在多个线程之间进行字节数据的通信。</li>
<li><code>SequenceInputStream</code>: 序列输入流，用于将多个输入流串联起来顺序读取数据。</li>
</ul>
</li>
<li><p><strong>字符流</strong></p>
<ul>
<li><code>FileReader</code>: 文件字符输入流，用于从文件中读取字符数据。</li>
<li><code>FileWriter</code>: 文件字符输出流，用于向文件中写入字符数据。</li>
<li><code>BufferedReader</code>: 带缓冲的字符输入流，提供了逐行读取文本数据的功能。</li>
<li><code>BufferedWriter</code>: 带缓冲的字符输出流，提供了逐行写入文本数据的功能。</li>
<li><code>CharArrayReader</code>: 字符数组输入流，用于从字符数组中读取数据。</li>
<li><code>CharArrayWriter</code>: 字符数组输出流，用于向字符数组中写入数据。</li>
<li><code>InputStreamReader</code>: 字节流到字符流的桥接器，用于将字节流转换为字符流。</li>
<li><code>OutputStreamWriter</code>: 字符流到字节流的桥接器，用于将字符流转换为字节流。</li>
<li><code>StringReader</code>: 字符串输入流，</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>Java泛型（Generics）是 JDK 5 中引入的一个新特性。</p>
<p>泛型一般有三种使用方式：<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p>
<blockquote>
<p>Java和C++的不同：</p>
<p>Java中的泛型没有C++中的特殊template关键字。</p>
</blockquote>
<h2 id="泛型类型参数"><a href="#泛型类型参数" class="headerlink" title="泛型类型参数"></a>泛型类型参数</h2><p>在Java中，泛型类型参数常用的命名约定如下：</p>
<ul>
<li><code>T</code>：表示泛型类型的参数。它是最常用的泛型类型参数名称，通常表示任意类型，例如<code>public class Box&lt;T&gt;</code>。</li>
<li><code>E</code>：表示集合中的元素类型的参数。它常用于表示集合类中的元素类型，例如<code>List&lt;E&gt;</code>。</li>
<li><code>K</code>：表示映射中的键类型的参数。它通常用于表示键-值对中的键类型，例如<code>Map&lt;K, V&gt;</code>。</li>
<li><code>V</code>：表示映射中的值类型的参数。它通常用于表示键-值对中的值类型，例如<code>Map&lt;K, V&gt;</code>。</li>
</ul>
<p><code>T</code>、<code>E</code>、<code>K</code>和<code>V</code>只是通用的命名约定，并没有强制规定使用这些字母。在实际使用中，可以根据上下文和需求来选择更有意义的类型参数名称。</p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符?"></a>通配符?</h2><p>通配符（wildcard type）?代表某种未知类型。</p>
<p>通配符?的使用方法包括：</p>
<ol>
<li>?：无界通配符<ul>
<li>表示类型参数可以是任何类型，相当于未知类型。</li>
</ul>
</li>
<li><? extends Employee>：上界通配符
- 表示类型参数是Employee或Employee的子类，即类型参数的上界是Employee。
- 使用这种通配符时，只能从泛型集合中**获取数据**（获取的数据是Employee类型或Employee类型的子类类型的对象，一定可以被Employee类型的对象接收，如果需要具体的子类类型，可以通过强制类型转换来实现），不能向泛型集合中添加数据，因为无法确定是Employee还是Employee的某个子类。</li>
<li><? super People>：下界通配符
- 表示类型参数是People或People的父类，即类型参数的下界是People。
- 使用这种通配符时，只能向泛型集合中**添加数据**（添加的数据是People类型或People类型的子类类型的对象，一定能被People类型的对象接收），不能从泛型集合中获取数据，因为无法确定是People还是People的某个父类。</li>
</ol>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html#%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93">集合</a></h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p>
<p><img src="/2023/05/02/Java%E5%9F%BA%E7%A1%80/.././Java%E5%9F%BA%E7%A1%80/java-collection-hierarchy-1691553026437-6.png" alt="Java 集合框架https://oss.javaguide.cn/github/javaguide/java/collection/java-collection-hierarchy.png"></p>
<p>注：图中只列举了主要的继承派生关系，并没有列举所有关系。比方省略了<code>AbstractList</code>, <code>NavigableSet</code>等抽象类以及其他的一些辅助类</p>
<h2 id="集合类型及分类"><a href="#集合类型及分类" class="headerlink" title="集合类型及分类"></a>集合类型及分类</h2><p><strong>Map</strong>（Key是唯一的）</p>
<ol>
<li><p><code>HashMap</code>：JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。<code>HashMap</code> 默认的初始化大小为 16，之后每次扩充，容量变为原来的 2 倍。</p>
<p>HashMap扩容为什么是2倍：</p>
<ol>
<li>做除余的时候2的倍数可以直接使用<code>&amp;</code>进行快速计算，如<code>19%16</code>可以写成<code>19&amp;(16-1)</code>，位运算更高效</li>
<li>扩容的时候只移动大约一半的数据，并且不会造成扩容之后碰撞依然严重的情况</li>
</ol>
</li>
<li><p><code>LinkedHashMap</code>：继承了 <code>HashMap</code>，底层也是基于数组和红黑树的。在HashMap结构的基础上，增加了一条双向链表，可以保持键值对的插入顺序，并且支持访问顺序（访问元素后移动元素的位置）相关的操作。详细可以查看：<a target="_blank" rel="noopener" href="https://www.imooc.com/article/22931">《LinkedHashMap 源码详细分析（JDK1.8）》</a></p>
</li>
<li><p><code>TreeMap</code>：红黑树（自平衡的排序二叉树），实现了<code>NavigableMap</code>接口（对集合内元素的搜索）和<code>SortedMap</code> 接口（对集合中的元素根据键排序，默认是按 key 的升序排序，可以自定义排序的比较器）。<strong>相比于<code>HashMap</code>来说 <code>TreeMap</code> 主要多了对集合中的元素根据键排序的能力。</strong></p>
</li>
</ol>
<p><strong>Set</strong>（元素唯一）</p>
<ol>
<li><p><code>HashSet</code>：底层使用 <code>HashMap</code> 对象保存元素，与 <code>HashMap</code> 的区别是 <code>HashSet</code>不能存储键值对。HashSet的两个特性是无序性和不可重复性：</p>
<ol>
<li><p>无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。无序性不等于随机性。</p>
</li>
<li><p>不可重复性是指元素不重复。</p>
<blockquote>
<p>HashSet判断元素是否重复的方法（引自《Head first java》第二版）：</p>
<p>当你把对象加入<code>HashSet</code>时，<code>HashSet</code> 会先计算对象的<code>hashcode</code>值来判断对象加入的位置，同时也会与其他加入的对象的 <code>hashcode</code> 值作比较，如果没有相符的 <code>hashcode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashcode</code> 值的对象，这时会调用<code>equals()</code>方法来检查 <code>hashcode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让加入操作成功。</p>
</blockquote>
</li>
</ol>
</li>
<li><p><code>LinkedHashSet</code>：继承了<code>HashSet</code>，在<code>HashSet</code>结构的基础上，增加了一条双向链表，可以保持键值对的插入顺序。</p>
</li>
<li><p><code>TreeSet</code>： 底层使用<code>TreeMap</code>对象保存元素，与<code>TreeMap</code>的区别是<code>TreeSet</code>不能存储键值对。</p>
</li>
</ol>
<p><strong>List</strong></p>
<ul>
<li><code>ArrayList</code>：底层是基于数组实现的。初始大小是10，后期如果扩容，则新的容量大小是<code>prefLength = oldLength + Math.max(minGrowth, oldCapacity &gt;&gt; 1);</code>即如果增加的元素数量小于0.5oldCapacity则新的容量大小是1.5倍的oldCapacity。</li>
<li><code>LinkedList</code>：底层是基于双向链表实现的（JDK1.6 之前为循环链表，JDK1.7 取消了循环）。</li>
</ul>
<p><strong>Queue</strong></p>
<ul>
<li><code>PriorityQueue</code>：底层是使用<code>Object[]</code> 数组实现的二叉堆。</li>
<li><code>ArrayQueue</code>：底层是<code>Object[]</code> 数组，并且有两个分别指向队列头部和尾部的指针。</li>
<li><code>LinkedList</code>：既属于Queue又属于List。</li>
</ul>
<h2 id="Set的两大特性"><a href="#Set的两大特性" class="headerlink" title="Set的两大特性"></a>Set的两大特性</h2><ul>
<li><p>无序性</p>
<p>无序性是指存储的数据在底层数组中并非按照数组索引的顺序添加 ，而是根据数据的哈希值决定的。无序性不等于随机性。</p>
</li>
<li><p>不可重复性</p>
</li>
</ul>
<h2 id="是否支持存储null"><a href="#是否支持存储null" class="headerlink" title="是否支持存储null"></a>是否支持存储null</h2><table>
<thead>
<tr>
<th>类别</th>
<th>类型</th>
<th>是否支持存储null</th>
<th>补充</th>
</tr>
</thead>
<tbody><tr>
<td>Map</td>
<td>HashMap</td>
<td>是</td>
<td>null作为key只能有一个，null 作为value可以有多个</td>
</tr>
<tr>
<td></td>
<td>LinkedHashMap</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td></td>
<td>TreeMap</td>
<td><strong>否</strong></td>
<td>key不能为空，value 可以为空</td>
</tr>
<tr>
<td>Set</td>
<td>HashSet</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td></td>
<td>LinkedHashSet</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td></td>
<td>TreeSet</td>
<td><strong>否</strong></td>
<td></td>
</tr>
<tr>
<td>List</td>
<td>ArrayList</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>List&amp;Queue</td>
<td>LinkedList</td>
<td>是</td>
<td></td>
</tr>
<tr>
<td>Queue</td>
<td>PriorityQueue</td>
<td><strong>否</strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ArrayQueue</td>
<td><strong>否</strong></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Comparable和Comparator"><a href="#Comparable和Comparator" class="headerlink" title="Comparable和Comparator"></a>Comparable和Comparator</h2><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口。</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>抽象方法签名</th>
<th>包名</th>
</tr>
</thead>
<tbody><tr>
<td>Comparable</td>
<td>public int compareTo(T o);</td>
<td>java.lang</td>
</tr>
<tr>
<td>Comparator</td>
<td>int compare(T o1, T o2);</td>
<td>java.util</td>
</tr>
</tbody></table>
<p>Comparable和Comparator一个基本的区别特征是，使用 Comparable只能定义一种比较。而使用Comparator可以根据需要为给定类型定义多种比较逻辑。</p>
<p><strong>Comparable</strong></p>
<p>Comparable顾名思义，表示实现了Comparable接口的类型的对象是可比较的。</p>
<p>类对Comparable接口的compareTo方法的实现，定义了同一个类的不同对象之间进行比较的策略。这被称为类的“自然排序”。</p>
<p>如果类实现了 Comparable 接口，那么在使用 Collections.sort() 或 Arrays.sort() 方法时，会自动根据 CompareTo 方法定义的自然顺序，对该对象的 List 或 Array 进行排序。</p>
<p><strong>Comparator</strong></p>
<p>Comparator接口和要排序的对象类型之间没有实现（implements）关系。Comparator接口的compare方法的实现，定义了比较逻辑，如果返回正数，表示第一个对象大于第二个对象，如果返回负数，表示第一个对象小于第二个对象，如果返回0，说明第一个对象等于第二个对象。</p>
<h1 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h1><p>在Java中，深拷贝（Deep Copy）和浅拷贝（Shallow Copy）都涉及到对象复制的概念，但它们处理对象内部数据的方式有所不同。</p>
<p>深拷贝和浅拷贝的概念和区别：</p>
<p><strong>浅拷贝（Shallow Copy）</strong>：<br>浅拷贝是一种对象复制方式，其中只复制了对象本身以及其内部的基本数据类型（如int、float等）和引用类型（如数组、对象等）的引用地址，而不是复制引用类型对象的内容。这意味着浅拷贝后的对象和原始对象会共享相同的引用类型对象。</p>
<p>在Java中，可以使用<code>Object.clone()</code>方法或一些库来实现浅拷贝。例如，通过实现<code>Cloneable</code>接口并重写<code>clone()</code>方法，你可以实现一个浅拷贝。然而，需要注意的是，这种方式只会复制对象的字段值，而不会递归复制引用类型字段指向的对象。</p>
<p><strong>深拷贝（Deep Copy）</strong>：<br>深拷贝是一种对象复制方式，其中除了复制对象本身，还会递归复制引用类型对象的内容，包括引用类型对象内部的引用类型对象，以确保新创建的对象和原始对象的所有内容都是独立的，不共享引用。</p>
<p>在Java中，实现深拷贝需要自行编写代码来递归复制对象的每个字段，包括引用类型字段。这可能会涉及到对象图的遍历和递归复制。</p>
<p>需要注意的是，实现深拷贝可能会比较复杂，特别是当对象的层次结构很深或者涉及循环引用时。因此，一些类库或框架可能提供了更方便的深拷贝实现，或者你也可以使用序列化和反序列化来实现深拷贝。</p>
<p>总结：</p>
<ul>
<li>浅拷贝只复制对象本身和引用类型的引用地址，多个对象可能会共享同一个引用对象。</li>
<li>深拷贝会递归复制引用类型对象的内容，确保复制后的对象和原始对象完全独立。</li>
</ul>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/69136675">逃逸分析</a></h1><p>逃逸分析（Escape Analysis）简单来讲就是，Java Hotspot 虚拟机可以分析新创建对象的使用范围，并决定是否在 Java 堆上分配内存的一项技术。</p>
<p>逃逸分析的 JVM 参数如下：</p>
<ul>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>关闭逃逸分析：-XX:-DoEscapeAnalysis</li>
<li>显示分析结果：-XX:+PrintEscapeAnalysis</li>
</ul>
<h2 id="对象逃逸状态"><a href="#对象逃逸状态" class="headerlink" title="对象逃逸状态"></a>对象逃逸状态</h2><p>对象逃逸状态描述了一个对象是否在其创建方法或作用域之外被引用，从而决定了对象的生命周期和内存分配方式。根据对象是否逃逸，可以将对象的状态分为以下几种：</p>
<ol>
<li><strong>无逃逸（No Escape）：</strong> 当一个对象只在创建它的方法或作用域内被引用，并且不会被传递给其他方法或线程，我们称之为无逃逸。逃逸分析优化就是针对无逃逸的对象状态进行的优化。</li>
<li><strong>方法逃逸（Method Escape）：</strong> 当一个对象在创建它的方法内部被创建，但随后被返回给调用方法的代码，即对象在创建方法内部逃逸到了调用方法中，我们称之为方法逃逸。</li>
<li><strong>线程逃逸（Thread Escape）：</strong> 当一个对象在创建它的线程内部被创建，但随后被传递给其他线程，即对象在创建线程内部逃逸到了其他线程中，我们称之为线程逃逸。</li>
<li><strong>全局逃逸（Global Escape）：</strong> 当一个对象在创建它的方法内部被创建，但随后被全局引用（如保存在全局变量、静态字段等），即对象在创建方法内部逃逸到了全局范围中，我们称之为全局逃逸。</li>
<li><strong>返回值逃逸（Return Escape）：</strong> 当一个对象在创建它的方法内部被创建，然后被作为返回值传递给调用方法的代码，即对象在创建方法内部逃逸到了调用方法中，但不逃逸到其他方法或线程，我们称之为返回值逃逸。</li>
</ol>
<p>逃逸分析的目的是识别出对象的逃逸状态，以便编译器可以进行优化。例如，对于无逃逸的对象，可以选择在栈上分配或进行标量替换，而不必在堆上分配内存。对于方法逃逸的对象，可能需要在堆上分配，但编译器可以根据逃逸的程度决定是否进行其他优化。逃逸分析在多线程环境中尤其重要，因为它可以帮助开发人员识别潜在的数据竞争和内存问题。</p>
<h2 id="逃逸分析优化"><a href="#逃逸分析优化" class="headerlink" title="逃逸分析优化"></a>逃逸分析优化</h2><p>针对上面第三点，当一个对象<strong>没有逃逸</strong>时，可以得到以下几个虚拟机的优化。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>我们知道线程同步锁是非常牺牲性能的，<strong>当编译器确定当前对象只有当前线程使用，那么就会移除该对象的同步锁</strong>。</p>
<p>例如，StringBuffer 和 Vector 都是用 synchronized 修饰线程安全的，但大部分情况下，它们都只是在当前线程中用到，这样编译器就会优化移除掉这些锁操作。</p>
<p>锁消除的 JVM 参数如下：</p>
<ul>
<li>开启锁消除：-XX:+EliminateLocks</li>
<li>关闭锁消除：-XX:-EliminateLocks</li>
</ul>
<p>锁消除在 JDK8 中都是默认开启的，并且锁消除都要建立在逃逸分析的基础上。</p>
<h3 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h3><p>如果编译器能够确定一个对象在方法内部创建，并且不会被方法之外的其他代码引用，那么它可以选择<strong>在方法的栈帧上分配这个对象，而不是在堆上分配</strong>。栈上分配可以减少堆内存的压力，同时也可以提高访问速度，因为栈上分配的对象通常在内存上更加连续。</p>
<p><a target="_blank" rel="noopener" href="https://www.51cto.com/article/685667.html">衍生出的面试题</a>：</p>
<p><strong>Java中的对象一定是在堆上分配的吗?</strong></p>
<p>面试官这样问，如果大家不了解逃逸分析的话，那肯定就有些小伙伴心里会想：我从一开始学习Java时，就知道了：Java中的对象是在堆上创建的，对象的引用是存储到栈中的，那Java中的对象是在堆上分配的啊!难道不是吗?</p>
<p>如果你这样回答，就会被直接Pass掉。</p>
<p>今天，我们介绍完什么是逃逸分析后，相信各位小伙伴就知道如何去完美的回答这道面试题了吧。</p>
<p><strong>面试题解答思路</strong></p>
<p>总体思路上，你可以这样回答：Java中的对象不一定是在堆上分配的，因为JVM通过逃逸分析，能够分析出一个新对象的使用范围，并以此确定是否要将这个对象分配到堆上。 </p>
<h3 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h3><p><strong>首先要明白标量和聚合量，基础类型和对象的引用可以理解为标量，它们不能被进一步分解</strong>。而能被进一步分解的量就是聚合量，比如：对象。</p>
<p>对象是聚合量，它又可以被进一步分解成标量，将其成员变量分解为分散的变量，这就叫做标量替换。</p>
<p>这样，<strong>如果一个对象没有发生逃逸，那压根就不用创建它，只会在栈或者寄存器上创建它用到的成员标量</strong>，节省了内存空间，也提升了应用程序性能。</p>
<p>标量替换的 JVM 参数如下：</p>
<ul>
<li>开启标量替换：-XX:+EliminateAllocations</li>
<li>关闭标量替换：-XX:-EliminateAllocations</li>
<li>显示标量替换详情：-XX:+PrintEliminateAllocations</li>
</ul>
<p>标量替换同样在 JDK8 中都是默认开启的，并且都要建立在逃逸分析的基础上。</p>
<h1 id="Java8新特性（部分）"><a href="#Java8新特性（部分）" class="headerlink" title="Java8新特性（部分）"></a>Java8新特性（部分）</h1><ol>
<li><strong>默认方法（Default Methods）</strong>：接口中可以定义默认方法，这些方法具有默认的实现，可以在接口中直接使用，而不需要实现类必须重写这些方法。这样的设计使得在接口的演进过程中可以向现有的接口添加新的方法，而不会破坏现有的实现。</li>
<li><strong>Lambda 表达式</strong>：Lambda 表达式是一种简洁的语法形式，用于表示匿名函数。它可以用来简化代码，尤其是在使用函数式接口（只有一个抽象方法的接口）时。Lambda 表达式可以使代码更加紧凑和易读。</li>
<li><strong>函数式接口</strong>：Java 8 引入了 <code>java.util.function</code> 包，提供了一组函数式接口，用于支持函数式编程。例如，<code>Predicate</code>、<code>Function</code>、<code>Consumer</code> 等接口可以在 Lambda 表达式中使用，使得函数式编程更加便捷。</li>
<li><strong>方法引用</strong>：方法引用是一种更简洁的 Lambda 表达式的写法，它直接引用现有的方法作为 Lambda 表达式的实现。方法引用可以提高代码的可读性，并且可以重用现有的方法逻辑。</li>
<li><strong>Stream API</strong>：Stream API 提供了一种流式操作集合数据的方式。它可以用于对集合进行过滤、映射、排序、归约等操作，提供了函数式、流畅的操作方式，可以编写简洁、高效的代码。</li>
<li><strong>新的日期&#x2F;时间 API</strong>：Java 8 引入了新的日期&#x2F;时间 API（<code>java.time</code> 包），提供了更加强大和易用的日期和时间处理功能。新的 API 解决了旧的 <code>Date</code> 和 <code>Calendar</code> 类的许多问题，并提供了更多的操作和格式化选项。</li>
</ol>
<h1 id="Guava"><a href="#Guava" class="headerlink" title="Guava"></a>Guava</h1><p>Guava（Google Guava）是Google开发的一个开源Java库，提供了许多实用的工具类和函数，用于简化Java开发过程中的常见任务和操作。</p>
<p>Guava提供了多个模块，包括集合（Collections）、缓存（Caches）、并发（Concurrency）、字符串处理（Strings）、IO操作（IO）、函数式编程（Functional Programming）、原生类型支持（Primitives）、事件总线（EventBus）等。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>凯·S. 霍斯特曼. Java核心技术:原书第12版. 卷一, 开发基础. –北京: 机械工业出版社. 2022.5.</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</a></li>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/java-collection-questions-01.html">https://javaguide.cn/java/collection/java-collection-questions-01.html</a></li>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html</a> </li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/SnailClimb/JavaGuide/blob/main/docs/java/basis/serialization.md">https://gitee.com/SnailClimb/JavaGuide/blob/main/docs/java/basis/serialization.md</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/SnailClimb/JavaGuide/blob/main/docs/java/io/nio-basis.md">https://gitee.com/SnailClimb/JavaGuide/blob/main/docs/java/io/nio-basis.md</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io">Song Baoru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io/2023/05/02/Java%E5%9F%BA%E7%A1%80/">https://songbaoru.github.io/2023/05/02/Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/Java%E5%9F%BA%E7%A1%80.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/05/03/JVM%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" title="JVM底层原理"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/JVM%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">JVM底层原理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Song Baoru</div><div class="author-info__description">锲而不舍，金石可镂</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SongBaoru"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E4%B8%ADScanner%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8AnextLine%E5%92%8CnextInt%E7%AD%89%E6%B7%B7%E7%94%A8%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">1.</span> <span class="toc-text">JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanner%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">Scanner常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.</span> <span class="toc-text">IO流分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%B5%81%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">2.2.</span> <span class="toc-text">输入流和输出流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">2.3.</span> <span class="toc-text">字节流和字符流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">2.4.</span> <span class="toc-text">节点流和处理流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E6%8A%80%E6%9C%AF"><span class="toc-number">2.5.</span> <span class="toc-text">内存映射文件技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NIO%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.6.</span> <span class="toc-text">NIO的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.7.</span> <span class="toc-text">IO典型应用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%A4%A7%E6%96%87%E4%BB%B6"><span class="toc-number">2.7.1.</span> <span class="toc-text">打开大文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BIO%E3%80%81NIO%E3%80%81AIO"><span class="toc-number">2.8.</span> <span class="toc-text">BIO、NIO、AIO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">序列化和反序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.</span> <span class="toc-text">序列化的应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E4%B8%AD%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">JDK中的序列化方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%B7%A5%E5%85%B7"><span class="toc-number">3.4.</span> <span class="toc-text">常用的序列化工具</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.1.</span> <span class="toc-text">8种基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">4.1.1.</span> <span class="toc-text">包装器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">4.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0"><span class="toc-number">4.3.</span> <span class="toc-text">大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.1.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.2.</span> <span class="toc-text">位移运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">5.3.</span> <span class="toc-text">switch语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.4.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0Math"><span class="toc-number">5.5.</span> <span class="toc-text">数学函数Math</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.</span> <span class="toc-text">面向对象编程的概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">方法参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">7.2.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">7.3.</span> <span class="toc-text">覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">7.4.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E7%B1%BB%E5%92%8Cfinal%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.1.</span> <span class="toc-text">final类和final方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protected%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">7.4.2.</span> <span class="toc-text">protected访问修饰符</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">对象与类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">8.1.</span> <span class="toc-text">类之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">8.3.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.4.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.4.1.</span> <span class="toc-text">非静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.4.2.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.4.3.</span> <span class="toc-text">方法局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">8.4.4.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cloneable"><span class="toc-number">8.5.</span> <span class="toc-text">Cloneable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">equals方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashCode%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">hashCode方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getClass%E6%96%B9%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">getClass方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">10.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">10.2.</span> <span class="toc-text">反射机制的核心类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E7%B1%BB"><span class="toc-number">10.2.1.</span> <span class="toc-text">Class类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructor"><span class="toc-number">10.2.2.</span> <span class="toc-text">Constructor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Method"><span class="toc-number">10.2.3.</span> <span class="toc-text">Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Field"><span class="toc-number">10.2.4.</span> <span class="toc-text">Field</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modifier"><span class="toc-number">10.2.5.</span> <span class="toc-text">Modifier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">10.3.</span> <span class="toc-text">反射的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDBC-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">10.3.1.</span> <span class="toc-text">JDBC 的数据库的连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-%E6%A1%86%E6%9E%B6%E7%9A%84IoC"><span class="toc-number">10.3.2.</span> <span class="toc-text">Spring 框架的IoC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-number">11.</span> <span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">11.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">11.2.</span> <span class="toc-text">代理和反射的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">11.3.</span> <span class="toc-text">动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">11.3.1.</span> <span class="toc-text">JDK动态代理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">11.3.1.1.</span> <span class="toc-text">核心类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">11.3.1.2.</span> <span class="toc-text">使用步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">11.3.2.</span> <span class="toc-text">CGLIB动态代理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB-1"><span class="toc-number">11.3.2.1.</span> <span class="toc-text">核心类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">11.3.2.2.</span> <span class="toc-text">使用步骤</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">11.4.</span> <span class="toc-text">代理的应用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">12.1.</span> <span class="toc-text">定位和特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">12.2.</span> <span class="toc-text">默认方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">12.3.</span> <span class="toc-text">Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.3.1.</span> <span class="toc-text">函数式接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">12.3.2.</span> <span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">12.3.3.</span> <span class="toc-text">闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF"><span class="toc-number">13.</span> <span class="toc-text">异常和错误</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">13.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-catch-finally"><span class="toc-number">13.2.</span> <span class="toc-text">try-catch-finally</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#try-with-resource"><span class="toc-number">13.3.</span> <span class="toc-text">try-with-resource</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">14.</span> <span class="toc-text">泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">14.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="toc-number">14.2.</span> <span class="toc-text">泛型类型参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">14.3.</span> <span class="toc-text">通配符?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">15.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">15.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%88%86%E7%B1%BB"><span class="toc-number">15.2.</span> <span class="toc-text">集合类型及分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E7%9A%84%E4%B8%A4%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">15.3.</span> <span class="toc-text">Set的两大特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%AD%98%E5%82%A8null"><span class="toc-number">15.4.</span> <span class="toc-text">是否支持存储null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Comparable%E5%92%8CComparator"><span class="toc-number">15.5.</span> <span class="toc-text">Comparable和Comparator</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">16.</span> <span class="toc-text">浅拷贝和深拷贝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="toc-number">17.</span> <span class="toc-text">逃逸分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E9%80%83%E9%80%B8%E7%8A%B6%E6%80%81"><span class="toc-number">17.1.</span> <span class="toc-text">对象逃逸状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E4%BC%98%E5%8C%96"><span class="toc-number">17.2.</span> <span class="toc-text">逃逸分析优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">17.2.1.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E4%B8%8A%E5%88%86%E9%85%8D"><span class="toc-number">17.2.2.</span> <span class="toc-text">栈上分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E9%87%8F%E6%9B%BF%E6%8D%A2"><span class="toc-number">17.2.3.</span> <span class="toc-text">标量替换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java8%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-number">18.</span> <span class="toc-text">Java8新特性（部分）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Guava"><span class="toc-number">19.</span> <span class="toc-text">Guava</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">20.</span> <span class="toc-text">References</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法二刷"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法二刷"/></a><div class="content"><a class="title" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法二刷">数据结构和算法二刷</a><time datetime="2023-07-10T00:32:48.000Z" title="Created 2023-07-10 08:32:48">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/RocketMQ/" title="RocketMQ"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/RocketMQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/2023/05/24/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2023-05-24T08:13:44.000Z" title="Created 2023-05-24 16:13:44">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/SpringCloud.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud">Spring Cloud</a><time datetime="2023-05-24T08:08:42.000Z" title="Created 2023-05-24 16:08:42">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程"/></a><div class="content"><a class="title" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程">Java并发编程</a><time datetime="2023-05-07T13:39:13.000Z" title="Created 2023-05-07 21:39:13">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-05-07T13:37:05.000Z" title="Created 2023-05-07 21:37:05">2023-05-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Song Baoru</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>