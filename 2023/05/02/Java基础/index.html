<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java基础 | SBR Blog</title><meta name="author" content="Song Baoru"><meta name="copyright" content="Song Baoru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决 参考出处：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_38367575&#x2F;article&#x2F;details&#x2F;120420633  Scanner类用于扫描从控制台输入的数据，可以接收字符串和基本数据类型的数据。位于java.util.Scanner包中。 Scanner常用方法 String  next();">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础">
<meta property="og:url" content="https://songbaoru.github.io/2023/05/02/Java%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:description" content="JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决 参考出处：https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_38367575&#x2F;article&#x2F;details&#x2F;120420633  Scanner类用于扫描从控制台输入的数据，可以接收字符串和基本数据类型的数据。位于java.util.Scanner包中。 Scanner常用方法 String  next();">
<meta property="og:locale">
<meta property="og:image" content="https://th.bing.com/th/id/R.938bed6fc39fc253a7cd36e5481b79c0?rik=Y2Po9N8cpCfjDg&riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_12064_1.jpg&ehk=14nQEbT9IJH%2frqdvkztI9ztPhTEGaionf87iHCQxaz8%3d&risl=&pid=ImgRaw&r=0">
<meta property="article:published_time" content="2023-05-02T13:23:04.000Z">
<meta property="article:modified_time" content="2023-06-05T03:51:34.544Z">
<meta property="article:author" content="Song Baoru">
<meta property="article:tag" content="java基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://th.bing.com/th/id/R.938bed6fc39fc253a7cd36e5481b79c0?rik=Y2Po9N8cpCfjDg&riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_12064_1.jpg&ehk=14nQEbT9IJH%2frqdvkztI9ztPhTEGaionf87iHCQxaz8%3d&risl=&pid=ImgRaw&r=0"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://songbaoru.github.io/2023/05/02/Java%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-05 11:51:34'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SBR Blog"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">SBR Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-02T13:23:04.000Z" title="Created 2023-05-02 21:23:04">2023-05-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-06-05T03:51:34.544Z" title="Updated 2023-06-05 11:51:34">2023-06-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/IT/">IT</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">10.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>36min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决"><a href="#JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决" class="headerlink" title="JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决"></a>JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决</h1><blockquote>
<p>参考出处：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_38367575/article/details/120420633">https://blog.csdn.net/qq_38367575/article/details/120420633</a></p>
</blockquote>
<p>Scanner类用于扫描从控制台输入的数据，可以接收字符串和基本数据类型的数据。位于java.util.Scanner包中。</p>
<h2 id="Scanner常用方法"><a href="#Scanner常用方法" class="headerlink" title="Scanner常用方法"></a>Scanner常用方法</h2><ol>
<li><p>String  next(); </p>
<p>作用：接收控制台输入的一个字符串。</p>
<p>注意：以空格和回车为结束符 </p>
</li>
<li><p>String  nextLine(); </p>
<p>作用：接收控制台输入的一个字符串。 </p>
<p>注意：以回车为结束符</p>
</li>
<li><p>int  nextInt(); </p>
<p>作用：接收控制台输入的一个int类型的数据。</p>
<p>注意：以空格和回车为结束符 </p>
</li>
<li><p>double  nextDouble(); </p>
<p>作用：接收控制台输入的一个double类型的数据。</p>
<p>注意：以空格和回车为结束符  </p>
</li>
<li><p>boolean  nextBoolean(); </p>
<p>作用：接收控制台输入的一个boolean类型的数据。</p>
<p>注意：以空格和回车为结束符</p>
</li>
</ol>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//步骤1、创建Scanner类的一个对象。 </span><br><span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in); 	 <br><span class="hljs-comment">//步骤2、通过scanner调用next等方法，接收控制台输入的数据。 </span><br>System.out.println(“姓名：”);<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> scanner.next();<br></code></pre></td></tr></table></figure>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><img src="./Java基础/image-20230517204729870.png" alt="image-20230517204729870" style="zoom:80%;" />

<p>原因分析：原因是nextDouble()、nextInt()等方法，能够读出空格或者回车前的字符串或者数字，并且下次读时不会切换到空格或者回车之后（也就是还在18之后继续读，不会切换到下一行）。而nextLine则会读取本行且下次自动切换到下一行开头读。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在nextDouble()、nextInt()等方法后面都要加上一句不需要赋值的nextLine()，把读的位置切换到下一行</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tess</span> &#123;<br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>		<span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>		<span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> scanner.nextInt();<br>		scanner.nextLine();<span class="hljs-comment">//把读的位置切换到下一行</span><br>		<span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>		<span class="hljs-type">double</span> <span class="hljs-variable">salary</span> <span class="hljs-operator">=</span> scanner.nextDouble();<br>		scanner.nextLine();<span class="hljs-comment">//把读的位置切换到下一行</span><br>		System.out.println(<span class="hljs-string">&quot;age:&quot;</span> + age);<br>		System.out.println(<span class="hljs-string">&quot;name:&quot;</span> + name);<br>		System.out.println(<span class="hljs-string">&quot;salary:&quot;</span> + salary);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h2><blockquote>
<p>根据数据流向的方向不同，分为输入流和输出流</p>
</blockquote>
<p>IO流的输入\出源有控制台、文件、网络、数据库…</p>
<p>常用的IO流：分字节流（以字节，8bit为单位对数据进行读写操作）和字符流（以字符为单位，一个字符占2个字节）</p>
<p>输入字节流包含：文件（File）、对象（Object）、字节数组（ByteArray）、管道（Pipe）、过滤器（Filter）、缓冲字符串、顺序输入流（InputStream），都是InputStream（抽象类）的子类</p>
<p>输出字节流包含：文件（File）、对象（Object）、字节数组（ByteArray）、管道（Pipe）、过滤器（Filter）输出流（OutputStream），都是OutputStream（抽象类）的子类</p>
<p>输入字符流包含：字符数组（CharArray）、字符串（String）、其他输入流的缓冲区（Buffered）、管道（Piped）、过滤器（Filter）、将字节输入流转换为字符输入流（InputStream）Reader，都是Reader的子类（Reader是所有字符输入流的父类）</p>
<p>输出字符流包含：字符数组（CharArray）、字符串（String）、其他输出流的缓冲区（Buffered）、管道（Piped）、过滤器（Filter）、将字节输入流转换为字符输入流（InputStream）Writer，都是Writer的子类（Writer是所有字符输出流的父类）</p>
<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><p>节点流是低级流，直接与数据源相连，并且进行读写；处理流是高级流，不直接和数据源相连（采用装饰器模式对节点流进行封装），主要用于消除不同节点实现上的差异。</p>
<p>节点流包含：FileInputStream、FileOutputStream、FileReader、FileWriter</p>
<p>处理流包含：BufferInputStream（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/io/FilterInputStream.html">FilterInputStream</a>的实现类）、BufferOutputStream、BufferReader、BufferWriter</p>
<p>处理流相比节点流的优点：通过增加缓存提高了数据输入和输出的效率、封装了一系列高级方法来完成一次性大批量数据的输入和输出</p>
<h2 id="内存映射文件技术"><a href="#内存映射文件技术" class="headerlink" title="内存映射文件技术"></a>内存映射文件技术</h2><p>含义：操作系统利用虚拟内存将文件映射到内存中，然后，这个文件就可以被当作内存数据来访问</p>
<p>关键技术优势：</p>
<ul>
<li>让操作系统负责文件的读写，应用程序只需要处理内存数据，就可以实现IO操作；</li>
<li>可以实现共享内存，内存映射文件可以被多个进程同时访问；内存映射文件技术涉及的内存在Java的堆空间之外；</li>
<li>大幅提升文件数据的输入输出速度</li>
</ul>
<p>Java的NIO包支持内存映射技术，实现方式是通过<strong>MapperdBytyBuffer</strong>读写内存</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="8种基本类型"><a href="#8种基本类型" class="headerlink" title="8种基本类型"></a>8种基本类型</h2><p>在Java中共有8种基本类型（primitive type），其中包含4种整型、2种浮点型、1种字符类型（用于表示Unicode编码）和1种真值类型。</p>
<ol>
<li><p>4种整型</p>
<p>byte：1字节；取值范围是从-128 (-2^7) 到 127 (2^7 - 1)</p>
<p>short：2字节；取值范围是从 -32,768 (-2^15) 到 32,767 (2^15 - 1)</p>
<p>int：4字节；取值范围是从 -2,147,483,648 (-2^31) 到 2,147,483,647 (2^31 - 1)</p>
<p>long：8字节；取值范围是从-9,223,372,036,854,775,808 (-2^63) 到 9,223,372,036,854,775,807 (2^63 - 1)</p>
<p>Java整型数值的表示方法：</p>
<ul>
<li><p>长整型（long）数值后面有一个后缀L或l</p>
</li>
<li><p>十六进制数值有一个前缀0X或0x</p>
</li>
<li><p>八进制有一个前缀0</p>
</li>
<li><p>二进制有一个前缀0B或0b</p>
</li>
<li><p>可以在整数类型的数字字面量上加下划线进行分组，以提高可读性</p>
</li>
</ul>
<blockquote>
<p>Java和C++的不同：</p>
<p>Java中整型的范围是平台无关的，而C++（C同样也是）中，是平台相关的。</p>
</blockquote>
</li>
<li><p>2种浮点型</p>
<p>float：4字节；取值范围是大约是正负3.4E+38（约7位有效数字）</p>
<p>double：8字节；取值范围大约是正负1.7E+308（约15位有效数字）</p>
<p>取值范围是由IEEE 754浮点数标准规定的，float类型的32位二进制数被划分为三个部分：1个符号位，8个指数位和23个尾数位。double类型的64位二进制数被划分为三个部分：1个符号位，11个指数位和52个尾数位。其中，指数位决定了浮点数的范围，尾数位决定了浮点数的精度。</p>
<p>double这种表示浮点数的类型数值精度是float类型的两倍，所以称为双精度浮点数。</p>
<p>Java整型数值的表示方法：</p>
<ul>
<li>float类型的数值有一个后缀F或f</li>
<li>double类型的数值既可以没有后缀，也可以有一个后缀D或d，所以Java中没有后缀的浮点数类型默认是double</li>
</ul>
<blockquote>
<p> 警告： </p>
<p>浮点数不适用于无法接受舍入误差的金童计算，如果需要精确的数值计算，不允许有舍入误差，应该使用BigDecimal类。</p>
</blockquote>
</li>
<li><p>1种字符类型</p>
<p>char：2字节；取值范围是从0到65535（包括0和65535）</p>
<p>char类型的作用主要有两个，表示单个字符，以及表示Unicode字符（目前，16位的char类型已经不足以描述所有Unicode字符了，部分Unicode字符需要两个char来表示）。</p>
<blockquote>
<p>备注：</p>
<p>Unicode字符是一种用于表示文本字符的国际标准编码系统。它为几乎所有的字符（包括字母、数字、标点符号、符号、表情符号等）分配了唯一的代码点，以便在计算机系统中进行存储和处理。</p>
<p>Unicode字符使用十六进制表示，前缀为”\u”，后跟四个十六进制数字。</p>
<p>Unicode转义序列会在解释代码之前处理。</p>
</blockquote>
</li>
<li><p>1种真值类型</p>
<p>boolean：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">“大小”并不是精确定义的</a>，通常是1字节；取值范围是true或false</p>
<blockquote>
<p>注意：</p>
<p>在Java8HotSpot虚拟机下，单个boolean数值和数组中的boolean数值都是占1个字节。</p>
<p>使用JOL对象布局分析工具，编写测试程序如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BooleanLength</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-type">boolean</span>[] bArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[]&#123;<span class="hljs-literal">true</span>&#125;;<br>        System.out.println(ClassLayout.parseInstance(b).toPrintable());<br>        System.out.println(ClassLayout.parseInstance(bArr).toPrintable());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<p><img src="/2023/05/02/Java%E5%9F%BA%E7%A1%80/.././Java%E5%9F%BA%E7%A1%80/image-20230602165516573.png" alt="image-20230602165516573"></p>
<p>可以看到无论是单个boolean对象还是数组中的boolean对象，其boolean数值都只占1个字节。</p>
</blockquote>
</li>
</ol>
<p>在Java中只有基本类型不是对象。</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Java字符串（String类对象）是Unicode字符序列，每个字符char都对应一个Unicode码点。</p>
<p><strong>字符串不可变</strong></p>
<blockquote>
<p> <code>String</code> objects are <em>immutable</em>, which means that once created, their values cannot be changed. </p>
</blockquote>
<p>Java中字符串是不可变的（immutable），并且也没有提供任何方法来修改字符串中的某个字符。</p>
<p><strong>字符串共享</strong></p>
<p>字符串常量池是一块位于Java堆内存中的特殊存储区域，用于存储字符串字面量（直接以双引号括起来的字符串）和显式通过String类的<code>intern()</code>方法调用加入常量池的字符串。当创建字符串时，如果字符串常量池中已经存在相同内容的字符串，则不会创建新的字符串对象，而是直接返回常量池中的字符串引用。</p>
<p>需要注意的是，通过<code>new</code>关键字创建的字符串对象不会被共享，而是在堆内存中创建新的对象。只有使用字符串字面量或显式调用<code>intern()</code>方法将字符串加入常量池时才会进行共享。此外，+或substring等操作得到的字符串也不共享。</p>
<p><strong>检测字符串是否相等</strong></p>
<p>String类覆盖了equals方法。</p>
<p>可以使用equals方法检测两个字符串是否相等，不能使用&#x3D;&#x3D;运算符，因为&#x3D;&#x3D;运算符只能确定两个字符串是否存储在同一个位置上，而Java中的相等的字符串可以存储在不共享的位置，不能仅通过位置判断是否相等。</p>
<p><strong>文本块</strong></p>
<p>Java15新增了文本块（text block）特性，提供了跨多行的字符串字面量。</p>
<p>文本块特别适合包含用其它语言编写的代码，如SQL或HTML。</p>
<p>文本块示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">html</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">    	HTML...</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span>;<br></code></pre></td></tr></table></figure>

<p>文本块需要转义的情况：</p>
<ul>
<li><p>文本块以引号结尾</p>
</li>
<li><p>文本块中包含三个及以上的引号</p>
</li>
<li><p>文本块中有反斜杠（\）</p>
</li>
<li><p>文本块以空格结尾</p>
<p>文本块会删除末尾的空格，如果需要保留末尾的空格，可以把空格替换为\s。</p>
</li>
</ul>
<h2 id="大数"><a href="#大数" class="headerlink" title="大数"></a>大数</h2><p>Java的<code>java.math</code>包中提供了两个重要的数值处理类，BigInteger和BigDecimal，用于处理大整数和高精度浮点数的运算。BigInteger类能够表示任意精度的整数。BigDecimal类能够实现任意精度的浮点数运算。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>for each循环的对象必须是一份数组或者是一个实现了Iterable接口的类对象。</p>
<p><strong>Arrays类</strong></p>
<ul>
<li><p><strong>数组打印</strong></p>
<p>如果要打印数组中的所有值，可以使用另一种方法，使用Arrays类的<strong>toString</strong>方法，该方法会返回一个包含数组元素的字符串，这些元素包围在中括号内，并使用逗号分隔。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(Arrays.toString(a));<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>数组拷贝</strong></p>
<p>如果要拷贝数组内的所有值，可以使用Arrays类的<strong>copyOf</strong>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] copiedArray = Arrays.copyOf(a, length); <span class="hljs-comment">//第二个参数length是新数组的长度</span><br></code></pre></td></tr></table></figure>

<p>如果要拷贝数组内指定范围内的所有值，可以使用Arrays类的<strong>copyOfRange</strong>方法。</p>
</li>
<li><p><strong>数组排序</strong></p>
<p>如果要对数值型的数组进行排序，可以使用Arrays类中的<strong>sort</strong>方法。如果是其它类型的数组，也可以使用该方法，前提是数组元素的类实现了Comparator接口的compareTo方法（x小于y时返回负数）。</p>
<p>这个方法使用了优化的快速排序（QuickSort）算法</p>
</li>
<li><p><strong>数组二分查找</strong></p>
<p>如果要使用二分查找算法在有序数组a中或a中的指定范围内查找值v，可以使用Arrays的binarySearch方法，如果找到v，该方法会返回值的索引，否则返回一个负数值r，-r-1是v在保持a有序的前提下可以插入的位置。</p>
</li>
<li><p><strong>数组填充</strong></p>
<p>如果要将数组所有元素设置为指定值，可以使用Arrays类的fill方法。</p>
</li>
<li><p><strong>数组元素比较</strong></p>
<p>如果两个数组长度相同，并且相同索引对应的元素都相同，则返回true。</p>
</li>
</ul>
<p><strong>不规则数组</strong></p>
<p>Java中的数组可以是不规则的数组，即数组的每一行有不同的长度。</p>
<blockquote>
<p>Java和C++的不同：</p>
<p>C++的Vector是按值复制的，赋值操作b&#x3D;a将会构造一个与a长度相同的新向量，并将所有元素从a复制到b。而在Java中，这条赋值语句的操作结果是让a和b引用同一个数组列表。</p>
</blockquote>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>Java的运算符包括&amp;（and）、|（or）、^（or）、~（not）。</p>
<p>对于布尔值，&amp;和|运算符的返回结果也是布尔值，不过与<code>&amp;&amp;</code>和<code>||</code>不同的是，$和|运算符不是短路的，也就是说，计算结果之前两个操作数都需要计算</p>
<h2 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h2><p>Java的位移运算符包括&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;，不存在&lt;&lt;&lt;。</p>
<ul>
<li>&gt;&gt;会用符号位填充高位</li>
<li>&gt;&gt;&gt;会用0填充高位</li>
</ul>
<h2 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h2><p>Java14中引入switch，既可以作为语句，也可以做表达式。</p>
<p><strong>参数类型</strong></p>
<p>可以作为switch参数数据类型的有：int、bype、short、char、String、枚举</p>
<p>不能作为switch参数的有：long、float、double、boolean、复杂的表达式</p>
<p>case的参数可以有多个。如<code>case &quot;Summer&quot;， &quot;Winter&quot; -&gt; 0;</code></p>
<p><strong>直通和非直通</strong></p>
<p>Java中switch语句的行为可以被描述为直通和非直通：</p>
<ul>
<li><p>直通行为</p>
<ul>
<li>case以冒号（:）结尾，是有直通行为的。</li>
</ul>
</li>
<li><p>非直通行为</p>
<ul>
<li>case以箭头（-&gt;）结尾，是无直通行为的。</li>
<li>switch表达式中有yield关键字，yield关键字会返回表达式的值并终止执行。</li>
<li>switch表达式中有break关键字，break关键字会终止执行，switch表达式中不能使用return、break或continue语句。</li>
</ul>
</li>
</ul>
<p><strong>switch的使用方法</strong></p>
<ul>
<li><p>-&gt;</p>
<ul>
<li><p>switch表达式</p>
<ul>
<li><p>直接返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;<br><span class="hljs-type">Size</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Size.LARGE;<br><span class="hljs-comment">// switch表达式</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> SMALL -&gt; <span class="hljs-string">&quot;S&quot;</span>;<br>    <span class="hljs-keyword">case</span> MEDIUM -&gt; <span class="hljs-string">&quot;M&quot;</span>;<br>    <span class="hljs-keyword">case</span> LARGE -&gt; <span class="hljs-string">&quot;L&quot;</span>;<br>    <span class="hljs-keyword">case</span> EXTRA_LARGE -&gt; <span class="hljs-string">&quot;XL&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用yield返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;<br><span class="hljs-type">Size</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Size.LARGE;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> SMALL -&gt; &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;S&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> MEDIUM -&gt; &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;M&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> LARGE -&gt; &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;L&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">case</span> EXTRA_LARGE -&gt; &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;XL&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>switch语句</p>
<ul>
<li><p>直接赋值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;<br><span class="hljs-type">Size</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Size.LARGE;<br>String result;<br><span class="hljs-comment">// switch语句</span><br><span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> SMALL -&gt; result = <span class="hljs-string">&quot;S&quot;</span>;<br>    <span class="hljs-keyword">case</span> MEDIUM -&gt; result = <span class="hljs-string">&quot;M&quot;</span>;<br>    <span class="hljs-keyword">case</span> LARGE -&gt; result = <span class="hljs-string">&quot;L&quot;</span>;<br>    <span class="hljs-keyword">case</span> EXTRA_LARGE -&gt; result = <span class="hljs-string">&quot;XL&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>:</p>
<ul>
<li><p>switch表达式</p>
<ul>
<li><p>使用yield返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;<br><span class="hljs-type">Size</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Size.LARGE;<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">switch</span> (size) &#123;<br>     <span class="hljs-keyword">case</span> SMALL:<br>         <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;S&quot;</span>;<br>     <span class="hljs-keyword">case</span> MEDIUM:<br>         <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;M&quot;</span>;<br>     <span class="hljs-keyword">case</span> LARGE:<br>         <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;L&quot;</span>;<br>     <span class="hljs-keyword">case</span> EXTRA_LARGE:<br>         <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;XL&quot;</span>;<br> &#125;;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>switch语句</p>
<ul>
<li><p>赋值后使用break返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;;<br><span class="hljs-type">Size</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Size.LARGE;<br>String result;<br><span class="hljs-keyword">switch</span> (size) &#123;<br>    <span class="hljs-keyword">case</span> SMALL:<br>        result = <span class="hljs-string">&quot;S&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> MEDIUM:<br>        result = <span class="hljs-string">&quot;M&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> LARGE:<br>        result = <span class="hljs-string">&quot;L&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> EXTRA_LARGE:<br>        result = <span class="hljs-string">&quot;XL&quot;</span>;<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h2><p>数值类型转换中int转float，long转double可能产生精度损失。</p>
<p><strong>自动类型转换</strong></p>
<p>二元运算符在计算前会先将两个操作数转换为同一类型，如果有一个操作数是double&#x2F;float&#x2F;long（存在优先顺序），另一个操作数就会被转换（自动类型转换）为double&#x2F;float&#x2F;long。</p>
<p><strong>强制类型转换</strong></p>
<p>对于可能丢失信息的转换需要通过强制类型转换完成。</p>
<p>浮点数转换为整数时会截断小数位。</p>
<h2 id="数学函数Math"><a href="#数学函数Math" class="headerlink" title="数学函数Math"></a>数学函数Math</h2><p>Math.pow方法：进行幂运算，Java中没有完成幂运算的运算符</p>
<p>Math.round方法：舍入（round）浮点数来得到最接近的整数</p>
<p>Math.ramdom方法：返回一个0到1（包含0，不包含1）之间的随机浮点数，用n乘以这个浮点数，可以得到从0到n-1之间的一个随机数。例如：<code>int result = (int) (Math.random() * n);</code></p>
<h1 id="对象与类"><a href="#对象与类" class="headerlink" title="对象与类"></a>对象与类</h1><h2 id="面向对象编程的概念"><a href="#面向对象编程的概念" class="headerlink" title="面向对象编程的概念"></a>面向对象编程的概念</h2><p><strong>封装（encapsulation）</strong></p>
<p>从形式上看，封装就是将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现细节。</p>
<p>实现封装的关键在于，不能让其它类中的方法直接访问被封装的类的实例字段，程序只能通过对象的方法与对象的数据进行交互。这意味着一个类可以完全改变存储数据的方式，只要仍旧向外提供同样的方法，调用该方法的对象不需要关心这个类所发生的变化。</p>
<p><strong>继承（Inheritance）</strong></p>
<p>继承可以让实现Java类变得更容易，因为可以通过继承（extends、implements）其它类来构建新类。</p>
<p><strong>多态（Polymorphism）</strong></p>
<p>多态是指在父类或接口类型上使用不同的子类对象，以实现同一个方法的多种不同行为。一个父类变量既可以引用父类对象，也可以引用其任何一个子类的对象。</p>
<h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><table>
<thead>
<tr>
<th>关系</th>
<th>含义</th>
<th>UML（Unified Modeling Language）连接符</th>
<th>关系强弱</th>
</tr>
</thead>
<tbody><tr>
<td>实现（Implementation，is-a）</td>
<td>implements interface</td>
<td>虚线+三角箭头</td>
<td></td>
</tr>
<tr>
<td>继承（Inheritance，is-a）</td>
<td>inherits from</td>
<td>实线+三角箭头</td>
<td></td>
</tr>
<tr>
<td>依赖（Dependency，uses-a）</td>
<td>depend on</td>
<td>虚线+三线箭头</td>
<td>弱（如成员函数里的局部变量）</td>
</tr>
<tr>
<td>关联（Association，uses-a）</td>
<td>is associated with</td>
<td>实线+三线箭头</td>
<td>强（如成员变量）</td>
</tr>
<tr>
<td>聚合（Aggregation，has-a）</td>
<td>is an aggregate of</td>
<td>空心菱形箭头+实线</td>
<td>弱</td>
</tr>
<tr>
<td>组合（Composition，has-a）</td>
<td>is composed of</td>
<td>实心菱形箭头+实线</td>
<td>强</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h2><p><strong>方法参数能否改变的规则</strong></p>
<ul>
<li>方法不能改变基本数据类型的参数</li>
<li>方法可以改变对象参数的状态</li>
<li>方法不能改变对象参数的引用对象</li>
</ul>
<p><strong>变长参数</strong></p>
<p>在 Java 5 中提供了变长参数，允许在调用方法时传入不定长度的参数。变长参数是 Java 的一个语法糖，本质上还是基于数组的实现。</p>
<p>定义变长参数的方法是，在最后一个形参后加上三点 <strong>…</strong>，就表示该形参可以接受多个参数值，需要注意的是：</p>
<ul>
<li>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数</li>
<li>由于可变参数必须是最后一个参数，所以一个函数最多只能有一个可变参数</li>
<li>Java的可变参数，会被编译器转型为一个数组</li>
</ul>
<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载（orverloading）指的是一个类的多个方法有相同的参数名，但是有不同的参数。</p>
<h2 id="包装器"><a href="#包装器" class="headerlink" title="包装器"></a>包装器</h2><p>所有基本类型都有一个与之对应的类，这些类被称为包装器（wrapper），分别是：<strong>Byte、Integer、Long、Float、Double、Boolean、Character</strong>（前6个类派生于父类Number）。</p>
<blockquote>
<p>由于每个值分别包装在一个对象中，所以ArrayList&lt;Integer&gt;的效率远远低于int[]数组。</p>
</blockquote>
<p><strong>自动装箱</strong></p>
<p>list.add(1);会自动转换为list.add(Integer.valueOf(1))，这种转换称为自动装箱（autoboxing）。</p>
<p><strong>自动拆箱</strong></p>
<p>当将Integer对象赋给一个int值时，会自动拆箱（unboxed）。例如，int n &#x3D; list.get(i)会转换成int n &#x3D; list.get(i).intValue()。</p>
<p>自动装箱和自动拆箱也适用于算术表达式。例如，对于Integer n &#x3D; 1; n++;编译器会自动地对n拆箱，将拆箱后的结果增1，最后再将其装箱。</p>
<p>装箱和拆箱由编译器完成，而不是虚拟机。编译在再生成类的字节码时会插入必要的方法调用，虚拟机只是执行这些字节码。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><blockquote>
<p>Java和C++的不同：</p>
<p>在C++中，抽象方法称为纯虚函数（pure virtual function），要在末尾用&#x3D;0标记，没有用于表示抽象类的特殊关键字。</p>
</blockquote>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>在比较枚举类的值时，不需要使用equals，可以之间使用&#x3D;&#x3D;来比较。</p>
<p>枚举类可以有构造器、方法和字段。枚举类的构造器是私有的。</p>
<p>有构造器、方法和字段的枚举类示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">Size</span> &#123;<br>    SMALL(<span class="hljs-string">&quot;S&quot;</span>), MEDIUM(<span class="hljs-string">&quot;M&quot;</span>), LARGE(<span class="hljs-string">&quot;L&quot;</span>), EXTRA_LARGE(<span class="hljs-string">&quot;XL&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String abbreviation;<br><br>    Size(String abbreviation) &#123;<br>        <span class="hljs-built_in">this</span>.abbreviation = abbreviation;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getAbbreviation</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> abbreviation;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所有枚举类型都是抽象类Enum的子类。</p>
<h2 id="Cloneable"><a href="#Cloneable" class="headerlink" title="Cloneable"></a>Cloneable</h2><p><code>Cloneable</code> 是一个标记接口（marker interface），用于指示一个类可以被克隆（clone）。</p>
<p>要让一个类可以被克隆，需要满足两个条件：</p>
<ol>
<li>类实现 <code>Cloneable</code> 接口。</li>
<li>重写 <code>clone()</code> 方法，实现对象的克隆逻辑。</li>
</ol>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>继承的基本思想是基于已有的类创建新的类。</p>
<blockquote>
<p>Java和C++的不同：</p>
<p>Java中继承是使用关键字extends，而C++中是使用冒号（:）</p>
<p>Java中所有的继承都是公共继承，没有C++中的私有继承和保护继承。</p>
</blockquote>
<p>在覆盖一个方法的时候，子类的方法不能低于超类方法的可见性。</p>
<h2 id="final类和final方法"><a href="#final类和final方法" class="headerlink" title="final类和final方法"></a>final类和final方法</h2><p>final能够阻止类的继承，以及方法的覆盖。</p>
<h2 id="protected访问修饰符"><a href="#protected访问修饰符" class="headerlink" title="protected访问修饰符"></a>protected访问修饰符</h2><p>protected是Java的一个访问修饰符（access modifier）。</p>
<p>当一个类的成员被声明为 protected，意味着它只能被以下两种情况下的代码访问：</p>
<ol>
<li>在同一包内的其他类</li>
<li>所有（在同一包或不同包中）的子类</li>
</ol>
<p>需要注意的是，protected 修饰符并不会对类本身的可见性产生影响，也就是说，如果一个public类的某个成员被声明为 protected，不同包下的非子类仍然能够访问该类，只是不能访问该类的protected成员。</p>
<blockquote>
<p>注意：</p>
<p>如果在Java中不指定类中某个方法的访问修饰符，则默认使用包级私有（package-private）修饰符，而不是protected修饰符。</p>
</blockquote>
<h2 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h2><p>覆盖（override）指的是子类提供从父类中继承的方法的新的实现。</p>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>Object类中的equals方法的默认实现是比较两个对象的引用地址（即内存地址）是否相同。所以如果需要比较两个对象中参数是否一致，就需要覆盖该equals方法。</p>
<p>Java规范要求equals方法具有如下特性：</p>
<ol>
<li>自反性：对于非null的引用x，x.equals(x)应返回true。</li>
<li>对称性：对于非null的引用x、y，x.equals(y)返回true时，y.equals(x)也要返回true。</li>
<li>传递性：对于非null的引用x、y、z，x.equals(y)返回true且y.equals(z)返回true，则x.equals(z)返回true。</li>
<li>一致性：如果x，y引用的对象没有发送变化，则反复调用x.equals(y)应该返回相同的结果。</li>
<li>对于非null的引用x，x.equals(null)应返回false。</li>
</ol>
<h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><p>Java中，散列码（hash code）是由对象导出的一个整型值（可以是负数）。</p>
<p>内容相同的字符串有相同的散列码，这是因为字符串的散列码是由内容导出的。</p>
<p>如果一个类覆盖了equals方法，则该类必须也覆盖hashCode方法。如果两个对象通过 equals 方法比较相等，那么它们的 hashCode 必须相等。比如如果equals方法比较的是参数id，那么hashCode方法就需要对id计算散列值，且不考虑其它的参数。</p>
<blockquote>
<p>提示：</p>
<p>如果有数组类型的字段，那么可以使用静态的Arrays.hashCode方法计算一个散列码，该散列码有数组元素的散列码组成。</p>
</blockquote>
<h2 id="getClass方法"><a href="#getClass方法" class="headerlink" title="getClass方法"></a>getClass方法</h2><p>Object类提供了getClass方法，返回值是对象的运行时类的Class对象。</p>
<p>调用getClass().getName()可以得到对象的类名。</p>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>反射（reflection）是在程序运行期间获取类的信息（如类名、类的方法、类的属性等信息）并进行操作（如创建对象、调用方法等操作）的技术。</p>
<h3 id="反射机制的核心类"><a href="#反射机制的核心类" class="headerlink" title="反射机制的核心类"></a>反射机制的核心类</h3><p>Java 反射机制的核心类包括“java.lang”包下的Class 类，以及“ java.lang.reflect”包下的Constructor类、Method类、Field类、Modifier类。这些类可以让我们在运行时动态地获取类的相关信息，并进行相应的操作。例如，我们可以使用 Method 类中的 invoke() 方法来调用一个指定方法，或者使用 Field 类的 get() 和 set() 方法来读取或修改一个对象的属性值。</p>
<h4 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h4><p>虚拟机中每个类型只要唯一的Class对象，因此可以使用&#x3D;&#x3D;运算符比较两个类对象是否相等。</p>
<p>Class类的部分方法示例：</p>
<ul>
<li><p>getName方法，由获取的Class类对象获取类的全限定名（fully qualified name）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-type">Class</span> <span class="hljs-variable">classObject</span> <span class="hljs-operator">=</span> object.getClass();<span class="hljs-comment">//获取Class类对象</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> classObject.getName();<br></code></pre></td></tr></table></figure>
</li>
<li><p>forName方法，由类的全限定名获取Class类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;java.lang.Integer&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>	classObject = Class.forName(name);<br>&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>由类型获取Class类对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">classObject1</span> <span class="hljs-operator">=</span> Integer.class;<br><span class="hljs-type">Class</span> <span class="hljs-variable">classObject2</span> <span class="hljs-operator">=</span> <span class="hljs-type">int</span>.class; <span class="hljs-comment">//int不是类，但是int.Class是类对象</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>getConstructor方法，由Class类对象获取构造器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">classObject</span> <span class="hljs-operator">=</span> TestGetLClass.class;<br><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> classObject.getConstructor().newInstance();<br>&#125; <span class="hljs-keyword">catch</span> (InstantiationException | IllegalAccessException | InvocationTargetException | NoSuchMethodException e) &#123;<br>	<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h4 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h4><table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>newInstance(Object … initargs)</td>
<td>根据传递的参数创建类的对象</td>
</tr>
</tbody></table>
<h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><table>
<thead>
<tr>
<th>方法</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h4><h4 id="Modifier"><a href="#Modifier" class="headerlink" title="Modifier"></a>Modifier</h4><h3 id="反射的应用"><a href="#反射的应用" class="headerlink" title="反射的应用"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000010162647">反射的应用</a></h3><h4 id="JDBC-的数据库的连接"><a href="#JDBC-的数据库的连接" class="headerlink" title="JDBC 的数据库的连接"></a>JDBC 的数据库的连接</h4><p>在JDBC 的操作中，如果要想进行数据库的连接，则必须按照以上的几步完成</p>
<ol>
<li>通过Class.forName()加载数据库的驱动程序 （通过<strong>反射</strong>加载，前提是引入相关了Jar包）</li>
<li>通过 DriverManager 类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密码</li>
<li>通过Connection 接口接收连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectionJDBC</span> &#123;  <br>    <span class="hljs-comment">/** </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args </span><br><span class="hljs-comment">     */</span>  <br>    <span class="hljs-comment">//驱动程序就是之前在classpath中配置的JDBC的驱动程序的JAR 包中  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DBDRIVER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>;  <br>    <span class="hljs-comment">//连接地址是由各个数据库生产商单独提供的，所以需要单独记住  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DBURL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>;  <br>    <span class="hljs-comment">//连接数据库的用户名  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DBUSER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;  <br>    <span class="hljs-comment">//连接数据库的密码  </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DBPASS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;  <br>      <br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">//表示数据库的连接对象  </span><br>        Class.forName(DBDRIVER); <span class="hljs-comment">//1、使用CLASS 类加载驱动程序 ,反射机制的体现 </span><br>        con = DriverManager.getConnection(DBURL,DBUSER,DBPASS); <span class="hljs-comment">//2、连接数据库  </span><br>        System.out.println(con);  <br>        con.close(); <span class="hljs-comment">// 3、关闭数据库  </span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Spring-框架的IoC"><a href="#Spring-框架的IoC" class="headerlink" title="Spring 框架的IoC"></a>Spring 框架的IoC</h4><p>在 Java的反射机制在做基础框架的时候非常有用，行内有一句这样的老话：反射机制是Java框架的基石。一般应用层面很少用，不过这种东西，现在很多开源框架基本都已经封装好了，自己基本用不着写。典型的除了hibernate之外，还有spring也用到很多反射机制。最经典的就是xml的配置模式。</p>
<p>Spring 通过 XML 配置模式装载 Bean 的过程：</p>
<ol>
<li>将程序内所有 XML 或 Properties 配置文件加载入内存中</li>
<li>Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息</li>
<li>使用<strong>反射</strong>机制，根据这个字符串获得某个类的Class实例</li>
<li>动态配置实例的属性</li>
</ol>
<p>Spring这样做的好处是：</p>
<ul>
<li>不用每一次都要在代码里面去new或者做其他的事情</li>
<li>以后要改的话直接改配置文件，代码维护起来就很方便了</li>
<li>有时为了适应某些需求，Java类里面不一定能直接调用另外的方法，可以通过反射机制来实现</li>
</ul>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>代理（proxy）是在运行时创建创建接口的代理类和代理对象的技术。</p>
<p>代理模式一般分为静态代理和动态代理两种。</p>
<p>Java代理是指在不改变原有类的基础上，通过引入代理类来完成对该类的功能扩展或调整。代理模式一般分为静态代理和动态代理两种。</p>
<p>静态代理的实现需要开发者手动编写一个代理类，该代理类与被代理类实现同样的接口或继承同样的父类，并在代理类中将被代理类的核心业务逻辑嵌入到自己的方法中，同时在代理类中添加额外的功能实现。静态代理的优点是简单易懂、效率高，缺点是需要手动编写代理类，且每个被代理对象都需要一个独立的代理类。</p>
<p>动态代理则是在程序运行时使用反射机制动态创建代理对象，无需手动编写代理类。Java提供了两种动态代理方式：基于接口的动态代理（JDK动态代理）和基于类的动态代理（CGLib）。其中，基于接口的动态代理要求被代理对象必须实现接口，而基于类的动态代理则可以对任意类进行代理，包括没有实现接口的类。动态代理的优点是灵活性高，无需手动编写代理类，缺点是相较于静态代理，在性能上稍有损耗。</p>
<p>Java动态代理的核心类是java.lang.reflect.Proxy和java.lang.reflect.InvocationHandler。开发者可以通过传入一个类加载器、一组接口和一个InvocationHandler对象来创建代理对象，在代理对象调用方法时，实际上是调用了InvocationHandler的invoke方法。开发者需要自定义该接口的实现类来完成代理对象的方法调用。</p>
<p>在Java中，代理机制的核心类包括以下两个类：</p>
<ol>
<li><code>java.lang.reflect.Proxy</code>：这是Java提供的用于创建代理对象的核心类。<code>Proxy</code>类提供了静态方法来动态创建代理类和代理对象。它是实现代理模式的关键类之一。</li>
<li><code>java.lang.reflect.InvocationHandler</code>：这是一个接口，用于定义代理对象的调用处理程序。代理对象的方法调用会被转发给<code>InvocationHandler</code>的实现类来处理。通过实现<code>InvocationHandler</code>接口，可以自定义代理对象的行为。</li>
</ol>
<p>使用这两个核心类，可以实现动态代理，通过在运行时创建代理类和代理对象来拦截并处理方法调用。</p>
<p>请注意，代理机制还涉及其他辅助类和接口，如被代理的接口或类、代理类的字节码生成等，但上述两个类是代理机制的核心类，用于创建代理对象和定义代理行为。</p>
<p>代理（Proxy）是指在程序中创建一个代理对象，用于控制对另一个对象的访问。代理对象充当被代理对象的替身，通过代理对象可以拦截对原始对象的访问，并在访问前后执行一些附加操作。代理模式常用于实现横切关注点（cross-cutting concerns）的功能，如日志记录、事务管理等。</p>
<h3 id="代理机制的核心类"><a href="#代理机制的核心类" class="headerlink" title="代理机制的核心类"></a>代理机制的核心类</h3><p>在Java中代理机制的核心类包括，<code>java.lang.reflect.Proxy</code>类和<code>java.lang.reflect.InvocationHandler</code>接口。<code>Proxy</code>类用于创建代理类和代理对象，而<code>InvocationHandler</code>接口定义了代理对象的调用处理程序。</p>
<h3 id="代理的应用"><a href="#代理的应用" class="headerlink" title="代理的应用"></a>代理的应用</h3><p>代理机制在Java中的应用非常广泛，例如在AOP（面向切面编程）中，可以利用代理机制实现对方法的增强。</p>
<p>RPC（远程过程调用）框架使用动态代理来实现远程方法的调用和网络通信。下面是一个典型的RPC框架使用动态代理的工作流程：</p>
<ol>
<li><p>定义服务接口：首先，定义一个公共的接口，该接口描述了远程服务提供的方法和参数。</p>
</li>
<li><p>创建服务实现类：编写服务接口的实现类，该类包含了具体的业务逻辑。</p>
</li>
<li><p>创建代理对象：使用动态代理创建一个代理对象。代理对象实现了服务接口，并将方法调用转发给远程服务。</p>
</li>
<li><p>发送请求：当客户端调用代理对象的方法时，代理对象将通过网络将方法名和参数等信息打包成一个请求，发送给远程服务。</p>
</li>
<li><p>接收请求：远程服务接收到请求后，解析请求，提取方法名和参数等信息。</p>
</li>
<li><p>执行方法：远程服务根据方法名在服务实现类中找到对应的方法，并使用提供的参数执行该方法。</p>
</li>
<li><p>返回结果：远程服务将执行结果打包成响应，通过网络将响应发送回客户端。</p>
</li>
<li><p>解析响应：客户端接收到响应后，解析响应，提取返回结果。</p>
</li>
<li><p>返回结果：客户端将返回结果返回给调用方。</p>
</li>
</ol>
<p>在这个过程中，动态代理起到了关键的作用。客户端通过动态代理对象来调用远程服务的方法，而不需要直接关注底层的网络通信细节。代理对象将方法调用转发给远程服务，同时可以在方法调用前后添加一些额外的逻辑，比如实现负载均衡、服务治理、日志记录等。</p>
<p>Java中的RPC框架，如Dubbo、gRPC等，通常使用动态代理来实现客户端的远程方法调用。通过使用动态代理，可以实现透明的远程方法调用，使得调用远程服务的代码看起来像是调用本地方法一样简单和直观。</p>
<h2 id="代理和反射的关系"><a href="#代理和反射的关系" class="headerlink" title="代理和反射的关系"></a>代理和反射的关系</h2><p>反射和代理之间的关系是通过反射可以创建动态代理对象这一点来联系起来的。Java中的动态代理是一种利用反射机制在运行时动态地创建代理对象的技术。通过动态代理，可以在运行时创建代理类和代理对象，并将方法的调用转发给代理对象的调用处理程序（InvocationHandler）来处理。代理对象可以在调用前后执行一些额外的操作，例如记录日志、检查权限、实现缓存等。</p>
<p>总结：反射和代理是Java中两个相关的概念。反射是一种在运行时动态获取类信息和操作类的能力，而代理是一种在程序中创建代理对象来控制对另一个对象的访问的技术。反射可以用于创建动态代理对象，通过动态代理可以在方法调用前后执行额外的操作。</p>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="定位和特性"><a href="#定位和特性" class="headerlink" title="定位和特性"></a>定位和特性</h2><p>接口（interface）用来描述类应该做什么（一组需求），而不指定应该怎么做（静态方法除外，从Java8开始允许在接口中增加静态方法包括方法的实现）。接口中除了可以声明方法，还可以定义静态常量。</p>
<p>接口中的所有方法都默认是public方法，因此在接口中声明方法时，可以不提供关键字public。不过在实现接口时必须把方法声明为public；所有静态常量的类型默认是public static final类型，可以不提供关键字public static final。</p>
<p>每个类只能有一个父类，但可以有多个接口。</p>
<blockquote>
<p>Java和C++的不同：</p>
<p>Java只允许有一个父类，C++可以有多个父类。</p>
<p>Java和C++都有抽象类的概念，但是C++中没有接口的概念。</p>
</blockquote>
<h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>可以为接口中的方法提供一个默认实现，方法是在方法上添加default修饰符。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式是一种用来创建代码块的简洁的方法。</p>
<p><strong>语法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(参数列表) -&gt; 表达式<br></code></pre></td></tr></table></figure>

<p>即使Lambda表达式没有参数，仍然要带有括号。</p>
<p>Lambda表达式的示例：</p>
<ol>
<li>无参数的Lambda表达式： () -&gt; System.out.println(“Hello, Lambda!”);</li>
<li>单个参数的Lambda表达式： (x) -&gt; System.out.println(“The value is: “ + x);</li>
<li>多个参数的Lambda表达式： (x, y) -&gt; { int sum &#x3D; x + y; System.out.println(“The sum is: “ + sum); };</li>
<li>Lambda表达式作为方法的参数： Arrays.asList(1, 2, 3, 4, 5).forEach(n -&gt; System.out.println(n));</li>
</ol>
<p>Lambda表达式中的变量必须是final或等效于final的（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html">final or effectively final</a>）。</p>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是一种特殊的接口，接口内部除静态方法、默认方法、静态常量外只有一个抽象类。</p>
<p>只有函数式接口才能使用Lambda表达式。</p>
<p>在Java中，使用@FunctionalInterface注解来标记一个接口为函数式接口，这样编译器就可以检查这个接口是否符合函数式接口的要求（即只有一个抽象方法）。</p>
<h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>Java方法引用是一种Lambda表达式的简化写法，它可以直接引用已有Java方法来替代Lambda表达式。</p>
<p>使用方法是，通过::操作符将一个已有方法的引用赋值给一个函数式接口变量，从而创建一个方法引用。</p>
<p> Java 中 4 种不同方法的引用：</p>
<ol>
<li><p><strong>构造器引用：</strong>它的语法是Class::new，或者更一般的Class&lt; T &gt;::new实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> Car.create( Car::<span class="hljs-keyword">new</span> ); <br><span class="hljs-keyword">final</span> List&lt; Car &gt; cars = Arrays.asList( car );<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>静态方法引用：</strong>它的语法是Class::static_method，实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cars.forEach( Car::collide );<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>特定类的任意对象的方法引用：</strong>它的语法是Class::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">cars.forEach( Car::repair );<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>特定对象的方法引用：</strong>它的语法是instance::method实例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">Car</span> <span class="hljs-variable">police</span> <span class="hljs-operator">=</span> Car.create( Car::<span class="hljs-keyword">new</span> ); <br>cars.forEach( police::follow );<br></code></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br>    <span class="hljs-comment">//Supplier是jdk1.8的接口，这里和lamda一起使用了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Car <span class="hljs-title function_">create</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Supplier&lt;Car&gt; supplier)</span> &#123;<br>        <span class="hljs-keyword">return</span> supplier.get();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">collide</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Car car)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Collided &quot;</span> + car.toString());<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Car another)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Following the &quot;</span> + another.toString());<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">repair</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Repaired &quot;</span> + <span class="hljs-built_in">this</span>.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包（Closure）指的是一个函数（或者方法），可以引用到自己作用域以外的变量。</p>
<p>Java中的Lambda表达式是闭包，Lambda表达式可以引用其作用域之外的变量，不过，Lambda表达式中引用的作用域外的变量不能被改变。</p>
<h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>内部类（inner class）是定义在类中类。</p>
<p>内部类的分类：</p>
<p><img src="https://www.tutorialspoint.com/java/images/inner_classes.jpg" alt="内部类的分类"></p>
<ul>
<li>非静态的<ul>
<li>Inner Classes：非静态内部类，又称成员内部类</li>
<li>Method Local Inner Classes：方法方法局部内部类</li>
<li>Annonymous Inner Classes：匿名内部类</li>
</ul>
</li>
<li>静态的（类的前面多了一个关键字static）<ul>
<li>Static Nested Classes：静态内部类</li>
</ul>
</li>
</ul>
<h2 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a><a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/java-inner-class-intro.html">非静态内部类</a></h2><p><strong>访问成员的规则</strong></p>
<ul>
<li><p>非静态内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。当非静态内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是非静态内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.<span class="hljs-built_in">this</span>.成员变量<br>外部类.<span class="hljs-built_in">this</span>.成员方法<br></code></pre></td></tr></table></figure>
</li>
<li><p>在外部类中如果要访问非静态内部类的成员，必须先创建一个非静态内部类的对象，再通过指向这个对象的引用来访问。</p>
</li>
</ul>
<p><strong>创建的方法</strong></p>
<p>非静态内部类是依附外部类而存在的，也就是说，如果要创建非静态内部类的对象，前提是必须存在一个外部类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一种方式：</span><br><span class="hljs-type">Outter</span> <span class="hljs-variable">outter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outter</span>();<br>Outter.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outter.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();  <span class="hljs-comment">//必须通过Outter对象来创建</span><br></code></pre></td></tr></table></figure>

<p><strong>访问权限修饰</strong></p>
<p>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。比如上面的例子，如果非静态内部类 Inner 用 private 修饰，则只能在外部类的内部访问，如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p><strong>访问成员的规则</strong></p>
<ul>
<li>静态内部类可以直接访问外部类的静态成员。如果要访问外部类的实例成员，需要通过外部类的实例去访问。</li>
<li>外部类以外的其他类需要通过完整的类名访问静态内部类中的静态成员。如果要访问静态内部类中的实例成员，则需要通过静态内部类的实例。</li>
</ul>
<p><strong>创建的方法</strong></p>
<p>在创建静态内部类的实例时，不需要创建外部类的实例。</p>
<h2 id="方法局部内部类"><a href="#方法局部内部类" class="headerlink" title="方法局部内部类"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1028.html">方法局部内部类</a></h2><p>方法局部内部类是定义在一个方法或者一个作用域里面的类。方法局部内部类只在当前方法中有效。</p>
<p><strong>实现规则</strong></p>
<ol>
<li>方法局部内部类中不能定义 static 成员。</li>
<li>方法局部内部类与局部变量一样，不能使用访问控制修饰符（public、private 和 protected）和 static 修饰符修饰。</li>
<li>方法局部内部类中还可以包含内部类，但是这些内部类也不能使用访问控制修饰符（public、private 和 protected）和 static 修饰符修饰。</li>
</ol>
<p><strong>访问成员的规则</strong></p>
<ul>
<li><p>方法局部内部类只可以访问<strong>当前方法</strong>中 final 类型的参数与变量。</p>
<p>在方法局部内部类中可以访问<strong>外部类</strong>的所有成员。如果方法中的成员与外部类中的成员同名，则可以使用 &lt;OuterClassName&gt;.this.&lt;MemberName&gt; 的形式访问外部类中的成员。</p>
</li>
</ul>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1031.html">匿名内部类</a></h2><p>匿名类是指没有类名的内部类，必须在创建时使用 new 语句来声明类。其语法形式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> &lt;类或接口&gt;() &#123;<br>    <span class="hljs-comment">// 类的主体</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<p>匿名内部类不能是静态的。</p>
<p><strong>实现方法</strong></p>
<p>匿名类有两种实现方式：</p>
<ul>
<li>继承一个类，重写其方法。</li>
<li>实现一个接口（可以是多个），实现其方法。</li>
</ul>
<p><strong>访问成员的规则</strong></p>
<ul>
<li><p>如果匿名类位于一个方法中，则匿名类只能访问方法中 final 类型的局部变量。</p>
<p>匿名内部类可以访问外部类的所有成员。</p>
</li>
</ul>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常有两种类型：检查型（checked）异常和非检查型（unchecked）异常。检查型异常是指程序在编译时必须处理的异常，也称为受检异常。非检查型异常是指程序在运行时才能发现的异常，也称为运行时异常。</p>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>将List转为数组可以使用toArray()方法。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li>凯·S. 霍斯特曼. Java核心技术:原书第12版. 卷一, 开发基础. –北京: 机械工业出版社. 2022.5.</li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html">https://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io">Song Baoru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io/2023/05/02/Java%E5%9F%BA%E7%A1%80/">https://songbaoru.github.io/2023/05/02/Java%E5%9F%BA%E7%A1%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80/">java基础</a></div><div class="post_share"><div class="social-share" data-image="https://th.bing.com/th/id/R.938bed6fc39fc253a7cd36e5481b79c0?rik=Y2Po9N8cpCfjDg&amp;riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_12064_1.jpg&amp;ehk=14nQEbT9IJH%2frqdvkztI9ztPhTEGaionf87iHCQxaz8%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2023/05/03/JVM%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" title="JVM底层原理"><img class="cover" src="https://th.bing.com/th/id/R.22f11d40e255acfdd79725639136d216?rik=6sX7IVmauPHLHA&amp;riu=http%3a%2f%2fup.deskcity.org%2fpic_360%2f202010%2fsl%2forx1oja4chp1120.jpg&amp;ehk=AmTg0CepawJWQDpxVYKxNFtBAxg0bJf830W5BvMPyl4%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">JVM底层原理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Song Baoru</div><div class="author-info__description">锲而不舍，金石可镂</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SongBaoru"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E4%B8%ADScanner%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8AnextLine%E5%92%8CnextInt%E7%AD%89%E6%B7%B7%E7%94%A8%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3"><span class="toc-number">1.</span> <span class="toc-text">JAVA中Scanner的使用及nextLine和nextInt等混用报错问题解决</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Scanner%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">Scanner常用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.</span> <span class="toc-text">常见问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">解决方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">2.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">2.1.</span> <span class="toc-text">字节流和字符流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">2.2.</span> <span class="toc-text">节点流和处理流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E6%8A%80%E6%9C%AF"><span class="toc-number">2.3.</span> <span class="toc-text">内存映射文件技术</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text">8种基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">3.2.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">大数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">位移运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch%E8%AF%AD%E5%8F%A5"><span class="toc-number">4.3.</span> <span class="toc-text">switch语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.4.</span> <span class="toc-text">数值类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0Math"><span class="toc-number">4.5.</span> <span class="toc-text">数学函数Math</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB"><span class="toc-number">5.</span> <span class="toc-text">对象与类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.</span> <span class="toc-text">面向对象编程的概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.2.</span> <span class="toc-text">类之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0"><span class="toc-number">5.3.</span> <span class="toc-text">方法参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">5.4.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">包装器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">5.6.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">5.7.</span> <span class="toc-text">枚举类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cloneable"><span class="toc-number">5.8.</span> <span class="toc-text">Cloneable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">6.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#final%E7%B1%BB%E5%92%8Cfinal%E6%96%B9%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">final类和final方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#protected%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">protected访问修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%86%E7%9B%96"><span class="toc-number">6.3.</span> <span class="toc-text">覆盖</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">7.</span> <span class="toc-text">Object类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#equals%E6%96%B9%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text">equals方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashCode%E6%96%B9%E6%B3%95"><span class="toc-number">7.2.</span> <span class="toc-text">hashCode方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getClass%E6%96%B9%E6%B3%95"><span class="toc-number">7.3.</span> <span class="toc-text">getClass方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">7.4.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">7.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">7.4.2.</span> <span class="toc-text">反射机制的核心类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Class%E7%B1%BB"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">Class类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Constructor"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">Constructor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Method"><span class="toc-number">7.4.2.3.</span> <span class="toc-text">Method</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Field"><span class="toc-number">7.4.2.4.</span> <span class="toc-text">Field</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Modifier"><span class="toc-number">7.4.2.5.</span> <span class="toc-text">Modifier</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.4.3.</span> <span class="toc-text">反射的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JDBC-%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">7.4.3.1.</span> <span class="toc-text">JDBC 的数据库的连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spring-%E6%A1%86%E6%9E%B6%E7%9A%84IoC"><span class="toc-number">7.4.3.2.</span> <span class="toc-text">Spring 框架的IoC</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86"><span class="toc-number">7.5.</span> <span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">7.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BB"><span class="toc-number">7.5.2.</span> <span class="toc-text">代理机制的核心类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.5.3.</span> <span class="toc-text">代理的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E5%92%8C%E5%8F%8D%E5%B0%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.6.</span> <span class="toc-text">代理和反射的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E5%92%8C%E7%89%B9%E6%80%A7"><span class="toc-number">8.1.</span> <span class="toc-text">定位和特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">8.2.</span> <span class="toc-text">默认方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">8.3.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">8.4.</span> <span class="toc-text">函数式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8"><span class="toc-number">8.5.</span> <span class="toc-text">方法引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">8.6.</span> <span class="toc-text">闭包</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">非静态内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.3.</span> <span class="toc-text">方法局部内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">9.4.</span> <span class="toc-text">匿名内部类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">10.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">12.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#List"><span class="toc-number">12.1.</span> <span class="toc-text">List</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Reference"><span class="toc-number">13.</span> <span class="toc-text">Reference</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/RocketMQ/" title="RocketMQ"><img src="https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJlbKx9CIKZ-qABs7mJV2aP0AALH5ALBgd0AGzuw770.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/2023/05/24/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2023-05-24T08:13:44.000Z" title="Created 2023-05-24 16:13:44">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img src="https://th.bing.com/th/id/OIP.fekfR1FWtn_EXSMaueufagHaEK?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud">Spring Cloud</a><time datetime="2023-05-24T08:08:42.000Z" title="Created 2023-05-24 16:08:42">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程"><img src="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&amp;riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&amp;ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程"/></a><div class="content"><a class="title" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程">Java并发编程</a><time datetime="2023-05-07T13:39:13.000Z" title="Created 2023-05-07 21:39:13">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://th.bing.com/th/id/R.826fae185d03cd7935cc5haf1cd1844c3?rik=9ONAxF3s06zoPg&amp;riu=http%3a%2f%2fpic5.bbzhi.com%2ffengjingbizhi%2fgaoqingziranfengjingbizhi%2fgaoqingziranfengjingbizhi_415690_15.jpg&amp;ehk=BbD3V6XWzCc5AJ7yXlMt4j5AU09Nk56syRdeDXFSvYY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-05-07T13:37:05.000Z" title="Created 2023-05-07 21:37:05">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/06/MyBatis/" title="MyBatis"><img src="https://th.bing.com/th/id/R.f30d1b50c29ba7f0e12424fbbf0551ca?rik=hnAxT1tmhc0F6w&amp;riu=http%3a%2f%2fpic1.nipic.com%2f2008-12-08%2f2008128103444133_2.jpg&amp;ehk=qaYhQ%2bunO6OW2e3CpMr0hG1F0%2fDwzdUsf6rpZ9plC5Y%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis"/></a><div class="content"><a class="title" href="/2023/05/06/MyBatis/" title="MyBatis">MyBatis</a><time datetime="2023-05-06T03:04:46.000Z" title="Created 2023-05-06 11:04:46">2023-05-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Song Baoru</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>