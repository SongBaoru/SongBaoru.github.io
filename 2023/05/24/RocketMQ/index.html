<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>RocketMQ | SBR Blog</title><meta name="author" content="Song Baoru"><meta name="copyright" content="Song Baoru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="RocketMQ简介RocketMQ是一款由Alibaba研发的分布式的消息中间件。支持事务消息、顺序消息、延时消息、定时消息、批量消息。 Apache RocketMQ 中消息的生命周期主要分为消息生产、消息存储、消息消费这三部分。生产者生产消息并发送至 Apache RocketMQ 服务端（Broker），消息被存储在Broker的主题（Topic）中，主题内可以有多个消费队列，消费者通过订">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ">
<meta property="og:url" content="https://songbaoru.github.io/2023/05/24/RocketMQ/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:description" content="RocketMQ简介RocketMQ是一款由Alibaba研发的分布式的消息中间件。支持事务消息、顺序消息、延时消息、定时消息、批量消息。 Apache RocketMQ 中消息的生命周期主要分为消息生产、消息存储、消息消费这三部分。生产者生产消息并发送至 Apache RocketMQ 服务端（Broker），消息被存储在Broker的主题（Topic）中，主题内可以有多个消费队列，消费者通过订">
<meta property="og:locale">
<meta property="og:image" content="https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJlbKx9CIKZ-qABs7mJV2aP0AALH5ALBgd0AGzuw770.jpg">
<meta property="article:published_time" content="2023-05-24T08:13:44.000Z">
<meta property="article:modified_time" content="2023-07-03T01:20:13.865Z">
<meta property="article:author" content="Song Baoru">
<meta property="article:tag" content="RocketMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJlbKx9CIKZ-qABs7mJV2aP0AALH5ALBgd0AGzuw770.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://songbaoru.github.io/2023/05/24/RocketMQ/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'RocketMQ',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-03 09:20:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SBR Blog"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">SBR Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">RocketMQ</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-24T08:13:44.000Z" title="Created 2023-05-24 16:13:44">2023-05-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-07-03T01:20:13.865Z" title="Updated 2023-07-03 09:20:13">2023-07-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/IT/">IT</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">11.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>34min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="RocketMQ"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="RocketMQ简介"><a href="#RocketMQ简介" class="headerlink" title="RocketMQ简介"></a>RocketMQ简介</h1><p>RocketMQ是一款由Alibaba研发的分布式的消息中间件。支持事务消息、顺序消息、延时消息、定时消息、批量消息。</p>
<p>Apache RocketMQ 中消息的生命周期主要分为消息生产、消息存储、消息消费这三部分。生产者生产消息并发送至 Apache RocketMQ 服务端（Broker），消息被存储在Broker的主题（Topic）中，主题内可以有多个消费队列，消费者通过订阅主题消费消息。</p>
<h1 id="消息中间件的应用场景"><a href="#消息中间件的应用场景" class="headerlink" title="消息中间件的应用场景"></a>消息中间件的应用场景</h1><p>消息中间件常用于分布式系统中的应用解耦、流量削峰填谷、异步处理等场景。比如，再秒杀业务中，在秒杀业务中下单后可以发送延迟消息，若5分钟未支付，就取消订单、回滚库存。</p>
<p>消息队列的应用场景：</p>
<ol>
<li>应用解耦：系统的耦合度越高，容错性就越低。在等待系统恢复正常的时间里，要处理的数据可以被缓存到消息队列中。</li>
<li>流量削峰填谷：消息到加入消息队列而不是直接发给消费者，消费者按照自己的消费速度从消息队列获取消息进行处理。</li>
<li>异步处理：不需要同步处理完成后才能响应，由消息队列缓存消息后续通知消息接收方进行异步处理，提高了响应效率。</li>
</ol>
<h1 id="模型概念"><a href="#模型概念" class="headerlink" title="模型概念"></a>模型概念</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ul>
<li><p>Broker</p>
<p>Broker是Apache RocketMQ的服务端，生产者生产的消息会发送到 Broker，并存储在Broker的主题（Topic）中。</p>
</li>
<li><p>NameServer</p>
<p>NameServer是Broker注册中心，支持Broker的注册和发现、Topic路由、Broker心跳检测。</p>
<p>NameServer通常采用集群的方式部署，各实例间互相不进行通信，Broker会向每一台NameServer注册，所以每一个NameServer都保存一份完整的路由信息，当某个NameServer下线了，Broker依然可以向其它的NameServer注册。</p>
</li>
</ul>
<h2 id="消息生产"><a href="#消息生产" class="headerlink" title="消息生产"></a><strong>消息生产</strong></h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/04producer">生产者（Producer）</a>：</p>
<p>Apache RocketMQ 中用于产生消息的运行实体，一般集成于业务调用链路的上游。生产者是轻量级匿名无身份的。</p>
</li>
</ul>
<h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a><strong>消息存储</strong></h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/02topic">主题（Topic）</a>：</p>
<p>Apache RocketMQ 消息传输和存储的分组容器，主题内部由多个队列组成，消息的存储和水平扩展实际是通过主题内的队列实现的。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/03messagequeue">队列（MessageQueue）</a>：</p>
<p>Apache RocketMQ 消息传输和存储的实际单元容器，类比于其他消息队列中的分区。 Apache RocketMQ 通过流式特性的无限队列结构来存储消息，消息在队列内具备顺序性存储特征。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/04message">消息（Message）</a>：</p>
<p>Apache RocketMQ 的最小传输单元。消息具备不可变性，在初始化发送和完成存储后即不可变。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/introduction/02concepts#messagetype">队列类型（MessageType）</a>：</p>
<p>由用于类型管理和安全验证的消息传输特性定义的类别。Apache RocketMQ支持NORMAL、FIFO、TRANSACTION和DELAY消息类型。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/introduction/02concepts#messageview">消息视图（MessageView）</a>：</p>
<p>从开发的角度来看，MessageView 是消息的只读接口。消息视图允许读取消息中的多个属性和负载信息，但不能对消息本身进行任何更改。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/introduction/02concepts#messagetag">消息标签（MessageTag）</a>：</p>
<p>MessageTag是一个细粒度的消息分类属性，允许在主题级别以下对消息进行细分。消费者通过订阅特定标签来实现消息过滤。</p>
</li>
</ul>
<h2 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a><strong>消息消费</strong></h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/07consumergroup">消费者分组（ConsumerGroup）</a>：</p>
<p>Apache RocketMQ 发布订阅模型中定义的独立的消费身份分组，用于统一管理底层运行的多个消费者（Consumer）。同一个消费组的多个消费者必须保持消费逻辑和配置一致，共同分担该消费组订阅的消息，实现消费能力的水平扩展。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/08consumer">消费者（Consumer）</a>：</p>
<p>Apache RocketMQ 消费消息的运行实体，一般集成在业务调用链路的下游。消费者必须被指定到某一个消费组中。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/09subscription">订阅关系（Subscription）</a>：</p>
<p>Apache RocketMQ 发布订阅模型中消息过滤、重试、消费进度的规则配置。订阅关系以消费组粒度进行管理，消费组通过定义订阅关系控制指定消费组下的消费者如何实现消息过滤、消费重试及消费进度恢复等。</p>
<p>Apache RocketMQ 的订阅关系除过滤表达式之外都是持久化的，即服务端重启或请求断开，订阅关系依然保留。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E6%B6%88%E8%B4%B9%E7%BB%93%E6%9E%9Cconsumeresult">消费结果（ConsumeResult）</a></p>
<p>Apache RocketMQ 中PushConsumer消费监听器处理消息完成后返回的处理结果，用来标识本次消息是否正确处理。消费结果包含消费成功和消费失败。</p>
</li>
</ul>
<h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/01normalmessage">普通消息</a></p>
<p>普通消息为 Apache RocketMQ 中最基础的消息，区别于有特性的顺序消息、定时&#x2F;延时消息和事务消息。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">事务消息</a></p>
<p>事务消息是Apache RocketMQ 提供的一种高级消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E5%AE%9A%E6%97%B6%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF">定时&#x2F;延时消息</a></p>
<p>定时&#x2F;延时消息是Apache RocketMQ 提供的一种高级消息类型，消息被发送至服务端后，在指定时间后才能被消费者消费。通过设置一定的定时时间可以实现分布式场景的延时调度触发效果。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF">顺序消息</a></p>
<p>顺序消息是Apache RocketMQ 提供的一种高级消息类型，支持消费者按照发送消息的先后顺序获取消息，从而实现业务场景中的顺序处理。</p>
</li>
</ul>
<h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4">消息过滤</a></p>
<p>消费者可以通过订阅指定消息标签（Tag）对消息进行过滤，确保最终只接收被过滤后的消息合集。过滤规则的计算和匹配在Apache RocketMQ 的服务端完成。更多信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/07messagefilter">消息过滤</a>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E9%87%8D%E7%BD%AE%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9">重置消费位点</a></p>
<p>以时间轴为坐标，在消息持久化存储的时间范围内，重新设置消费者分组对已订阅主题的消费进度，设置完成后消费者将接收设定时间点之后，由生产者发送到Apache RocketMQ 服务端的消息。更多信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/09consumerprogress">重置消费位点</a>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E6%B6%88%E6%81%AF%E8%BD%A8%E8%BF%B9">消息轨迹</a></p>
<p>在一条消息从生产者发出到消费者接收并处理过程中，由各个相关节点的时间、地点等数据汇聚而成的完整链路信息。通过消息轨迹，您能清晰定位消息从生产者发出，经由Apache RocketMQ 服务端，投递给消费者的完整链路，方便定位排查问题。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF">消息堆积</a></p>
<p>生产者已经将消息发送到Apache RocketMQ 的服务端，但由于消费者的消费能力有限，未能在短时间内将所有消息正确消费掉，此时在服务端保存着未被消费的消息，该状态即消息堆积。</p>
</li>
</ul>
<h1 id="消息类型原理"><a href="#消息类型原理" class="headerlink" title="消息类型原理"></a>消息类型原理</h1><h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/01normalmessage">普通消息</a></h2><p><strong>应用场景</strong></p>
<p>普通消息一般应用于微服务解耦、事件驱动、数据集成等场景，这些场景大多数要求数据传输通道具有可靠传输的能力，且对消息的处理时机、处理顺序没有特别要求。</p>
<p>普通消息仅支持使用MessageType为Normal主题，即普通消息只能发送至类型为普通消息的主题中，发送的消息的类型必须和主题的类型一致。</p>
<p><strong>普通消息生命周期</strong></p>
<ul>
<li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li>
<li>待消费：消息被发送到服务端，对消费者可见，等待消费者消费的状态。</li>
<li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，Apache RocketMQ会对消息进行重试处理。具体信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/10consumerretrypolicy">消费重试</a>。</li>
<li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。 Apache RocketMQ默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li>
<li>消息删除：Apache RocketMQ按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。更多信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/11messagestorepolicy">消息存储和清理机制</a>。</li>
</ul>
<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/03fifomessage">顺序消息</a></h2><p>顺序消息是 Apache RocketMQ 提供的一种高级消息类型，支持消费者按照发送消息的先后顺序获取消息，从而实现业务场景中的顺序处理。 相比其他类型消息，顺序消息在发送、存储和投递的处理过程中，更多强调多条消息间的先后顺序关系。</p>
<p>Apache RocketMQ 顺序消息的顺序关系通过消息组（MessageGroup）判定和识别，发送顺序消息时需要为每条消息设置归属的消息组，相同消息组的多条消息之间遵循先进先出的顺序关系，不同消息组、无消息组的消息之间不涉及顺序性。</p>
<p>基于消息组的顺序判定逻辑，支持按照业务逻辑做细粒度拆分，可以在满足业务局部顺序的前提下提高系统的并行度和吞吐能力。</p>
<p>顺序消息仅支持使用MessageType为FIFO的主题，即顺序消息只能发送至类型为顺序消息的主题中，发送的消息的类型必须和主题的类型一致。</p>
<p><strong>应用场景</strong></p>
<p>在有序事件处理、撮合交易、数据实时增量同步等场景下，异构系统间需要维持强一致的状态同步，上游的事件变更需要按照顺序传递到下游进行处理。在这类场景下使用 Apache RocketMQ 的顺序消息可以有效保证数据传输的顺序性。</p>
<ul>
<li><p><strong>典型场景一：撮合交易</strong></p>
<p>以证券、股票交易撮合场景为例，对于出价相同的交易单，坚持按照先出价先交易的原则，下游处理订单的系统需要严格按照出价顺序来处理订单。</p>
</li>
<li><p><strong>典型场景二：数据实时增量同步</strong></p>
<p>以数据库变更增量同步场景为例，上游源端数据库按需执行增删改操作，将二进制操作日志作为消息，通过 Apache RocketMQ 传输到下游搜索系统，下游系统按顺序还原消息数据，实现状态数据按序刷新。如果是普通消息则可能会导致状态混乱，和预期操作结果不符，基于顺序消息可以实现下游状态和上游操作结果一致。</p>
</li>
</ul>
<p><strong>如何保证消息的顺序性</strong></p>
<p>Apache RocketMQ 的消息的顺序性分为两部分，生产顺序性和消费顺序性。</p>
<ul>
<li><p><strong>生产顺序性</strong> ：</p>
<p>Apache RocketMQ 通过生产者和服务端的协议保障单个生产者串行地发送消息，并按序存储和持久化。</p>
<p>如需保证消息生产的顺序性，则必须满足以下条件：</p>
<ul>
<li>单一生产者：消息生产的顺序性仅支持单一生产者，不同生产者分布在不同的系统，即使设置相同的消息组，不同生产者之间产生的消息也无法判定其先后顺序。</li>
<li>串行发送：Apache RocketMQ 生产者客户端支持多线程安全访问，但如果生产者使用多线程并行发送，则不同线程间产生的消息将无法判定其先后顺序。</li>
</ul>
<p>满足以上条件的生产者，将顺序消息发送至 Apache RocketMQ 后，会保证设置了同一消息组的消息，按照发送顺序存储在同一队列中。服务端顺序存储逻辑如下：</p>
<ul>
<li>相同消息组的消息按照先后顺序被存储在同一个队列。</li>
<li>不同消息组的消息可以混合在同一个队列中，且不保证连续。</li>
</ul>
<p><img src="https://rocketmq.apache.org/zh/assets/images/fifomessagegroup-aad0a1b7e64089075db956c0eca0cbf4.png" alt="顺序存储逻辑"></p>
</li>
</ul>
<p>如上图所示，消息组1和消息组4的消息混合存储在队列1中， Apache RocketMQ 保证消息组1中的消息G1-M1、G1-M2、G1-M3是按发送顺序存储，且消息组4的消息G4-M1、G4-M2也是按顺序存储，但消息组1和消息组4中的消息不涉及顺序关系。</p>
<ul>
<li><p><strong>消费顺序性</strong> ：</p>
<p>Apache RocketMQ 通过消费者和服务端的协议保障消息消费严格按照存储的先后顺序来处理。</p>
<p>如需保证消息消费的顺序性，则必须满足以下条件：</p>
<ul>
<li><p>投递顺序</p>
<p>Apache RocketMQ 通过客户端SDK和服务端通信协议保障消息按照服务端存储顺序投递，但业务方消费消息时需要严格按照接收—处理—应答的语义处理消息，避免因异步处理导致消息乱序。</p>
<p>备注：消费者类型为PushConsumer时， Apache RocketMQ 保证消息按照存储顺序一条一条投递给消费者，若消费者类型为SimpleConsumer，则消费者有可能一次拉取多条消息。此时，消息消费的顺序性需要由业务方自行保证。消费者类型的具体信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/06consumertype">消费者分类</a>。</p>
</li>
<li><p>有限重试</p>
<p>Apache RocketMQ 顺序消息投递仅在重试次数限定范围内，即一条消息如果一直重试失败，超过最大重试次数后将不再重试，跳过这条消息消费，不会一直阻塞后续消息处理。</p>
<p>对于需要严格保证消费顺序的场景，请务设置合理的重试次数，避免参数不合理导致消息乱序。</p>
</li>
</ul>
</li>
</ul>
<p><strong>生产顺序性和消费顺序性组合</strong></p>
<p>如果消息需要严格按照先进先出（FIFO）的原则处理，即先发送的先消费、后发送的后消费，则必须要同时满足生产顺序性和消费顺序性。</p>
<p>一般业务场景下，同一个生产者可能对接多个下游消费者，不一定所有的消费者业务都需要顺序消费，您可以将生产顺序性和消费顺序性进行差异化组合，应用于不同的业务场景。例如发送顺序消息，但使用非顺序的并发消费方式来提高吞吐能力。</p>
<p><strong>顺序消息生命周期</strong></p>
<p><a href="/2023/05/24/RocketMQ/#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage">事务消息</a></h2><p>Apache RocketMQ 提供的事务消息支持在分布式场景下保障消息的最终一致性。</p>
<p><strong>其它事务消息的处理方案</strong></p>
<ul>
<li><p><strong>传统XA事务方案：性能不足</strong></p>
<p>为了保证分支的执行结果一致性，典型方案是基于XA协议的分布式事务系统来实现。将多个调用分支封装成包含独立事务分支的大事务。基于XA分布式事务的方案可以满足业务处理结果的正确性，但最大的缺点是多分支环境下资源锁定范围大，并发度低，随着下游分支的增加，系统性能会越来越差。</p>
</li>
</ul>
<p><strong>事务消息处理流程</strong></p>
<p>事务消息交互流程如下图所示。<img src="https://rocketmq.apache.org/zh/assets/images/transflow-0b07236d124ddb814aeaf5f6b5f3f72c.png" alt="事务消息"></p>
<ol>
<li>生产者将消息发送至Apache RocketMQ服务端。</li>
<li>Apache RocketMQ服务端将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息被标记为”暂不能投递”，这种状态下的消息即为<strong>半事务消息</strong>。</li>
<li>生产者开始执行本地事务逻辑。</li>
<li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：<ul>
<li>二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li>
<li>二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li>
</ul>
</li>
<li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到生产者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。 <strong>说明</strong>：服务端回查的间隔时间和最大回查次数，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/03limits">参数限制</a>。</li>
<li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</li>
</ol>
<p><strong>事务消息生命周期</strong></p>
<ul>
<li>初始化：半事务消息被生产者构建并完成初始化，待发送到服务端的状态。</li>
<li><strong>事务待提交</strong>：半事务消息被发送到服务端，和普通消息不同，并不会直接被服务端持久化，而是会被单独存储到事务存储系统中，等待第二阶段本地事务返回执行结果后再提交。此时消息对下游消费者不可见。</li>
<li><strong>消息回滚</strong>：第二阶段如果事务执行结果明确为回滚，服务端会将半事务消息回滚，该事务消息流程终止。</li>
<li>（提交）待消费：第二阶段如果事务执行结果明确为提交，服务端会将半事务消息重新存储到普通存储系统中，此时消息对下游消费者可见，等待被消费者获取并消费。</li>
<li>消费中：<a href="/2023/05/24/RocketMQ/#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
<li>消费提交：<a href="/2023/05/24/RocketMQ/#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
<li>消息删除：<a href="/2023/05/24/RocketMQ/#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
</ul>
<h2 id="定时-x2F-延时消息"><a href="#定时-x2F-延时消息" class="headerlink" title="定时&#x2F;延时消息"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/02delaymessage">定时&#x2F;延时消息</a></h2><p>在分布式定时调度触发、任务超时处理等场景，需要实现精准、可靠的定时事件触发。使用 Apache RocketMQ 的定时消息可以简化定时调度任务的开发逻辑，实现高性能、可扩展、高可靠的定时触发能力。</p>
<ul>
<li>定时消息：例如，当前系统时间为2022-06-09 17:30:00，您希望消息在下午19:20:00定时投递，则定时时间为2022-06-09 19:20:00，转换成时间戳格式为1654773600000。</li>
<li>延时消息：例如，当前系统时间为2022-06-09 17:30:00，您希望延时1个小时后投递消息，则您需要根据当前时间和延时时长换算成定时时刻，即消息投递时间为2022-06-09 18:30:00，转换为时间戳格式为1654770600000。</li>
</ul>
<p>定时消息仅支持在 MessageType为Delay 的主题内使用，即定时消息只能发送至类型为定时消息的主题中，发送的消息的类型必须和主题的类型一致。</p>
<p><strong>应用场景</strong></p>
<ul>
<li><p><strong>典型场景一：分布式定时调度</strong></p>
<p>在分布式定时调度场景下，需要实现各类精度的定时任务，例如每天5点执行文件清理，每隔2分钟触发一次消息推送等需求。传统基于数据库的定时调度方案在分布式场景下，性能不高，实现复杂。基于 Apache RocketMQ 的定时消息可以封装出多种类型的定时触发器。</p>
</li>
<li><p><strong>典型场景二：任务超时处理</strong></p>
<p>以电商交易场景为例，订单下单后暂未支付，此时不可以直接关闭订单，而是需要等待一段时间后才能关闭订单。使用 Apache RocketMQ 定时消息可以实现超时任务的检查触发。</p>
</li>
</ul>
<p><strong>定时消息生命周期</strong></p>
<ul>
<li>初始化：<a href="/2023/05/24/RocketMQ/#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
<li><strong>定时中</strong>：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息单独存储在定时存储系统中，等待定时时刻到达。</li>
<li>待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对下游消费者可见，等待消费者消费的状态。</li>
<li>消费中：<a href="/2023/05/24/RocketMQ/#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
<li>消费提交：<a href="/2023/05/24/RocketMQ/#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
<li>消息删除：<a href="/2023/05/24/RocketMQ/#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
</ul>
<h1 id="消息处理原理"><a href="#消息处理原理" class="headerlink" title="消息处理原理"></a>消息处理原理</h1><h2 id="消息发送重试"><a href="#消息发送重试" class="headerlink" title="消息发送重试"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy">消息发送重试</a></h2><p>Apache RocketMQ 客户端连接服务端发起消息发送请求时，可能会因为网络故障、服务异常等原因导致调用失败。为保证消息的可靠性， Apache RocketMQ 在客户端SDK中内置请求重试逻辑，尝试通过重试发送达到最终调用成功的效果。</p>
<p>同步发送和异步发送模式均支持消息发送重试。</p>
<p> <strong>重试触发条件</strong></p>
<p>触发消息发送重试机制的条件包含调用失败、请求超时、连接失败或返回失败错误码，具体场景包含如下：</p>
<ul>
<li>客户端消息发送请求<strong>调用失败或请求超时</strong></li>
<li>网络异常造成<strong>连接失败</strong>或请求超时。</li>
<li>服务端节点处于重启或下线等状态造成连接失败。</li>
<li>服务端运行慢造成请求超时。</li>
<li>服务端<strong>返回失败错误码</strong><ul>
<li>系统逻辑错误：因运行逻辑不正确造成的错误。</li>
<li>系统流控错误：因容量超限造成的流控错误。</li>
</ul>
</li>
</ul>
<p>对于事务消息，只会进行<a target="_blank" rel="noopener" href="https://github.com/grpc/proposal/blob/master/A6-client-retries.md#transparent-retries">透明重试（transparent retries）</a>，请求超时或异常等场景不会进行重试。</p>
<h3 id="重试流程"><a href="#重试流程" class="headerlink" title="重试流程"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy#%E9%87%8D%E8%AF%95%E6%B5%81%E7%A8%8B">重试流程</a></h3><p>生产者在初始化时设置消息发送最大重试次数，当出现上述触发条件的场景时，生产者客户端会按照设置的重试次数一直重试发送消息，直到消息发送成功或达到最大重试次数重试结束，并在最后一次重试失败后返回调用错误响应。</p>
<ul>
<li>同步发送：调用线程会一直阻塞，直到某次重试成功或最终重试失败，抛出错误码和异常。</li>
<li>异步发送：调用线程不会阻塞，但调用结果会通过异常事件或者成功事件返回。</li>
</ul>
<h3 id="功能约束"><a href="#功能约束" class="headerlink" title="功能约束"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy#%E5%8A%9F%E8%83%BD%E7%BA%A6%E6%9D%9F">功能约束</a></h3><ul>
<li><strong>链路耗时阻塞评估</strong>：从上述重试机制可以看出，在重试流程中生产者仅能控制最大重试次数。若由于系统异常触发了SDK内置的重试逻辑，则服务端需要等待最终重试结果，可能会导致消息发送请求链路被阻塞。对于某些实时调用类场景，您需要合理评估每次调用请求的超时时间以及最大重试次数，避免影响全链路的耗时。</li>
<li><strong>最终异常兜底</strong>： Apache RocketMQ 客户端内置的发送请求重试机制并不能保证消息发送一定成功。当最终重试仍然失败时，业务方调用需要捕获异常，并做好冗余保护处理，避免消息发送结果不一致。</li>
<li><strong>消息重复问题</strong>：因远程调用的不确定性，当Apache RocketMQ客户端因请求超时触发消息发送重试流程，此时客户端无法感知服务端的处理结果，客户端进行的消息发送重试可能会产生消息重复问题，业务逻辑需要自行处理消息重复问题。</li>
</ul>
<h2 id="消息消费重试"><a href="#消息消费重试" class="headerlink" title="消息消费重试"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/10consumerretrypolicy">消息消费重试</a></h2><h3 id="消费重试策略概述"><a href="#消费重试策略概述" class="headerlink" title="消费重试策略概述"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/10consumerretrypolicy/#%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5%E6%A6%82%E8%BF%B0">消费重试策略概述</a></h3><p>消费重试指的是，消费者在消费某条消息失败后，Apache RocketMQ 服务端会根据重试策略重新消费该消息，超过一次定数后若还未消费成功，则该消息将不再继续重试，直接被发送到<strong>死信队列</strong>中。</p>
<p><strong>消息重试的触发条件</strong></p>
<ul>
<li>消费失败，包括消费者返回消息失败状态标识或抛出非预期异常。</li>
<li>消息处理超时，包括在PushConsumer中排队超时。</li>
</ul>
<p><strong>消息重试策略主要行为</strong></p>
<ul>
<li>重试过程状态机：控制消息在重试流程中的状态和变化逻辑。</li>
<li>重试间隔：上一次消费失败或超时后，下次重新尝试消费的间隔时间。</li>
<li>最大重试次数：消息可被重试消费的最大次数。</li>
</ul>
<h3 id="消费重试策略"><a href="#消费重试策略" class="headerlink" title="消费重试策略"></a>消费重试策略</h3><h4 id="PushConsumer"><a href="#PushConsumer" class="headerlink" title="PushConsumer"></a>PushConsumer</h4><p>PushConsumer消费消息时，消息的几个主要状态如下（重试状态机）：</p>
<ol>
<li><p>Ready：已就绪状态。消息在Apache RocketMQ服务端已就绪，可以被消费者消费。</p>
</li>
<li><p>Inflight：处理中状态。消息被消费者客户端获取，处于消费中还未返回消费结果的状态。</p>
</li>
<li><p>WaitingRetry：待重试状态，PushConsumer独有的状态。当消费者消息处理失败或消费超时，会触发消费重试逻辑判断。如果当前重试次数未达到最大次数，则该消息变为待重试状态，经过重试间隔后，消息将重新变为已就绪状态可被重新消费。多次重试之间，可通过重试间隔进行延长，防止无效高频的失败。</p>
</li>
<li><p>Commit：提交状态。消费成功的状态，消费者返回成功响应即可结束消息的状态机。</p>
</li>
<li><p>DLQ：死信状态。消费逻辑的最终兜底机制，若消息一直处理失败并不断进行重试，直到超过最大重试次数还未成功，此时消息不会再重试，会被投递至死信队列。您可以通过消费死信队列的消息进行业务恢复。</p>
</li>
</ol>
<p>消息重试过程中，每次重试消息状态都会经过已就绪&gt;处理中&gt;待重试的变化，两次消费间的间隔时间实际由消费耗时及重试间隔控制，消费耗时的最大上限受服务端系统参数控制，一般不应该超过上限时间。</p>
<h4 id="SimpleConsumer"><a href="#SimpleConsumer" class="headerlink" title="SimpleConsumer"></a>SimpleConsumer</h4><p><strong>重试状态机</strong></p>
<p>SimpleConsumer消费消息时，消息的几个主要状态如下：</p>
<ol>
<li><p>Ready：已就绪状态。消息在Apache RocketMQ服务端已就绪，可以被消费者消费。</p>
</li>
<li><p>Inflight：处理中状态。消息被消费者客户端获取，处于消费中还未返回消费结果的状态。</p>
</li>
<li><p>Commit：提交状态。消费成功的状态，消费者返回成功响应即可结束消息的状态机。</p>
</li>
<li><p>DLQ：死信状态。消费逻辑的最终兜底机制，若消息一直处理失败并不断进行重试，直到超过最大重试次数还未成功，此时消息不会再重试，会被投递至死信队列。您可以通过消费死信队列的消息进行业务恢复。</p>
</li>
</ol>
<h2 id="消息流控"><a href="#消息流控" class="headerlink" title="消息流控"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy">消息流控</a></h2><p>消息流控指的是系统容量或水位过高， Apache RocketMQ 服务端会通过<strong>快速失败</strong>返回流控错误来避免底层资源承受过高压力。</p>
<h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6">触发条件</a></h3><p>Apache RocketMQ 的消息流控触发条件如下：</p>
<ul>
<li>存储压力大：参考<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/09consumerprogress">消费进度管理</a>的原理机制，消费者分组的初始消费位点为当前队列的最大消费位点。若某些场景例如业务上新等需要回溯到指定时刻前开始消费，此时队列的存储压力会瞬间飙升，触发消息流控。</li>
<li>服务端请求任务排队溢出：若消费者消费能力不足，导致队列中有大量堆积消息，当堆积消息超过一定数量后会触发消息流控，减少下游消费系统压力。</li>
</ul>
<h3 id="流控行为"><a href="#流控行为" class="headerlink" title="流控行为"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy#%E6%B5%81%E6%8E%A7%E8%A1%8C%E4%B8%BA">流控行为</a></h3><p>当系统触发消息发送流控时，客户端会收到系统限流错误和异常，错误码信息如下：</p>
<ul>
<li>reply-code：530</li>
<li>reply-text：TOO_MANY_REQUESTS</li>
</ul>
<p>客户端收到系统流控错误码后，会根据指数退避策略进行消息发送重试。</p>
<p><strong><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy#%E5%A4%84%E7%90%86%E5%BB%BA%E8%AE%AE">处理建议</a></strong></p>
<ul>
<li>如何避免触发消息流控：触发限流的根本原因是系统容量或水位过高，您可以利用可观测性功能监控系统水位容量等，保证底层资源充足，避免触发流控机制。</li>
<li>突发消息流控处理：如果因为突发原因触发消息流控，且客户端内置的重试流程执行失败，则建议业务方将请求调用临时替换到其他系统进行应急处理。</li>
</ul>
<h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/07messagefilter">消息过滤</a></h2><h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/07messagefilter#%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0">功能概述</a></h3><p><strong>消息过滤定义</strong></p>
<p>过滤的含义指的是将符合条件的消息投递给消费者，而不是将匹配到的消息过滤掉。</p>
<p>Apache RocketMQ 的消息过滤功能通过生产者和消费者对消息的属性、标签进行定义，并在 Apache RocketMQ 服务端根据过滤条件进行筛选匹配，将符合条件的消息投递给消费者进行消费。</p>
<p>消息过滤主要解决的单个业务域即同一个主题内不同消息子集的过滤问题，一般是基于同一业务下更具体的分类进行过滤匹配。如果是需要对不同业务域的消息进行拆分，建议使用不同主题处理不同业务域的消息。</p>
<p><strong>消息过滤原理</strong></p>
<p>消息过滤主要通过以下几个关键流程实现：</p>
<ul>
<li>生产者：生产者在初始化消息时预先为消息设置一些属性和标签，用于后续消费时指定过滤目标。</li>
<li>消费者：消费者在初始化及后续消费流程中通过调用订阅关系注册接口，向服务端上报需要订阅指定主题的哪些消息，即过滤条件。</li>
<li>服务端：消费者获取消息时会触发服务端的动态过滤计算，Apache RocketMQ 服务端根据消费者上报的过滤条件的表达式进行匹配，并将符合条件的消息投递给消费者。</li>
</ul>
<h3 id="消息过滤分类"><a href="#消息过滤分类" class="headerlink" title="消息过滤分类"></a><strong>消息过滤分类</strong></h3><p>Apache RocketMQ 支持Tag标签过滤和SQL属性过滤。</p>
<ul>
<li><p>Tag标签过滤方式是生产者在发送消息时，设置消息的Tag标签，消费者需指定已有的Tag标签来进行匹配订阅。</p>
</li>
<li><p>SQL属性过滤方式是是生产者定义消息属性，消费者设置SQL过滤条件。生产者发送消息时可以自定义消息属性，每个属性都是一个自定义的键值对（Key-Value）。生产者在发送消息时可设置多个属性，消费者订阅时可设置SQL语法的过滤表达式过滤多个属性。</p>
</li>
</ul>
<h2 id="消费者负载均衡"><a href="#消费者负载均衡" class="headerlink" title="消费者负载均衡"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/08consumerloadbalance">消费者负载均衡</a></h2><p>消费者从 Apache RocketMQ 获取消息消费时，通过消费者负载均衡策略，可将主题内的消息分配给指定消费者分组中的多个消费者共同分担，提高消费并发能力和消费者的水平扩展能力。</p>
<h3 id="广播消费和共享消费"><a href="#广播消费和共享消费" class="headerlink" title="广播消费和共享消费"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/08consumerloadbalance#%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9%E5%92%8C%E5%85%B1%E4%BA%AB%E6%B6%88%E8%B4%B9">广播消费和共享消费</a></h3><p>在 Apache RocketMQ 领域模型中，同一条消息支持被多个消费者分组订阅，同时，对于每个消费者分组可以初始化多个消费者。</p>
<p>可以根据消费者分组和消费者的不同组合，实现以下两种不同的消费效果：</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/consumemode-74d53c59b3266f1f633b1392f5a0f279.png" alt="广播消费和共享消费"></p>
<ul>
<li><p><strong>消费组间广播消费</strong> ：如上图所示，每个消费者分组只初始化唯一一个消费者，每个消费者可消费到消费者分组内所有的消息，各消费者分组都订阅相同的消息，以此实现单客户端级别的广播一对多推送效果。</p>
<p>该方式一般可用于网关推送、配置推送等场景。</p>
</li>
<li><p><strong>消费组内共享消费</strong> ：如上图所示，每个消费者分组下初始化了多个消费者，这些消费者共同分担消费者分组内的所有消息，实现消费者分组内流量的水平拆分和均衡负载。</p>
<p>该方式一般可用于微服务解耦场景。</p>
</li>
</ul>
<h3 id="消费者负载均衡策略"><a href="#消费者负载均衡策略" class="headerlink" title="消费者负载均衡策略"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/08consumerloadbalance#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E8%B4%B9%E8%80%85%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">消费者负载均衡策略</a></h3><p>如上文所述，<strong>消费组间广播消费场景下，每个消费者分组内只有一个消费者，因此不涉及消费者的负载均衡。</strong></p>
<p><strong>消费组内共享消费场景</strong>下，消费者分组内多个消费者共同分担消息，消息按照哪种逻辑分配给哪个消费者，就是由消费者负载均衡策略所决定的。</p>
<p>根据消费者类型的不同，消费者负载均衡策略分为以下两种模式：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/08consumerloadbalance#section-x2b-2cu-gpf">消息粒度负载均衡</a>：PushConsumer和SimpleConsumer默认负载策略</li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/08consumerloadbalance#section-n9m-6xy-y77">队列粒度负载均衡</a>：PullConsumer默认负载策略</li>
</ul>
<h4 id="消息粒度负载均衡"><a href="#消息粒度负载均衡" class="headerlink" title="消息粒度负载均衡"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/08consumerloadbalance#%E6%B6%88%E6%81%AF%E7%B2%92%E5%BA%A6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">消息粒度负载均衡</a></h4><p><strong>策略原理</strong></p>
<p>消息粒度负载均衡策略中，同一消费者分组内的多个消费者将按照消息粒度平均分摊主题中的所有消息，即同一个队列中的消息，可被平均分配给多个消费者共同消费。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/clustermode-dfd781d08bc0c69111841bda537aa302.png" alt="消息粒度负载均衡策略"></p>
<p>如上图所示，消费者分组Group A中有三个消费者A1、A2和A3，这三个消费者将共同消费主题中同一队列Queue1中的多条消息。 </p>
<p><strong>注意</strong>：消息粒度负载均衡策略保证同一个队列的消息可以被多个消费者共同处理，但是该策略使用的消息分配算法结果是随机的，并不能指定消息被哪一个特定的消费者处理。</p>
<p>消息粒度的负载均衡机制，是基于内部的单条消息确认语义实现的。消费者获取某条消息后，服务端会将该消息加锁，保证这条消息对其他消费者不可见，直到该消息消费成功或消费超时。因此，即使多个消费者同时消费同一队列的消息，服务端也可保证消息不会被多个消费者重复消费。</p>
<p><strong>顺序消息负载机制</strong></p>
<p>在顺序消息中，消息的顺序性指的是同一消息组内的多个消息之间的先后顺序。因此，顺序消息场景下，消息粒度负载均衡策略还需要保证同一消息组内的消息，按照服务端存储的先后顺序进行消费。不同消费者处理同一个消息组内的消息时，会严格按照先后顺序锁定消息状态，确保同一消息组的消息串行消费。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/fifoinclustermode-60b2f917ab49333f93029cee178b13f0.png" alt="**顺序消息负载机制**"></p>
<p>如上图所述，队列Queue1中有4条顺序消息，这4条消息属于同一消息组G1，存储顺序由M1到M4。在消费过程中，前面的消息M1、M2被消费者Consumer A1处理时，只要消费状态没有提交，消费者A2是无法并行消费后续的M3、M4消息的，必须等前面的消息提交消费状态后才能消费后面的消息。</p>
<p><strong>策略特点</strong></p>
<p>相对于队列粒度负载均衡策略，消息粒度负载均衡策略有以下特点：</p>
<ul>
<li><p>消费分摊更均衡</p>
<p>传统队列级的负载均衡策略中，如果队列数量和消费者数量不均衡，则可能会出现部分消费者空闲，或部分消费者处理过多消息的情况。消息粒度负载均衡策略无需关注消费者和队列的相对数量，能够更均匀地分摊消息。</p>
</li>
<li><p>对非对等消费者更友好</p>
<p>对于线上生产环境，由于网络机房分区延迟、消费者物理资源规格不一致等原因，消费者的处理能力可能会不一致，如果按照队列分配消息，则可能出现部分消费者消息堆积、部分消费者空闲的情况。消息粒度负载均衡策略按需分配，消费者处理任务更均衡。</p>
</li>
<li><p>队列分配运维更方便</p>
<p>传统基于绑定队列的负载均衡策略，必须保证队列数量大于等于消费者数量，以免产生部分消费者获取不到队列出现空转的情况，而消息粒度负载均衡策略则无需关注队列数。</p>
</li>
</ul>
<p><strong>适用场景</strong></p>
<p>消息粒度消费负载均衡策略下，同一队列内的消息离散地分布于多个消费者，适用于绝大多数在线事件处理的场景。只需要基本的消息处理能力，对消息之间没有批量聚合的诉求。而对于流式处理、聚合计算场景，需要明确地对消息进行聚合、批处理时，更适合使用队列粒度的负载均衡策略。</p>
<h4 id="队列粒度负载均衡"><a href="#队列粒度负载均衡" class="headerlink" title="队列粒度负载均衡"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/08consumerloadbalance#%E9%98%9F%E5%88%97%E7%B2%92%E5%BA%A6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">队列粒度负载均衡</a></h4><p><strong>策略原理</strong></p>
<p>队列粒度负载均衡策略中，同一消费者分组内的多个消费者将按照队列粒度消费消息，即每个队列仅被一个消费者消费。</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/clusterqueuemode-ce4f88dc594c1237ba95db2fa9146b8c.png" alt="队列粒度负载均衡策略"></p>
<p>如上图所示，主题中的三个队列Queue1、Queue2、Queue3被分配给消费者分组中的两个消费者，每个队列只能分配给一个消费者消费，该示例中由于队列数大于消费者数，因此，消费者A2被分配了两个队列。若队列数小于消费者数量，可能会出现部分消费者无绑定队列的情况。</p>
<p>队列粒度的负载均衡，基于队列数量、消费者数量等运行数据进行统一的算法分配，将每个队列绑定到特定的消费者，然后每个消费者按照取消息&gt;提交消费位点&gt;持久化消费位点的消费语义处理消息，取消息过程不提交消费状态，因此，为了避免消息被多个消费者重复消费，每个队列仅支持被一个消费者消费。</p>
<p>备注：队列粒度负载均衡策略保证同一个队列仅被一个消费者处理，该策略的实现依赖消费者和服务端的信息协商机制，Apache RocketMQ 并不能保证协商结果完全强一致。因此，在消费者数量、队列数量发生变化时，可能会出现短暂的队列分配结果不一致，从而导致少量消息被重复处理。</p>
<p><strong>策略特点</strong></p>
<p>相对于消息粒度负载均衡策略，队列粒度负载均衡策略分配粒度较大，不够灵活。但该策略在流式处理场景下有天然优势，能够保证同一队列的消息被相同的消费者处理，对于批量处理、聚合处理更友好。</p>
<p><strong>适用场景</strong></p>
<p>队列粒度负载均衡策略适用于流式计算、数据聚合等需要明确对消息进行聚合、批处理的场景。</p>
<h2 id="消费进度管理"><a href="#消费进度管理" class="headerlink" title="消费进度管理"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/09consumerprogress">消费进度管理</a></h2><h3 id="消息位点"><a href="#消息位点" class="headerlink" title="消息位点"></a><strong>消息位点</strong></h3><p>Apache RocketMQ 通过消费位点（Offset）管理消费进度。</p>
<p>参考 Apache RocketMQ <a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/02topic">主题</a>和<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/03messagequeue">队列</a>的定义，消息是按到达服务端的先后顺序存储在指定主题的多个队列中，每条消息在队列中都有一个唯一的Long类型坐标，这个坐标被定义为消息位点。</p>
<p>任意一个消息队列在<strong>逻辑上</strong>都是无限存储，即消息位点会从0到Long.MAX无限增加。通过主题、队列和位点就可以定位任意一条消息的位置。</p>
<p>Apache RocketMQ 定义队列中最早一条消息的位点为最小消息位点（MinOffset）；最新一条消息的位点为最大消息位点（MaxOffset）。虽然消息队列逻辑上是无限存储，但由于服务端物理节点的存储空间有限， Apache RocketMQ 会滚动删除队列中存储最早的消息。因此，消息的最小消费位点和最大消费位点会一直递增变化。 </p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/updateprogress-02d1a9de72aa4f72c3b1e1c6e03d2407.png" alt="消息位点"></p>
<h3 id="消费位点"><a href="#消费位点" class="headerlink" title="消费位点"></a><strong>消费位点</strong></h3><p>Apache RocketMQ 通过消费位点（ConsumerOffset）管理消息的消费进度。每条消息被某个消费者消费完成后不会立即在队列中删除，Apache RocketMQ 会基于每个消费者分组维护一份消费记录，该记录指定消费者分组消费某一个队列时，消费过的最新一条消息的位点，即消费位点。</p>
<p>当消费者客户端离线，又再次重新上线时，会严格按照服务端保存的消费进度继续处理消息。如果服务端保存的历史位点信息已过期被删除，此时消费位点向前移动至服务端存储的最小位点。</p>
<p>队列中消息位点MinOffset、MaxOffset和每个消费者分组的消费位点ConsumerOffset的关系如下：</p>
<p><img src="https://rocketmq.apache.org/zh/assets/images/consumerprogress1-07d9f77dd7e62f2250330ed36f36fe3c.png" alt="消费位点"></p>
<ul>
<li>ConsumerOffset≤MaxOffset：<ul>
<li>当消费速度和生产速度一致，且全部消息都处理完成时，最大消息位点和消费位点相同，即ConsumerOffset&#x3D;MaxOffset。</li>
<li>当消费速度较慢小于生产速度时，队列中会有部分消息未消费，此时消费位点小于最大消息位点，即ConsumerOffset&lt;MaxOffset，两者之差就是该队列中堆积的消息量。</li>
</ul>
</li>
<li>ConsumerOffset≥MinOffset：正常情况下有效的消费位点ConsumerOffset必然大于等于最小消息位点MinOffset。消费位点小于最小消息位点时是无效的，相当于消费者要消费的消息已经从队列中删除了，是无法消费到的，此时服务端会将消费位点强制纠正到合法的消息位点。</li>
</ul>
<p><strong>消费位点初始值</strong></p>
<p>消费位点初始值指的是消费者分组首次启动消费者消费消息时，服务端保存的消费位点的初始值。</p>
<p>Apache RocketMQ 定义消费位点的初始值为消费者首次获取消息时，该时刻队列中的最大消息位点。相当于消费者将从队列中最新的消息开始消费。</p>
<h3 id="重置消费位点"><a href="#重置消费位点" class="headerlink" title="重置消费位点"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/09consumerprogress#%E9%87%8D%E7%BD%AE%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9">重置消费位点</a></h3><p>若消费者分组的初始消费位点或当前消费位点不符合您的业务预期，可以通过重置消费位点调整消费进度。</p>
<p><strong>适用场景</strong></p>
<ul>
<li>初始消费位点不符合需求：因初始消费位点为当前队列的最大消息位点，即客户端会直接从最新消息开始消费。若业务上线时需要消费部分历史消息，您可以通过重置消费位点功能消费到指定时刻前的消息。</li>
<li>消费堆积快速清理：当下游消费系统性能不足或消费速度小于生产速度时，会产生大量堆积消息。若这部分堆积消息可以丢弃，您可以通过重置消费位点快速将消费位点更新到指定位置，绕过这部分堆积的消息，减少下游处理压力。</li>
<li>业务回溯，纠正处理：由于业务消费逻辑出现异常，消息被错误处理。若您希望重新消费这些已被处理的消息，可以通过重置消费位点快速将消费位点更新到历史指定位置，实现消费回溯。</li>
</ul>
<p><strong>重置功能</strong></p>
<p>Apache RocketMQ 的重置消费位点提供以下能力：</p>
<ul>
<li>重置到队列中的指定位点。</li>
<li>重置到某一时刻对应的消费位点，匹配位点时，服务端会根据自动匹配到该时刻最接近的消费位点。</li>
</ul>
<p><strong>使用限制</strong></p>
<ul>
<li>重置消费位点后消费者将直接从重置后的位点开始消费，对于回溯重置类场景，重置后的历史消息大多属于存储冷数据，可能会造成系统压力上升，一般称为冷读现象。因此，需要谨慎评估重置消费位点后的影响。建议严格控制重置消费位点接口的调用权限，避免无意义、高频次的消费位点重置。</li>
<li>Apache RocketMQ 重置消费位点功能只能重置对消费者可见的消息，不能重置定时中、重试等待中的消息。更多信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/02delaymessage">定时&#x2F;延时消息</a>和<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/10consumerretrypolicy">消费重试</a>。</li>
</ul>
<h1 id="消息存储原理"><a href="#消息存储原理" class="headerlink" title="消息存储原理"></a>消息存储原理</h1><h2 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a><strong>CommitLog</strong></h2><p>RocketMQ单个Broker实例下的所有队列共用一个日志数据文件（CommitLog）来存储。而Kafka采用的是独立型的存储结构，每个队列一个文件。</p>
<p>CommitLog的文件大小默认是1G（1G &#x3D; 1073741824byte），文件名是字节的起始偏移量，文件名长度是20位，左边补零。</p>
<h2 id="ConsumerQueue"><a href="#ConsumerQueue" class="headerlink" title="ConsumerQueue"></a><strong>ConsumerQueue</strong></h2><p>ConsumerQueue（逻辑消费队列）可以看成是基于Topic和QueueId的CommitLog索引文件，提供了一种可以通过Topic和QueueId来查询消息队列的方法。</p>
<p>由于RocketMQ是基于主题（Topic）的订阅模式，消息消费是针对主题进行的，如果遍历CommitLog文件，根据Topic检索消息是非常低效的。使用ConsumerQueue可以快速查找CommitLog中待消费的消息。</p>
<h2 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a><strong>IndexFile</strong></h2><p>IndexFile（索引文件）可以看成是基于Key或时间区间的CommitLog索引文件。提供了一种可以通过Key或时间区间来查询消息的方法。</p>
<h2 id="页缓存与内存映射"><a href="#页缓存与内存映射" class="headerlink" title="页缓存与内存映射"></a><strong>页缓存与内存映射</strong></h2><p>页缓存（Page Cache）是操作系统（OS）对文件的缓存，用于加速对文件的读写，实现原理是OS将一部分内存用作PageCache，对于数据的写入，OS会先写入Cache内，然后通过异步的方式将Cache内的数据刷至物理磁盘上。</p>
<p>RocketMQ中的ConsumerQueue就是基于页缓存机制达到读写速度接近内存读写速度。</p>
<p>RocketMQ主要通过MappedByteBuffer对文件进行读写操作，MappedByteBuffer是 Java NIO 中的一个类，它提供了一种将文件的内容映射到进程的地址空间中，使得可以像访问内存一样来访问文件的内容（内存映射）的方法。</p>
<h2 id="消息刷盘"><a href="#消息刷盘" class="headerlink" title="消息刷盘"></a><strong>消息刷盘</strong></h2><p>RocketMQ支持的消息刷盘包括同步刷盘和异步刷盘两种，指定了消息是否真正持久化道Broker磁盘后才给Producer反馈。</p>
<ul>
<li>同步刷盘：只有在消息真正持久化道磁盘后，Broker端才会真正返回给Producer端一个成功的ACK响应。</li>
<li>异步刷盘：只要消息写入PageCache，Broker就返回给Producer端ACK响应。这种方式能够充分利用OS的页缓存机制的优势。</li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/">https://rocketmq.apache.org/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a></li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/">https://rocketmq.apache.org/zh/</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io">Song Baoru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io/2023/05/24/RocketMQ/">https://songbaoru.github.io/2023/05/24/RocketMQ/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/RocketMQ/">RocketMQ</a></div><div class="post_share"><div class="social-share" data-image="https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJlbKx9CIKZ-qABs7mJV2aP0AALH5ALBgd0AGzuw770.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法（更新中）"><img class="cover" src="https://th.bing.com/th/id/R.ee995d98e687b0896c006b16980e126b?rik=ZPHZfBPZDznIiw&amp;riu=http%3a%2f%2fimg.sj33.cn%2fuploads%2fallimg%2f200912%2f20091223150352964.jpg&amp;ehk=ETvV5eN%2fU0LZJE9ZbDxQN%2btQkl3ZWmIGnhIp8GzKzZs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">数据结构和算法（更新中）</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img class="cover" src="https://th.bing.com/th/id/OIP.fekfR1FWtn_EXSMaueufagHaEK?pid=ImgDet&amp;rs=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Spring Cloud</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Song Baoru</div><div class="author-info__description">锲而不舍，金石可镂</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SongBaoru"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RocketMQ%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">RocketMQ简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.</span> <span class="toc-text">消息中间件的应用场景</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%A6%82%E5%BF%B5"><span class="toc-number">3.</span> <span class="toc-text">模型概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">3.1.</span> <span class="toc-text">服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%94%9F%E4%BA%A7"><span class="toc-number">3.2.</span> <span class="toc-text">消息生产</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8"><span class="toc-number">3.3.</span> <span class="toc-text">消息存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9"><span class="toc-number">3.4.</span> <span class="toc-text">消息消费</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.5.</span> <span class="toc-text">消息类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.6.</span> <span class="toc-text">消息处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">消息类型原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF"><span class="toc-number">4.1.</span> <span class="toc-text">普通消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF"><span class="toc-number">4.2.</span> <span class="toc-text">顺序消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF"><span class="toc-number">4.3.</span> <span class="toc-text">事务消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6-x2F-%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF"><span class="toc-number">4.4.</span> <span class="toc-text">定时&#x2F;延时消息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">消息处理原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E9%87%8D%E8%AF%95"><span class="toc-number">5.1.</span> <span class="toc-text">消息发送重试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%B5%81%E7%A8%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">重试流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E7%BA%A6%E6%9D%9F"><span class="toc-number">5.1.2.</span> <span class="toc-text">功能约束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95"><span class="toc-number">5.2.</span> <span class="toc-text">消息消费重试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5%E6%A6%82%E8%BF%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">消费重试策略概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E9%87%8D%E8%AF%95%E7%AD%96%E7%95%A5"><span class="toc-number">5.2.2.</span> <span class="toc-text">消费重试策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PushConsumer"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">PushConsumer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleConsumer"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">SimpleConsumer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E6%B5%81%E6%8E%A7"><span class="toc-number">5.3.</span> <span class="toc-text">消息流控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.3.1.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%8E%A7%E8%A1%8C%E4%B8%BA"><span class="toc-number">5.3.2.</span> <span class="toc-text">流控行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4"><span class="toc-number">5.4.</span> <span class="toc-text">消息过滤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">功能概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4%E5%88%86%E7%B1%BB"><span class="toc-number">5.4.2.</span> <span class="toc-text">消息过滤分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">5.5.</span> <span class="toc-text">消费者负载均衡</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E6%92%AD%E6%B6%88%E8%B4%B9%E5%92%8C%E5%85%B1%E4%BA%AB%E6%B6%88%E8%B4%B9"><span class="toc-number">5.5.1.</span> <span class="toc-text">广播消费和共享消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AD%96%E7%95%A5"><span class="toc-number">5.5.2.</span> <span class="toc-text">消费者负载均衡策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%B2%92%E5%BA%A6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">5.5.2.1.</span> <span class="toc-text">消息粒度负载均衡</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%B2%92%E5%BA%A6%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">5.5.2.2.</span> <span class="toc-text">队列粒度负载均衡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%BF%9B%E5%BA%A6%E7%AE%A1%E7%90%86"><span class="toc-number">5.6.</span> <span class="toc-text">消费进度管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BD%8D%E7%82%B9"><span class="toc-number">5.6.1.</span> <span class="toc-text">消息位点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9"><span class="toc-number">5.6.2.</span> <span class="toc-text">消费位点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9"><span class="toc-number">5.6.3.</span> <span class="toc-text">重置消费位点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">消息存储原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CommitLog"><span class="toc-number">6.1.</span> <span class="toc-text">CommitLog</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConsumerQueue"><span class="toc-number">6.2.</span> <span class="toc-text">ConsumerQueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IndexFile"><span class="toc-number">6.3.</span> <span class="toc-text">IndexFile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E7%BC%93%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="toc-number">6.4.</span> <span class="toc-text">页缓存与内存映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98"><span class="toc-number">6.5.</span> <span class="toc-text">消息刷盘</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">7.</span> <span class="toc-text">References</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法（更新中）"><img src="https://th.bing.com/th/id/R.ee995d98e687b0896c006b16980e126b?rik=ZPHZfBPZDznIiw&amp;riu=http%3a%2f%2fimg.sj33.cn%2fuploads%2fallimg%2f200912%2f20091223150352964.jpg&amp;ehk=ETvV5eN%2fU0LZJE9ZbDxQN%2btQkl3ZWmIGnhIp8GzKzZs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法（更新中）"/></a><div class="content"><a class="title" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法（更新中）">数据结构和算法（更新中）</a><time datetime="2023-07-10T00:32:48.000Z" title="Created 2023-07-10 08:32:48">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/RocketMQ/" title="RocketMQ"><img src="https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJlbKx9CIKZ-qABs7mJV2aP0AALH5ALBgd0AGzuw770.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/2023/05/24/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2023-05-24T08:13:44.000Z" title="Created 2023-05-24 16:13:44">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img src="https://th.bing.com/th/id/OIP.fekfR1FWtn_EXSMaueufagHaEK?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud">Spring Cloud</a><time datetime="2023-05-24T08:08:42.000Z" title="Created 2023-05-24 16:08:42">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程"><img src="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&amp;riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&amp;ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程"/></a><div class="content"><a class="title" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程">Java并发编程</a><time datetime="2023-05-07T13:39:13.000Z" title="Created 2023-05-07 21:39:13">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://th.bing.com/th/id/R.826fae185d03cd7935cc5haf1cd1844c3?rik=9ONAxF3s06zoPg&amp;riu=http%3a%2f%2fpic5.bbzhi.com%2ffengjingbizhi%2fgaoqingziranfengjingbizhi%2fgaoqingziranfengjingbizhi_415690_15.jpg&amp;ehk=BbD3V6XWzCc5AJ7yXlMt4j5AU09Nk56syRdeDXFSvYY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-05-07T13:37:05.000Z" title="Created 2023-05-07 21:37:05">2023-05-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Song Baoru</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>