<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java并发编程 | SBR Blog</title><meta name="author" content="Song Baoru"><meta name="copyright" content="Song Baoru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程线程的创建方式Java 中创建线程的方法有四种：继承 Thread 类、实现 Runnable 接口、实现 Callable 接口并使用FutureTask类以及通过线程池创建线程。  继承 Thread 类：  继承 Thread 类是创建线程最简单的方式，在该类中重写 run() 方法即可实现线程的执行逻辑。可以通过 start() 方法启动线程，如下所示： 12345678class M">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:description" content="线程线程的创建方式Java 中创建线程的方法有四种：继承 Thread 类、实现 Runnable 接口、实现 Callable 接口并使用FutureTask类以及通过线程池创建线程。  继承 Thread 类：  继承 Thread 类是创建线程最简单的方式，在该类中重写 run() 方法即可实现线程的执行逻辑。可以通过 start() 方法启动线程，如下所示： 12345678class M">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&risl=&pid=ImgRaw&r=0">
<meta property="article:published_time" content="2023-05-07T13:39:13.000Z">
<meta property="article:modified_time" content="2023-05-31T03:56:55.958Z">
<meta property="article:author" content="Song Baoru">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&risl=&pid=ImgRaw&r=0"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-31 11:56:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SBR Blog"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">SBR Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-07T13:39:13.000Z" title="Created 2023-05-07 21:39:13">2023-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-05-31T03:56:55.958Z" title="Updated 2023-05-31 11:56:55">2023-05-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/IT/">IT</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><p>Java 中创建线程的方法有四种：继承 Thread 类、实现 Runnable 接口、实现 Callable 接口并使用FutureTask类以及通过线程池创建线程。</p>
<ol>
<li>继承 Thread 类：</li>
</ol>
<p>继承 Thread 类是创建线程最简单的方式，在该类中重写 run() 方法即可实现线程的执行逻辑。可以通过 start() 方法启动线程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实现线程执行逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>thread.start();<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>实现 Runnable 接口：</li>
</ol>
<p>实现 Runnable 接口也是一种常见的创建线程的方式，可以将 Runnable 对象传递给 Thread 类，通过 start() 方法启动线程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实现线程执行逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>thread.start();<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>实现 Callable 接口并使用FutureTask类：</li>
</ol>
<p>与 Runnable 接口相比，Callable 接口可以返回执行结果，并且可以抛出异常。</p>
<p>但是Callable接口实例不能作为Thread类的target，所以还需要一个搭桥接口，RunnableFuture接口就是Thread和Callable之间的“搭桥接口”。RunnableFuture继承了Runnable接口和Future接口。其中Future接口提供的功能有取消执行中的任务、获取任务的执行结果等。</p>
<p>FutureTask类实现了RunnableFuture接口。</p>
<p>使用方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;calling&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is the result of the execute&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>    FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(myCallable);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>    thread.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(futureTask.get()); <span class="hljs-comment">// 获取任务的执行结果</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">    calling</span><br><span class="hljs-comment">    this is the result of the execute</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li>通过线程池创建线程</li>
</ol>
<h2 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h2><p>线程局部变量有两种，ThreadLocal和InheritableThreadLocal，其中ThreadLocal在主线程和子线程之间不具备可继承性，而InheritableThreadLocal具备可继承。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code>由一个线程的类型为<code>ThreadLocal.ThreadLocalMap</code>的对象<code>threadlocals</code>来保存，<code>ThreadLocalMap</code>是<code>ThreadLocal</code>类的内部类。具体来说，在<code>ThreadLocalMap</code>中，set到<code>ThreadLocal</code>对象的值作为值（value），<code>ThreadLocal</code>对象作为键（key），并且key是一个弱引用。</p>
<p>因为ThreadLocal对象（key）是一个弱引用，所以当线程销毁后，由于ThreadLocal对象不再被强引用，所以ThreadLocal对象可以被垃圾回收。但是threadlocals中依然存在键值对，所以为了避免内存溢出，还是需要手动移除（remove）ThreadLocal对象。</p>
<p>ThreadLocal的使用方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;(); <span class="hljs-comment">//创建一个用于存储String类型的ThreadLocal变量</span><br>threadLocal.set(<span class="hljs-string">&quot;Hello, ThreadLocal!&quot;</span>); <span class="hljs-comment">//设置当前线程的ThreadLocal变量值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> threadLocal.get(); <span class="hljs-comment">//返回当前线程的ThreadLocal变量值</span><br>threadLocal.remove(); <span class="hljs-comment">//清除当前线程的ThreadLocal变量值</span><br></code></pre></td></tr></table></figure>

<p>可以创建多个ThreadLocal实例，每个ThreadLocal实例可以用来存储一个特定的值，例如，可以创建两个ThreadLocal实例来存储不同类型的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; threadLocal1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;(); <span class="hljs-comment">//创建一个用于存储String类型的ThreadLocal变量</span><br>ThreadLocal&lt;Integer&gt; threadLocal2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;(); <span class="hljs-comment">//创建一个用于存储Integer类型的ThreadLocal变量</span><br></code></pre></td></tr></table></figure>

<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>使用InheritableThreadLocal创建对象保存的变量具有继承性，子线程调用该对象的get方法可以获取到父线程set到该对象中的值。父线程是创建和启动子线程的线程。</p>
<p>InheritableThreadLocal的使用方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InheritableThreadLocal&lt;String&gt; INHERITABLE_THREAD_LOCAL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    INHERITABLE_THREAD_LOCAL.set(<span class="hljs-string">&quot;主线程保存的值&quot;</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> INHERITABLE_THREAD_LOCAL.get();<br>    System.out.println(<span class="hljs-string">&quot;子线程中访问主线程中保存的局部变量值：&quot;</span> + value);<br>    &#125;).start();<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">	子线程中访问主线程中保存的局部变量值：主线程保存的值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>通过InheritableThreadLocal对象之所以能够访问到父（parent）线程的inheritableThreadLocals，是因为在创建线程的时候，会将parent线程的inheritableThreadLocals复制一份到子线程的inheritableThreadLocals中。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>在Java和许多其他编程语言中，线程的<code>sleep()</code>方法并不会导致线程释放锁，但是不会阻塞其他线程。</p>
<p>当一个线程调用<code>sleep()</code>方法时，它会使线程进入阻塞状态一段时间，但该线程仍然保有它已经获得的所有锁。这意味着如果一个线程在进入<code>sleep()</code>之前获得了一个锁，那么它在<code>sleep()</code>期间仍然会保持这个锁，其他线程无法获得这个锁。</p>
<p>这与线程的<code>wait()</code>方法不同。当一个线程调用<code>wait()</code>方法时，它会释放它在相应对象上的锁，允许其他线程获得这个锁。</p>
<p>这是因为<code>sleep()</code>和<code>wait()</code>方法的设计目标不同：<code>sleep()</code>方法主要用于让线程暂停一段时间，而<code>wait()</code>方法主要用于实现线程间的同步。所以，在编写多线程程序时，需要根据实际的需求和情况选择合适的方法。</p>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h3><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><ol>
<li><p>用户线程</p>
<p>默认情况下主线程和创建的新线程、新线程池都为用户线程</p>
<p>以线程为例，想要查看线程是否为守护线程只需通过调用 <code>isDaemon()</code> 方法查询即可，如果查询的值为 <code>false</code> 则表示不为守护线程。</p>
</li>
<li><p>守护线程</p>
<p>守护线程（Daemon Thread）也被称之为后台线程或服务线程，当程序中的用户线程全部执行结束之后，守护线程也会跟随结束。</p>
<p>JVM中的垃圾回收线程、JIT编译线程都是守护线程</p>
<p>守护线程可以按来源分两种：</p>
<ul>
<li><p>JVM中带有的守护线程</p>
</li>
<li><p>将默认的用户线程修改为守护线程</p>
<ul>
<li>如果是线程，则可以通过设置 <code>setDaemon(true)</code> 方法将用户线程直接修改为守护线程</li>
<li>如果是线程池则需要通过 <code>ThreadFactory</code> 将线程池中的每个线程都为守护线程才行，接下来我们分别来实现一下</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p>线程池在运行过程中涉及的状态包括RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED</p>
<p>RUNNING：表示线程池处在运行状态，能处理正在执行的任务，能处理阻塞队列中的任务，能够接收新提交的任务。</p>
<p>SHUTDOWN：表示线程池处在关闭状态，能处理正在执行的任务，能处理阻塞队列中的任务，但是不能接收新提交的任务。如果线程池处于RUNNING状态，此时调用shutdown()方法会使线程进入SHUTDOWN状态。</p>
<p>STOP：表示线程池处于停止状态，线程会中断正在执行的任务，不能处理阻塞队列中的任务，也不能接收新提交的任务。如果线程池处于RUNNING或者SHUTDOWN状态，那么调用线程池的shutdownNow()方法会使线程池进入STOP状态。</p>
<p>TIDYING：如果线程池中已经没有正在执行的任务，并且线程池的阻塞队列为空，线程池就会进入TIDYING状态。当线程池处于SHUTDOWN或者STOP状态时，如果满足TIDYING状态的条件，线程池就会进入TIDYING状态。</p>
<p>TERMINATED：如果线程池处于TIDYING状态，此时调用线程池的terminated方法，线程池就会进入TERMINATED状态。</p>
<h2 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h2><p>Java中线程池的创建有四个类可以实现，分别是Executors、ThreadPoolExecutor、ForkJoinPool、ScheduledThreadPoolExecutor。</p>
<ol>
<li><p>使用Executors类创建线程池</p>
<p>Executors 提供了一些静态工厂方法来创建不同类型的线程池，包括newFixedThreadPool、newWorkStealingPool、newCachedThreadPool、newScheduledThreadPool、newSingleThreadExecutor、newSingleThreadScheduledExecutor等。这种方式适用于简单的场景，但缺少可定制性，无法精细调整线程池的参数。其中newWorkStealingPool是JDK1.8新增的方法，表示创建一个具有并行级别的线程池，比Executors类中断其它方法创建的线程池有更高的并发性能。</p>
<p>在Executors类中，newFixedThreadPool、newCachedThreadPool和newSingleThreadExecutor都是调用ThreadPoolExecutor类的构造方法实现的。所以《阿里巴巴Java开发手册》推荐直接调用ThreadPoolExecutor类的构造方法创建线程。</p>
<p>newWorkStealingPool是调用ForkJoinPool类的构造方法实现的。</p>
<p>newScheduledThreadPool和newSingleThreadScheduledExecutor是调用ScheduledThreadPoolExecutor类的构造方法实现的。</p>
<p>Executors类的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个固定大小的线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用ThreadPoolExecutor类创建线程池</p>
<p>使用 ThreadPoolExecutor 构造函数手动创建线程池，可以自定义线程池的参数，参数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, //线程池的核心线程数</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize, //最大线程数</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime, //空闲线程存活时间</span><br><span class="hljs-params">                              TimeUnit unit, //空闲线程存活时间单位</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列</span><br><span class="hljs-params">                              ThreadFactory threadFactory, // 用来创建线程的线程工厂</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span> <span class="hljs-comment">//拒绝处理任务时的策略</span><br></code></pre></td></tr></table></figure>

<ol>
<li>当线程池中的线程数小于corePoolSize，即使存在空闲线程，也会创建新的线程。</li>
<li>当线程池中的线程数大于corePoolSize，小于maximunPoolSize，那么只有当workQueue队列已满时才会创建新线程来执行任务。</li>
<li>如果线程池中运行的线程数等于maximunPoolSize，并且workQueue队列已满，就会触发拒绝处理任务时的策略（handler）来拒绝任务的执行。</li>
</ol>
<p>ThreadPoolExecutor类的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 手动创建 ThreadPoolExecutor 对象</span><br><span class="hljs-comment">// 除ArrayBlockingQueue外还有LinkedBlockingQueue</span><br>BlockingQueue&lt;Runnable&gt; workQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>); <br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS, workQueue);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用ForkJoinPool类创建线程池</p>
<blockquote>
<p>维基百科为工作窃取的介绍：</p>
<p>在并行计算中，工作窃取是多线程计算机程序的一种调度策略。它解决了在具有固定数量处理器（或内核）的静态多线程计算机上执行动态多线程计算的问题，这种计算可以“生成”新的执行线程。它在执行时间、内存使用和处理器间通信方面都很有效。</p>
</blockquote>
<p>从JDK1.8开始，Java增加了创建work-stealing（工作窃取）线程池的方法，ForkJoinPool类就是提供了创建work-stealing线程池的实现。</p>
<p>使用 ThreadPoolExecutor 构造函数手动创建线程池，可以自定义的线程池参数如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism, //线程池的并发级别</span><br><span class="hljs-params">                         ForkJoinWorkerThreadFactory factory, //用来创建线程的线程工厂</span><br><span class="hljs-params">                         UncaughtExceptionHandler handler, // 执行任务时遇到不可恢复的错误而终止的内部工作线程的处理程序</span><br><span class="hljs-params">                         <span class="hljs-type">int</span> mode, //处理任务队列的模式，取值可为FIFO_QUEUE或LIFO_QUEUE</span><br><span class="hljs-params">                         String workerNamePrefix)</span> <span class="hljs-comment">//表示线程池中执行任务的线程的名称前缀</span><br></code></pre></td></tr></table></figure>

<p>ForkJoinPool类的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(Runtime.getRuntime().availableProcessors());<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(Runtime.getRuntime().availableProcessors(), <br>                 ForkJoinPool.defaultForkJoinWorkerThreadFactory, <br>                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler()&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>		<span class="hljs-comment">//处理异常</span><br>	&#125;<br>&#125;, <span class="hljs-literal">true</span>);  <br></code></pre></td></tr></table></figure>
</li>
<li><p>使用ScheduledThreadPoolExecutor类创建线程池</p>
<p>ScheduledThreadPoolExecutor类用于创建定时任务线程池。ScheduledThreadPoolExecutor继承了ThreadPoolExecutor类，本质上ScheduledThreadPoolExecutor类的构造方法还是调用了ThreadPoolExecutor类的构造方法，只不过在调用时，传递的阻塞队列的类型是DelayedWorkQueue。</p>
</li>
</ol>
<h2 id="线程池执行任务的流程"><a href="#线程池执行任务的流程" class="headerlink" title="线程池执行任务的流程"></a>线程池执行任务的流程</h2><p>以ThreadPoolExecutor为例，线程池的任务执行流程是：</p>
<ol>
<li>对于提交到线程池的任务，首先会判断线程池中的线程数是否达到corePoolSize<ol>
<li>如果没有达到，就创建新的线程执行任务</li>
<li>如果达到了，就判断workQueue是否已满<ol>
<li>如果没满，就添加到workQueue</li>
<li>如果满了，就判断线程池中的线程数是否达到maximunPoolSize<ol>
<li>如果没有达到，就创建新线程来执行任务</li>
<li>如果达到了，就执行拒绝执行策略</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>以ThreadPoolExecutor为例，如果线程池中的线程数达到了maximunPoolSize，并且workQueue已满，没有空闲的线程，此时如果有任务提交到线程池，就会执行线程池的拒绝策略处理函数handler.rejectedExecution(command, this)。</p>
<p>ThreadPoolExecutor中的handler的类型是RejectedExecutionHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<br></code></pre></td></tr></table></figure>

<p>RejectedExecutionHandler接口有四个实现类，这四个类就是JDK提供的线程池拒绝策略的实现类，如果没有传递该handler参数指定使用的拒绝策略，则默认执行AbortPolicy类的拒绝策略，否则执行传递的类的执行策略。继承RejectedExecutionHandler可以实现自定义的拒绝策略。</p>
<img src="/.io//image-20230519215921078.png" alt="image-20230519215921078" style="zoom:80%;">

<h2 id="线程池的关闭方式"><a href="#线程池的关闭方式" class="headerlink" title="线程池的关闭方式"></a>线程池的关闭方式</h2><p>Java 线程池的关闭方式有两种：调用 shutdown() 和 shutdownNow() 方法。</p>
<ol>
<li>调用 shutdown() 方法</li>
</ol>
<p>shutdown() 方法会平缓地关闭线程池，即不会中断正在执行的任务，能够处理完阻塞队列中已提交的任务，但不会接收新的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 提交任务给线程池执行</span><br>...<br><span class="hljs-comment">// 关闭线程池</span><br>executor.shutdown();<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>调用 shutdownNow() 方法</li>
</ol>
<p>shutdownNow() 方法会强制立即关闭线程池，即中断所有正在执行的任务，不会处理阻塞队列中已提交的任务，更不会接收新的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 提交任务给线程池执行</span><br>...<br><span class="hljs-comment">// 关闭线程池</span><br>executor.shutdownNow();<br></code></pre></td></tr></table></figure>

<h2 id="最佳线程数"><a href="#最佳线程数" class="headerlink" title="最佳线程数"></a>最佳线程数</h2><p>要确定线程池的最佳线程数是根据应用场景确定的，一般可以将程序分为CPU密集型程序和I&#x2F;O密集型程序，对于这两种程序，计算最佳线程数的方法是不同的。</p>
<ol>
<li><p>CPU密集型程序</p>
<p>CPU密集型程序对CPU的资源利用率高，理论最佳线程数&#x3D;CPU核心数，一般会将线程数设为CPU核心数+1，以避免有的线程阻塞浪费CPU资源</p>
</li>
<li><p>I&#x2F;O密集型程序</p>
<p>I&#x2F;O密集型程序对CPU的资源利用率低，线程数的计算需要考虑I&#x2F;O操作的CPU占用率，理论上最佳线程数&#x3D;CPU核心数 * (1 + I&#x2F;O操作的耗时&#x2F;CPU计算的耗时)</p>
</li>
</ol>
<p>通过上述方式计算出的线程数只是理论上的最佳线程数，在实际中，需要对系统进行压测，并根据压测结果确定最佳线程数。</p>
<h1 id="XXX程"><a href="#XXX程" class="headerlink" title="XXX程"></a>XXX程</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul>
<li><p>进程：CPU分配资源的基本单位</p>
</li>
<li><p>线程：CPU执行的基本单位</p>
</li>
</ul>
<p>线程可以通俗的理解为程序不同的执行路径</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h2 id="纤程"><a href="#纤程" class="headerlink" title="纤程"></a>纤程</h2><h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>超线程（Hyper-Threading）是Intel公司引入的一种处理器（CPU）技术。这项技术的主要目标是提高处理器核心的效率和性能。超线程通过使单个处理器核心模拟出两个“逻辑”核心，以便同时处理两个线程，从而提高了处理器的并行处理能力。</p>
<p>传统的单核心处理器在任何时刻只能处理一个线程。但是，由于各种原因（例如，等待数据从内存中加载），处理器可能无法始终保持忙碌状态。在这些情况下，处理器的一部分（例如，算术逻辑单元或浮点单元）可能会闲置，从而造成资源浪费。</p>
<p>超线程技术试图解决这个问题，通过在单个核心上同时运行两个线程，使得当一个线程在等待时，另一个线程可以使用处理器的资源进行计算。因此，超线程可以使处理器在相同的时间内完成更多的工作，从而提高处理器的整体效率和性能。</p>
<p>然而，超线程并不总是能提供显著的性能提升。在某些情况下，如果两个线程需要使用相同的处理器资源，那么它们可能会相互竞争，从而导致性能下降。此外，超线程对于多线程程序或多任务环境最有效，对于单线程程序或单任务环境的效果可能不明显。</p>
<p>请注意，虽然超线程可以提高处理器的并行处理能力，但它并不能取代多核处理器。多核处理器具有多个独立的物理核心，每个核心都可以处理自己的线程，因此它们通常可以提供比超线程更好的并行性和性能。</p>
<h1 id="并发编程相关的概念"><a href="#并发编程相关的概念" class="headerlink" title="并发编程相关的概念"></a>并发编程相关的概念</h1><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><ul>
<li>临界区表示可以被多线程共享的资源，但是每次只能提供给一个线程使用</li>
<li>在并发编程中，临界区指的是受保护的对象或程序代码段</li>
</ul>
<h2 id="操作系统的互斥量"><a href="#操作系统的互斥量" class="headerlink" title="操作系统的互斥量"></a>操作系统的互斥量</h2><h2 id="用户态、内核态"><a href="#用户态、内核态" class="headerlink" title="用户态、内核态"></a>用户态、内核态</h2><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><ul>
<li>以同步方式调用方法时，必须在方法返回结果之后才能执行后面的操作</li>
<li>以异步方式调用方法时，不需要等方法返回信息就可以执行后面的操作，当方法完成后，会以通知或回调的方式告诉调用方</li>
</ul>
<h2 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h2><ol>
<li>死锁指两个或多个线程在执行过程中互相等待对方释放资源的情况，导致彼此无法继续执行；</li>
<li>饥饿指某个线程由于无法获得所需资源而一直无法执行；</li>
<li>活锁指两个或多个线程由于某些条件发生变化，导致彼此不断地改变自己的状态和行为，但始终无法向前推进。</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="形成死锁的必要条件"><a href="#形成死锁的必要条件" class="headerlink" title="形成死锁的必要条件"></a>形成死锁的必要条件</h3><ol>
<li>互斥条件：资源只能被一个线程占有</li>
<li>不可剥夺条件：线程占有的资源不能被其他线程强行撤销</li>
<li>请求与保持条件：如果线程已经占有了一个资源，有需要抢占新资源，而该新资源已经被其它线程占有时，那么抢占新资源的线程会阻塞等待，不会释放自己已经占有的资源</li>
<li>循环等待条件：发生死锁时，必然存在一个线程与资源的循环等待链，链中的线程请求的资源被下一个线程占有</li>
</ol>
<h3 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h3><ol>
<li>死锁的预防是破坏死锁形成的条件，而互斥条件不能被破坏，因为使用锁的目的就是要保证这一点。</li>
<li>破坏不可剥夺条件：让当前线程主动释放锁，JVM内置的synchronized锁不能实现这一点，JDK的Lock锁可以实现。使用方法是，通过tryLock()方法加锁，并在finally代码块中调用unlock()方法释放锁。</li>
<li>破坏请求与保持条件：一次性申请线程所需的全部资源，再运行过程中不再请求新的资源。</li>
<li>破坏循环等待条件：按照一定的顺序申请资源，实现方法是为每一个资源分配一个唯一编号，每次申请资源时都按照一定的顺序加锁，比如每次都先对编号较小的资源加锁。</li>
</ol>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁是指线程在获取锁失败后，不会立即进入阻塞状态，而是继续不断尝试获取锁</p>
<h1 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h1><ol>
<li><p>原子性</p>
<p>原子性操作和数据库中的事务类似</p>
<p>造成原子性问题的根本原因是在线程执行过程中发生了线程切换</p>
</li>
<li><p>可见性</p>
<p>可见性是指一个线程修改共享变量，其他线程能够立即读取到共享变量的最新值</p>
<p>造成可见性问题的根本原因是CPU的缓存机制</p>
</li>
<li><p>有序性</p>
<p>有序性指程序能够按照代码的顺序执行，不会发送乱序执行</p>
<p>一个典型的有序性问题是使用双重监测机制创建单例对象（DCL单例），如果在多线程情况下创建单例对象发送乱序执行就可能产生bug</p>
</li>
</ol>
<p>解决方法：</p>
<ol>
<li>原子性：Java中解决原子性问题的方案是使用synchronized锁、Lock锁、ReentrantLock、ReentrantReadWriteLock锁、CAS操作或原子类等。</li>
<li>可见性：使用缓存一致性协议</li>
<li>有序性：禁止指令重排</li>
</ol>
<h2 id="原子性核心原理"><a href="#原子性核心原理" class="headerlink" title="原子性核心原理"></a>原子性核心原理</h2><h3 id="总线锁保证原子性"><a href="#总线锁保证原子性" class="headerlink" title="总线锁保证原子性"></a>总线锁保证原子性</h3><p>多核CPU对内存中的一个共享变量值进行加1操作不是原子操作，这是因为在CPU中对值加1的操作有三步（设被加1的数叫count）：</p>
<ol>
<li>将内存中的count值读取到寄存器。</li>
<li>对寄存器中的count值进行加1操作。</li>
<li>将寄存器中的count值写回内存。</li>
</ol>
<p>如果要保证这三步的原子性，就要保证在CPU1执行这三步的时候，其他CPU不能读写这个共享变量的内存。CPU可以通过对总线加锁来解决这个问题。</p>
<p>在Linux系统中，锁定总线的指令是lock前缀指令。该指令可以与其他指令组合使用，例如lock add、lock cmpxchg、lock xchg等，用于实现原子性操作。</p>
<p>lock前缀指令会将总线置为锁定状态，以确保对内存的访问具有原子性和互斥性。当一个CPU执行带有lock前缀的指令时，它将先发送请求到总线，获取总线的独占控制权，然后执行相关的操作并释放总线控制权。由于总线只能被一个CPU独占，因此其他CPU在访问内存时会被阻塞，直到当前CPU执行完成。</p>
<p>总线锁定会导致其他CPU核心跟所有内存之间的通信全部阻塞，开销极大，而输出LOCK#信号的CPU核心可能只需要使用内存中的很小一部分空间，会造成资源的浪费。</p>
<h3 id="互斥锁保证原子性"><a href="#互斥锁保证原子性" class="headerlink" title="互斥锁保证原子性"></a>互斥锁保证原子性</h3><p>互斥锁是一种显式地获取和释放锁的方式，当一个线程尝试获取互斥锁时，如果该锁已经被其他线程占用，那么当前线程就会被阻塞。</p>
<p>互斥锁模型：</p>
<ol>
<li>对保护临界区资源的锁对象加锁</li>
<li>进入临界区代码执行</li>
<li>对锁对象进行解锁</li>
</ol>
<h3 id="CAS保证原子性"><a href="#CAS保证原子性" class="headerlink" title="CAS保证原子性"></a>CAS保证原子性</h3><p>CAS底层使用的操作系统原语是lock cmpxchg</p>
<h2 id="可见性和有序性核心原理"><a href="#可见性和有序性核心原理" class="headerlink" title="可见性和有序性核心原理"></a>可见性和有序性核心原理</h2><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>由于CPU的多级缓存架构，引入了数据的不一致问题</p>
<p>CPU的缓存一致性要求CPU内部缓存中的数据和主内存中的数据一致</p>
<p>缓存一致性的特点：每个读操作所返回的值必须是最后一次对该存储位置的写操作的值。</p>
<h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>CPU通过缓存一致性协议（如MESI协议、MSI协议等）来保证缓存一致性</p>
<p>MESI协议的每一个字母都是一种一种状态的简称</p>
<ul>
<li><p>M：Modify</p>
<p>处于M状态的缓存行的特点是：</p>
<ol>
<li>缓存行数据被本地写（当前CPU核心修改缓存行数据），缓存行中的数据和主内存中的数据不一致</li>
<li>数据只在当前CPU核心的缓存中存在</li>
<li>处于M状态的缓存行中的数据必须在其他CPU核心读取主内存的数据之前写回主内存</li>
<li>M状态的缓存行数据被写回主内存后，当前缓存行的状态会被标记为E</li>
</ol>
</li>
<li><p>E：Exclusive</p>
<p>处于E状态的缓存行的特点：</p>
<ol>
<li>缓存行数据未被修改过，缓存行中的数据和主内存中的数据一致，缓存行有效</li>
<li>数据只在当前CPU核心的缓存中存在</li>
<li>处于E状态的缓存行的数据如果被其他的CPU核心读取，会变成S状态</li>
<li>E状态的缓存行数据被修改后，当前缓存行的状态会被标记为M</li>
</ol>
</li>
<li><p>S：Shared</p>
<p>处于S状态的缓存行的特点是：</p>
<ol>
<li>缓存行数据未被修改过，缓存行中的数据和主内存中的数据一致，缓存行有效</li>
<li>数据存在于多个CPU核心的缓存</li>
<li>处于S状态的缓存行的数据如果发生本地写，会变成M状态</li>
<li>处于S状态的缓存行的数据如果发生远程写（其他CPU核心修改缓存行数据），会变成I状态</li>
</ol>
</li>
<li><p>I：Invalid</p>
<p>处于I状态的缓存行的特点是：</p>
<ol>
<li>处于I状态的缓存行无效</li>
<li>处于M、E或S状态的缓存行数据，如果发生远程写，则这些缓存行状态都会改为I状态</li>
</ol>
</li>
</ul>
<p>MESI存在的问题：</p>
<ol>
<li><p>MESI协议在高并发场景下可能会存在问题，原因是在MESI协议下，如果当前CPU需要其他的CPU缓存行改变状态，会发送RFO（Request For Owner）请求进行通知，请求到达其他的CPU是需要时间的，在高并发场景下状态的修改可能会不及时。</p>
</li>
<li><p>M状态的缓存行数据不会立即更新到主内存，可能会导致其他CPU缓存行中读取的数据和修改后的数据出现短暂的不一致，</p>
<p>这一问题可以通过加锁或volatile解决。</p>
</li>
<li><p>存在伪共享问题。伪共享问题产生的原因是，CPU进行缓存和主内存交换数据的单位是缓存行（目前主流CPU缓存行的大小是64bytes），MESI协议也是针对缓存行变更状态，不是单个数据的状态。一个缓存行可能会存储了多个不同数据，所以缓存行中不同数据的状态存在共享的可能（伪共享），会导致不同数据的缓存状态彼此干扰。</p>
<p>JDK8之前可以通过字节填充的方式解决伪共享问题，思路大致是在创建变量时，用其他字段填充当前变量所在的缓存行，避免同一个缓存行内存放多个数据变量。</p>
<p>JDK8中引入了@Contended注解来自动填充缓存行，@Contended注解可以用在类和成员变量上，加上@Contended注解后JVM会自动填充，避免出现伪共享问题。使用@Contended注解需要注意的问题是，@Contended只能用在Java自身的核心类中，如果要用在自己写的类里面，需要添加JVM参数<code>-XX:RestrictContended</code>，此外，@Contended默认的填充宽度是128bytes，如果需要自定义宽度需要配置JVM的<code>-XX:ContendedPaddingWidth</code>参数。</p>
</li>
</ol>
<h3 id="volatile核心原理"><a href="#volatile核心原理" class="headerlink" title="volatile核心原理"></a>volatile核心原理</h3><p>volatile在内存语义上有两个作用：</p>
<ol>
<li>保证被volatile修饰的共享变量对每个线程都是可见的（可见性）</li>
<li>禁止指令重排（有序性）</li>
</ol>
<p>volatile不支持原子性，非线程安全</p>
<h4 id="保证可见性的核心原理"><a href="#保证可见性的核心原理" class="headerlink" title="保证可见性的核心原理"></a>保证可见性的核心原理</h4><p>volatile能够保证共享变量的可见性，如果一个共享变量使用volatile修饰，则共享变量所在的缓存行会被要求进行一致性校验，当一个线程修改了volatile修饰的共享变量后，修改后的共享变量值会立即刷新到主内存（MESI协议不会立即刷新，而是等远程读或远程写才会将修改后的数据值刷新到主内存）。</p>
<h4 id="保证有序性的核心原理"><a href="#保证有序性的核心原理" class="headerlink" title="保证有序性的核心原理"></a>保证有序性的核心原理</h4><p>volatile禁止指令重排是通过内存屏障（Memory Barrier）实现的。</p>
<p>内存屏障的底层是CPU指令。这个指令有两个作用：</p>
<ul>
<li><p>强制刷新缓存，保证共享变量的可见性</p>
<p>强制刷新缓存是指将处理器的缓存中的数据立即写回到主内存。当处理器修改了某个内存地址的值时，为了确保其他处理器能够看到最新的值，处理器会将修改后的值先写入自己的缓存中，然后再定期将缓存中的数据刷新回主内存。但是有时候我们需要立即刷新缓存，以确保其他处理器能够尽快看到最新的值。这可以通过执行一个写屏障或者其他特定的指令来实现。</p>
</li>
<li><p>禁止指令重排，保证指令的执行顺序</p>
<p>处理器为了提高程序执行效率，在编译（编译器重排序）或运行（CPU重排序）时会针对代码中的语句进行优化和重排。然而，在多线程并发环境下，这种重排可能会导致一些共享变量的状态无法正确传递，从而出现数据不一致的情况。内存屏障可以禁止指令重排，确保程序执行顺序的正确性。</p>
<p>注：</p>
<ol>
<li>编译器重排序：在代码编译阶段为了提高程序的执行效率，但不改变程序执行结果的重排序。</li>
<li>CPU重排序：CPU按照as-if-serial原则进行指令级重排序和内存系统重排序。as-if-serial原则能够保证在单线程环境下程序执行的正确性，不能保证在多线程环境下程序执行结果的正确性。</li>
</ol>
</li>
</ul>
<p>volatile禁止指令重排序的规则：</p>
<table>
<thead>
<tr>
<th>是否能重排序</th>
<th>第二个操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>第一个操作</td>
<td>普通读或写</td>
<td>volatile读</td>
<td>volatile写</td>
</tr>
<tr>
<td>普通读或写</td>
<td>是</td>
<td>是</td>
<td><strong>否</strong></td>
</tr>
<tr>
<td>volatile写</td>
<td>是</td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
</tr>
<tr>
<td>volatile读</td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
</tr>
</tbody></table>
<p>可以总结出规则是：</p>
<ol>
<li>当第一个操作是volatile读，无论第二个操作是什么，都不能重排序（读操作禁止重排序之后的操作）</li>
<li>当第一个操作是volatile写，第二个操作是volatile读，不能重排序</li>
<li>当第二个操作是volatile写，无论第一个操作是什么，都不能重排序（写操作禁止重排序之前的操作）</li>
</ol>
<p>内存屏障的类型：</p>
<ul>
<li>LoadLoad屏障：禁止前面的读（Load）和后面的Load重排</li>
<li>LoadStore屏障：禁止前面的Load和后面的写（Store）重排</li>
<li>StoreStore屏障：禁止前面的Store重排和后面的Store重排</li>
<li>StoreLoad屏障：禁止前面的Store重排和后面的Load重排</li>
</ul>
<p>JVM编译器会按照上述规则在程序编译生成的指令中插入内存屏障，规则是：</p>
<ol>
<li>对于volatile读<ol>
<li>后面插入一个LoadLoad屏障</li>
<li>后面插入一个LoadStore屏障</li>
</ol>
</li>
<li>对于volatile写<ol>
<li>前面插入一个StoreStore屏障</li>
<li>后面插入一个StoreLoad屏障</li>
</ol>
</li>
</ol>
<h4 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h4><p>DCL（Double Check Lock）单例为什么需要加volatile：</p>
<p>如果不加volatile，不能避免指令重排序，初始化指令和堆栈建立连接的指令可能会倒换，即可能出现堆栈建立连接发生在初始化指令之前，即</p>
<ul>
<li>加volatile，没有被重排序的指令执行过程如下<ol>
<li>初始化指令</li>
<li>堆栈建立连接的指令</li>
</ol>
</li>
<li>不加volatile，可能出现的重排序的指令执行过程如下<ul>
<li>堆栈建立连接的指令</li>
<li>初始化指令</li>
</ul>
</li>
</ul>
<p>这就导致在多线程环境下，如果没有使用volatile，假如一个线程正在使用创建对象，并且发生了指令重排序，使得堆栈建立连接的指令发生在初始化指令之前，那么当这条线程恰好执行完堆栈建立连接的指令，还没有执行初始化指令时，有一个新的线程线程执行DCL单例的函数，判断得到栈中已经指向堆中已有的对象，就会执行返回此对象，而此时对象还没有被初始化，此时获取的对象的值仅仅是默认值而不是初始化的值。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型简称JMM，是Java为了解决可见性和有序性问题而指定的一种编程规范。</p>
<p>主内存：主要对应于Java堆中存储对象实例数据的部分</p>
<p>工作内存：主要对应于虚拟机栈中的部分区域</p>
<h4 id="JMM的概念"><a href="#JMM的概念" class="headerlink" title="JMM的概念"></a>JMM的概念</h4><p>对于线程的工作内存和主内存之间的数据交互，JMM规定了变量从主内存复制到工作内存，以及从工作内存同步到主内存的实现细节。</p>
<p>JMM规定</p>
<ol>
<li>所有变量都存储在主内存中，也就是存储在计算机的物理内存中</li>
<li>每个线程都有自己的工作内存，用于存储线程私有数据</li>
<li>线程不能直接访问其他线程的工作内存中的数据，只能通过主内存进行数据交互</li>
<li>当线程需要操作变量时，需要先将主内存中的变量复制到对应的工作内存中</li>
</ol>
<p>JMM同步数据的八种操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>名称</th>
<th>目标</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>加锁</td>
<td>主内存中的变量</td>
<td>把主内存中的变量标记为线程独占的状态</td>
</tr>
<tr>
<td>unlock</td>
<td>解锁</td>
<td>主内存中的变量</td>
<td>释放主内存中锁定的变量，释放后可以被其他线程锁定</td>
</tr>
<tr>
<td>store</td>
<td>存储</td>
<td>工作内存中的变量</td>
<td>把工作内存中的变量的值刷新到主内存中，以便随后的write操作使用</td>
</tr>
<tr>
<td>write</td>
<td>写入</td>
<td>工作内存中的变量</td>
<td>把store操作从工作内存中得到的变量写入到主内存的变量中</td>
</tr>
<tr>
<td>read</td>
<td>读取</td>
<td>主内存中的变量</td>
<td>把主内存中的变量写入到工作内存中</td>
</tr>
<tr>
<td>load</td>
<td>载入</td>
<td>主内存中的变量</td>
<td>将read操作从主内存中得到的变量值载入工作内存的变量中</td>
</tr>
<tr>
<td>use</td>
<td>使用</td>
<td>工作内存中的变量</td>
<td>将工作内存中的变量值传递给执行引擎</td>
</tr>
<tr>
<td>assign</td>
<td>赋值</td>
<td>工作内存中的变量</td>
<td>执行引擎将值赋值给工作内存中的变量</td>
</tr>
</tbody></table>
<h4 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h4><p>在JMM中定义了一套Happens-Before原则，用于保证程序在执行过程中的可见性和有序性。</p>
<p>Happens-Before原则主要包括以下内容：</p>
<ol>
<li><p>程序次序原则</p>
<p>写在前面的操作先行发生于写在后面的操作</p>
</li>
<li><p>volatile变量原则</p>
<p>对一个volatile变量的写操作必然发生在后续对这个变量的读操作之前</p>
</li>
<li><p>传递原则</p>
<p>ABC三个操作，A先于B，B先于C，则A先于C</p>
</li>
<li><p>监视锁规则</p>
<p>对监视器的加锁发生在解锁之前</p>
</li>
<li><p>锁定原则</p>
<p>先解锁才能加锁</p>
</li>
<li><p>线程启动原则</p>
<p>线程start()后才能执行线程中的代码</p>
</li>
<li><p>线程中断原则</p>
<p>对线程的interrupt()方法的调用发生在中断事件产生之前</p>
</li>
<li><p>线程终结原则</p>
<p>线程结束后，其他线程能够访问到该线程修改后的共享变量的值</p>
</li>
<li><p>对象终结原则</p>
<p>一个对象的初始化必然在其finalize()方法之前执行</p>
</li>
</ol>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h2><p>synchronized用法分三种：</p>
<ol>
<li><p>同步实例方法</p>
<p>当类的普通方法被synchronized修饰时，相当于对this加锁，这个方法被声明为同步方法。</p>
</li>
<li><p>同步静态方法</p>
<p>当类的静态方法被synchronized修饰时，相当于对这个类的Class对象（.class）加锁，而一个类只对应一个Class对象。</p>
</li>
<li><p>同步代码块</p>
<p>通过对互不影响的临界区资源分别加锁（可能需要创建锁对象），可以减小对临界区资源的等待，提高程序的执行效率。</p>
</li>
</ol>
<p>可以由此将synchronized的锁分成两类锁：</p>
<p><strong>对象锁</strong>：对实例方法和同步代码块加的锁称为对象锁</p>
<p><strong>类锁</strong>：对静态方法加的锁称为类锁</p>
<h2 id="Java对象结构"><a href="#Java对象结构" class="headerlink" title="Java对象结构"></a>Java对象结构</h2><p>Java对象结构按照顺序由以下几部分组成：</p>
<ol>
<li>对象头<ol>
<li>Mark Word</li>
<li>类型指针</li>
<li>数组长度（仅在当前对象是数组时才会存在）</li>
</ol>
</li>
<li>实例数据</li>
<li>对齐填充</li>
</ol>
<p>以下是对Java对象组成部分的详细说明（64位JVM下）：</p>
<ol>
<li><p>对象头（8 + 4 + 4 &#x3D; 12 + 4 &#x3D; 16字节）</p>
<ol>
<li><p>Mark Word（8字节）</p>
<p>Mark Word用于存储对象的运行时数据，按照锁状态可以分为以下几类：</p>
<ul>
<li>无锁：对象的Hash码（31位）、GC的分代年龄（4位）、偏向锁标记（1位）、锁的状态标志（2位）</li>
<li>偏向锁：偏向锁线程id（54位）、获得偏向锁的时间戳（2位）、GC的分代年龄、偏向锁标记、锁的状态标志</li>
<li>轻量级锁：轻量级锁指针（指向栈中锁的指针，62位）、锁的状态标志</li>
<li>重量级锁：重量级锁指针（指向对象监视器的指针，62位）、锁的状态标志</li>
<li>GC标记（GC标记用于标记可以回收的垃圾对象）：锁的状态标志</li>
</ul>
</li>
<li><p>类型指针（4字节，默认开启压缩，由8字节压缩为4字节）</p>
<p>类的类元信息存储在JVM的方法区中，对象头的类型指针会指向存储在方法区中的类元信息</p>
<p>不同位数的JVM中长度不同，在32位JVM中，类型指针占用32位的存储空间，64位JVM中，占用64位。</p>
</li>
<li><p>数组长度（仅在当前对象是数组时才会存在，4字节）</p>
</li>
</ol>
</li>
<li><p>实例数据</p>
<p>存储对象的成员变量信息，既包含了类的成员变量值（具体值），也包含了父类的成员变量值</p>
</li>
<li><p>对齐填充</p>
<p>以满足JVM中对象的起始地址是8的整数倍的要求，所以对象的实例变量占用的存储空间需要是8字节的整数倍</p>
</li>
</ol>
<h2 id="使用JOL查看对象结构"><a href="#使用JOL查看对象结构" class="headerlink" title="使用JOL查看对象结构"></a>使用JOL查看对象结构</h2><p>为了方便查看JVM中对象结构并计算某个对象的大小，OpenJDK提供了一个JOL工具包</p>
<p>定义了一个int[]数组，并使用JOL提供的方法输出对象信息：</p>
<img src="/.io//image-20230516191412412.png" alt="image-20230516191412412" style="zoom:93%;">

<p>输出的Java对象信息：</p>
<img src="/.io//image-20230516190422449.png" alt="image-20230516190422449" style="zoom: 80%;">

<h2 id="synchronized底层实现"><a href="#synchronized底层实现" class="headerlink" title="synchronized底层实现"></a>synchronized底层实现</h2><p>JVM是基于JVM中的monitor锁实现的，Java1.5版本之前的synchronized锁性能较低，但是从Java1.6开始，对synchronized锁进行了优化，引入了锁升级、锁粗化、锁消除等技术来提高synchronized的性能。</p>
<ol>
<li><p>字节码层面</p>
<ul>
<li><p>synchronized修饰的方法的字节码会比普通方法多一个ACC_SYNCHRONIZED标识符</p>
</li>
<li><p>synchronized修饰的代码块的字节码会在同步代码块的前后分别添加monitorenter和monitorexit指令</p>
</li>
</ul>
</li>
<li><p>JVM层面</p>
<p>synchronized修饰方法和代码块，在底层实现上没有本质区别</p>
<p>重量级锁的底层是基于Monitor锁实现的</p>
</li>
<li><p>操作系统层面</p>
<p>轻量级锁的底层是基于CAS实现的</p>
<p>Monitor锁是基于操作系统的Mutex锁实现的，Mutex锁是操作系统级别的重量级锁。</p>
</li>
</ol>
<h2 id="Monitor锁原理"><a href="#Monitor锁原理" class="headerlink" title="Monitor锁原理"></a>Monitor锁原理</h2><p>重量级锁的底层是基于Monitor锁实现的，而Monitor锁又是基于操作系统的Mutex锁实现的</p>
<p>在Java中创建出来的任何一个对象都会关联一个Monitor对象，当Monitor对象被一个Java对象持有后（Monitor对象的owner参数不为空），这个Monitor对象就会处于锁定状态。</p>
<p>在HotSpot JVM中，Monitor对象是由ObjectMonitor实现的，ObjectMonitor 是JVM中用于实现对象的同步、监视和锁定的重要数据结构。ObjectMonitor的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">ObjectMonitor() &#123;<br>    _header       = <span class="hljs-literal">NULL</span>;<br>    _count        = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录线程获取锁的次数</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 锁的重入次数</span><br>    _object       = <span class="hljs-literal">NULL</span>;<br>    _owner        = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 指向持有ObjectMonitor对象的线程</span><br>    _WaitSet      = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 处于wait状态的线程，会被加入到_WaitSet</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = <span class="hljs-literal">NULL</span> ;<br>    _succ         = <span class="hljs-literal">NULL</span> ;<br>    _cxq          = <span class="hljs-literal">NULL</span> ;<br>    FreeNext      = <span class="hljs-literal">NULL</span> ;<br>    _EntryList    = <span class="hljs-literal">NULL</span> ;  <span class="hljs-comment">// 处于等待锁block状态的线程，会被加入到该列表</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>ObjectMonitor的几个关键属性 <code>count、recursions、owner、WaitSet、 EntryList</code> 体现了monitor的工作原理</p>
<p>synchronized加锁与解锁在JVM底层的实现流程大致分为以下几步：</p>
<ol>
<li><p>被阻塞的线程被封装成ObjectWaiter对象进入<code>_EntryList</code>，获取到锁（获取到Monitor对象）的线程就会被<code>_owner</code>指向，并把ObjectMonitor对象的<code>_count</code>变量值加1。</p>
</li>
<li><p>当线程调用wait()方法时，当前线程会释放持有的ObjectMonitor对象，并把<code>_owner</code>变量值设为NULL，<code>_count</code>变量值减1。</p>
<p>由于wait()、notify()、notifyAll()等方法在执行过程中会使用ObjectMonitor对象，所以，必须在同步代码块或方法中调用这些方法。</p>
</li>
<li><p>如果获取到ObjectMonitor对象的线程执行完毕，则会释放ObjectMonitor对象，将ObjectMonitor对象中的<code>_count</code>变量值减1（当<code>_count</code>变量值再次为0，当前线程就成功的释放了锁），<code>_owner</code>变量值设为NULL。</p>
</li>
</ol>
<h2 id="锁升级的过程"><a href="#锁升级的过程" class="headerlink" title="锁升级的过程"></a>锁升级的过程</h2><p>锁升级的过程经历以下几个阶段</p>
<ol>
<li><p>无锁</p>
</li>
<li><p>偏向锁</p>
</li>
<li><p>轻量级锁（自旋锁）</p>
</li>
<li><p>重量级锁</p>
</li>
</ol>
<p>Java锁对象由无锁升级为重量级锁的详细步骤：</p>
<ol>
<li><p>线程的抢占锁时首先会检查偏向锁标记位和锁标记位，如果发现是偏向锁，进行锁竞争的一般流程：</p>
<ol>
<li>线程获取锁：线程会检查Mark Word中的偏向锁线程id是否是自己的线程id<ol>
<li>如果是，则当前线程已经持有了锁，直接执行同步代码</li>
<li>如果不是，则当前线程会通过CAS自旋的方式尝试将Mark Word中的偏向锁线程id设为自己的线程id<ol>
<li>CAS操作成功，将Mark Word中的偏向锁线程id设为自己的线程id的操作成功</li>
<li>CAS操作失败，说明此时有其他线程也在争抢锁资源，此时会撤销偏向锁，升级为轻量级锁</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>如果发现是轻量级锁，进行锁竞争的一般流程：</p>
<ol>
<li><p>将锁对象的 Mark Word 备份到 Displaced Mark Word （当线程被创建后，JVM会在线程的栈帧中创建一个用于存储锁记录（Lock Record）的空间，里面存储了owner和Displaced Mark Word）中，并将栈帧的owner指针指向锁对象</p>
</li>
<li><p>尝试通过 CAS 将锁对象的 Mark Word 更新为指向 Displaced Mark Word 的指针</p>
<ol>
<li><p>如果CAS操作成功，表示当前线程成功获取了轻量级锁，并进入临界区执行。</p>
</li>
<li><p>如果已经指向其他线程，竞争锁失败，会进行CAS操作</p>
<ol>
<li><p>自旋等待：如果CAS操作失败，表示锁对象已经被其他线程占用。此时，请求锁的线程会进入自旋等待状态。在自旋等待状态下，线程会反复尝试使用CAS操作获取锁，而不会被阻塞。</p>
</li>
<li><p>自旋限制：CAS自旋操作超过一定的次数仍未抢占到锁，轻量级锁会膨胀为重量级锁，进入阻塞状态。</p>
<p>对于自旋次数上限值，JDK中提供了自适应自旋的方案，如果当前线程的CAS自旋成功，就会增大下一次的自旋次数上限值，如果失败，就会减小。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>当线程释放锁</p>
<ol>
<li>如果锁对象还是轻量级锁的状态，当前线程就会使用CAS操作将Displaced Mark Word中存储的信息复制到锁对象的Mark Word中</li>
<li>如果锁对象已经升级为了重量级锁，当前线程就会释放锁并唤醒其他被阻塞的线程争抢锁</li>
</ol>
</li>
</ol>
</li>
<li><p>如果发现是重量级锁，进行锁竞争的一般流程：</p>
<ol>
<li>线程请求锁：当一个线程需要获取重量级锁时，它会向操作系统发送请求。<ol>
<li><p>如果当前没有其他线程持有锁，请求的线程会成功获取锁，并进入临界区执行。</p>
</li>
<li><p>如果锁已经被其他线程占用，请求的线程将进入阻塞等待状态，线程会被操作系统挂起，不会占用CPU资源。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Java锁对象由无锁升级为重量级锁的其他途径：</p>
<ol>
<li><p>计算一致性哈希</p>
<p>只要锁对象计算过一致性哈希，偏向模式就置为0了，也就意味着该对象锁不能再偏向了，最低也会膨胀会轻量级锁。<br>如果对象锁处于偏向模式时遇到计算一致性哈希请求，那么会跳过轻量级锁模式，直接膨胀为重量级锁。</p>
</li>
</ol>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>重量级锁的降级只会发生在GC期间的STW阶段，只能降级为可以被JVM线程访问，而不被其他Java线程访问的对象。</p>
<h1 id="AQS核心原理"><a href="#AQS核心原理" class="headerlink" title="AQS核心原理"></a>AQS核心原理</h1><p>，</p>
<p>AQS（AbstractQueuedSynchronizer）是volatile和CAS和队列的组合应用</p>
<p>java中哪些同步锁是基于AQS实现的：</p>
<p>Java 并发包 <code>java.util.concurrent</code> 中的许多同步工具类都是基于 <code>AbstractQueuedSynchronizer</code> (简称 AQS) 来实现的。AQS 是一个用于构建锁和同步器的框架，它使用一个 int 成员变量来表示同步状态，并提供了一种使用 CAS（Compare-and-Swap）设置同步状态的方式。以下是一些基于 AQS 实现的同步类：</p>
<ol>
<li><p><strong>ReentrantLock</strong>：重入锁，是一种互斥锁，它的特点是支持重入功能，也就是说，一个线程能够对已经获取到的锁再次获取，而不会发生死锁。</p>
</li>
<li><p><strong>ReentrantReadWriteLock</strong>：读写锁，它分为两个锁，一个是读锁，一个是写锁。多个读锁之间不会互斥，读锁与写锁互斥，写锁与写锁互斥。这是由jvm自己控制的，你只要上好相应的锁即可。</p>
</li>
<li><p><strong>Semaphore</strong>：信号量，内部维护了一组”许可”，线程可以申请许可（如果无可用许可则阻塞），也可以释放许可。信号量可用于实现资源池，或者对某个操作的并发线程数进行限制。</p>
</li>
<li><p><strong>CountDownLatch</strong>：倒计时门栓，它可以让一个或多个线程等待其他线程完成各自的工作后再执行。</p>
</li>
<li><p><strong>CyclicBarrier</strong>：循环栅栏，它允许一组线程互相等待，直到所有的线程都准备就绪后，所有的线程才能继续执行。</p>
</li>
<li><p><strong>FutureTask</strong>：一个实现了 <code>Future</code> 和 <code>Runnable</code> 接口的类，可以用来执行 <code>Callable</code> 任务，并且可以获取任务执行后的结果。</p>
</li>
</ol>
<p>这些类都通过自定义 AQS 来实现它们自己的同步语义。</p>
<h2 id="AQS数据结构原理"><a href="#AQS数据结构原理" class="headerlink" title="AQS数据结构原理"></a>AQS数据结构原理</h2><p>AQS（AbstractQueuedSynchronizer，抽象队列同步器）是Java中提供的一个抽象类，位于java.util.concurrent.locks包下</p>
<p>AQS的数据结构主要包括以下几个部分：</p>
<ol>
<li><p>两类FIFO（先进先出）的双向链表（同步队列和同步条件队列）</p>
<p>链表中的每个节点都是对线程的封装，如果线程竞争锁失败，就会被封装成一个Node节点加入AQS队列的尾部。当获取锁的线程释放锁之后，会从AQS中唤醒一个被阻塞的线程。</p>
<ol>
<li>同步队列通过addWaiter()方法添加到队列的尾部，通过acquire()方法退出同步队列</li>
<li>同步条件队列addConditionWaiter()方法添加到队列的尾部，通过doSignal()方法退出同步队列。AQS中的同步条件队列就是为Lock锁实现的一个基础同步器，只有在使用了Condition时会存在条件队列，并且一个线程可能存在多个条件队列</li>
</ol>
</li>
<li><p>头节点指针、尾节点指针</p>
<p>头节点指针指向的节点封装的线程会占用资源，同时会通过CAS的方式更新state变量、头&#x2F;尾节点指针的指针的指向。</p>
</li>
<li><p>用来标识状态的volatile修饰的变量state</p>
<p>AQS中使用getState()方法读取state变量的值，使用setState()（无法保证原子性）和compareAndSetState()方法（能够保证原子性）设置state变量的值</p>
</li>
<li><p>Node类，AQS实现的独占锁和共享锁是在其静态内部类Node中定义的</p>
<p>静态内部类Node是一个双向链表，节点中保存了当前的状态waitState和当前线程thread。通过SHARED和EXCLUSIVE定义共享或独占状态。</p>
<p>Node中有四个常量，是waitState变量的取值，waitState变量也是用volatile修饰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span><br><span class="hljs-comment">// 表示当前节点中的线程已被取消</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br><span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br><span class="hljs-comment">// 表示后继节点中的线程处于等待状态，需要被唤醒</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span><br><span class="hljs-comment">// 表示当前节点中的线程在等待某个条件，也就是当前节点处于condition队列中</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * waitStatus value to indicate the next acquireShared should</span><br><span class="hljs-comment"> * unconditionally propagate</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 表示在当前场景下能够执行后续的acquireShared操作</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="AQS底层对锁的支持"><a href="#AQS底层对锁的支持" class="headerlink" title="AQS底层对锁的支持"></a>AQS底层对锁的支持</h2><p>Java中java.util.concurrent包下的大部分工具类的实现都基于AQS（都extends Sync，而Sync extends AbstractQueuedSynchronizer）。基于AQS的工具类：</p>
<img src="/.io//image-20230517221126607.png" alt="image-20230517221126607" style="zoom:80%;">

<p>AQS底层支持独占锁和共享锁两种模式：</p>
<ol>
<li>独占锁同一时刻只能被一个线程占用，如ReentrantLock</li>
<li>共享锁同一时刻可以被多个线程占用，如CountDownLatch、Semaphore等</li>
<li>有的锁实现类同时实现了独占锁和共享锁两种模式：如ReentrantReadWriteLock</li>
</ol>
<h2 id="独占锁和共享锁的实现流程"><a href="#独占锁和共享锁的实现流程" class="headerlink" title="独占锁和共享锁的实现流程"></a>独占锁和共享锁的实现流程</h2><p><strong>独占锁模式下的加锁流程：</strong></p>
<p>独占锁加锁的入口是acquire()方法，当线程调用acquire()方法获取独占锁时，首先会调用tryAcquire()方法尝试获取锁资源，如果获取失败返回false，就会调用addWaiter()方法将当前线程封装为Node节点，添加到AQS队列的尾部。然后调用acquireQueued()方法在等待队列中排队，在acquireQueued()方法中进入一个循环逻辑：如果监测到前驱节点是head节点，就尝试获取锁，如果获取成功就将head指向当前Node节点；如果前驱节点不是head节点，就调用shouldParkAfterFailedAcquire()方法判断是否可以进入waiting状态，如果可以，就进入阻塞状态直到调用LockSupport的unpark()方法唤醒当前线程。</p>
<p><strong>独占锁模式下的解锁流程：</strong></p>
<p>独占锁模式中，释放锁的入口方法是release()，在release()方法中首先会调用tryRelease()方法尝试释放锁，如果返回true，并且head节点不为空且head节点的waitState状态不为0，会调用unparkSuccessor()方法唤醒队列最前面可以被唤醒的节点。</p>
<p><strong>共享锁模式下的加锁流程：</strong></p>
<p>共享锁加锁的入口是acquireShared()方法，当线程调用acquireShared()方法获取共享锁时，首先会调用tryAcquireShared()方法尝试获取锁资源，如果获取失败返回负数，就会调用doAcquireShared()方法将当前线程封装为Node节点，添加到AQS队列的尾部并阻塞。然后监测前驱节点是否是head节点，就尝试获取锁，如果获取成功就将head指向当前Node节点，如果同时还有剩余资源则继续唤醒队列中后面的线程；如果前驱节点不是head节点，就调用shouldParkAfterFailedAcquire()方法判断是否可以进入waiting状态，如果可以，就进入阻塞状态直到调用LockSupport的unpark()方法唤醒当前线程。</p>
<p><strong>共享锁模式下的解锁流程：</strong></p>
<p>共享锁模式中，释放锁的入口方法是releaseShared()，在release()方法中首先会调用tryReleaseShared()方法尝试释放锁，如果返回true，就执行doReleaseShared()方法唤醒队列后面的线程。</p>
<h1 id="Lock锁核心原理"><a href="#Lock锁核心原理" class="headerlink" title="Lock锁核心原理"></a>Lock锁核心原理</h1><h2 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h2><p>Lock显示锁和synchronized隐式锁</p>
<ol>
<li>Lock锁都是手动写代码去获取锁和释放锁的，所以也叫显示锁</li>
<li>而当调用synchronized修饰的代码时，并不需要显示的加锁和解锁的过程，所以称之为隐式锁</li>
</ol>
<p>JUC显示锁中核心的接口是Lock接口，位于java.util.concurrent.locks包下：</p>
<img src="/.io//image-20230517172627640.png" alt="image-20230517172627640" style="zoom:80%;">

<p>Lock接口提供的方法：</p>
<img src="/.io//image-20230517173037786.png" alt="image-20230517173037786" style="zoom:80%;">

<h2 id="公平锁和非公平锁的原理"><a href="#公平锁和非公平锁的原理" class="headerlink" title="公平锁和非公平锁的原理"></a>公平锁和非公平锁的原理</h2><p>公平锁中的线程在抢占锁时首先会判断等待队列是否为空，如果队列为空或者当前线程是队列的队首元素，则当前线程获取到锁资源，否则会被放入队列尾部等待获取锁</p>
<p>非公平锁中的线程在抢占锁时会先直接尝试抢占锁，如果抢占成功就继续执行程序的业务逻辑，如果抢占失败，才会进入等待队列中等待</p>
<p>ReentrantLock支持公平锁和非公平锁，在使用时公平锁和非公平锁的用法一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建公平锁实例</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 创建公平锁</span><br><span class="hljs-comment">// Lock lock = new ReentrantLock(false); // 创建非公平锁</span><br><span class="hljs-comment">// Lock lock = new ReentrantLock(); // 创建非公平锁</span><br><span class="hljs-keyword">try</span> &#123;<br>	lock.lock();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="悲观锁和乐观锁的原理"><a href="#悲观锁和乐观锁的原理" class="headerlink" title="悲观锁和乐观锁的原理"></a>悲观锁和乐观锁的原理</h2><p>悲观锁的核心思想是对数据是否被修改持有悲观态度，认为其他线程会修改数据，所以在线程每次获取数据时都会加锁。</p>
<p>乐观锁的核心思想是对数据是否被修改持有乐观态度，认为其他线程不会修改数据，所以在线程每次获取数据时都不会加锁。乐观锁适合读多写少的场景。</p>
<p>synchronized锁就是悲观锁</p>
<p>java.util.concurrent.atomic包下的原子类就是乐观锁</p>
<p>AtomicInteger类的用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(); <span class="hljs-comment">//创建原子类</span><br>atomicInteger.incrementAndGet(); <span class="hljs-comment">//加1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> atomicInteger.get(); <span class="hljs-comment">// get值</span><br></code></pre></td></tr></table></figure>

<h2 id="可中断锁和不可中断锁的原理"><a href="#可中断锁和不可中断锁的原理" class="headerlink" title="可中断锁和不可中断锁的原理"></a>可中断锁和不可中断锁的原理</h2><p>可中断锁指在多个线程抢占的过程中可以被中断的锁。</p>
<p>不可中断锁指在多个线程抢占的过程中不可以被中断的锁。</p>
<p>ReentrantLock，就是可中断锁，ReentrantLock支持两种可中断锁的使用方式，lockInterruptibly()和tryLock(long timeout, TimeUnit unit)，如果当前线程在抢占锁的过程中被中断，就会抛出InterruptedException()用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	lock.lockInterruptibly();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException) &#123;<br>	<span class="hljs-comment">// 抢占锁被中断</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>synchronized锁是不可中断锁，只能在抢占锁成功后被中断，不能在抢占锁的过程中被中断。</p>
<h2 id="独占锁和共享锁的原理"><a href="#独占锁和共享锁的原理" class="headerlink" title="独占锁和共享锁的原理"></a>独占锁和共享锁的原理</h2><p>按照加锁后的资源能否在被多个线程访问，可以将锁分为独占锁和共享锁</p>
<p>线程获取到独占锁后，其他线程如果想要获取该锁，只能等待。</p>
<p>线程获取到共享锁后，其他线程也可以获取到该锁，但是共享锁只允许对临界区的数据进行读取操作，不允许修改。也就是说，共享锁是针对读操作的锁。</p>
<p>synchronized锁、ReentrantLock锁、ReentrantReadWriteLock的写锁都是独占锁。</p>
<p>ReentrantReadWriteLock的读锁、Semaphore类、CountDownLatch类都是共享锁。</p>
<h2 id="读-x2F-写锁"><a href="#读-x2F-写锁" class="headerlink" title="读&#x2F;写锁"></a>读&#x2F;写锁</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock是ReadWriteLock接口的实现类：<code>ReentrantReadWriteLock implements ReadWriteLock</code></p>
<p>ReadWriteLock支持由写锁将为读锁（锁降级）</p>
<p>ReentrantReadWriteLock的写锁（独占锁）用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteUsage</span> &#123;<br>    <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> readWriteLock.writeLock(); <span class="hljs-comment">//ReadWriteLock的写锁（独占锁）</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeLockUsage</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeLock.lock();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢占锁成功&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//使占有锁的线程运行一段时间后再释放</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;sleeping&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;释放锁成功&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WriteUsage</span> <span class="hljs-variable">writeUsage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteUsage</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始抢占锁&quot;</span>);<br>                writeUsage.writeLockUsage();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	输出的结果：</span><br><span class="hljs-comment">            Thread-1开始抢占锁</span><br><span class="hljs-comment">            Thread-4开始抢占锁</span><br><span class="hljs-comment">            Thread-3开始抢占锁</span><br><span class="hljs-comment">            Thread-0开始抢占锁</span><br><span class="hljs-comment">            Thread-2开始抢占锁</span><br><span class="hljs-comment">            Thread-1抢占锁成功</span><br><span class="hljs-comment">            Thread-1释放锁成功</span><br><span class="hljs-comment">            Thread-4抢占锁成功</span><br><span class="hljs-comment">            Thread-4释放锁成功</span><br><span class="hljs-comment">            Thread-3抢占锁成功</span><br><span class="hljs-comment">            Thread-3释放锁成功</span><br><span class="hljs-comment">            Thread-0抢占锁成功</span><br><span class="hljs-comment">            Thread-0释放锁成功</span><br><span class="hljs-comment">            Thread-2抢占锁成功</span><br><span class="hljs-comment">            Thread-2释放锁成功</span><br><span class="hljs-comment">        只有一个线程能够抢占到写锁</span><br><span class="hljs-comment">    */</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>ReentrantReadWriteLock的读锁（共享锁）用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadUsage</span> &#123;<br>    <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> readWriteLock.readLock(); <span class="hljs-comment">//ReadWriteLock的读锁（共享锁）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readLockUsage</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            readLock.lock();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢占锁成功&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//使占有锁的线程运行一段时间后再释放</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;sleeping&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readLock.unlock();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;释放锁成功&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReadUsage</span> <span class="hljs-variable">readUsage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadUsage</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始抢占锁&quot;</span>);<br>                readUsage.readLockUsage();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	输出的结果：</span><br><span class="hljs-comment">            Thread-0开始抢占锁</span><br><span class="hljs-comment">            Thread-4开始抢占锁</span><br><span class="hljs-comment">            Thread-2开始抢占锁</span><br><span class="hljs-comment">            Thread-3开始抢占锁</span><br><span class="hljs-comment">            Thread-1开始抢占锁</span><br><span class="hljs-comment">            Thread-0抢占锁成功</span><br><span class="hljs-comment">            Thread-4抢占锁成功</span><br><span class="hljs-comment">            Thread-2抢占锁成功</span><br><span class="hljs-comment">            Thread-3抢占锁成功</span><br><span class="hljs-comment">            Thread-1抢占锁成功</span><br><span class="hljs-comment">            Thread-0释放锁成功</span><br><span class="hljs-comment">            Thread-2释放锁成功</span><br><span class="hljs-comment">            Thread-4释放锁成功</span><br><span class="hljs-comment">            Thread-1释放锁成功</span><br><span class="hljs-comment">            Thread-3释放锁成功</span><br><span class="hljs-comment">        多个线程都能够抢占到读锁</span><br><span class="hljs-comment">    */</span><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>StampedLock支持读锁、写锁、乐观锁三种模式。</p>
<h2 id="LockSupport原理"><a href="#LockSupport原理" class="headerlink" title="LockSupport原理"></a>LockSupport原理</h2><p>LockSupport位于<code>java.util.concurrent.locks</code>包，是Java提供的创建锁和其他多线程工具的基础类库，主要作用就是阻塞和唤醒线程，底层是基于UnSafe类实现的。AQS 底层就是使用了<code>LockSupport</code>来实现线程的阻塞和唤醒。</p>
<p>LockSupport类提供的核心方法：</p>
<img src="/.io//image-20230518115147049.png" alt="image-20230518115147049" style="zoom:80%;">

<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>public static void park()</td>
<td>阻塞当前线程</td>
</tr>
<tr>
<td>public static void park(Object blocker)</td>
<td>使用指定的 blocker（锁对象）阻塞当前线程</td>
</tr>
<tr>
<td>public static void parkNanos(long nanos)</td>
<td>阻塞当前线程，并指定了最长阻塞的时间，单位是纳秒</td>
</tr>
<tr>
<td>public static void parkUntil(long deadline)</td>
<td>阻塞当前线程，并指定了deadline时间点</td>
</tr>
<tr>
<td>public static void parkNanos(Object blocker, long nanos)</td>
<td>阻塞当前线程，并指定了使用的 blocker（锁对象）、最长阻塞的时间，单位是纳秒</td>
</tr>
<tr>
<td>public static void parkUntil(Object blocker, long deadline)</td>
<td>阻塞当前线程，并指定了使用的 blocker（锁对象）、deadline时间点</td>
</tr>
<tr>
<td>public static void unpark(Thread thread)</td>
<td>解除指定已被park的线程的阻塞状态；如果线程已经启动但还未park，就取消下一次的park。</td>
</tr>
</tbody></table>
<p>在底层实现上，<code>LockSupport</code>使用了一种名为”许可（Permit）”的概念来控制阻塞和唤醒。Permit的数量最多为1。</p>
<p>如果线程已经拿到了Permit，则调用<code>LockSupport.park()</code>会立即返回；如果没有拿到Permit，<code>park()</code>方法会阻塞线程。调用<code>LockSupport.unpark(Thread)</code>方法会给指定的线程发放Permit。</p>
<p>unpark()可以先于park()调用：如果 <code>unpark(thread)</code> 在 <code>park()</code> 之前被调用，那么线程会获得一个Permit，当后续 <code>park()</code> 被调用时，线程可以立即消费掉这个Permit并继续执行，而不会阻塞。</p>
<p>如果调用者的线程被中断，park 将返回。</p>
<p>下面是一个简单的<code>LockSupport</code>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Child thread begin park!&quot;</span>);<br><br>            <span class="hljs-comment">// 调用park方法，挂起自己</span><br>            LockSupport.park();<br><br>            System.out.println(<span class="hljs-string">&quot;Child thread end park!&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br><br>        <span class="hljs-comment">// 主线程延迟2s</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Main thread begin unpark!&quot;</span>);<br><br>        <span class="hljs-comment">// 调用unpark方法让thread线程持有许可证，然后park方法返回</span><br>        LockSupport.unpark(thread);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，子线程通过调用<code>LockSupport.park()</code>方法阻塞自己，主线程在延迟2秒后调用<code>LockSupport.unpark(thread)</code>方法唤醒子线程。</p>
<h1 id="CAS核心原理"><a href="#CAS核心原理" class="headerlink" title="CAS核心原理"></a>CAS核心原理</h1><h2 id="CAS的基本概念"><a href="#CAS的基本概念" class="headerlink" title="CAS的基本概念"></a>CAS的基本概念</h2><blockquote>
<p>将内存位置的内容与给定值进行比较，只有当它们相同时，才将该内存位置的内容修改为新的给定值</p>
</blockquote>
<p>CAS（Compare And Swap）是一种无锁编程算法，属于乐观锁。</p>
<p>CAS以原子性的方式更新共享变量的数据，能够保证线程安全。</p>
<p>CAS算法的使用包含以下步骤（假设新值是基于共享变量的旧值计算得到的，比如加1操作）：</p>
<ol>
<li>读取到的共享变量的值是prev</li>
<li>确定要修改的值是next（如next&#x3D;prev+1）</li>
<li>再次读取共享变量的值是cur，并比较prev和cur是否一样，即计算得到next的操作前后共享变量的值是否发生了改变。如果没有发生改变就更新共享变量的值为next；如果发生了改变，则重新从第一步开始执行，或者根据需要结束执行。</li>
</ol>
<p>AtomicInteger的getAndUpdate方法的实现就体现了这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndUpdate</span><span class="hljs-params">(IntUnaryOperator updateFunction)</span> &#123;<br>    <span class="hljs-type">int</span> prev, next;<br>    <span class="hljs-keyword">do</span> &#123;<br>        prev = get();<br>        next = updateFunction.applyAsInt(prev);<br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSet(prev, next));<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CAS的核心类Unsafe"><a href="#CAS的核心类Unsafe" class="headerlink" title="CAS的核心类Unsafe"></a>CAS的核心类Unsafe</h2><p>Unsafe类是Java中实现CAS操作的核心类，位于sun.misc包，在UnSafe类中提供了大量的native方法，通过JNI的方式调用JVM底层的C和C++实现的方法。java.util.concurrent.atomic包下提供的原子类底层操作都是基于Unsafe类实现的。</p>
<p>使用Unsafe的CAS方法实现count++：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CasCountIncrement</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">singleOneInstanceField</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            singleOneInstanceField.setAccessible(<span class="hljs-literal">true</span>);<br>            unsafe = (Unsafe) singleOneInstanceField.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> unsafe;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXECUTE_COUNT_EACH_THREAD</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">countOffset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countOffset = unsafe.objectFieldOffset(CasCountIncrement.class.getDeclaredField(<span class="hljs-string">&quot;count&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementCountByCas</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            oldCount = count;<br>        &#125; <span class="hljs-keyword">while</span> (!unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, countOffset, oldCount, oldCount + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CasCountIncrement</span> <span class="hljs-variable">casCountIncrement</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CasCountIncrement</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_COUNT);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_COUNT; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                IntStream.range(<span class="hljs-number">0</span>, EXECUTE_COUNT_EACH_THREAD).forEach((j) -&gt; &#123;<br>                    casCountIncrement.incrementCountByCas();<br>                &#125;);<br>                countDownLatch.countDown();<br>            &#125;).start();<br>        &#125;;<br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + casCountIncrement.count); <span class="hljs-comment">//count = 10000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ABA问题的解决方案"><a href="#ABA问题的解决方案" class="headerlink" title="ABA问题的解决方案"></a>ABA问题的解决方案</h2><p>java中的java.util.concurrent.atomic包下提供了AtomicStampedReference类和AtomicMarkableReference类来解决ABA问题。</p>
<p>区别是：</p>
<ol>
<li>AtomicStampedReference使用的是int类型的stamp，可以区分每一次的修改</li>
<li>AtomicMarkableReference使用的是boolean类型的mark，只能判断有没有修改过</li>
</ol>
<p>实现源码：</p>
<ol>
<li><p>AtomicStampedReference：在CAS的基础上增加了stamp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Params:</span><br><span class="hljs-comment">    expectedReference – the expected value of the reference </span><br><span class="hljs-comment">    newReference – the new value for the reference </span><br><span class="hljs-comment">    expectedStamp – the expected value of the stamp </span><br><span class="hljs-comment">    newStamp – the new value for the stamp</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V expectedReference,</span><br><span class="hljs-params">                             V newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> expectedStamp,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> newStamp)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newStamp == current.stamp) ||<br>         casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>AtomicMarkableReference：在CAS的基础上增加了mark</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Params:</span><br><span class="hljs-comment">    expectedReference – the expected value of the reference </span><br><span class="hljs-comment">    newReference – the new value for the reference </span><br><span class="hljs-comment">    expectedMark – the expected value of the mark </span><br><span class="hljs-comment">    newMark – the new value for the mark</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V expectedReference,</span><br><span class="hljs-params">                             V newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">boolean</span> expectedMark,</span><br><span class="hljs-params">                             <span class="hljs-type">boolean</span> newMark)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedMark == current.mark &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newMark == current.mark) ||<br>         casPair(current, Pair.of(newReference, newMark)));<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="JUC同步锁"><a href="#JUC同步锁" class="headerlink" title="JUC同步锁"></a>JUC同步锁</h1><p>以下的锁当中除了LockSupport之外，其他的都是基于AQS实现的</p>
<img src="/.io//image-20230517170215865.png" alt="image-20230517170215865" style="zoom:80%;">

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是Java并发包<code>java.util.concurrent.locks</code>中的一个类，ReentrantLock是可重入锁，每获取一次，重入的计数就会增加1。当线程释放锁时，重入的计数就会减少1。只有当重入的计数变为0时，锁才会真正被释放。</p>
<p><code>ReentrantLock</code>是基于Java的<code>AbstractQueuedSynchronizer</code>(AQS)框架实现的。AQS使用一个整数值来表示锁的状态，并使用一个FIFO队列来管理等待的线程。ReentrantLock底层使用的是锁的park()和unpark()</p>
<p>要使用<code>ReentrantLock</code>，需要创建一个<code>ReentrantLock</code>的实例，然后在需要互斥访问的代码前调用<code>lock()</code>方法，代码后调用<code>unlock()</code>方法。为了确保锁可以被正确释放，通常需要将<code>unlock()</code>方法放在<code>finally</code>块中。下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// critical section</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>doSomething</code>方法中的代码是互斥的，也就是说，在任何时刻，最多只有一个线程可以执行这段代码。</p>
<p>ReentrantLock提供了比内置<code>synchronized</code>关键字更强大更灵活的锁机制。</p>
<p>ReentrantLock比synchronized增加的功能：</p>
<ol>
<li>ReentrantLock可以设置等待时间，如果超时未得到锁，可以进入finally里面解除获取锁的操作</li>
<li>ReentrantLock可以使用可打断的等待lock.lockInterruptibly()，其他线程打断可打断的等待线程之后，等待线程就可以进入被打断的catch</li>
<li>ReentrantLock还支持公平锁，synchronized只支持非公平锁。公平锁模式可以防止线程饥饿，但是在性能上通常不如非公平锁模式。ReentrantLock使用公平锁的方式是往够早函数里面传一个true参数，即new ReentrantLock(true)。</li>
</ol>
<p><strong>lock.lock();是写在try里面还是外面</strong></p>
<p>在使用 <code>Lock</code> 的时候，通常建议将 <code>lock.lock();</code> 写在 <code>try</code> 块的外面，然后在 <code>finally</code> 块中释放锁。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// access shared resources</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样做的原因是，如果获取锁（<code>lock.lock()</code>）失败抛出了异常，那么在 <code>finally</code> 块中就无需（也不能）去释放这个锁。如果将 <code>lock.lock();</code> 写在 <code>try</code> 块内部，当获取锁抛出异常时，<code>finally</code> 块仍然会执行，这可能会导致尝试释放一个实际上并未被当前线程持有的锁，从而引发 <code>IllegalMonitorStateException</code>。</p>
<p>然而，需要注意的是，这种模式主要适用于 <code>lock.lock()</code> 不会抛出受检异常的情况。在 <code>java.util.concurrent.locks.Lock</code> 接口中，<code>lock()</code> 方法是不会抛出受检异常的。但如果你使用的锁实现可能会在 <code>lock()</code> 方法中抛出受检异常，那么你可能需要将 <code>lock()</code> 调用放入 <code>try</code> 块中，并在 <code>catch</code> 块中适当地处理异常。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>概念：</p>
<p><code>CountDownLatch</code>位于<code>java.util.concurrent</code>包中。<code>CountDownLatch</code>允许一个或多个线程等待其他线程完成一组操作。</p>
<p><code>CountDownLatch</code>是不能重用的，一旦计数器的值变为0，就不能再次将它重置回一个非零的值。</p>
<p>使用场景：</p>
<p>假设一个并发程序的主线程需要等待其他几个工作线程完成一组操作后才能继续执行。在这种情况下，我们可以使用<code>CountDownLatch</code>。</p>
<p>用法：</p>
<p>创建一个<code>CountDownLatch</code>的实例，将计数器的初始值设为工作线程的数量。每个工作线程完成任务后调用<code>countDown()</code>方法。主线程在开始任务前调用<code>await()</code>方法，然后等待所有的工作线程都完成任务。这里有一个简单的例子来说明<code>CountDownLatch</code>的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">workerNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(workerNum);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; workerNum; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-comment">// do some work</span><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; finished work.&quot;</span>);<br>                latch.countDown();<br>            &#125;).start();<br>        &#125;<br><br>        latch.await();<br>        System.out.println(<span class="hljs-string">&quot;All workers have finished their jobs.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，创建一个了<code>CountDownLatch</code>的实例时，传递给它的构造函数的整数就是计数器的初始值。每个工作线程在完成任务后调用<code>countDown()</code>方法，每次调用这个方法都会将计数器的值减1。主线程在开始任务前调用<code>await()</code>方法，使主线程等待，然后等待计数器的值变为0，主线程继续执行，并输出一条消息。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code> 是 Java 并发编程中一种同步辅助工具，它允许一组线程互相等待，直到所有线程都到达某个公共的屏障点（Barrier Point）。</p>
<p>“Cyclic” 的含义是这个屏障点是可以重复利用的，也就是说，一旦所有等待线程都达到了屏障点，这个屏障就可以为下一轮的等待线程使用。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个新的CyclicBarrier，当有3个线程达到时触发</span><br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 所有线程到达屏障后执行此任务</span><br>                System.out.println(<span class="hljs-string">&quot;所有线程都到达了屏障点&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 启动三个将在屏障处等待的线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(barrier), <span class="hljs-string">&quot;线程 1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(barrier), <span class="hljs-string">&quot;线程 2&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(barrier), <span class="hljs-string">&quot;线程 3&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> CyclicBarrier barrier;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(CyclicBarrier barrier)</span> &#123;<br>            <span class="hljs-built_in">this</span>.barrier = barrier;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 在屏障处等待&quot;</span>);<br>                barrier.await();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 已经通过了屏障&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>                ex.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException ex) &#123;<br>                ex.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock，读写锁，</p>
<p>读写锁：</p>
<ul>
<li>共享锁（读锁）：读共享</li>
<li>排他锁（写锁）：写互斥</li>
</ul>
<p>由ReadWriteLock对象可以得到读锁和写锁</p>
<h2 id="StampedLock-1"><a href="#StampedLock-1" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><code>StampedLock</code> 是 Java 在 JDK 8 中引入的一个新的同步工具类，用来解决某些场景下的并发问题。它设计的初衷是为了优化读多写少的场景，因此在读线程非常多，写线程非常少的情况下，<code>StampedLock</code> 提供了一种乐观读锁，可以使得多个线程同时读，大大提高了并发性能。</p>
<p><code>StampedLock</code> 提供的锁包括写锁、悲观读锁以及乐观读，这三种锁的释放和获取都是通过一个 <code>stamp</code>（邮票）变量来控制的，这个 <code>stamp</code> 变量类似于版本号，每次写锁的获取和释放都会导致 <code>stamp</code> 变化。</p>
<p>下面是一个使用 <code>StampedLock</code> 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x, y;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">double</span> deltaX, <span class="hljs-type">double</span> deltaY)</span> &#123; <span class="hljs-comment">// 移动点的位置</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.writeLock(); <span class="hljs-comment">// 获取写锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            x += deltaX;<br>            y += deltaY;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            sl.unlockWrite(stamp); <span class="hljs-comment">// 释放写锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">distanceFromOrigin</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 计算从原点到现在位置的距离</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.tryOptimisticRead(); <span class="hljs-comment">// 尝试获取乐观读锁</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">currentX</span> <span class="hljs-operator">=</span> x, currentY = y;<br>        <span class="hljs-keyword">if</span> (!sl.validate(stamp)) &#123; <span class="hljs-comment">// 如果乐观读锁验证失败，改用悲观读锁</span><br>            stamp = sl.readLock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                currentX = x;<br>                currentY = y;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sl.unlockRead(stamp); <span class="hljs-comment">// 释放悲观读锁</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>move</code> 方法使用写锁，保证了数据的完整性，而 <code>distanceFromOrigin</code> 方法首先尝试获取乐观读锁，如果验证成功，则直接计算结果，否则改用悲观读锁。</p>
<p>需要注意的是，<code>StampedLock</code> 不支持重入和条件变量，使用时也要注意避免锁升级导致的死锁问题。此外，<code>StampedLock</code> 的锁方法不响应中断，如果需要支持中断，可以使用相应的 <code>xxxLockInterruptibly</code> 方法。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量</p>
<p>用途：限流</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger 是 Java 并发包中提供的一个工具类，它用于在两个线程之间交换数据。Exchanger 提供了一个对外公开的 exchange() 方法，当一个线程调用该方法时，如果另一个线程已经调用了同一 Exchanger 对象的 exchange() 方法，则会导致两个线程相互阻塞，直到两个线程均完成数据的交换。</p>
<p>Exchanger 的主要特点如下：</p>
<ol>
<li><p>只支持两个线程之间的数据交换，不能用于多个线程之间的通信。</p>
</li>
<li><p>数据交换的过程是原子性的，即在一个线程完成数据交换之前，另一个线程无法访问交换的数据，保证了线程安全性。</p>
</li>
<li><p>如果一个线程先调用了 exchange() 方法，那么它会被阻塞等待另一个线程进行数据交换，避免了资源浪费和不必要的竞争。</p>
</li>
</ol>
<p>Exchanger 的使用场景比较广泛，例如可以用于实现两个线程之间的数据异步传递、多线程流水线处理等。在使用 Exchanger 时需要注意线程安全问题和数据的一致性问题，确保数据交换的正确性和可靠性。</p>
<p>下面是一个简单的示例，演示了两个线程之间通过 Exchanger 进行数据交换的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Exchanger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello from thread 1&quot;</span>;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> exchanger.exchange(data);<br>                System.out.println(<span class="hljs-string">&quot;Thread 1 got result: &quot;</span> + result);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello from thread 2&quot;</span>;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> exchanger.exchange(data);<br>                System.out.println(<span class="hljs-string">&quot;Thread 2 got result: &quot;</span> + result);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Thread 1 got result: Hello from thread 2<br>Thread 2 got result: Hello from thread 1<br></code></pre></td></tr></table></figure>

<p>可以看到，两个线程之间成功进行了数据交换，并且获取到了对方传递的数据。</p>
<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p>略</p>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><img src="/.io//image-20230517170045229.png" alt="image-20230517170045229" style="zoom:80%;">

<img src="/.io//05/07/Java并发编程/image-20230516190422449.png" alt="image-20230517170045229" style="zoom:80%;">

<h2 id="秒杀性能比较"><a href="#秒杀性能比较" class="headerlink" title="秒杀性能比较"></a>秒杀性能比较</h2><ul>
<li><p>synchronized</p>
</li>
<li><p>AtomicInteger</p>
<p>实现原理：基于CAS，使用了<code>Unsafe</code>类的一些函数来进行底层的原子性操作。</p>
<p>虽然<code>Unsafe</code>类可以进行一些不安全的操作，但在<code>AtomicInteger</code>中，它被用来实现线程安全的原子性操作。这是一个很好的例子，说明了工具本身并不决定结果，关键在于如何使用工具。</p>
</li>
<li><p>LongAdder</p>
<p>实现原理：分段锁，每个线程对应数组中的一个值，最后将值加和</p>
</li>
</ul>
<h1 id="锁优化方案"><a href="#锁优化方案" class="headerlink" title="锁优化方案"></a>锁优化方案</h1><h2 id="减小锁的范围"><a href="#减小锁的范围" class="headerlink" title="减小锁的范围"></a>减小锁的范围</h2><p>缩小锁的范围就是缩短持有锁的时间，减轻阻塞。</p>
<p>最简单的做法是将一些不会产生线程安全问题的代码移到同步代码块之外，比如把不会产生线程安全问题的I&#x2F;O类耗时的操作，放在同步代码块之外。</p>
<h2 id="减小锁的粒度"><a href="#减小锁的粒度" class="headerlink" title="减小锁的粒度"></a>减小锁的粒度</h2><p>减小锁的粒度就是缩小锁定对象的范围，就能够减少锁的竞争。</p>
<p>做法是把对大对象的加锁转换为对小对象的加锁，比如一个类中的多个方法都是对this加锁，按照减小锁粒度的思路就可以转换为只对每个方法中用到的临界区对象加锁。</p>
<h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h2><p>锁分离就是把锁拆分为读锁和写锁，规则是读读不互斥、读写和写写互斥</p>
<p>锁分离最典型的应用是ReadWriteLock（读&#x2F;写锁）</p>
<h2 id="锁分段"><a href="#锁分段" class="headerlink" title="锁分段"></a>锁分段</h2><p>锁分段就是对一组对象上的锁进行分解，以减小锁的粒度。</p>
<p>锁分段的典型应用是ConcurrentHashMap，ConcurrentHashMap将数据按照不同的数据段进行存储（使用了一个包含16个锁的数组），并为每一个数据段分配一把锁（第N个数据交给第N%16把锁保护）。</p>
<h2 id="避免热点区域"><a href="#避免热点区域" class="headerlink" title="避免热点区域"></a>避免热点区域</h2><p>避免热点区域是对热点区域（经常被访问的临界区）进行优化。</p>
<p>避免热点区域典型的应用是ConcurrentHashMap的size，ConcurrentHashMap会给每个数据段分别维护size，而不是共用一个size，这些size由所在数据段的锁来维护，减小了size改变的竞争频率，要统计size长度时，会累加数据段的size。</p>
<h2 id="使用独占锁的替换方案"><a href="#使用独占锁的替换方案" class="headerlink" title="使用独占锁的替换方案"></a>使用独占锁的替换方案</h2><p>要保证线程安全，还可以根据需要使用下面的方案替换独占锁：</p>
<ol>
<li>并发容器</li>
<li>读&#x2F;写锁</li>
<li>乐观锁（如使用了CAS操作的原子类）</li>
<li>final关键字修饰的不可变对象（final修饰的的变量是不可变的，不存在线程安全问题）</li>
</ol>
<h2 id="JVM自带的锁优化"><a href="#JVM自带的锁优化" class="headerlink" title="JVM自带的锁优化"></a>JVM自带的锁优化</h2><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除的前提的JVM开启了逃逸分析，如果JVM通过逃逸分析发现对象只能被一个线程访问到，就可以不对这个对象加锁。即便程序中使用了同步锁，JVM也会将锁消除。</p>
<p>JVM参数：</p>
<ol>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>开启同步锁消除：-XX:+EliminateLocks</li>
</ol>
<p>如下代码，尽管StringBuffer的append()是被synchronized修饰的，但是不存在线程竞争，JVM会进行锁消除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//append()是被synchronized修饰的</span><br>    sb.append(<span class="hljs-string">&quot;2&quot;</span>);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>由于锁的竞争和释放开销比较大，如果代码中对锁进行了频繁的竞争和释放，那么JVM会进行优化，将锁的范围适当扩大。</p>
<p>如下代码，在循环内使用synchronized，JVM锁粗化后，会将锁范围扩大到循环外。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>粗化后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>      		...      <br>    	&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然JVM内部会进行优化，但是最好还是在代码里就优化了。</p>
<h1 id="分布式锁架构"><a href="#分布式锁架构" class="headerlink" title="分布式锁架构"></a>分布式锁架构</h1><h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h2><p>超卖问题的意思是系统售出的商品数量超出库存量，产生原因是多个线程同时拿到了同一商品的相同库存量，对同一商品的相同库存量进行了多次扣减。</p>
<p>下面给出模拟超卖问题的示例。</p>
<ol>
<li>使用SpringBoot和Redis搭建的会产生超卖问题的程序：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order/v1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverSoldV1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRODUCT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">STOCK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(String.valueOf(OverSold.class));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverSold</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>        stringRedisTemplate.opsForValue().set(PRODUCT_ID, STOCK_COUNT);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/submitOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submitOrder</span><span class="hljs-params">()</span> &#123;<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">stockString</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(PRODUCT_ID);<br>        <span class="hljs-keyword">if</span> (stockString == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(stockString.trim())) &#123;<br>            logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> Integer.parseInt(stockString);<br>        <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>            stock -= <span class="hljs-number">1</span>;<br>            stringRedisTemplate.opsForValue().set(PRODUCT_ID, String.valueOf(stock));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;库存扣减成功，当前库存为：&quot;</span> + stock;<br>            logger.info(info);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p>使用JMeter对接口进行并发测试，设置线程数为5，Ramp-up period是0，即5个线程会同时访问</p>
</li>
<li><p>运行JMeter测试任务，得到输出结果，可以看到存在对同一商品的相同库存进行了多次扣减的问题，即超卖问题。</p>
<p><img src="/.io//05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521092117804.png" alt="image-20230521092117804"></p>
</li>
</ol>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="分布式锁的实现方式"><a href="#分布式锁的实现方式" class="headerlink" title="分布式锁的实现方式"></a>分布式锁的实现方式</h3><p>Java提供的锁机制都是JVM级别的，只在JVM进程内部有效。但是不能解决分布式场景下的高并发问题，要解决分布式环境下的高并发问题，需要使用分布式锁。</p>
<p>实现分布式锁可以参照JVM锁的实现方式，JVM中多个线程在访问临界区资源时，会到统一的地方检查程序的临界区是否已经加锁，JVM在统一的地方使用加锁状态来标记是否进行了加锁操作，这个统一的地方可以是保存加锁状态的服务。</p>
<p>分布式锁的实现方法和JVM锁的实现方法类似，只是在实现JVM锁时，是将锁的状态保存在Java对象头中，而实现分布式锁时，是将锁的状态保存在一个外部服务中，这个外部服务可以使用数据库（如MySQL）、Redis、Zookeeper等数据存储服务实现。</p>
<p>具体实现方式：</p>
<ol>
<li><p>基于数据库的锁：这种方式通常是在数据库中创建一张锁表，需要获取锁的时候在这张表中插入一条记录，释放锁的时候则删除这条记录。这种方式实现简单，但是性能可能会受到影响。</p>
</li>
<li><p>基于Redis的锁：Redis提供了一些原子性的操作，比如<code>SETNX</code>，set if not exist， 可以利用这些特性来实现分布式锁。<code>SETNX</code>命令可以在键不存在的情况下设置键值对，如果键已经存在，则不做任何操作。这种方式性能较好，但是需要处理好锁的超时和续期问题。</p>
</li>
<li><p>基于Zookeeper的锁：Zookeeper提供了一种叫做顺序临时节点的机制，可以利用这个机制来实现分布式锁。要获取锁的线程创建一个临时节点，如果这个节点是所有节点中序号最小的，那么就认为这个线程获取了锁。这种方式性能较差，但是更加可靠，适合对一致性要求更高的场景。</p>
</li>
</ol>
<h3 id="分布式锁的基本要求"><a href="#分布式锁的基本要求" class="headerlink" title="分布式锁的基本要求"></a>分布式锁的基本要求</h3><p>要实现一个分布式锁，需要满足以下要求：</p>
<ol>
<li>支持互斥性：支持多个线程操作同一共享变量的互斥性。</li>
<li>支持阻塞与非阻塞：当线程获取分布式锁失败，分布式锁能够支持当前线程是阻塞或者非阻塞的特性。</li>
<li>支持可重入性：分布式锁能够支持同一线程同时多次获取同一个分布式锁的特性。</li>
<li>支持锁超时：为避免获取到分布式锁的线程意外退出，进而无法正常释放锁，导致其它线程无法正常获取到锁的情况，分布式锁需要支持超时机制，若加锁时长超过一定时间，锁就会自动释放。</li>
</ol>
<h3 id="CAP理论与分布式锁模型"><a href="#CAP理论与分布式锁模型" class="headerlink" title="CAP理论与分布式锁模型"></a>CAP理论与分布式锁模型</h3><p>CAP理论是分布式领域非常著名的理论，CAP理论由C、A、P三部分组成，每个字母的含义如下：</p>
<ol>
<li>C（Consistency）：一致性，表示在分布式环境下，所有节点在任意时刻都具有相同的数据。</li>
<li>A（Availability）：可用性，表示在分布式环境下，每个请求都能得到响应，但是不能保证能够获取到最新的数据。</li>
<li>P（Partition Tolerance）：分区容错性，表示在分布式环境下，当系统中的某个分区发生故障或通信中断时，其他分区可以继续运行，保持整个系统的正常工作。</li>
</ol>
<p>同时，CAP理论指出，在分布式环境下，不可能同时保证一致性、可用性和分区容错性，最多只能保证其中的两个特性。</p>
<p>在分布式系统中，必须保证分区容错性。</p>
<p>基于CAP理论可以进行分布式锁模型的设计，例如：</p>
<ol>
<li><p>基于Redis的AP架构模型</p>
<p>Redis先返回请求结果，再以异步的方式同步数据</p>
</li>
<li><p>基于Zookeeper的CP架构模型</p>
<p>当数据在大多数Zookeeper节点间同步完成后，才返回请求结果</p>
</li>
</ol>
<h3 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h3><p>在超卖问题的示例代码的基础上，进行优化得到可以确保如下条件的分布式锁：</p>
<ol>
<li><p>不会出现超卖</p>
<p>使用Redis的SETNX命令，该命令的返回结果是：</p>
<ul>
<li>1：Redis中不存在当前key，设置键值对成功</li>
<li>0：Redis中存在当前key，设置键值对失败</li>
</ul>
<p>使用该命令对应的函数存储当前获取锁的线程id，以是否返回1作为是否获取到锁的判断条件，可以确保每次只有一个线程获取到锁</p>
<p>同时为了保证可重入性，在每次获取锁之前先判断是否是自己持有的锁</p>
</li>
<li><p>不会因为线程异常退出导致锁无法释放</p>
<p>解决方法是</p>
<ol>
<li>引入try finally块</li>
<li>引入超时机制，为避免获取到锁之后没有执行设置超时机制，需要和SETNX命令共同以原子化的方式使用</li>
</ol>
</li>
</ol>
<p>修改后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order/v2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverSoldV2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRODUCT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">THREAD_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;THREAD_ID&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">STOCK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(String.valueOf(OverSoldV2.class));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverSoldV2</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>        stringRedisTemplate.opsForValue().set(PRODUCT_ID, STOCK_COUNT);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/submitOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submitOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> String.valueOf(Thread.currentThread().getId());<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLocked</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(THREAD_ID, threadId, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(isLocked)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;failure&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">stockString</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(PRODUCT_ID);<br>            <span class="hljs-keyword">if</span> (stockString == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(stockString.trim())) &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> Integer.parseInt(stockString);<br>            <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>                stock -= <span class="hljs-number">1</span>;<br>                stringRedisTemplate.opsForValue().set(PRODUCT_ID, String.valueOf(stock));<br>                <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;库存扣减成功，当前库存为：&quot;</span> + stock;<br>                logger.info(info);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stringRedisTemplate.delete(THREAD_ID);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行JMeter测试任务，得到输出结果，可以看到不再发生对库存重复扣减，超卖问题被解决。</p>
<p><img src="/.io//05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521143353323.png" alt="image-20230521143353323"></p>
<p>虽然超卖问题已经解决，但是每次获取锁失败就直接返回，没有实现锁的阻塞性，要实现锁的阻塞性，一种简单的实现方式是使用自旋：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order/v3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverSoldV3</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRODUCT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">THREAD_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;THREAD_ID&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">STOCK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(String.valueOf(OverSoldV3.class));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverSoldV3</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>        stringRedisTemplate.opsForValue().set(PRODUCT_ID, STOCK_COUNT);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/submitOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submitOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> String.valueOf(Thread.currentThread().getId());<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLocked</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(THREAD_ID, threadId, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(isLocked)) &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                isLocked = stringRedisTemplate.opsForValue().setIfAbsent(THREAD_ID, threadId, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>            &#125; <span class="hljs-keyword">while</span> (Boolean.FALSE.equals(isLocked));<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">stockString</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(PRODUCT_ID);<br>            <span class="hljs-keyword">if</span> (stockString == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(stockString.trim())) &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> Integer.parseInt(stockString);<br>            <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>                stock -= <span class="hljs-number">1</span>;<br>                stringRedisTemplate.opsForValue().set(PRODUCT_ID, String.valueOf(stock));<br>                <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;库存扣减成功，当前库存为：&quot;</span> + stock;<br>                logger.info(info);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stringRedisTemplate.delete(THREAD_ID);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用阻塞等待后，调整JMeter的请求数等于商品数（100），如果恰好消费完，说明锁的阻塞等待是有效的。</p>
<p>JMeter的线程参数配置如下图，开启了5个线程，每个线程循环20次，请求次数总共100次：</p>
<p><img src="/.io//05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521144244517.png" alt="image-20230521144244517"></p>
<p>运行JMeter测试任务，输出结果显示如下图：</p>
<p><img src="/.io//05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/../Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521144440514.png" alt="image-20230521144440514"></p>
<p>输出结果显示，确实是恰好消费完，说明锁的阻塞等待是有效的。</p>
<h1 id="秒杀系统架构"><a href="#秒杀系统架构" class="headerlink" title="秒杀系统架构"></a>秒杀系统架构</h1><h2 id="电商系统架构"><a href="#电商系统架构" class="headerlink" title="电商系统架构"></a>电商系统架构</h2><p>一个简化的电商系统架构由上到下分为客户端、网关层、负载均衡层、应用层和存储层。各层包含的应用和服务举例如下：</p>
<ol>
<li>客户端：PC网页端、APP、H5网页端、小程序。</li>
<li>网关层：系统网关，包括硬件网关和软件网关。</li>
<li>负载均衡层：Nginx等负载均衡服务器</li>
<li>应用层：涵盖接入服务和基础服务等<ol>
<li>接入服务：商品接入服务、会员接入服务、订单接入服务、收银接入服务、物流接入服务等</li>
<li>基础服务：商品服务、用户服务、订单服务、库存服务、价格服务、物流服务等</li>
</ol>
</li>
<li>存储层：数据库集群、缓存集群、ElastichSearch集群等</li>
</ol>
<p>各层的并发度估计：</p>
<ol>
<li>假设负载均衡层使用的是Nginx，Nginx的最大并发度大于10万，数量级是万</li>
<li>假设应用层使用的是Tomcat，Tomcat的最大并发度8百左右，数量级是百</li>
<li>假设存储层的缓存使用的是Redis，Redis的最大并发度5万左右，数量级是万</li>
<li>假设存储层的数据库使用的是MySQL，MySQL的最大并发度1千左右，数量级是千</li>
</ol>
<p>在设计系统架构时需要综合考虑系统各层的最大并发度和数量级。</p>
<p>其中，</p>
<p>在 Redis 缓存层面可以采用主从复制、集群模式等技术来提高数据读写的并发度和可靠性，同时合理选择缓存策略，避免缓存雪崩和缓存穿透等问题。</p>
<p>在 MySQL 数据库层面可以采用水平分库分表、索引优化、SQL 语句优化等方式来提高并发度和性能。</p>
<p>需要注意的是，在实际应用中，系统性能还受到其它多种因素的影响，例如硬件配置、网络带宽、业务规模和复杂度等。</p>
<h3 id="系统扩容"><a href="#系统扩容" class="headerlink" title="系统扩容"></a>系统扩容</h3><p>系统扩容包括垂直扩容和水平扩容。</p>
<p>从应用层的角度来看，垂直扩容是提升服务器的配置，水平扩容是增加服务器的数据。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存包括本地缓存和集中式缓存。</p>
<p>本地缓存可以使用Guava Cache实现，集中式缓存可以使用Redis实现。</p>
<p>在实现中，读取数据的步骤是，先读取本地缓存，如果本地缓存中没有要读取的数据，就从集中式缓存中读取，如果集中式缓存中依然没有，则从数据库中读取，然后将数据依次存入集中式缓存和本地缓存。</p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>分库分表，顾名思义，就是将原本存储于单个数据库上的数据拆分到多个数据库，把原来存储在单张数据表的数据拆分到多张数据表中，实现数据切分。</p>
<p>分库分表的实现可以分为两种方式：垂直切分和水平切分。垂直切分是将数据库中的表按照业务划分，将功能相近的业务表独立出来，分开部署；水平切分是将单张数据表中的数据进行划分，分散成多张表存储到多台服务器。</p>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>通常情况下，数据库的读操作远远多于写操作。通过读写分离，可以利用这一特点，将读操作分发给多个只负责读取数据的从服务器（读库），而将写操作发送给主服务器（写库）。这样一来，主服务器专注于处理写操作，而从服务器处理读操作，从而提高系统的整体性能和并发处理能力。</p>
<h2 id="秒杀系统的特点"><a href="#秒杀系统的特点" class="headerlink" title="秒杀系统的特点"></a>秒杀系统的特点</h2><p>秒杀系统的并发量存在瞬时凸峰，也叫做流量突刺现象。</p>
<p>秒杀系统的技术特点是：瞬时高并发、读多写少、流程简单。</p>
<p>秒杀系统的三个阶段是：</p>
<ol>
<li><p>预热阶段</p>
<p>用户会刷新秒杀页面，查看秒杀活动，用户的刷新操作可以使部分数据存储到Redis缓存中，所以称为预热。</p>
</li>
<li><p>秒杀阶段</p>
<p>秒杀阶段会产生瞬时的高并发流量，在这一阶段，要确保已经做好了服务的限流、熔断和降级等。</p>
</li>
<li><p>结算阶段</p>
</li>
</ol>
<p>秒杀系统的性能优化方案：</p>
<ol>
<li><p>异步解耦</p>
<p>将秒杀系统的整体流程进行拆分，通过队列的方式控制核心部分，实现异步解耦。</p>
</li>
<li><p>限流防刷</p>
<p>对秒杀系统的部分业务进行限流、熔断和降级处理。</p>
</li>
<li><p>资源控制</p>
<p>由于应用层能够承受的并发量比缓存的并发量少很多，所以在高并发系统中，可以使用OpenResty，由负载均衡层访问缓存。</p>
</li>
</ol>
<h1 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h1><p>Java 同步容器是指线程安全的集合类，一般用于多线程并发场景下对数据进行存取、读写等操作。它们通常是在普通容器的基础上实现了同步化措施，可以防止出现并发访问引起的数据异常或不一致性问题。</p>
<p>Java 同步容器主要有以下几种：</p>
<ol>
<li>Vector</li>
</ol>
<p>Vector 是一个数组式的容器类，它实现了线程安全和可增长性，并提供了与 ArrayList 类似的 API 接口。</p>
<ol start="2">
<li>Stack</li>
</ol>
<p>Stack 是一个继承自 Vector 类的栈类，它实现了线程安全的 push 和 pop 操作。由于使用较少，已经不推荐使用 Stack。</p>
<ol start="3">
<li>Hashtable</li>
</ol>
<p>Hashtable 是一个散列表，它实现了线程安全的 key-value 存储，与 HashMap 类似。但它相对效率较低，主要用于早期 JDK 版本中的兼容性需求。</p>
<ol start="4">
<li>ConcurrentHashMap</li>
</ol>
<p>ConcurrentHashMap 是 Java 5 引入的高性能散列表，它采用分段锁机制实现并发访问，支持大量的并发读写操作，适用于高并发场景下的数据存储和读写。</p>
<ol start="5">
<li>CopyOnWriteArrayList&#x2F;CopyOnWriteArraySet</li>
</ol>
<p>CopyOnWriteArrayList&#x2F;CopyOnWriteArraySet 是两个线程安全的集合类，它们通过复制源数据来实现并发读写。在有大量读操作但少量写操作的场景下，它们可以提供更好的性能和可靠性。</p>
<p>需要注意的是，在使用同步容器时，由于涉及到线程安全问题，需要仔细考虑同步措施、锁的粒度、并发处理能力等因素，以确保数据的正确性和稳定性。同时，也应该根据具体场景选择合适的容器类型和 API 接口。</p>
<p>同步容器类的演变<br>Map&#x2F;Set从无锁到同步<br>ArrayList<br>LinkedList<br>Collections.synchronizedXXX<br>CopyOnWriteList<br>队列<br>ConcurrentLinkedQueue<br>ConcurrentArrayQueue<br>LinkedBlockingQueue<br>Queue<br>ArrayBlockingQueue<br>TransferQueue<br>SynchronousQueue<br>DelayQueue</p>
<h1 id="分工问题的实现方式"><a href="#分工问题的实现方式" class="headerlink" title="分工问题的实现方式"></a>分工问题的实现方式</h1><p>Guarded Suspension模式</p>
<p>Thread-Pre-Message模式</p>
<p>生产者-消费者模式</p>
<p>两阶段终止模式</p>
<p>Worker-Thread模式</p>
<p>Balking模式</p>
<h1 id="ParallelStream"><a href="#ParallelStream" class="headerlink" title="ParallelStream"></a>ParallelStream</h1><p>ParallelStream 是 JDK 8 中新增的流式 API，它继承自 Java.util.stream.Stream 接口，并提供了并行流（Parallel Stream）处理能力。</p>
<p>与普通流不同的是，ParallelStream 可以利用多个线程（默认情况下是 ForkJoinPool 中的线程）来并行执行部分或全部流处理操作，以加速大容量数据的处理和分析。在并行流执行流处理操作时，它会将数据划分成多个小块，并分别交给不同的线程进行处理，在处理完成后再将结果合并返回。</p>
<p>ParallelStream 支持大部分 Stream 的 API 操作，例如 filter、map、reduce、sorted 等，只需要调用 parallel() 方法即可将一个普通流转换为并行流。需要注意的是，由于并行流涉及到多线程的协作，因此在使用 ParallelStream 时需要考虑线程安全和共享变量等问题，避免出现并发问题和数据异常。</p>
<p>以下是一个 ParallelStream 的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;scala&quot;</span>, <span class="hljs-string">&quot;ruby&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list.parallelStream().filter(str -&gt; str.length() &gt; <span class="hljs-number">4</span>).count();<br>System.out.println(count);<br></code></pre></td></tr></table></figure>

<p>以上代码演示了如何使用 ParallelStream 统计字符串列表中长度大于 4 的字符串数量。由于 ParallelStream 默认使用 ForkJoinPool 的线程池来执行并行计算，因此可以实现更高效的数据统计和分析。</p>
<h1 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h1><p>JMH解决什么问题<br>JMH插件安装<br>JMH吞吐量测试<br>JMH QPS&#x2F;TPS测试</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io">Song Baoru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><div class="post_share"><div class="social-share" data-image="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&amp;riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&amp;ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img class="cover" src="https://th.bing.com/th/id/OIP.fekfR1FWtn_EXSMaueufagHaEK?pid=ImgDet&amp;rs=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Spring Cloud</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="https://th.bing.com/th/id/R.826fae185d03cd7935cc5haf1cd1844c3?rik=9ONAxF3s06zoPg&amp;riu=http%3a%2f%2fpic5.bbzhi.com%2ffengjingbizhi%2fgaoqingziranfengjingbizhi%2fgaoqingziranfengjingbizhi_415690_15.jpg&amp;ehk=BbD3V6XWzCc5AJ7yXlMt4j5AU09Nk56syRdeDXFSvYY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">计算机网络</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Song Baoru</div><div class="author-info__description">锲而不舍，金石可镂</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SongBaoru"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text">线程的创建方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">线程局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">1.2.1.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InheritableThreadLocal"><span class="toc-number">1.2.2.</span> <span class="toc-text">InheritableThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">线程方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sleep"><span class="toc-number">1.4.1.</span> <span class="toc-text">sleep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt"><span class="toc-number">1.4.2.</span> <span class="toc-text">interrupt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">1.4.3.</span> <span class="toc-text">join</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yield"><span class="toc-number">1.4.4.</span> <span class="toc-text">yield</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#daemon"><span class="toc-number">1.4.5.</span> <span class="toc-text">daemon</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">1.5.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">1.6.</span> <span class="toc-text">线程间通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.7.</span> <span class="toc-text">用户线程和守护线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">2.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">线程池的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">线程池的创建方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">线程池执行任务的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">2.4.</span> <span class="toc-text">线程池的拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.</span> <span class="toc-text">线程池的关闭方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">2.6.</span> <span class="toc-text">最佳线程数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XXX%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">XXX程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A4%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">纤程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">超线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">4.</span> <span class="toc-text">并发编程相关的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">4.1.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">4.2.</span> <span class="toc-text">操作系统的互斥量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E3%80%81%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">4.3.</span> <span class="toc-text">用户态、内核态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">4.4.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E3%80%81%E6%B4%BB%E9%94%81"><span class="toc-number">4.5.</span> <span class="toc-text">死锁、饥饿、活锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">4.6.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E6%88%90%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.6.1.</span> <span class="toc-text">形成死锁的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-number">4.6.2.</span> <span class="toc-text">死锁的预防</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.7.</span> <span class="toc-text">自旋锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">5.</span> <span class="toc-text">原子性、可见性、有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">5.1.</span> <span class="toc-text">原子性核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E9%94%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.1.1.</span> <span class="toc-text">总线锁保证原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.1.2.</span> <span class="toc-text">互斥锁保证原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">5.1.3.</span> <span class="toc-text">CAS保证原子性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">可见性和有序性核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">5.2.1.</span> <span class="toc-text">缓存一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MESI%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.2.2.</span> <span class="toc-text">MESI协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.3.</span> <span class="toc-text">volatile核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">保证可见性的核心原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">保证有序性的核心原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DCL%E5%8D%95%E4%BE%8B"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">DCL单例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.4.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">JMM的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Happens-Before%E5%8E%9F%E5%88%99"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">Happens-Before原则</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized"><span class="toc-number">6.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E7%94%A8%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">synchronized用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">Java对象结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JOL%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.</span> <span class="toc-text">使用JOL查看对象结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.4.</span> <span class="toc-text">synchronized底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monitor%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">6.5.</span> <span class="toc-text">Monitor锁原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.6.</span> <span class="toc-text">锁升级的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-number">6.7.</span> <span class="toc-text">锁降级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">7.</span> <span class="toc-text">AQS核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">AQS数据结构原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E5%BA%95%E5%B1%82%E5%AF%B9%E9%94%81%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">7.2.</span> <span class="toc-text">AQS底层对锁的支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">7.3.</span> <span class="toc-text">独占锁和共享锁的实现流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lock%E9%94%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">8.</span> <span class="toc-text">Lock锁核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E9%94%81"><span class="toc-number">8.1.</span> <span class="toc-text">显示锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.</span> <span class="toc-text">公平锁和非公平锁的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text">悲观锁和乐观锁的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.4.</span> <span class="toc-text">可中断锁和不可中断锁的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">8.5.</span> <span class="toc-text">独占锁和共享锁的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB-x2F-%E5%86%99%E9%94%81"><span class="toc-number">8.6.</span> <span class="toc-text">读&#x2F;写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">8.6.1.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StampedLock"><span class="toc-number">8.6.2.</span> <span class="toc-text">StampedLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport%E5%8E%9F%E7%90%86"><span class="toc-number">8.7.</span> <span class="toc-text">LockSupport原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">CAS核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">CAS的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BBUnsafe"><span class="toc-number">9.2.</span> <span class="toc-text">CAS的核心类Unsafe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">9.3.</span> <span class="toc-text">ABA问题的解决方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JUC%E5%90%8C%E6%AD%A5%E9%94%81"><span class="toc-number">10.</span> <span class="toc-text">JUC同步锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">10.1.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">10.2.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">10.3.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReadWriteLock"><span class="toc-number">10.4.</span> <span class="toc-text">ReadWriteLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StampedLock-1"><span class="toc-number">10.5.</span> <span class="toc-text">StampedLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-number">10.6.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exchanger"><span class="toc-number">10.7.</span> <span class="toc-text">Exchanger</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Phaser"><span class="toc-number">10.8.</span> <span class="toc-text">Phaser</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">11.</span> <span class="toc-text">原子类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">11.1.</span> <span class="toc-text">秒杀性能比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">12.</span> <span class="toc-text">锁优化方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%8F%E5%B0%8F%E9%94%81%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">12.1.</span> <span class="toc-text">减小锁的范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%8F%E5%B0%8F%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-number">12.2.</span> <span class="toc-text">减小锁的粒度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%88%86%E7%A6%BB"><span class="toc-number">12.3.</span> <span class="toc-text">锁分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%88%86%E6%AE%B5"><span class="toc-number">12.4.</span> <span class="toc-text">锁分段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%83%AD%E7%82%B9%E5%8C%BA%E5%9F%9F"><span class="toc-number">12.5.</span> <span class="toc-text">避免热点区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88"><span class="toc-number">12.6.</span> <span class="toc-text">使用独占锁的替换方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%87%AA%E5%B8%A6%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">12.7.</span> <span class="toc-text">JVM自带的锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">12.7.1.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">12.7.2.</span> <span class="toc-text">锁粗化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9E%B6%E6%9E%84"><span class="toc-number">13.</span> <span class="toc-text">分布式锁架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">13.1.</span> <span class="toc-text">超卖问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">13.2.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">13.2.1.</span> <span class="toc-text">分布式锁的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82"><span class="toc-number">13.2.2.</span> <span class="toc-text">分布式锁的基本要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">13.2.3.</span> <span class="toc-text">CAP理论与分布式锁模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">13.2.4.</span> <span class="toc-text">基于Redis实现分布式锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">14.</span> <span class="toc-text">秒杀系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">14.1.</span> <span class="toc-text">电商系统架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%AE%B9"><span class="toc-number">14.1.1.</span> <span class="toc-text">系统扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98"><span class="toc-number">14.1.2.</span> <span class="toc-text">缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">14.1.3.</span> <span class="toc-text">分库分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">14.1.4.</span> <span class="toc-text">读写分离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">14.2.</span> <span class="toc-text">秒杀系统的特点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">15.</span> <span class="toc-text">同步容器</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B7%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">16.</span> <span class="toc-text">分工问题的实现方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ParallelStream"><span class="toc-number">17.</span> <span class="toc-text">ParallelStream</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JMH"><span class="toc-number">18.</span> <span class="toc-text">JMH</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/RocketMQ/" title="RocketMQ"><img src="https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJlbKx9CIKZ-qABs7mJV2aP0AALH5ALBgd0AGzuw770.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/2023/05/24/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2023-05-24T08:13:44.000Z" title="Created 2023-05-24 16:13:44">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img src="https://th.bing.com/th/id/OIP.fekfR1FWtn_EXSMaueufagHaEK?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud">Spring Cloud</a><time datetime="2023-05-24T08:08:42.000Z" title="Created 2023-05-24 16:08:42">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程"><img src="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&amp;riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&amp;ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程"/></a><div class="content"><a class="title" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程">Java并发编程</a><time datetime="2023-05-07T13:39:13.000Z" title="Created 2023-05-07 21:39:13">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://th.bing.com/th/id/R.826fae185d03cd7935cc5haf1cd1844c3?rik=9ONAxF3s06zoPg&amp;riu=http%3a%2f%2fpic5.bbzhi.com%2ffengjingbizhi%2fgaoqingziranfengjingbizhi%2fgaoqingziranfengjingbizhi_415690_15.jpg&amp;ehk=BbD3V6XWzCc5AJ7yXlMt4j5AU09Nk56syRdeDXFSvYY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-05-07T13:37:05.000Z" title="Created 2023-05-07 21:37:05">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/06/MyBatis/" title="MyBatis"><img src="https://th.bing.com/th/id/R.f30d1b50c29ba7f0e12424fbbf0551ca?rik=hnAxT1tmhc0F6w&amp;riu=http%3a%2f%2fpic1.nipic.com%2f2008-12-08%2f2008128103444133_2.jpg&amp;ehk=qaYhQ%2bunO6OW2e3CpMr0hG1F0%2fDwzdUsf6rpZ9plC5Y%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MyBatis"/></a><div class="content"><a class="title" href="/2023/05/06/MyBatis/" title="MyBatis">MyBatis</a><time datetime="2023-05-06T03:04:46.000Z" title="Created 2023-05-06 11:04:46">2023-05-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Song Baoru</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>