<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"songbaoru.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Java 并发编程是 Java 面试中的一个重要部分，因为在现代多核处理器和高并发应用程序中，充分理解并发编程及其挑战非常关键。以下是一些 Java 并发编程的常见面试考点：  Java 中的线程创建和管理：了解如何创建和管理线程，包括使用 Thread 类、Runnable 接口和 Java 8 中的 CompletableFuture 类。  线程同步：了解如何使用 synchronized">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:description" content="Java 并发编程是 Java 面试中的一个重要部分，因为在现代多核处理器和高并发应用程序中，充分理解并发编程及其挑战非常关键。以下是一些 Java 并发编程的常见面试考点：  Java 中的线程创建和管理：了解如何创建和管理线程，包括使用 Thread 类、Runnable 接口和 Java 8 中的 CompletableFuture 类。  线程同步：了解如何使用 synchronized">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2023-05-07T13:39:13.000Z">
<meta property="article:modified_time" content="2023-05-11T14:30:37.001Z">
<meta property="article:author" content="SBR">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/","path":"2023/05/07/Java并发编程/","title":"Java并发编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Java并发编程 | SBR Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">SBR Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">创建线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="nav-number">1.2.</span> <span class="nav-text">线程间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="nav-number">1.3.</span> <span class="nav-text">线程局部变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B6%85%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.4.</span> <span class="nav-text">超线程</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CAS"><span class="nav-number">2.</span> <span class="nav-text">CAS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CAS%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.</span> <span class="nav-text">CAS底层实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">Java内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.1.</span> <span class="nav-text">对象内存模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#synchronized"><span class="nav-number">4.</span> <span class="nav-text">synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.</span> <span class="nav-text">synchronized底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="nav-number">4.2.</span> <span class="nav-text">锁升级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%92%E6%96%A5%E9%87%8F"><span class="nav-number">4.3.</span> <span class="nav-text">操作系统的互斥量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E3%80%81%E5%86%85%E6%A0%B8%E6%80%81"><span class="nav-number">4.4.</span> <span class="nav-text">用户态、内核态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="nav-number">4.5.</span> <span class="nav-text">锁消除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="nav-number">4.6.</span> <span class="nav-text">锁粗化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#volatile"><span class="nav-number">5.</span> <span class="nav-text">volatile</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%80%A7"><span class="nav-number">5.1.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.2.</span> <span class="nav-text">应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%AF%B9volatile%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E7%89%B9%E6%AE%8A%E8%A7%84%E5%88%99"><span class="nav-number">5.3.</span> <span class="nav-text">Java内存模型对volatile变量定义的特殊规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.4.</span> <span class="nav-text">volatile底层实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DCL%E5%8D%95%E4%BE%8B"><span class="nav-number">5.5.</span> <span class="nav-text">DCL单例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">6.</span> <span class="nav-text">ThreadLocal</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadPool"><span class="nav-number">7.</span> <span class="nav-text">ThreadPool</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#FutureTask"><span class="nav-number">8.</span> <span class="nav-text">FutureTask</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88"><span class="nav-number">9.</span> <span class="nav-text">并发集合</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8"><span class="nav-number">10.</span> <span class="nav-text">同步容器</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">并发工具类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AQS"><span class="nav-number">11.1.</span> <span class="nav-text">AQS</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LockSupport"><span class="nav-number">11.2.</span> <span class="nav-text">LockSupport</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC%E5%90%8C%E6%AD%A5%E9%94%81"><span class="nav-number">12.</span> <span class="nav-text">JUC同步锁</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock"><span class="nav-number">12.1.</span> <span class="nav-text">ReentrantLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CountDownLatch"><span class="nav-number">12.2.</span> <span class="nav-text">CountDownLatch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CyclicBarrier"><span class="nav-number">12.3.</span> <span class="nav-text">CyclicBarrier</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Phaser"><span class="nav-number">12.4.</span> <span class="nav-text">Phaser</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReadWriteLock"><span class="nav-number">12.5.</span> <span class="nav-text">ReadWriteLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#StampedLock"><span class="nav-number">12.6.</span> <span class="nav-text">StampedLock</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Semaphore"><span class="nav-number">12.7.</span> <span class="nav-text">Semaphore</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exchanger"><span class="nav-number">12.8.</span> <span class="nav-text">Exchanger</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">13.</span> <span class="nav-text">线程池</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E3%80%81%E6%B4%BB%E9%94%81"><span class="nav-number">14.</span> <span class="nav-text">死锁、饥饿、活锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JUC%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7"><span class="nav-number">15.</span> <span class="nav-text">JUC同步工具</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JMH"><span class="nav-number">16.</span> <span class="nav-text">JMH</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="nav-number">17.</span> <span class="nav-text">原子类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B7%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">18.</span> <span class="nav-text">分工问题的实现方式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">19.</span> <span class="nav-text">分布式锁</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81"><span class="nav-number">20.</span> <span class="nav-text">乐观锁和悲观锁</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SBR</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Java并发编程 | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java并发编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-07 21:39:13" itemprop="dateCreated datePublished" datetime="2023-05-07T21:39:13+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-11 22:30:37" itemprop="dateModified" datetime="2023-05-11T22:30:37+08:00">2023-05-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>Java 并发编程是 Java 面试中的一个重要部分，因为在现代多核处理器和高并发应用程序中，充分理解并发编程及其挑战非常关键。以下是一些 Java 并发编程的常见面试考点：</p>
<ol>
<li><p>Java 中的线程创建和管理：了解如何创建和管理线程，包括使用 <code>Thread</code> 类、<code>Runnable</code> 接口和 Java 8 中的 <code>CompletableFuture</code> 类。</p>
</li>
<li><p>线程同步：了解如何使用 <code>synchronized</code> 关键字、<code>ReentrantLock</code>、<code>Semaphore</code> 等同步原语来保证线程安全。</p>
</li>
<li><p>线程间通信：了解如何使用 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法以及 <code>BlockingQueue</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code> 等机制进行线程间通信。</p>
</li>
<li><p>线程局部变量：了解 <code>ThreadLocal</code> 类的使用，它允许在不同线程中存储和访问线程独立的变量。</p>
</li>
<li><p>Java 内存模型：理解 Java 内存模型中的关键概念，如原子性、可见性和有序性，以及如何使用 <code>volatile</code> 关键字和原子操作类（如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等）来确保并发安全。</p>
</li>
<li><p>线程池：了解 Java 中线程池的概念和用法，包括 <code>Executor</code>、<code>ExecutorService</code> 和 <code>ScheduledExecutorService</code> 接口，以及 <code>ThreadPoolExecutor</code> 和 <code>ForkJoinPool</code> 等具体实现。</p>
</li>
<li><p>并发集合：了解 Java 并发包中提供的线程安全集合类，如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code> 等。</p>
</li>
<li><p>并行流：了解 Java 8 中引入的并行流（Parallel Streams）概念，以及如何利用它进行数据并行处理。</p>
</li>
<li><p>CompletableFuture：了解 Java 8 引入的 <code>CompletableFuture</code> 类，它提供了异步编程、组合和转换操作的强大功能。</p>
</li>
<li><p>死锁、饥饿和活锁：理解死锁、饥饿和活锁的概念，以及如何检测和解决这些问题。</p>
</li>
</ol>
<p>这些是 Java 并发编程的一些关键考点，掌握它们将有助于面试过程中回答相关问题。同时，在实际项目中应用这些知识，能够更好地解决并发编程中可能遇到的问题。</p>
<p>以下是一些关于 Java 并发的面试常见问题：</p>
<ol>
<li><p>如何在 Java 中创建线程？</p>
</li>
<li><p>描述 <code>Runnable</code> 和 <code>Callable</code> 接口之间的区别。</p>
</li>
<li><p>什么是线程同步？解释 <code>synchronized</code> 关键字和 <code>ReentrantLock</code>。</p>
</li>
<li><p>什么是死锁？如何预防和解决死锁？</p>
</li>
<li><p>解释线程间通信的方法，例如 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code>。</p>
</li>
<li><p>什么是线程池？如何在 Java 中创建和使用线程池？</p>
</li>
<li><p>描述 Java 中的 <code>Executor</code>、<code>ExecutorService</code> 和 <code>ScheduledExecutorService</code> 接口。</p>
</li>
<li><p>什么是 Java 内存模型？解释原子性、可见性和有序性。</p>
</li>
<li><p>什么是 <code>volatile</code> 关键字？它如何确保可见性和有序性？</p>
</li>
<li><p>解释 Java 中的原子操作类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 和 <code>AtomicReference</code>。</p>
</li>
<li><p>描述 Java 并发包中的线程安全集合类，如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code>。</p>
</li>
<li><p>什么是 Java 8 中的并行流（Parallel Streams）？如何使用它们？</p>
</li>
<li><p>解释 Java 8 中的 <code>CompletableFuture</code> 类及其用法。</p>
</li>
<li><p>描述线程饥饿和活锁问题，以及如何解决它们。</p>
</li>
<li><p>什么是 <code>ThreadLocal</code> 类？它如何在 Java 中使用？</p>
</li>
</ol>
<p>这些问题涵盖了 Java 并发编程的各个方面。为了在面试中表现出色，请确保熟悉这些问题并准备好清晰、简洁的答案。同时，在实际项目中应用这些知识，能够更好地解决并发编程中可能遇到的问题。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程可以通俗的理解为程序不同的执行路径</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul>
<li>继承Thread类</li>
<li>定义一个类实现Runnable接口</li>
<li>使用Callable和Future创建线程</li>
<li>通过线程池创建线程</li>
</ul>
<p>线程状态</p>
<p>线程同步</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h2 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h2><p>线程池</p>
<p>线程顺序执行控制<br>高频面试加分项<br>JDK13&#x2F;14的改变<br>纤程<br>Quasar类库的使用</p>
<p>在Java和许多其他编程语言中，线程的<code>sleep()</code>方法并不会导致线程释放锁，但是不会阻塞其他线程。</p>
<p>当一个线程调用<code>sleep()</code>方法时，它会使线程进入阻塞状态一段时间，但该线程仍然保有它已经获得的所有锁。这意味着如果一个线程在进入<code>sleep()</code>之前获得了一个锁，那么它在<code>sleep()</code>期间仍然会保持这个锁，其他线程无法获得这个锁。</p>
<p>这与线程的<code>wait()</code>方法不同。当一个线程调用<code>wait()</code>方法时，它会释放它在相应对象上的锁，允许其他线程获得这个锁。</p>
<p>这是因为<code>sleep()</code>和<code>wait()</code>方法的设计目标不同：<code>sleep()</code>方法主要用于让线程暂停一段时间，而<code>wait()</code>方法主要用于实现线程间的同步。所以，在编写多线程程序时，需要根据实际的需求和情况选择合适的方法。</p>
<h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>超线程（Hyper-Threading）是Intel公司引入的一种处理器（CPU）技术。这项技术的主要目标是提高处理器核心的效率和性能。超线程通过使单个处理器核心模拟出两个“逻辑”核心，以便同时处理两个线程，从而提高了处理器的并行处理能力。</p>
<p>传统的单核心处理器在任何时刻只能处理一个线程。但是，由于各种原因（例如，等待数据从内存中加载），处理器可能无法始终保持忙碌状态。在这些情况下，处理器的一部分（例如，算术逻辑单元或浮点单元）可能会闲置，从而造成资源浪费。</p>
<p>超线程技术试图解决这个问题，通过在单个核心上同时运行两个线程，使得当一个线程在等待时，另一个线程可以使用处理器的资源进行计算。因此，超线程可以使处理器在相同的时间内完成更多的工作，从而提高处理器的整体效率和性能。</p>
<p>然而，超线程并不总是能提供显著的性能提升。在某些情况下，如果两个线程需要使用相同的处理器资源，那么它们可能会相互竞争，从而导致性能下降。此外，超线程对于多线程程序或多任务环境最有效，对于单线程程序或单任务环境的效果可能不明显。</p>
<p>请注意，虽然超线程可以提高处理器的并行处理能力，但它并不能取代多核处理器。多核处理器具有多个独立的物理核心，每个核心都可以处理自己的线程，因此它们通常可以提供比超线程更好的并行性和性能。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="CAS底层实现"><a href="#CAS底层实现" class="headerlink" title="CAS底层实现"></a>CAS底层实现</h2><p>使用的操作系统原语是lock cmpxchg</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>原子性</p>
<p>可见性</p>
<p>有序性</p>
<p>进程：CPU分配资源的基本单位</p>
<p>线程：CPU执行的基本单位</p>
<p>缓存行对齐 – Disruptor就应用了缓存行对齐技术提高了数据修改效率</p>
<h2 id="对象内存模型"><a href="#对象内存模型" class="headerlink" title="对象内存模型"></a>对象内存模型</h2><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized底层实现"><a href="#synchronized底层实现" class="headerlink" title="synchronized底层实现"></a>synchronized底层实现</h2><ol>
<li>Java代码层面：使用synchronized关键字</li>
<li>字节码层面：monitorenter、monitorexit</li>
<li>执行层面：锁升级（偏向锁、自旋锁、重量级锁）</li>
<li>操作系统层面：使用的操作系统原语是lock cmpxchg</li>
</ol>
<p>synchronized是可重入的，一个原因是，如果synchronized是不可重入的，那么当一个方法调用另一个需要同一把锁的方法（被调用方法）时，被调用方法等待发起调用的方法释放锁，发起调用的方法等待被调用方法的执行，会产生死锁。</p>
<p>程序中如果出现异常，默认情况下锁会被释放，可能会导致数据不一致的情况发生，如果不想释放，可以加catch捕获异常</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><ol>
<li><p>无锁</p>
</li>
<li><p>偏向锁</p>
</li>
<li><p>自旋锁（如果发生线程争用，就由偏向锁升级为自旋锁，如果超过默认自旋次数上限，默认是10次，就会升级为重量级锁）</p>
</li>
<li><p>重量级锁（重量级锁下线程等待不占用CPU）</p>
</li>
</ol>
<p>自旋锁效率比重量级锁高的条件：同步代码块执行时间短、等待线程数少</p>
<h2 id="操作系统的互斥量"><a href="#操作系统的互斥量" class="headerlink" title="操作系统的互斥量"></a>操作系统的互斥量</h2><h2 id="用户态、内核态"><a href="#用户态、内核态" class="headerlink" title="用户态、内核态"></a>用户态、内核态</h2><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>保证可见性：Volatile变量在线程内存中被修改之后要立即同步回主内存中，以保证其他线程使用该volatile关键字修饰的变量时获取到的是最新的变量值。Volatile可以保证每次线程从主内存中刷新到最新的变量值。</li>
<li>禁止指令重排序优化（内存屏障，也会牺牲掉一些性能）</li>
</ul>
<p>不支持原子性，非线程安全：对一个volatile修饰的变量的读写操作不是原子性的。因为如果在第一个线程加载某个volatile修饰的变量值到工作内存之后有其他线程修改了这个变量值，那么第一个线程是感知不到这个值的变化的。这个时候就会出现线程安全的问题，所以为了保证线程安全问题还是需要synchronized关键字。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>运算结果不依赖于变量的当前值或者能够确保只有一个线程修改这个变量的值；</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ol>
<h2 id="Java内存模型对volatile变量定义的特殊规则"><a href="#Java内存模型对volatile变量定义的特殊规则" class="headerlink" title="Java内存模型对volatile变量定义的特殊规则"></a>Java内存模型对volatile变量定义的特殊规则</h2><ul>
<li>在工作内存中每次使用变量前都需要从主内存中刷新最新值；</li>
<li>每次修改变量的值之后都必须立刻同步到主内存中；</li>
<li>要求volatile修饰的变量不会被指令重新排序。</li>
</ul>
<h2 id="volatile底层实现"><a href="#volatile底层实现" class="headerlink" title="volatile底层实现"></a>volatile底层实现</h2><ul>
<li>保证可见性：缓存一致性</li>
<li>禁止指令重排序优化：内存屏障</li>
</ul>
<h2 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h2><p>DCL（Double Check Lock）单例为什么需要加volatile？</p>
<p>如果不加volatile，不能避免指令重排序，初始化指令和堆栈建立连接的指令可能会倒换，即可能出现堆栈建立连接发生在初始化指令之前，即</p>
<ul>
<li>加volatile，没有被重排序的指令执行过程如下<ol>
<li>初始化指令</li>
<li>堆栈建立连接的指令</li>
</ol>
</li>
<li>不加volatile，可能出现的重排序的指令执行过程如下<ul>
<li>堆栈建立连接的指令</li>
<li>初始化指令</li>
</ul>
</li>
</ul>
<p>这就导致在多线程环境下，如果没有使用volatile，假如一个线程正在使用创建对象，并且发生了指令重排序，使得堆栈建立连接的指令发生在初始化指令之前，那么当这条线程恰好执行完堆栈建立连接的指令，还没有执行初始化指令时，有一个新的线程线程执行DCL单例的函数，判断得到栈中已经指向堆中已有的对象，就会执行返回此对象，而此时对象还没有被初始化，此时获取的对象的值仅仅是默认值而不是初始化的值。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p><code>ThreadLocal</code>由一个线程的类型为<code>ThreadLocal.ThreadLocalMap</code>的对象threadlocals来保存。具体来说，在<code>ThreadLocalMap</code>中，set到<code>ThreadLocal</code>对象的值作为值（value），<code>ThreadLocal</code>对象作为键（key），并且key是一个弱引用。</p>
<h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><p><code>FutureTask</code>是Java并发包<code>java.util.concurrent</code>中的一个类，它实现了<code>RunnableFuture</code>接口，<code>RunnableFuture</code>接口同时继承了<code>Runnable</code>接口和<code>Future</code>接口。</p>
<p><code>FutureTask</code>类的主要作用是用来表示一个可以产生结果的计算任务。你可以将这个任务提交给<code>ExecutorService</code>去执行，也可以直接在你的线程中执行它。当任务执行完毕后，你可以通过调用<code>FutureTask.get()</code>方法来获取计算的结果。</p>
<p>以下是使用<code>FutureTask</code>的一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 这里是你的计算任务</span></span><br><span class="line">        <span class="keyword">return</span> doSomeLongTimeComputation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将任务提交给线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">executor.execute(futureTask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在你需要结果的时候调用get()方法获取</span></span><br><span class="line"><span class="comment">// 注意：如果任务还没有完成，get()方法会阻塞，直到任务完成为止</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br></pre></td></tr></table></figure>

<p>这里的关键是<code>Callable</code>接口和<code>Future</code>接口。<code>Callable</code>接口表示一个可以返回结果的任务，而<code>Future</code>接口表示一个异步计算的结果。<code>FutureTask</code>就是这两个接口的一个实现，它既可以作为一个任务（<code>Runnable</code>）被线程执行，也可以作为一个结果（<code>Future</code>）被线程获取。</p>
<h1 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h1><h1 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h1><p>同步容器类的演变<br>Map&#x2F;Set从无锁到同步<br>ArrayList<br>LinkedList<br>Collections.synchronizedXXX<br>CopyOnWriteList<br>队列<br>ConcurrentLinkedQueue<br>ConcurrentArrayQueue<br>LinkedBlockingQueue<br>Queue<br>ArrayBlockingQueue<br>TransferQueue<br>SynchronousQueue<br>DelayQueue</p>
<h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS（AbstractQueuedSynchronizer）是volatile和CAS和队列的组合应用</p>
<p>java中哪些同步锁是基于AQS实现的：</p>
<p>Java 并发包 <code>java.util.concurrent</code> 中的许多同步工具类都是基于 <code>AbstractQueuedSynchronizer</code> (简称 AQS) 来实现的。AQS 是一个用于构建锁和同步器的框架，它使用一个 int 成员变量来表示同步状态，并提供了一种使用 CAS（Compare-and-Swap）设置同步状态的方式。以下是一些基于 AQS 实现的同步类：</p>
<ol>
<li><p><strong>ReentrantLock</strong>：重入锁，是一种互斥锁，它的特点是支持重入功能，也就是说，一个线程能够对已经获取到的锁再次获取，而不会发生死锁。</p>
</li>
<li><p><strong>ReentrantReadWriteLock</strong>：读写锁，它分为两个锁，一个是读锁，一个是写锁。多个读锁之间不会互斥，读锁与写锁互斥，写锁与写锁互斥。这是由jvm自己控制的，你只要上好相应的锁即可。</p>
</li>
<li><p><strong>Semaphore</strong>：信号量，内部维护了一组”许可”，线程可以申请许可（如果无可用许可则阻塞），也可以释放许可。信号量可用于实现资源池，或者对某个操作的并发线程数进行限制。</p>
</li>
<li><p><strong>CountDownLatch</strong>：倒计时门栓，它可以让一个或多个线程等待其他线程完成各自的工作后再执行。</p>
</li>
<li><p><strong>CyclicBarrier</strong>：循环栅栏，它允许一组线程互相等待，直到所有的线程都准备就绪后，所有的线程才能继续执行。</p>
</li>
<li><p><strong>FutureTask</strong>：一个实现了 <code>Future</code> 和 <code>Runnable</code> 接口的类，可以用来执行 <code>Callable</code> 任务，并且可以获取任务执行后的结果。</p>
</li>
</ol>
<p>这些类都通过自定义 AQS 来实现它们自己的同步语义。</p>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p><code>LockSupport</code>是Java并发编程中一个非常有用的工具类，它位于<code>java.util.concurrent.locks</code>包中。<code>LockSupport</code>提供了一种基于线程的，低层次的线程阻塞和唤醒机制。</p>
<p>AQS 底层使用了<code>LockSupport</code>来实现线程的阻塞和唤醒</p>
<p>在底层实现上，<code>LockSupport</code>使用了一种名为”许可（Permit）”的概念来控制阻塞和唤醒。许可的数量最多为1，如果线程已经拿到了许可，则调用<code>LockSupport.park()</code>会立即返回；如果没有拿到许可，<code>park()</code>方法会阻塞线程。调用<code>LockSupport.unpark(Thread)</code>方法会给指定的线程发放许可。</p>
<p>下面是一个简单的<code>LockSupport</code>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Child thread begin park!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用park方法，挂起自己</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Child thread end park!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程延迟2s</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread begin unpark!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用unpark方法让thread线程持有许可证，然后park方法返回</span></span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，子线程通过调用<code>LockSupport.park()</code>方法阻塞自己，主线程在延迟2秒后调用<code>LockSupport.unpark(thread)</code>方法唤醒子线程。</p>
<p>需要注意的是，<code>LockSupport.park()</code>方法不会响应中断，并且不会抛出<code>InterruptedException</code>。如果线程在调用<code>park()</code>方法时被中断，或者在调用<code>park()</code>方法之前已经被中断，那么调用<code>park()</code>方法会立即返回，但是不会清除线程的中断标记。你可以通过<code>Thread.interrupted()</code>方法来检查和清除线程的中断标记。</p>
<p>unpark()可以先于park()调用：</p>
<p><code>LockSupport.unpark(thread)</code> 可以在 <code>LockSupport.park()</code> 之前调用。实际上，这是 <code>LockSupport</code> 的一个特性，即“许可”机制。</p>
<p><code>LockSupport</code> 的工作原理是，每个线程都有一个许可（permit），许可的数量最多为1。如果线程已经拿到了许可，那么调用 <code>LockSupport.park()</code> 会立即返回；如果没有许可，那么 <code>park()</code> 方法会阻塞线程。调用 <code>LockSupport.unpark(Thread)</code> 方法会给指定的线程发放许可。</p>
<p>因此，如果 <code>unpark(thread)</code> 在 <code>park()</code> 之前被调用，那么线程会获得一个许可，当后续 <code>park()</code> 被调用时，线程可以立即消费掉这个许可并继续执行，而不会阻塞。</p>
<p>这种机制使得 <code>unpark</code> 方法可以在 <code>park</code> 方法之前调用，线程仍然能够正确地阻塞和唤醒。</p>
<p>java中哪些同步锁是基于LockSupport实现的：</p>
<p>Java中许多的同步类底层使用了<code>LockSupport</code>来实现线程的阻塞和唤醒。最主要的类就是<code>AbstractQueuedSynchronizer</code>（简称AQS），它是许多同步类的基础框架。以下是一些基于AQS，从而间接使用<code>LockSupport</code>实现的同步类：</p>
<ol>
<li><p><strong>ReentrantLock</strong>：重入锁，是一个互斥锁，支持重入功能，也就是说，一个线程能够对已经获取到的锁再次获取，而不会发生死锁。</p>
</li>
<li><p><strong>ReentrantReadWriteLock</strong>：读写锁，它分为两个锁，一个是读锁，一个是写锁。多个读锁之间不会互斥，读锁与写锁互斥，写锁与写锁互斥。</p>
</li>
<li><p><strong>Semaphore</strong>：信号量，内部维护了一组”许可”，线程可以申请许可（如果无可用许可则阻塞），也可以释放许可。</p>
</li>
<li><p><strong>CountDownLatch</strong>：倒计时门栓，它可以让一个或多个线程等待其他线程完成各自的工作后再执行。</p>
</li>
<li><p><strong>CyclicBarrier</strong>：循环栅栏，它允许一组线程互相等待，直到所有的线程都准备就绪后，所有的线程才能继续执行。</p>
</li>
<li><p><strong>FutureTask</strong>：实现了<code>Future</code>和<code>Runnable</code>接口的类，可以用来执行<code>Callable</code>任务，并且可以获取任务执行后的结果。</p>
</li>
</ol>
<p>所有这些类都通过使用<code>LockSupport.park()</code>和<code>LockSupport.unpark(Thread)</code>方法来阻塞和唤醒线程。</p>
<h1 id="JUC同步锁"><a href="#JUC同步锁" class="headerlink" title="JUC同步锁"></a>JUC同步锁</h1><p>以下的锁当中除了LockSupport之外，其他的都是基于AQS实现的</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是Java并发包<code>java.util.concurrent.locks</code>中的一个类，ReentrantLock是可重入锁，每获取一次，重入的计数就会增加1。当线程释放锁时，重入的计数就会减少1。只有当重入的计数变为0时，锁才会真正被释放。</p>
<p><code>ReentrantLock</code>是基于Java的<code>AbstractQueuedSynchronizer</code>(AQS)框架实现的。AQS使用一个整数值来表示锁的状态，并使用一个FIFO队列来管理等待的线程。ReentrantLock底层使用的是锁的park()和unpark()</p>
<p>要使用<code>ReentrantLock</code>，需要创建一个<code>ReentrantLock</code>的实例，然后在需要互斥访问的代码前调用<code>lock()</code>方法，代码后调用<code>unlock()</code>方法。为了确保锁可以被正确释放，通常需要将<code>unlock()</code>方法放在<code>finally</code>块中。下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// critical section</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>doSomething</code>方法中的代码是互斥的，也就是说，在任何时刻，最多只有一个线程可以执行这段代码。</p>
<p>ReentrantLock提供了比内置<code>synchronized</code>关键字更强大更灵活的锁机制。</p>
<p>ReentrantLock比synchronized增加的功能：</p>
<ol>
<li>ReentrantLock可以设置等待时间，如果超时未得到锁，可以进入finally里面解除获取锁的操作</li>
<li>ReentrantLock可以使用可打断的等待lock.lockInterruptibly()，其他线程打断可打断的等待线程之后，等待线程就可以进入被打断的catch</li>
<li>ReentrantLock还支持公平锁，synchronized只支持非公平锁。公平锁模式可以防止线程饥饿，但是在性能上通常不如非公平锁模式。ReentrantLock使用公平锁的方式是往够早函数里面传一个true参数，即new ReentrantLock(true)。</li>
</ol>
<p><strong>lock.lock();是写在try里面还是外面</strong></p>
<p>在使用 <code>Lock</code> 的时候，通常建议将 <code>lock.lock();</code> 写在 <code>try</code> 块的外面，然后在 <code>finally</code> 块中释放锁。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// access shared resources</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的原因是，如果获取锁（<code>lock.lock()</code>）失败抛出了异常，那么在 <code>finally</code> 块中就无需（也不能）去释放这个锁。如果将 <code>lock.lock();</code> 写在 <code>try</code> 块内部，当获取锁抛出异常时，<code>finally</code> 块仍然会执行，这可能会导致尝试释放一个实际上并未被当前线程持有的锁，从而引发 <code>IllegalMonitorStateException</code>。</p>
<p>然而，需要注意的是，这种模式主要适用于 <code>lock.lock()</code> 不会抛出受检异常的情况。在 <code>java.util.concurrent.locks.Lock</code> 接口中，<code>lock()</code> 方法是不会抛出受检异常的。但如果你使用的锁实现可能会在 <code>lock()</code> 方法中抛出受检异常，那么你可能需要将 <code>lock()</code> 调用放入 <code>try</code> 块中，并在 <code>catch</code> 块中适当地处理异常。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>概念：</p>
<p><code>CountDownLatch</code>是Java并发编程中的一个重要工具，它位于<code>java.util.concurrent</code>包中。<code>CountDownLatch</code>允许一个或多个线程等待其他线程完成一组操作。</p>
<p><code>CountDownLatch</code>是不能重用的，一旦计数器的值变为0，就不能再次将它重置回一个非零的值。</p>
<p>使用场景：</p>
<p>这种机制在某些场景下非常有用。例如，假设我们有一个并发程序，主线程需要等待其他几个工作线程完成一组操作后才能继续执行。在这种情况下，我们可以使用<code>CountDownLatch</code>。</p>
<p>用法：</p>
<p>我们可以创建一个<code>CountDownLatch</code>的实例，将计数器的初始值设为工作线程的数量。每个工作线程完成任务后调用<code>countDown()</code>方法。主线程在开始任务前调用<code>await()</code>方法，然后等待所有的工作线程都完成任务。这里有一个简单的例子来说明<code>CountDownLatch</code>的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">workerNum</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerNum);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerNum; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// do some work</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finished work.&quot;</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;All workers have finished their jobs.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，创建一个了<code>CountDownLatch</code>的实例时，传递给它的构造函数的整数就是计数器的初始值。每个工作线程在完成任务后调用<code>countDown()</code>方法，每次调用这个方法都会将计数器的值减1。主线程在开始任务前调用<code>await()</code>方法，使主线程等待，然后等待计数器的值变为0，主线程继续执行，并输出一条消息。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code> 是 Java 并发编程中一种同步辅助工具，它允许一组线程互相等待，直到所有线程都到达某个公共的屏障点（Barrier Point）。</p>
<p>“Cyclic” 的含义是这个屏障点是可以重复利用的，也就是说，一旦所有等待线程都达到了屏障点，这个屏障就可以为下一轮的等待线程使用。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的CyclicBarrier，当有3个线程达到时触发</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 所有线程到达屏障后执行此任务</span></span><br><span class="line">                System.out.println(<span class="string">&quot;所有线程都到达了屏障点&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动三个将在屏障处等待的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(barrier), <span class="string">&quot;线程 1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(barrier), <span class="string">&quot;线程 2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(barrier), <span class="string">&quot;线程 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(CyclicBarrier barrier)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 在屏障处等待&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已经通过了屏障&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock，读写锁，</p>
<p>读写锁：</p>
<ul>
<li>共享锁（读锁）：读共享</li>
<li>排他锁（写锁）：写互斥</li>
</ul>
<p>由ReadWriteLock对象可以得到读锁和写锁</p>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><code>StampedLock</code> 是 Java 在 JDK 8 中引入的一个新的同步工具类，用来解决某些场景下的并发问题。它设计的初衷是为了优化读多写少的场景，因此在读线程非常多，写线程非常少的情况下，<code>StampedLock</code> 提供了一种乐观读锁，可以使得多个线程同时读，大大提高了并发性能。</p>
<p><code>StampedLock</code> 提供的锁包括写锁、悲观读锁以及乐观读，这三种锁的释放和获取都是通过一个 <code>stamp</code>（邮票）变量来控制的，这个 <code>stamp</code> 变量类似于版本号，每次写锁的获取和释放都会导致 <code>stamp</code> 变化。</p>
<p>下面是一个使用 <code>StampedLock</code> 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123; <span class="comment">// 移动点的位置</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123; <span class="comment">// 计算从原点到现在位置的距离</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead(); <span class="comment">// 尝试获取乐观读锁</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x, currentY = y;</span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">// 如果乐观读锁验证失败，改用悲观读锁</span></span><br><span class="line">            stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>move</code> 方法使用写锁，保证了数据的完整性，而 <code>distanceFromOrigin</code> 方法首先尝试获取乐观读锁，如果验证成功，则直接计算结果，否则改用悲观读锁。</p>
<p>需要注意的是，<code>StampedLock</code> 不支持重入和条件变量，使用时也要注意避免锁升级导致的死锁问题。此外，<code>StampedLock</code> 的锁方法不响应中断，如果需要支持中断，可以使用相应的 <code>xxxLockInterruptibly</code> 方法。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量</p>
<p>用途：限流</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>ThreadPool与Executor<br>ExecuteService<br>Excecutors<br>Callable-带返回值的Runnable<br>异步调用Future<br>fixed<br>cached<br>single<br>常用线程池<br>scheduled<br>workstealing<br>forkjoin<br>ParallelStreamAPI</p>
<h1 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h1><h1 id="JUC同步工具"><a href="#JUC同步工具" class="headerlink" title="JUC同步工具"></a>JUC同步工具</h1><p>cas自旋原理<br>ReentrantLock可重入锁<br>Condition条件等待与通知<br>Latch<br>cyclicBarrier线程栅栏<br>Semaphore信号量<br>Semaphore与Lock的区别(高频面试)<br>ThreadLocal线程本地变量（高频面试)<br>phaser<br>Exchanger</p>
<h1 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h1><p>JMH解决什么问题<br>JMH插件安装<br>JMH吞吐量测试<br>JMH QPS&#x2F;TPS测试</p>
<p><strong>对象锁</strong>：适用于同步非static方法和同步代码块。当一个线程获取了对象锁，其他线程必须等待这个锁被释放才能执行被该对象锁保护的非static同步方法或者被该对象锁保护的同步代码块。</p>
<p><strong>类锁</strong>：适用于同步static方法和同步class对象的代码块。当一个线程获取了类锁，其他线程必须等待这个锁被释放才能执行被该类锁保护的static同步方法或者被该类锁保护的同步class对象的代码块。</p>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>秒杀性能比较：</p>
<p>synchronized</p>
<p>AtomicInteger</p>
<p>实现原理：基于CAS，使用了<code>Unsafe</code>类的一些函数来进行底层的原子性操作。虽然<code>Unsafe</code>类可以进行一些不安全的操作，但在<code>AtomicInteger</code>中，它被用来实现线程安全的原子性操作。这是一个很好的例子，说明了工具本身并不决定结果，关键在于如何使用工具。</p>
<p>LongAdder</p>
<p>实现原理：分段锁，每个线程对应数组中的一个值，最后将值加和</p>
<h1 id="分工问题的实现方式"><a href="#分工问题的实现方式" class="headerlink" title="分工问题的实现方式"></a>分工问题的实现方式</h1><p>Guarded Suspension模式</p>
<p>Thread-Pre-Message模式</p>
<p>生产者-消费者模式</p>
<p>两阶段终止模式</p>
<p>Worker-Thread模式</p>
<p>Balking模式</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>分布式锁是一种在分布式系统环境下的锁，用于控制跨多个节点的共享资源的访问。这对于需要在多个节点之间同步或序列化操作的应用来说是非常重要的。</p>
<p>实现分布式锁的方式有多种，例如基于数据库的锁、基于Redis的锁、基于Zookeeper的锁等。</p>
<p>以下是一些常见的分布式锁实现方式：</p>
<ol>
<li><p>基于数据库的锁：这种方式通常是在数据库中创建一张锁表，需要获取锁的时候在这张表中插入一条记录，释放锁的时候则删除这条记录。这种方式实现简单，但是性能可能会受到影响。</p>
</li>
<li><p>基于Redis的锁：Redis提供了一些原子性的操作，比如<code>SETNX</code>，可以利用这些特性来实现分布式锁。<code>SETNX</code>命令可以在键不存在的情况下设置键值对，如果键已经存在，则不做任何操作。这种方式性能较好，但是需要处理好锁的超时和续期问题。</p>
</li>
<li><p>基于Zookeeper的锁：Zookeeper提供了一种叫做顺序临时节点的机制，可以利用这个机制来实现分布式锁。要获取锁的线程创建一个临时节点，如果这个节点是所有节点中序号最小的，那么就认为这个线程获取了锁。这种方式性能较差，但是更加可靠，适合对一致性要求更高的场景。</p>
</li>
</ol>
<p>使用分布式锁需要注意一些问题，比如避免死锁、处理好锁的超时问题，以及在某些情况下可能需要考虑公平性问题。</p>
<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><p>乐观锁和悲观锁是数据库并发控制中的两种主要技术，它们各自对系统中的并发冲突有不同的预期和处理方式。</p>
<ol>
<li><p>悲观锁（Pessimistic Locking）：<br> 悲观锁假设数据在并发处理中很可能会引发冲突，因此在数据处理前会先加锁，以保证数据处理的独占性。例如，在读数据时加读锁，防止数据被其他事务修改；在写数据时加写锁，防止数据被其他事务读或写。悲观锁的主要优点是可以有效地避免数据的并发冲突，但缺点是锁的开销较大，且可能降低并发性能。</p>
</li>
<li><p>乐观锁（Optimistic Locking）：<br> 乐观锁相对于悲观锁来说，更“乐观”，它假设数据在大部分情况下并不会引发冲突，因此并不会在数据处理前加锁，而是在数据处理后（通常是在数据提交更新时）检查是否存在冲突。如果存在冲突（例如数据已经被其他事务修改），那么本次处理会失败，这时可以选择重试处理或者回滚操作。乐观锁的主要优点是并发性能较高，但缺点是需要处理因并发冲突导致的处理失败。</p>
</li>
</ol>
<p>乐观锁和悲观锁的选择通常取决于数据的并发冲突概率和对并发性能的要求。如果并发冲突概率较高，或者对数据一致性要求较严格，那么可以使用悲观锁；如果并发冲突概率较低，或者对并发性能要求较高，那么可以使用乐观锁。</p>
<p>monitorenter monitorexit AQS。里八尿埋: entry<br>count, state<br>2锁的四种状态及升级过程3.CMS和G1的异同<br>4.G1什么时候引发Full GC<br>5.除了CAS，原子类，syn,Lock还有什么线程安全的方式<br>final<br>6.HashMap和Hashtable的异同<br>7.允许null键的map你知道哪些<br>HashMap，LinkedHashMap, WeakHashMap<br>8.null键放在HashMap的哪里<br>底层数组的0号位置<br>9.为什么hashtable的扩容是2倍+1<br>从除留余数法，hashtable初始容量方面回答<br>10.红黑树的插入时间复杂度<br>11.解决哈希冲突的方式<br>12.现有1T的数据，内存只有1G，该怎么对他们排序<br>外部排序(多路归并)<br>13.Tomcat为什么要重写类加载器<br>14.tcp握手挥手过程及其状态转换15.mysql隔离级别<br>16.B树和B+树的区别<br>17.你知道哪些设计模式，它们在JDK源码中是怎么体现的18.Java运行时数据区<br>19.说一个最熟悉的垃圾回收算法<br>20.吞吐量优先和响应时间优先的回收器是哪些<br>parallel scavenge和CMS<br>21.类加载全过程</p>
<p>22.线程池7个参数<br>23.CAS的ABA问题怎么解决<br>AtomicStampedReference，还可月<br>24.Java内存模型<br>JMM共享内存模型以及8个原子操作指令<br>25.什么叫做阻塞队列的有界和无界<br>26.cookie和session介绍一下<br>27.说一下反射，反射会影响性能吗28.谈一下AQS吧<br>29.为什么你说AQS的底层是CAS+volatile<br>state是volatile修饰的，<br>:ompareAndSetState<br>30.JUC包里的同步组件主要实现了AQS的哪些主要方法<br>tryA<br>ryReleaseShared, isHeldExclusivelycoding: leetcode+剑指offer原题<br>美团(3轮技术面):<br>.ConcurrentHashMap底层原理?.手写一个LRU<br>用LinkedHashMap<br>3.HashMap底层数据结构<br>4.为什么用红黑树不用普通的AVL树5.为什么在8的时候链表变成树5.为什么在6的时候从树退回链表7.线程池7个参数，该怎么配置最好3.说一下volatile</p>
<p>19.具体讲一下CMS流程20.锁的四种状态<br>21.Object obj &#x3D; new Object()这句话在内存里占用了多少内存<br>引用<br>填充增值16Byte，共20Byte<br>22.synchronized和reentrantLock的异同<br>京东（2轮技术面):<br>1.总体说一下集合框架Ⅰ2.你怎么看待接口和抽象类3.索引的分类<br>4.主键索引的设计应该采用B-tree索引还是hash索引5.设计模式说5，6个<br>5.谈一谈DDD面向领域编程<br>7.说一下hibernate—级缓存和二级缓存3.说一下你了解的MQ<br>9.谈一谈你对高并发的理解，你会从什么角度设计高并发程序10.JUC包里的限流该怎么做到<br>Semaphore &#x2F; guava ratelimiter<br>11.索引不适用的条件<br>12.说一下NIO和AIO<br>13.AIO里用到什么设计模式<br>观察者<br>14.说一下select,poll, epoll<br>15.谈一下TCP的拥塞控制</p>
<p>Tomcat为什么要重写类加载器tcp握手挥手过程及其状态转换mysql隔离级别<br>B树和B+树的区别<br>你知道哪些设计模式，它们在JDK源码中是怎么体现的Java运行时数据区<br>说一个最熟悉的垃圾回收算法<br>吞吐量优先和响应时间优先的回收器是哪些<br>parallel scavenge和C<br>MS<br>类加载全过程<br>线程池7个参数<br>CAS的ABA问题怎么解决<br>AtomicStampedReference，还可用带boolean版本戳的AtomicMarkableReference<br>Java内存模型<br>JMM共享内存模型以及8个原子操作指令<br>什么叫做阻塞队列的有界和无界<br>cookie和session介绍一下<br>说一下反射，反射会影响性能吗谈一下AQS吧<br>为什么你说AQS的底层是CAS+volatile<br>state是volatile修饰的，并且设置state的方法除了有setState，还有<br>npareAndSetState<br>JUC包里的同步组件主要实现了AQS的哪些主要方法<br>tryAcquire,<br>tryRelease, tryAcquireShared,<br>ReleaseShared, isHeldExclusivelycoding: leetcode+剑指offer原题共5题</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag"># 并发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="prev" title="计算机网络">
                  <i class="fa fa-chevron-left"></i> 计算机网络
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SBR</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
