<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java并发编程 | SBR Blog</title><meta name="author" content="Song Baoru"><meta name="copyright" content="Song Baoru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程工具类Thread类Thread类用于创建和启动线程，Thread类对象就是线程对象，内部定义了线程名name、线程所在的线程组group、向JVM申请的堆栈大小stackSize等信息。 Thread类实现了Runnable接口，Runnable接口是一个函数时接口。  Thread类内部定义了一个枚举类State，State类中定义了线程的执行状态： 1234567891011121314">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程">
<meta property="og:url" content="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:description" content="线程工具类Thread类Thread类用于创建和启动线程，Thread类对象就是线程对象，内部定义了线程名name、线程所在的线程组group、向JVM申请的堆栈大小stackSize等信息。 Thread类实现了Runnable接口，Runnable接口是一个函数时接口。  Thread类内部定义了一个枚举类State，State类中定义了线程的执行状态： 1234567891011121314">
<meta property="og:locale">
<meta property="og:image" content="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&risl=&pid=ImgRaw&r=0">
<meta property="article:published_time" content="2023-05-07T13:39:13.000Z">
<meta property="article:modified_time" content="2023-07-20T09:07:27.075Z">
<meta property="article:author" content="Song Baoru">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&risl=&pid=ImgRaw&r=0"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":false,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java并发编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-07-20 17:07:27'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SBR Blog"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">SBR Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Java并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-07T13:39:13.000Z" title="Created 2023-05-07 21:39:13">2023-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-07-20T09:07:27.075Z" title="Updated 2023-07-20 17:07:27">2023-07-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/IT/">IT</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">30.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>105min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java并发编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="线程工具类"><a href="#线程工具类" class="headerlink" title="线程工具类"></a>线程工具类</h1><h2 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h2><p>Thread类用于创建和启动线程，Thread类对象就是线程对象，内部定义了线程名name、线程所在的线程组group、向JVM申请的堆栈大小stackSize等信息。</p>
<p>Thread类实现了Runnable接口，Runnable接口是一个函数时接口。</p>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230622113831682.png" alt="image-20230622113831682"></p>
<p>Thread类内部定义了一个枚举类State，State类中定义了<a href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">线程的执行状态</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>    <span class="hljs-comment">//初始化状态</span><br>    NEW,<br>    <span class="hljs-comment">//可运行状态，包括就绪状态和运行状态</span><br>    RUNNABLE,<br>    <span class="hljs-comment">//阻塞状态</span><br>    BLOCKED,<br>    <span class="hljs-comment">//等待状态</span><br>    WAITING,<br>    <span class="hljs-comment">//超时等待状态</span><br>    TIMED_WAITING,<br>    <span class="hljs-comment">//终止状态</span><br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h2><p>线程局部变量用于保证数据隔离与安全。</p>
<p>线程局部变量有两种，ThreadLocal和InheritableThreadLocal，其中ThreadLocal在主线程和子线程之间不具备可继承性，而InheritableThreadLocal具备可继承。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code>由一个线程的类型为<code>ThreadLocal.ThreadLocalMap</code>的对象<code>threadlocals</code>来保存，<code>ThreadLocalMap</code>是<code>ThreadLocal</code>类的内部类。具体来说，在<code>ThreadLocalMap</code>中，set到<code>ThreadLocal</code>对象的值作为值（value），<code>ThreadLocal</code>对象作为键（key），并且key是一个弱引用。</p>
<p>因为ThreadLocal对象（key）是一个弱引用，所以当线程销毁后，由于ThreadLocal对象不再被强引用，所以ThreadLocal对象可以被垃圾回收。但是threadlocals中依然存在键值对，所以为了避免内存溢出，还是需要手动移除（remove）ThreadLocal对象。</p>
<p>ThreadLocal的使用方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;(); <span class="hljs-comment">//创建一个用于存储String类型的ThreadLocal变量</span><br>threadLocal.set(<span class="hljs-string">&quot;Hello, ThreadLocal!&quot;</span>); <span class="hljs-comment">//设置当前线程的ThreadLocal变量值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> threadLocal.get(); <span class="hljs-comment">//返回当前线程的ThreadLocal变量值</span><br>threadLocal.remove(); <span class="hljs-comment">//清除当前线程的ThreadLocal变量值</span><br></code></pre></td></tr></table></figure>

<p>每个线程可以创建多个ThreadLocal实例，每个ThreadLocal实例可以用来存储一个特定的值，例如，可以创建两个ThreadLocal实例来存储不同类型的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; threadLocal1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;(); <span class="hljs-comment">//创建一个用于存储String类型的ThreadLocal变量</span><br>ThreadLocal&lt;Integer&gt; threadLocal2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;(); <span class="hljs-comment">//创建一个用于存储Integer类型的ThreadLocal变量</span><br></code></pre></td></tr></table></figure>

<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>使用InheritableThreadLocal创建对象保存的变量具有继承性，子线程调用该对象的get方法可以获取到父线程set到该对象中的值。父线程是创建和启动子线程的线程。</p>
<p>InheritableThreadLocal的使用方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InheritableThreadLocal&lt;String&gt; INHERITABLE_THREAD_LOCAL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    INHERITABLE_THREAD_LOCAL.set(<span class="hljs-string">&quot;主线程保存的值&quot;</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> INHERITABLE_THREAD_LOCAL.get();<br>    System.out.println(<span class="hljs-string">&quot;子线程中访问主线程中保存的局部变量值：&quot;</span> + value);<br>    &#125;).start();<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">	子线程中访问主线程中保存的局部变量值：主线程保存的值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>通过InheritableThreadLocal对象之所以能够访问到父（parent）线程的inheritableThreadLocals，是因为在创建线程的时候，会将parent线程的inheritableThreadLocals复制一份到子线程的inheritableThreadLocals中。</p>
<h2 id="Fork-x2F-Join框架"><a href="#Fork-x2F-Join框架" class="headerlink" title="Fork&#x2F;Join框架"></a>Fork&#x2F;Join框架</h2><p>Fork&#x2F;Join框架是从Java1.7开始提供的用于执行并行任务的框架，可以将一个比较大的任务拆分成多逻辑相同的小任务，最后汇总每个小任务的执行结果得到最终的结果，思想和Hadoop的MapReduce类似。</p>
<p>Fork&#x2F;Join框架使用了工作窃取算法，即处理完自己所在的任务队列的线程会去执行（窃取）其它线程的任务队列。</p>
<p>Java提供的Fork&#x2F;Join框架涉及的核心类包括ForkJoinPool类、ForkJoinTask类、ForkJoinWorkerThread类、RecursiveTask类、RecursiveAction类、CountedCompleter类：</p>
<ul>
<li>ForkJoinPool类：实现了Fork&#x2F;Join框架框架的线程池</li>
<li>ForkJoinWorkerThread类：是Fork&#x2F;Join框架的线程池中运行的线程</li>
<li>ForkJoinTask类：是Fork&#x2F;Join框架的任务，任务的处理逻辑在compute()方法中进行定义，提供了fork()和join()方法，分别实现了任务的拆分和合并。实际开发中，一般用它的两个子类RecursiveTask、RecursiveAction。</li>
<li>RecursiveTask类：是ForkJoinTask的子类，实现了Callable接口，并提供返回结果。</li>
<li>RecursiveAction类：是ForkJoinTask的子类，实现了Runnable接口，无返回结果。</li>
<li>CountedCompleter类：任务完成后会触发执行的一个自定义的任务。</li>
</ul>
<p>Java1.8中引入的并行流就是基于Fork&#x2F;Join框架实现的。</p>
<p>使用示例（使用Fork&#x2F;Join框架计算1~10000的累加和）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinTaskComputer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-comment">//任务拆分的最小粒度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//开始数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> start;<br>    <span class="hljs-comment">//结束数字</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinTaskComputer</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> end - start;<br>        <span class="hljs-keyword">if</span> (count &lt;= MIN_COUNT) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt;= end; i++) &#123;<br>                sum += i;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//找到中间值</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">middle</span> <span class="hljs-operator">=</span> start + ((end - start) &gt;&gt; <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//生成子任务</span><br>            <span class="hljs-type">ForkJoinTaskComputer</span> <span class="hljs-variable">leftTaskComputer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinTaskComputer</span>(start, middle);<br>            <span class="hljs-type">ForkJoinTaskComputer</span> <span class="hljs-variable">rightTaskComputer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinTaskComputer</span>(middle + <span class="hljs-number">1</span>, end);<br>            <span class="hljs-comment">//执行子任务</span><br>            leftTaskComputer.fork();<br>            rightTaskComputer.fork();<br>            <span class="hljs-comment">//合并子任务</span><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">leftResult</span> <span class="hljs-operator">=</span> leftTaskComputer.join();<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">rightResult</span> <span class="hljs-operator">=</span> rightTaskComputer.join();<br>            <span class="hljs-comment">//计算总和</span><br>            sum = leftResult + rightResult;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10_000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">ForkJoinTaskComputer</span> <span class="hljs-variable">taskComputer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinTaskComputer</span>(MIN_COUNT, MAX_COUNT);<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>        <span class="hljs-comment">//将计算任务提交到线程池进行执行</span><br>        ForkJoinTask&lt;Integer&gt; result = forkJoinPool.submit(taskComputer);<br>        System.out.println(<span class="hljs-string">&quot;计算结果是&quot;</span> + result.get());<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">计算结果是50005000</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，使用Fork&#x2F;Join框架实现了计算1~10000的累加和，通过将大任务拆分成小任务，再将拆分后的小任务提交到线程池进行执行，最后将结果合并得到最终的计算结果。输出的计算结果是50005000，正确。</p>
<h1 id="线程池工具类"><a href="#线程池工具类" class="headerlink" title="线程池工具类"></a>线程池工具类</h1><h2 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h2><h2 id="Executor"><a href="#Executor" class="headerlink" title="Executor"></a>Executor</h2><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h2 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h2><h2 id="AbstractExecutorService抽象类"><a href="#AbstractExecutorService抽象类" class="headerlink" title="AbstractExecutorService抽象类"></a>AbstractExecutorService抽象类</h2><h2 id="ScheduleExecutorService接口"><a href="#ScheduleExecutorService接口" class="headerlink" title="ScheduleExecutorService接口"></a>ScheduleExecutorService接口</h2><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><p>Java 中创建线程的方法有四种：继承 Thread 类、实现 Runnable 接口、实现 Callable 接口并使用FutureTask类以及通过线程池创建线程。</p>
<ol>
<li>继承 Thread 类：</li>
</ol>
<p>继承 Thread 类是创建线程最简单的方式，在该类中重写 run() 方法即可实现线程的执行逻辑。可以通过 start() 方法启动线程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实现线程执行逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>thread.start();<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>实现 Runnable 接口：</li>
</ol>
<p>实现 Runnable 接口也是一种常见的创建线程的方式，可以将 Runnable 对象传递给 Thread 类，通过 start() 方法启动线程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实现线程执行逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>thread.start();<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>实现 Callable 接口并使用FutureTask类：</li>
</ol>
<p>与 Runnable 接口相比，Callable 接口可以返回执行结果，并且可以抛出异常。</p>
<p>但是Callable接口实例不能作为Thread类的target，所以还需要一个搭桥接口，RunnableFuture接口就是Thread和Callable之间的“搭桥接口”。而FutureTask类实现了RunnableFuture接口。RunnableFuture继承了Runnable接口和Future接口。其中Future接口提供的功能有取消执行中的任务、获取任务的执行结果等。</p>
<p>使用方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;calling&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is the result of the execute&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>    FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(myCallable);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>    thread.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(futureTask.get()); <span class="hljs-comment">// 获取任务的执行结果</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">    calling</span><br><span class="hljs-comment">    this is the result of the execute</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li>通过线程池创建线程</li>
</ol>
<h2 id="操作系统线程生命周期"><a href="#操作系统线程生命周期" class="headerlink" title="操作系统线程生命周期"></a>操作系统线程生命周期</h2><ul>
<li>初始状态：处于初始状态的线程只是在编程语言层面被创建，在操作系统层面并没有被真正创建。</li>
<li>可运行状态：线程在操作系统层面真正被创建，可以被分配CPU资源。</li>
<li>运行状态：处于运行状态的线程已经获取到CPU资源，正在运行。</li>
<li>休眠状态：线程正在等待，或者正处于阻塞状态（如调用了一个阻塞的API），就可能（只有处在运行状态的线程才可以直接转换成休眠状态或终止状态）进入休眠状态。</li>
<li>终止状态：线程正常运行结束或出现异常，就可能进入终止状态。</li>
</ul>
<h2 id="Java线程的生命周期"><a href="#Java线程的生命周期" class="headerlink" title="Java线程的生命周期"></a>Java线程的生命周期</h2><ul>
<li>初始化状态：线程在Java中被创建（调用new方法），但还没有启动（调用start方法）。</li>
<li>可运行状态<ul>
<li>就绪状态：对应操作系统线程生命周期中的可运行状态。</li>
<li>运行状态：对应操作系统线程生命周期中的运行状态。</li>
</ul>
</li>
<li>阻塞状态：等待进入临界区。</li>
<li>等待状态：等待其它线程通知或中断等待。</li>
<li>超时等待状态：等待其它线程通知或中断等待，如果超过指定时间，当前线程也会进入下一个状态。</li>
<li>终止状态：表示当前线程执行完毕，包括正常执行结束和异常退出。</li>
</ul>
<h2 id="线程调度模型"><a href="#线程调度模型" class="headerlink" title="线程调度模型"></a>线程调度模型</h2><p>目前主流操作系统中主要基于时间片进行线程调度，调度模型可以分为分时调度模型和抢占式调度模型：</p>
<ul>
<li>分时调度模型：会平均分配CPU时间片，每个线程占用的CPU时间片都是一样的，所有线程会轮流占有CPU时间片。</li>
<li>抢占式调度模型：按照线程的优先级分配时间片，线程的优先级越高，分配到CPU时间片的概览越大。</li>
</ul>
<h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><ol>
<li>start：启动线程。</li>
<li>sleep：让当前线程休眠（暂停执行）一段时间，<strong>不会释放锁</strong>。</li>
<li>wait：让当前线程暂停执行<strong>并释放锁资源</strong>。</li>
<li>notify：随机唤醒一个因wait调用而处于等待中的线程。</li>
<li>notifyAll：唤醒所有因wait调用而处于等待中的线程。</li>
<li>park：阻塞当前线程，等待被其它线程唤醒，<strong>不会释放锁</strong>。</li>
<li>unpark：唤醒指定的线程，使其从等待状态中返回。</li>
<li>join：如果线程a调用了线程b的join()方法，则线程a会等待线程b执行完毕后再继续执行。</li>
<li>interrupt：如果是作用于对被sleep、wait、join阻塞的线程，会清除线程的中断标记并抛出异常；如果是作用于一个正在运行的线程，会强制终止该线程。</li>
<li>yield：<strong>不会释放锁</strong>，只是让出当前线程的CPU执行时间片，回到就绪状态，等待CPU的调度。</li>
</ol>
<h2 id="线程结束的方式"><a href="#线程结束的方式" class="headerlink" title="线程结束的方式"></a>线程结束的方式</h2><ol>
<li>等待线程自然执行完毕<ul>
<li>run()方法执行完毕</li>
</ul>
</li>
<li>强制结束线程<ul>
<li>调用Interrupt()方法：推荐使用，原因是interrupt方法并不直接停止线程，而是由线程决定如何响应中断，线程有机会执行释放资源、保持数据一致性等操作。</li>
<li>调用stop()方法：不推荐使用，原因是使用stop方法存在一些潜在的问题，如不能释放资源、数据不一致等。</li>
</ul>
</li>
</ol>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>当程序中可运行的线程数量大于CPU核心数时，CPU资源会在不同线程之间来回切换，就会发生线程的上下文切换，也叫做线程切换。</p>
<p>在线程上下文切换时，操作系统会保存运行线程的上下文。</p>
<p><strong>减少上下文切换的措施：</strong></p>
<ol>
<li>使用无锁编程</li>
<li>创建合适的线程数</li>
<li>使用协程</li>
</ol>
<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>线程同步是一种用于协调多个线程并发执行的机制，以确保它们按照特定的顺序或规则访问共享资源，避免数据出现不符合预期的操作结果。</p>
<h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><ol>
<li><p>用户线程</p>
<p>默认情况下主线程和创建的新线程、新线程池都为用户线程</p>
<p>以线程为例，想要查看线程是否为守护线程只需通过调用 <code>isDaemon()</code> 方法查询即可，如果查询的值为 <code>false</code> 则表示不为守护线程。</p>
</li>
<li><p>守护线程</p>
<p>守护线程（Daemon Thread）也被称之为后台线程或服务线程，当程序中的用户线程全部执行结束之后，守护线程也会跟随结束。</p>
<p>JVM中的垃圾回收线程、JIT编译线程都是守护线程</p>
<p>守护线程可以按来源分两种：</p>
<ul>
<li><p>JVM中带有的守护线程</p>
</li>
<li><p>将默认的用户线程修改为守护线程</p>
<ul>
<li>如果是线程，则可以通过设置 <code>setDaemon(true)</code> 方法将用户线程直接修改为守护线程</li>
<li>如果是线程池则需要通过 <code>ThreadFactory</code> 将线程池中的每个线程都为守护线程才行，接下来我们分别来实现一下</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p>线程池在运行过程中涉及的状态包括RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED</p>
<p>RUNNING：表示线程池处在运行状态，能处理正在执行的任务，能处理阻塞队列中的任务，能够接收新提交的任务。</p>
<p>SHUTDOWN：表示线程池处在关闭状态，能处理正在执行的任务，能处理阻塞队列中的任务，但是不能接收新提交的任务。如果线程池处于RUNNING状态，此时调用shutdown()方法会使线程进入SHUTDOWN状态。</p>
<p>STOP：表示线程池处于停止状态，线程会中断正在执行的任务，不能处理阻塞队列中的任务，也不能接收新提交的任务。如果线程池处于RUNNING或者SHUTDOWN状态，那么调用线程池的shutdownNow()方法会使线程池进入STOP状态。</p>
<p>TIDYING：如果线程池中已经没有正在执行的任务，并且线程池的阻塞队列为空，线程池就会进入TIDYING状态。当线程池处于SHUTDOWN或者STOP状态时，如果满足TIDYING状态的条件，线程池就会进入TIDYING状态。</p>
<p>TERMINATED：如果线程池处于TIDYING状态，此时调用线程池的terminated方法，线程池就会进入TERMINATED状态。</p>
<h2 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h2><p>Java中线程池的创建有四个类可以实现，分别是Executors、ThreadPoolExecutor、ForkJoinPool、ScheduledThreadPoolExecutor。</p>
<ol>
<li><p>使用Executors类创建线程池</p>
<p>Executors 提供了一些静态工厂方法来创建不同类型的线程池，包括newFixedThreadPool、newWorkStealingPool、newCachedThreadPool、newScheduledThreadPool、newSingleThreadExecutor、newSingleThreadScheduledExecutor等。这种方式适用于简单的场景，但缺少可定制性，无法精细调整线程池的参数。其中newWorkStealingPool是JDK1.8新增的方法，表示创建一个具有并行级别的线程池，比Executors类中断其它方法创建的线程池有更高的并发性能。</p>
<p>在Executors类中，newFixedThreadPool、newCachedThreadPool和newSingleThreadExecutor都是调用ThreadPoolExecutor类的构造方法实现的。所以《阿里巴巴Java开发手册》推荐直接调用ThreadPoolExecutor类的构造方法创建线程。</p>
<p>newWorkStealingPool是调用ForkJoinPool类的构造方法实现的。</p>
<p>newScheduledThreadPool和newSingleThreadScheduledExecutor是调用ScheduledThreadPoolExecutor类的构造方法实现的。</p>
<p>Executors类的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个固定大小的线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用ThreadPoolExecutor类创建线程池</p>
<p>使用 ThreadPoolExecutor 构造函数手动创建线程池，可以自定义线程池的参数，参数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, //线程池的核心线程数</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize, //最大线程数</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime, //空闲线程存活时间</span><br><span class="hljs-params">                              TimeUnit unit, //空闲线程存活时间单位</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列</span><br><span class="hljs-params">                              ThreadFactory threadFactory, // 用来创建线程的线程工厂</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span> <span class="hljs-comment">//拒绝处理任务时的策略</span><br></code></pre></td></tr></table></figure>

<ol>
<li>当线程池中的线程数小于corePoolSize，即使存在空闲线程，也会创建新的线程。</li>
<li>当线程池中的线程数大于corePoolSize，小于maximunPoolSize，那么只有当workQueue队列已满时才会创建新线程来执行任务。</li>
<li>如果线程池中运行的线程数等于maximunPoolSize，并且workQueue队列已满，就会触发拒绝处理任务时的策略（handler）来拒绝任务的执行。</li>
</ol>
<p>ThreadPoolExecutor类的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 手动创建 ThreadPoolExecutor 对象</span><br><span class="hljs-comment">// 除ArrayBlockingQueue外还有LinkedBlockingQueue</span><br>BlockingQueue&lt;Runnable&gt; workQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>); <br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS, workQueue);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用ForkJoinPool类创建线程池</p>
<blockquote>
<p>维基百科为工作窃取的介绍：</p>
<p>在并行计算中，工作窃取是多线程计算机程序的一种调度策略。它解决了在具有固定数量处理器（或内核）的静态多线程计算机上执行动态多线程计算的问题，这种计算可以“生成”新的执行线程。它在执行时间、内存使用和处理器间通信方面都很有效。</p>
</blockquote>
<p>从JDK1.8开始，Java增加了创建work-stealing（工作窃取）线程池的方法，ForkJoinPool类就是提供了创建work-stealing线程池的实现。</p>
<p>使用 ThreadPoolExecutor 构造函数手动创建线程池，可以自定义的线程池参数如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism, //线程池的并发级别</span><br><span class="hljs-params">                         ForkJoinWorkerThreadFactory factory, //用来创建线程的线程工厂</span><br><span class="hljs-params">                         UncaughtExceptionHandler handler, // 执行任务时遇到不可恢复的错误而终止的内部工作线程的处理程序</span><br><span class="hljs-params">                         <span class="hljs-type">int</span> mode, //处理任务队列的模式，取值可为FIFO_QUEUE或LIFO_QUEUE</span><br><span class="hljs-params">                         String workerNamePrefix)</span> <span class="hljs-comment">//表示线程池中执行任务的线程的名称前缀</span><br></code></pre></td></tr></table></figure>

<p>ForkJoinPool类的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(Runtime.getRuntime().availableProcessors());<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(Runtime.getRuntime().availableProcessors(), <br>                 ForkJoinPool.defaultForkJoinWorkerThreadFactory, <br>                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler()&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>		<span class="hljs-comment">//处理异常</span><br>	&#125;<br>&#125;, <span class="hljs-literal">true</span>);  <br></code></pre></td></tr></table></figure>
</li>
<li><p>使用ScheduledThreadPoolExecutor类创建线程池</p>
<p>ScheduledThreadPoolExecutor类用于创建定时任务线程池。ScheduledThreadPoolExecutor继承了ThreadPoolExecutor类，本质上ScheduledThreadPoolExecutor类的构造方法还是调用了ThreadPoolExecutor类的构造方法，只不过在调用时，传递的阻塞队列的类型是DelayedWorkQueue。</p>
</li>
</ol>
<h2 id="线程池执行任务的流程"><a href="#线程池执行任务的流程" class="headerlink" title="线程池执行任务的流程"></a>线程池执行任务的流程</h2><p>以ThreadPoolExecutor为例，线程池的任务执行流程是：</p>
<ol>
<li>对于提交到线程池的任务，首先会判断线程池中的线程数是否达到corePoolSize<ol>
<li>如果没有达到，就创建新的线程执行任务</li>
<li>如果达到了，就判断workQueue是否已满<ol>
<li>如果没满，就添加到workQueue</li>
<li>如果满了，就判断线程池中的线程数是否达到maximunPoolSize<ol>
<li>如果没有达到，就创建新线程来执行任务</li>
<li>如果达到了，就执行拒绝执行策略</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>以ThreadPoolExecutor为例，如果线程池中的线程数达到了maximunPoolSize，并且workQueue已满，没有空闲的线程，此时如果有任务提交到线程池，就会执行线程池的拒绝策略处理函数handler.rejectedExecution(command, this)。</p>
<p>ThreadPoolExecutor中的handler的类型是RejectedExecutionHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<br></code></pre></td></tr></table></figure>

<p>RejectedExecutionHandler接口有四个实现类，这四个类就是JDK提供的线程池拒绝策略的实现类，如果没有传递该handler参数指定使用的拒绝策略，则默认执行AbortPolicy类的拒绝策略，否则执行传递的类的执行策略。继承RejectedExecutionHandler可以实现自定义的拒绝策略。<br><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230519215921078.png" alt="image-20230519215921078"></p>
<h2 id="线程池的关闭方式"><a href="#线程池的关闭方式" class="headerlink" title="线程池的关闭方式"></a>线程池的关闭方式</h2><p>Java 线程池的关闭方式有两种：调用 shutdown() 和 shutdownNow() 方法。</p>
<ol>
<li>调用 shutdown() 方法</li>
</ol>
<p>shutdown() 方法会平缓地关闭线程池，即不会中断正在执行的任务，能够处理完阻塞队列中已提交的任务，但不会接收新的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 提交任务给线程池执行</span><br>...<br><span class="hljs-comment">// 关闭线程池</span><br>executor.shutdown();<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>调用 shutdownNow() 方法</li>
</ol>
<p>shutdownNow() 方法会强制立即关闭线程池，即中断所有正在执行的任务，不会处理阻塞队列中已提交的任务，更不会接收新的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 提交任务给线程池执行</span><br>...<br><span class="hljs-comment">// 关闭线程池</span><br>executor.shutdownNow();<br></code></pre></td></tr></table></figure>

<h2 id="最佳线程数"><a href="#最佳线程数" class="headerlink" title="最佳线程数"></a>最佳线程数</h2><p>要确定线程池的最佳线程数是根据应用场景确定的，一般可以将程序分为CPU密集型程序和I&#x2F;O密集型程序，对于这两种程序，计算最佳线程数的方法是不同的。</p>
<ol>
<li><p>CPU密集型程序</p>
<p>CPU密集型程序对CPU的资源利用率高，理论最佳线程数&#x3D;CPU核心数，一般会将线程数设为CPU核心数+1，以避免有的线程阻塞浪费CPU资源</p>
</li>
<li><p>I&#x2F;O密集型程序</p>
<p>I&#x2F;O密集型程序对CPU的资源利用率低，线程数的计算需要考虑I&#x2F;O操作的CPU占用率，理论上最佳线程数&#x3D;CPU核心数 * (1 + I&#x2F;O操作的耗时&#x2F;CPU计算的耗时)</p>
</li>
</ol>
<p>通过上述方式计算出的线程数只是理论上的最佳线程数，在实际中，需要对系统进行压测，并根据压测结果确定最佳线程数。</p>
<h1 id="XXX程"><a href="#XXX程" class="headerlink" title="XXX程"></a>XXX程</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul>
<li><p>进程：操作系统分配资源的基本单位</p>
</li>
<li><p>线程：操作系统执行的基本单位，可以通俗的理解为程序不同的执行路径</p>
</li>
</ul>
<h2 id="协程（纤程）"><a href="#协程（纤程）" class="headerlink" title="协程（纤程）"></a><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1839604">协程</a>（纤程）</h2><p>协程（Coroutine）是Linux中的概念，对应的纤程（Fiber）是Windows中的概念，实现思路大致相同。</p>
<p>协程，是一种用户态的轻量级线程，协程的调度完全由用户控制（也就是在用户态执行）。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到线程的堆区，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，所以上下文的切换非常快。</p>
<h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>超线程（Hyper-Threading）是Intel公司引入的一种处理器（CPU）技术。这项技术的主要目标是提高处理器核心的效率和性能。超线程通过使单个处理器核心模拟出两个“逻辑”核心，以便同时处理两个线程，从而提高了处理器的并行处理能力。</p>
<p>传统的单核心处理器在任何时刻只能处理一个线程。但是，由于各种原因（例如，等待数据从内存中加载），处理器可能无法始终保持忙碌状态。在这些情况下，处理器的一部分（例如，算术逻辑单元或浮点单元）可能会闲置，从而造成资源浪费。</p>
<p>超线程技术试图解决这个问题，通过在单个核心上同时运行两个线程，使得当一个线程在等待时，另一个线程可以使用处理器的资源进行计算。因此，超线程可以使处理器在相同的时间内完成更多的工作，从而提高处理器的整体效率和性能。</p>
<p>然而，超线程并不总是能提供显著的性能提升。在某些情况下，如果两个线程需要使用相同的处理器资源，那么它们可能会相互竞争，从而导致性能下降。此外，超线程对于多线程程序或多任务环境最有效，对于单线程程序或单任务环境的效果可能不明显。</p>
<p>请注意，虽然超线程可以提高处理器的并行处理能力，但它并不能取代多核处理器。多核处理器具有多个独立的物理核心，每个核心都可以处理自己的线程，因此它们通常可以提供比超线程更好的并行性和性能。</p>
<h1 id="并发编程相关的概念"><a href="#并发编程相关的概念" class="headerlink" title="并发编程相关的概念"></a>并发编程相关的概念</h1><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><ul>
<li>临界区表示可以被多线程共享的资源，但是每次只能提供给一个线程使用</li>
<li>在并发编程中，临界区指的是受保护的对象或程序代码段</li>
</ul>
<h2 id="操作系统的互斥量"><a href="#操作系统的互斥量" class="headerlink" title="操作系统的互斥量"></a>操作系统的互斥量</h2><h2 id="用户态、内核态"><a href="#用户态、内核态" class="headerlink" title="用户态、内核态"></a>用户态、内核态</h2><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><ul>
<li>以同步方式调用方法时，必须在方法返回结果之后才能执行后面的操作</li>
<li>以异步方式调用方法时，不需要等方法返回信息就可以执行后面的操作，当方法完成后，会以通知或回调的方式告诉调用方</li>
</ul>
<h2 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h2><ol>
<li>死锁指两个或多个线程在执行过程中互相等待对方释放资源的情况，导致彼此无法继续执行；</li>
<li>饥饿指某个线程由于无法获得所需资源而一直无法执行；</li>
<li>活锁指两个或多个线程由于某些条件发生变化，导致彼此不断地改变自己的状态和行为，但始终无法向前推进。</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="形成死锁的必要条件"><a href="#形成死锁的必要条件" class="headerlink" title="形成死锁的必要条件"></a>形成死锁的必要条件</h3><ol>
<li>互斥条件：资源只能被一个线程占有</li>
<li>不可剥夺条件：线程占有的资源不能被其他线程强行撤销</li>
<li>请求与保持条件：如果线程已经占有了一个资源，有需要抢占新资源，而该新资源已经被其它线程占有时，那么抢占新资源的线程会阻塞等待，不会释放自己已经占有的资源</li>
<li>循环等待条件：发生死锁时，必然存在一个线程与资源的循环等待链，链中的线程请求的资源被下一个线程占有</li>
</ol>
<h3 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h3><ol>
<li>死锁的预防是破坏死锁形成的条件，而互斥条件不能被破坏，因为使用锁的目的就是要保证这一点。</li>
<li>破坏不可剥夺条件：让当前线程主动释放锁，JVM内置的synchronized锁不能实现这一点，JDK的Lock锁可以实现。使用方法是，通过tryLock()方法加锁，并在finally代码块中调用unlock()方法释放锁。</li>
<li>破坏请求与保持条件：一次性申请线程所需的全部资源，再运行过程中不再请求新的资源。</li>
<li>破坏循环等待条件：按照一定的顺序申请资源，实现方法是为每一个资源分配一个唯一编号，每次申请资源时都按照一定的顺序加锁，比如每次都先对编号较小的资源加锁。</li>
</ol>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁是指线程在获取锁失败后，不会立即进入阻塞状态，而是继续不断尝试获取锁</p>
<h1 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h1><ol>
<li><p>原子性</p>
<p>原子性操作和数据库中的事务类似</p>
<p>造成原子性问题的根本原因是在线程执行过程中发生了线程切换</p>
</li>
<li><p>可见性</p>
<p>可见性是指一个线程修改共享变量，其他线程能够立即读取到共享变量的最新值</p>
<p>造成可见性问题的根本原因是CPU的缓存机制</p>
</li>
<li><p>有序性</p>
<p>有序性指程序能够按照代码的顺序执行，不会发送乱序执行</p>
<p>一个典型的有序性问题是使用双重监测机制创建单例对象（DCL单例），如果在多线程情况下创建单例对象发送乱序执行就可能产生bug</p>
</li>
</ol>
<p>解决方法：</p>
<ol>
<li>原子性：Java中解决原子性问题的方案是使用synchronized锁、Lock锁、ReentrantLock、ReentrantReadWriteLock锁、CAS操作或原子类等。</li>
<li>可见性：使用缓存一致性协议</li>
<li>有序性：禁止指令重排</li>
</ol>
<h2 id="原子性核心原理"><a href="#原子性核心原理" class="headerlink" title="原子性核心原理"></a>原子性核心原理</h2><h3 id="总线锁保证原子性"><a href="#总线锁保证原子性" class="headerlink" title="总线锁保证原子性"></a>总线锁保证原子性</h3><p>多核CPU对内存中的一个共享变量值进行加1操作不是原子操作，这是因为在CPU中对值加1的操作有三步（设被加1的数叫count）：</p>
<ol>
<li>将内存中的count值读取到寄存器。</li>
<li>对寄存器中的count值进行加1操作。</li>
<li>将寄存器中的count值写回内存。</li>
</ol>
<p>如果要保证这三步的原子性，就要保证在CPU1执行这三步的时候，其他CPU不能读写这个共享变量的内存。CPU可以通过对总线加锁来解决这个问题。</p>
<p>在Linux系统中，锁定总线的指令是lock前缀指令。该指令可以与其他指令组合使用，例如lock add、lock cmpxchg、lock xchg等，用于实现原子性操作。</p>
<p>lock前缀指令会将总线置为锁定状态，以确保对内存的访问具有原子性和互斥性。当一个CPU执行带有lock前缀的指令时，它将先发送请求到总线，获取总线的独占控制权，然后执行相关的操作并释放总线控制权。由于总线只能被一个CPU独占，因此其他CPU在访问内存时会被阻塞，直到当前CPU执行完成。</p>
<p>总线锁定会导致其他CPU核心跟所有内存之间的通信全部阻塞，开销极大，而输出LOCK#信号的CPU核心可能只需要使用内存中的很小一部分空间，会造成资源的浪费。</p>
<h3 id="互斥锁保证原子性"><a href="#互斥锁保证原子性" class="headerlink" title="互斥锁保证原子性"></a>互斥锁保证原子性</h3><p>互斥锁是一种显式地获取和释放锁的方式，当一个线程尝试获取互斥锁时，如果该锁已经被其他线程占用，那么当前线程就会被阻塞。</p>
<p>互斥锁模型：</p>
<ol>
<li>对保护临界区资源的锁对象加锁</li>
<li>进入临界区代码执行</li>
<li>对锁对象进行解锁</li>
</ol>
<h3 id="CAS保证原子性"><a href="#CAS保证原子性" class="headerlink" title="CAS保证原子性"></a>CAS保证原子性</h3><p>CAS底层使用的操作系统原语是lock cmpxchg</p>
<h2 id="可见性和有序性核心原理"><a href="#可见性和有序性核心原理" class="headerlink" title="可见性和有序性核心原理"></a>可见性和有序性核心原理</h2><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>由于CPU的多级缓存架构，引入了数据的不一致问题</p>
<p>CPU的缓存一致性要求CPU内部缓存中的数据和主内存中的数据一致</p>
<p>缓存一致性的特点：每个读操作所返回的值必须是最后一次对该存储位置的写操作的值。</p>
<h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>CPU通过缓存一致性协议（如MESI协议、MSI协议等）来保证缓存一致性</p>
<p>MESI协议的每一个字母都是一种一种状态的简称</p>
<ul>
<li><p>M：Modify</p>
<p>处于M状态的缓存行的特点是：</p>
<ol>
<li>缓存行数据被本地写（当前CPU核心修改缓存行数据），缓存行中的数据和主内存中的数据不一致</li>
<li>数据只在当前CPU核心的缓存中存在</li>
<li>处于M状态的缓存行中的数据必须在其他CPU核心读取主内存的数据之前写回主内存</li>
<li>M状态的缓存行数据被写回主内存后，当前缓存行的状态会被标记为E</li>
</ol>
</li>
<li><p>E：Exclusive</p>
<p>处于E状态的缓存行的特点：</p>
<ol>
<li>缓存行数据未被修改过，缓存行中的数据和主内存中的数据一致，缓存行有效</li>
<li>数据只在当前CPU核心的缓存中存在</li>
<li>处于E状态的缓存行的数据如果被其他的CPU核心读取，会变成S状态</li>
<li>E状态的缓存行数据被修改后，当前缓存行的状态会被标记为M</li>
</ol>
</li>
<li><p>S：Shared</p>
<p>处于S状态的缓存行的特点是：</p>
<ol>
<li>缓存行数据未被修改过，缓存行中的数据和主内存中的数据一致，缓存行有效</li>
<li>数据存在于多个CPU核心的缓存</li>
<li>处于S状态的缓存行的数据如果发生本地写，会变成M状态</li>
<li>处于S状态的缓存行的数据如果发生远程写（其他CPU核心修改缓存行数据），会变成I状态</li>
</ol>
</li>
<li><p>I：Invalid</p>
<p>处于I状态的缓存行的特点是：</p>
<ol>
<li>处于I状态的缓存行无效</li>
<li>处于M、E或S状态的缓存行数据，如果发生远程写，则这些缓存行状态都会改为I状态</li>
</ol>
</li>
</ul>
<p>MESI存在的问题：</p>
<ol>
<li><p>MESI协议在高并发场景下可能会存在问题，原因是在MESI协议下，如果当前CPU需要其他的CPU缓存行改变状态，会发送RFO（Request For Owner）请求进行通知，请求到达其他的CPU是需要时间的，在高并发场景下状态的修改可能会不及时。</p>
</li>
<li><p>M状态的缓存行数据不会立即更新到主内存，可能会导致其他CPU缓存行中读取的数据和修改后的数据出现短暂的不一致，</p>
<p>这一问题可以通过加锁或volatile解决。</p>
</li>
<li><p>存在伪共享问题。伪共享问题产生的原因是，CPU进行缓存和主内存交换数据的单位是缓存行（目前主流CPU缓存行的大小是64bytes），MESI协议也是针对缓存行变更状态，不是单个数据的状态。一个缓存行可能会存储了多个不同数据，所以缓存行中不同数据的状态存在共享的可能（伪共享），会导致不同数据的缓存状态彼此干扰。</p>
<p>JDK8之前可以通过字节填充的方式解决伪共享问题，思路大致是在创建变量时，用其他字段填充当前变量所在的缓存行，避免同一个缓存行内存放多个数据变量。</p>
<p>JDK8中引入了@Contended注解来自动填充缓存行，@Contended注解可以用在类和成员变量上，加上@Contended注解后JVM会自动填充，避免出现伪共享问题。使用@Contended注解需要注意的问题是，@Contended只能用在Java自身的核心类中，如果要用在自己写的类里面，需要添加JVM参数<code>-XX:RestrictContended</code>，此外，@Contended默认的填充宽度是128bytes，如果需要自定义宽度需要配置JVM的<code>-XX:ContendedPaddingWidth</code>参数。</p>
</li>
</ol>
<h3 id="volatile核心原理"><a href="#volatile核心原理" class="headerlink" title="volatile核心原理"></a>volatile核心原理</h3><p>volatile在内存语义上有两个作用：</p>
<ol>
<li>保证被volatile修饰的共享变量对每个线程都是可见的（可见性）</li>
<li>禁止指令重排（有序性）</li>
</ol>
<p>volatile不支持原子性，非线程安全</p>
<h4 id="保证可见性的核心原理"><a href="#保证可见性的核心原理" class="headerlink" title="保证可见性的核心原理"></a>保证可见性的核心原理</h4><p>volatile能够保证共享变量的可见性，如果一个共享变量使用volatile修饰，则共享变量所在的缓存行会被要求进行一致性校验，当一个线程修改了volatile修饰的共享变量后，修改后的共享变量值会立即刷新到主内存（MESI协议不会立即刷新，而是等远程读或远程写才会将修改后的数据值刷新到主内存）。</p>
<h4 id="保证有序性的核心原理"><a href="#保证有序性的核心原理" class="headerlink" title="保证有序性的核心原理"></a>保证有序性的核心原理</h4><p>volatile禁止指令重排是通过内存屏障（Memory Barrier）实现的。</p>
<p>内存屏障的底层是CPU指令。这个指令有两个作用：</p>
<ul>
<li><p>强制刷新缓存，保证共享变量的可见性</p>
<p>强制刷新缓存是指将处理器的缓存中的数据立即写回到主内存。当处理器修改了某个内存地址的值时，为了确保其他处理器能够看到最新的值，处理器会将修改后的值先写入自己的缓存中，然后再定期将缓存中的数据刷新回主内存。但是有时候我们需要立即刷新缓存，以确保其他处理器能够尽快看到最新的值。这可以通过执行一个写屏障或者其他特定的指令来实现。</p>
</li>
<li><p>禁止指令重排，保证指令的执行顺序</p>
<p>处理器为了提高程序执行效率，在编译（编译器重排序）或运行（CPU重排序）时会针对代码中的语句进行优化和重排。然而，在多线程并发环境下，这种重排可能会导致一些共享变量的状态无法正确传递，从而出现数据不一致的情况。内存屏障可以禁止指令重排，确保程序执行顺序的正确性。</p>
<p>注：</p>
<ol>
<li>编译器重排序：在代码编译阶段为了提高程序的执行效率，但不改变程序执行结果的重排序。</li>
<li>CPU重排序：CPU按照as-if-serial原则进行指令级重排序和内存系统重排序。as-if-serial原则能够保证在单线程环境下程序执行的正确性，不能保证在多线程环境下程序执行结果的正确性。</li>
</ol>
</li>
</ul>
<p>volatile禁止指令重排序的规则：</p>
<table>
<thead>
<tr>
<th>是否能重排序</th>
<th>第二个操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>第一个操作</td>
<td>普通读或写</td>
<td>volatile读</td>
<td>volatile写</td>
</tr>
<tr>
<td>普通读或写</td>
<td>是</td>
<td>是</td>
<td><strong>否</strong></td>
</tr>
<tr>
<td>volatile写</td>
<td>是</td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
</tr>
<tr>
<td>volatile读</td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
</tr>
</tbody></table>
<p>可以总结出规则是：</p>
<ol>
<li>当第一个操作是volatile读，无论第二个操作是什么，都不能重排序（读操作禁止重排序之后的操作）</li>
<li>当第一个操作是volatile写，第二个操作是volatile读，不能重排序</li>
<li>当第二个操作是volatile写，无论第一个操作是什么，都不能重排序（写操作禁止重排序之前的操作）</li>
</ol>
<p>内存屏障的类型：</p>
<ul>
<li>LoadLoad屏障：禁止前面的读（Load）和后面的Load重排</li>
<li>LoadStore屏障：禁止前面的Load和后面的写（Store）重排</li>
<li>StoreStore屏障：禁止前面的Store重排和后面的Store重排</li>
<li>StoreLoad屏障：禁止前面的Store重排和后面的Load重排</li>
</ul>
<p>JVM编译器会按照上述规则在程序编译生成的指令中插入内存屏障，规则是：</p>
<ol>
<li>对于volatile读<ol>
<li>后面插入一个LoadLoad屏障</li>
<li>后面插入一个LoadStore屏障</li>
</ol>
</li>
<li>对于volatile写<ol>
<li>前面插入一个StoreStore屏障</li>
<li>后面插入一个StoreLoad屏障</li>
</ol>
</li>
</ol>
<h4 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h4><p>DCL（Double Check Lock）单例为什么需要加volatile：</p>
<p>如果不加volatile，不能避免指令重排序，初始化指令和堆栈建立连接的指令可能会倒换，即可能出现堆栈建立连接发生在初始化指令之前，即</p>
<ul>
<li>加volatile，没有被重排序的指令执行过程如下<ol>
<li>初始化指令</li>
<li>堆栈建立连接的指令</li>
</ol>
</li>
<li>不加volatile，可能出现的重排序的指令执行过程如下<ul>
<li>堆栈建立连接的指令</li>
<li>初始化指令</li>
</ul>
</li>
</ul>
<p>这就导致在多线程环境下，如果没有使用volatile，假如一个线程正在使用创建对象，并且发生了指令重排序，使得堆栈建立连接的指令发生在初始化指令之前，那么当这条线程恰好执行完堆栈建立连接的指令，还没有执行初始化指令时，有一个新的线程线程执行DCL单例的函数，判断得到栈中已经指向堆中已有的对象，就会执行返回此对象，而此时对象还没有被初始化，此时获取的对象的值仅仅是默认值而不是初始化的值。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型简称JMM，是Java为了解决可见性和有序性问题而指定的一种编程规范。</p>
<p>主内存：主要对应于Java堆中存储对象实例数据的部分</p>
<p>工作内存：主要对应于虚拟机栈中的部分区域</p>
<h4 id="JMM的概念"><a href="#JMM的概念" class="headerlink" title="JMM的概念"></a>JMM的概念</h4><p>对于线程的工作内存和主内存之间的数据交互，JMM规定了变量从主内存复制到工作内存，以及从工作内存同步到主内存的实现细节。</p>
<p>JMM规定</p>
<ol>
<li>所有变量都存储在主内存中，也就是存储在计算机的物理内存中</li>
<li>每个线程都有自己的工作内存，用于存储线程私有数据</li>
<li>线程不能直接访问其他线程的工作内存中的数据，只能通过主内存进行数据交互</li>
<li>当线程需要操作变量时，需要先将主内存中的变量复制到对应的工作内存中</li>
</ol>
<p>JMM同步数据的八种操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>名称</th>
<th>目标</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>加锁</td>
<td>主内存中的变量</td>
<td>把主内存中的变量标记为线程独占的状态</td>
</tr>
<tr>
<td>unlock</td>
<td>解锁</td>
<td>主内存中的变量</td>
<td>释放主内存中锁定的变量，释放后可以被其他线程锁定</td>
</tr>
<tr>
<td>store</td>
<td>存储</td>
<td>工作内存中的变量</td>
<td>把工作内存中的变量的值刷新到主内存中，以便随后的write操作使用</td>
</tr>
<tr>
<td>write</td>
<td>写入</td>
<td>工作内存中的变量</td>
<td>把store操作从工作内存中得到的变量写入到主内存的变量中</td>
</tr>
<tr>
<td>read</td>
<td>读取</td>
<td>主内存中的变量</td>
<td>把主内存中的变量写入到工作内存中</td>
</tr>
<tr>
<td>load</td>
<td>载入</td>
<td>主内存中的变量</td>
<td>将read操作从主内存中得到的变量值载入工作内存的变量中</td>
</tr>
<tr>
<td>use</td>
<td>使用</td>
<td>工作内存中的变量</td>
<td>将工作内存中的变量值传递给执行引擎</td>
</tr>
<tr>
<td>assign</td>
<td>赋值</td>
<td>工作内存中的变量</td>
<td>执行引擎将值赋值给工作内存中的变量</td>
</tr>
</tbody></table>
<h4 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h4><p>在JMM中定义了一套Happens-Before原则，用于保证程序在执行过程中的可见性和有序性。</p>
<p>Happens-Before原则主要包括以下内容：</p>
<ol>
<li><p>程序次序原则</p>
<p>写在前面的操作先行发生于写在后面的操作</p>
</li>
<li><p>volatile变量原则</p>
<p>对一个volatile变量的写操作必然发生在后续对这个变量的读操作之前</p>
</li>
<li><p>传递原则</p>
<p>ABC三个操作，A先于B，B先于C，则A先于C</p>
</li>
<li><p>监视锁规则</p>
<p>对监视器的加锁发生在解锁之前</p>
</li>
<li><p>锁定原则</p>
<p>先解锁才能加锁</p>
</li>
<li><p>线程启动原则</p>
<p>线程start()后才能执行线程中的代码</p>
</li>
<li><p>线程中断原则</p>
<p>对线程的interrupt()方法的调用发生在中断事件产生之前</p>
</li>
<li><p>线程终结原则</p>
<p>线程结束后，其他线程能够访问到该线程修改后的共享变量的值</p>
</li>
<li><p>对象终结原则</p>
<p>一个对象的初始化必然在其finalize()方法之前执行</p>
</li>
</ol>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h2><p>synchronized用法分三种：</p>
<ol>
<li><p>同步实例方法</p>
<p>当类的普通方法被synchronized修饰时，相当于对this加锁，这个方法被声明为同步方法。</p>
</li>
<li><p>同步静态方法</p>
<p>当类的静态方法被synchronized修饰时，相当于对这个类的Class对象（.class）加锁，而一个类只对应一个Class对象。</p>
</li>
<li><p>同步代码块</p>
<p>通过对互不影响的临界区资源分别加锁（可能需要创建锁对象），可以减小对临界区资源的等待，提高程序的执行效率。</p>
</li>
</ol>
<p>可以由此将synchronized的锁分成两类锁：</p>
<p><strong>对象锁</strong>：对实例方法和同步代码块加的锁称为对象锁</p>
<p><strong>类锁</strong>：对静态方法加的锁称为类锁</p>
<h2 id="Java对象结构"><a href="#Java对象结构" class="headerlink" title="Java对象结构"></a>Java对象结构</h2><p>Java对象结构按照顺序由以下几部分组成：</p>
<ol>
<li>对象头<ol>
<li>Mark Word</li>
<li>类型指针</li>
<li>数组长度（仅在当前对象是数组时才会存在）</li>
</ol>
</li>
<li>实例数据</li>
<li>对齐填充</li>
</ol>
<p>以下是对Java对象组成部分的详细说明（64位JVM下）：</p>
<ol>
<li><p>对象头（8 + 4 + 4 &#x3D; 12 + 4 &#x3D; 16字节）</p>
<ol>
<li><p>Mark Word（8字节）</p>
<p>Mark Word用于存储对象的运行时数据，按照锁状态可以分为以下几类：</p>
<ul>
<li>无锁：对象的Hash码（31位）、GC的分代年龄（4位）、偏向锁标记（1位）、锁的状态标志（2位）</li>
<li>偏向锁：偏向锁线程id（54位）、获得偏向锁的时间戳（2位）、GC的分代年龄、偏向锁标记、锁的状态标志</li>
<li>轻量级锁：轻量级锁指针（指向栈中锁的指针，62位）、锁的状态标志</li>
<li>重量级锁：重量级锁指针（指向对象监视器的指针，62位）、锁的状态标志</li>
<li>GC标记（GC标记用于标记可以回收的垃圾对象）：锁的状态标志</li>
</ul>
</li>
<li><p>类型指针（4字节，默认开启压缩，由8字节压缩为4字节）</p>
<p>类的类元信息存储在JVM的方法区中，对象头的类型指针会指向存储在方法区中的类元信息</p>
<p>不同位数的JVM中长度不同，在32位JVM中，类型指针占用32位的存储空间，64位JVM中，占用64位。</p>
</li>
<li><p>数组长度（仅在当前对象是数组时才会存在，4字节）</p>
</li>
</ol>
</li>
<li><p>实例数据</p>
<p>存储对象的成员变量信息，既包含了类的成员变量值（具体值），也包含了父类的成员变量值</p>
</li>
<li><p>对齐填充</p>
<p>以满足JVM中对象的起始地址是8的整数倍的要求，所以对象的实例变量占用的存储空间需要是8字节的整数倍</p>
</li>
</ol>
<h2 id="使用JOL查看对象结构"><a href="#使用JOL查看对象结构" class="headerlink" title="使用JOL查看对象结构"></a>使用JOL查看对象结构</h2><p>为了方便查看JVM中对象结构并计算某个对象的大小，OpenJDK提供了一个JOL工具包</p>
<p>定义了一个int[]数组，并使用JOL提供的方法输出对象信息：</p>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230516191412412.png" alt="image-20230516191412412"></p>
<p>输出的Java对象信息：</p>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230516190422449.png" alt="image-20230516190422449"></p>
<h2 id="synchronized底层实现"><a href="#synchronized底层实现" class="headerlink" title="synchronized底层实现"></a>synchronized底层实现</h2><p>JVM是基于JVM中的monitor锁实现的，Java1.5版本之前的synchronized锁性能较低，但是从Java1.6开始，对synchronized锁进行了优化，引入了锁升级、锁粗化、锁消除等技术来提高synchronized的性能。</p>
<ol>
<li><p>字节码层面</p>
<ul>
<li><p>synchronized修饰的方法的字节码会比普通方法多一个ACC_SYNCHRONIZED标识符</p>
</li>
<li><p>synchronized修饰的代码块的字节码会在同步代码块的前后分别添加monitorenter和monitorexit指令</p>
</li>
</ul>
</li>
<li><p>JVM层面</p>
<p>synchronized修饰方法和代码块，在底层实现上没有本质区别</p>
<p>重量级锁的底层是基于Monitor锁实现的</p>
</li>
<li><p>操作系统层面</p>
<p>轻量级锁的底层是基于CAS实现的</p>
<p>Monitor锁是基于操作系统的Mutex锁实现的，Mutex锁是操作系统级别的重量级锁。</p>
</li>
</ol>
<h2 id="Monitor锁原理"><a href="#Monitor锁原理" class="headerlink" title="Monitor锁原理"></a>Monitor锁原理</h2><p>重量级锁的底层是基于Monitor锁实现的，而Monitor锁又是基于操作系统的Mutex锁实现的</p>
<p>在Java中创建出来的任何一个对象都会关联一个Monitor对象，当Monitor对象被一个Java对象持有后（Monitor对象的owner参数不为空），这个Monitor对象就会处于锁定状态。</p>
<p>在HotSpot JVM中，Monitor对象是由ObjectMonitor实现的，ObjectMonitor 是JVM中用于实现对象的同步、监视和锁定的重要数据结构。ObjectMonitor的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">ObjectMonitor() &#123;<br>    _header       = <span class="hljs-literal">NULL</span>;<br>    _count        = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录线程获取锁的次数</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 锁的重入次数</span><br>    _object       = <span class="hljs-literal">NULL</span>;<br>    _owner        = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 指向持有ObjectMonitor对象的线程</span><br>    _WaitSet      = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 处于wait状态的线程，会被加入到_WaitSet</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = <span class="hljs-literal">NULL</span> ;<br>    _succ         = <span class="hljs-literal">NULL</span> ;<br>    _cxq          = <span class="hljs-literal">NULL</span> ;<br>    FreeNext      = <span class="hljs-literal">NULL</span> ;<br>    _EntryList    = <span class="hljs-literal">NULL</span> ;  <span class="hljs-comment">// 处于等待锁block状态的线程，会被加入到该列表</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>ObjectMonitor的几个关键属性 <code>count、recursions、owner、WaitSet、 EntryList</code> 体现了monitor的工作原理</p>
<p>synchronized加锁与解锁在JVM底层的实现流程大致分为以下几步：</p>
<ol>
<li><p>被阻塞的线程被封装成ObjectWaiter对象进入<code>_EntryList</code>，获取到锁（获取到Monitor对象）的线程就会被<code>_owner</code>指向，并把ObjectMonitor对象的<code>_count</code>变量值加1。</p>
</li>
<li><p>当线程调用wait()方法时，当前线程会释放持有的ObjectMonitor对象，并把<code>_owner</code>变量值设为NULL，<code>_count</code>变量值减1。</p>
<p>由于wait()、notify()、notifyAll()等方法在执行过程中会使用ObjectMonitor对象，所以，必须在同步代码块或方法中调用这些方法。</p>
</li>
<li><p>如果获取到ObjectMonitor对象的线程执行完毕，则会释放ObjectMonitor对象，将ObjectMonitor对象中的<code>_count</code>变量值减1（当<code>_count</code>变量值再次为0，当前线程就成功的释放了锁），<code>_owner</code>变量值设为NULL。</p>
</li>
</ol>
<h2 id="锁升级的过程"><a href="#锁升级的过程" class="headerlink" title="锁升级的过程"></a>锁升级的过程</h2><p>锁升级的过程经历以下几个阶段</p>
<ol>
<li><p>无锁</p>
</li>
<li><p>偏向锁</p>
</li>
<li><p>轻量级锁（自旋锁）</p>
</li>
<li><p>重量级锁</p>
</li>
</ol>
<p>Java锁对象由无锁升级为重量级锁的详细步骤：</p>
<ol>
<li><p>线程的抢占锁时首先会检查偏向锁标记位和锁标记位，如果发现是偏向锁，进行锁竞争的一般流程：</p>
<ol>
<li>线程获取锁：线程会检查Mark Word中的偏向锁线程id是否是自己的线程id<ol>
<li>如果是，则当前线程已经持有了锁，直接执行同步代码</li>
<li>如果不是，则当前线程会通过CAS自旋的方式尝试将Mark Word中的偏向锁线程id设为自己的线程id<ol>
<li>CAS操作成功，将Mark Word中的偏向锁线程id设为自己的线程id的操作成功</li>
<li>CAS操作失败，说明此时有其他线程也在争抢锁资源，此时会撤销偏向锁，升级为轻量级锁</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>如果发现是轻量级锁，进行锁竞争的一般流程：</p>
<ol>
<li><p>将锁对象的 Mark Word 备份到 Displaced Mark Word （当线程被创建后，JVM会在线程的栈帧中创建一个用于存储锁记录（Lock Record）的空间，里面存储了owner和Displaced Mark Word）中，并将栈帧的owner指针指向锁对象</p>
</li>
<li><p>尝试通过 CAS 将锁对象的 Mark Word 更新为指向 Displaced Mark Word 的指针</p>
<ol>
<li><p>如果CAS操作成功，表示当前线程成功获取了轻量级锁，并进入临界区执行。</p>
</li>
<li><p>如果已经指向其他线程，竞争锁失败，会进行CAS操作</p>
<ol>
<li><p>自旋等待：如果CAS操作失败，表示锁对象已经被其他线程占用。此时，请求锁的线程会进入自旋等待状态。在自旋等待状态下，线程会反复尝试使用CAS操作获取锁，而不会被阻塞。</p>
</li>
<li><p>自旋限制：CAS自旋操作超过一定的次数仍未抢占到锁，轻量级锁会膨胀为重量级锁，进入阻塞状态。</p>
<p>对于自旋次数上限值，JDK中提供了自适应自旋的方案，如果当前线程的CAS自旋成功，就会增大下一次的自旋次数上限值，如果失败，就会减小。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>当线程释放锁</p>
<ol>
<li>如果锁对象还是轻量级锁的状态，当前线程就会使用CAS操作将Displaced Mark Word中存储的信息复制到锁对象的Mark Word中</li>
<li>如果锁对象已经升级为了重量级锁，当前线程就会释放锁并唤醒其他被阻塞的线程争抢锁</li>
</ol>
</li>
</ol>
</li>
<li><p>如果发现是重量级锁，进行锁竞争的一般流程：</p>
<ol>
<li>线程请求锁：当一个线程需要获取重量级锁时，它会向操作系统发送请求。<ol>
<li><p>如果当前没有其他线程持有锁，请求的线程会成功获取锁，并进入临界区执行。</p>
</li>
<li><p>如果锁已经被其他线程占用，请求的线程将进入阻塞等待状态，线程会被操作系统挂起，不会占用CPU资源。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Java锁对象由无锁升级为重量级锁的其他途径：</p>
<ol>
<li><p>计算一致性哈希</p>
<p>只要锁对象计算过一致性哈希，偏向模式就置为0了，也就意味着该对象锁不能再偏向了，最低也会膨胀会轻量级锁。<br>如果对象锁处于偏向模式时遇到计算一致性哈希请求，那么会跳过轻量级锁模式，直接膨胀为重量级锁。</p>
</li>
</ol>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>重量级锁的降级只会发生在GC期间的STW阶段，只能降级为可以被JVM线程访问，而不被其他Java线程访问的对象。</p>
<h1 id="AQS核心原理"><a href="#AQS核心原理" class="headerlink" title="AQS核心原理"></a>AQS核心原理</h1><p>AQS（AbstractQueuedSynchronizer）是volatile和CAS和队列的组合应用</p>
<p>java中哪些同步锁是基于AQS实现的：</p>
<p>Java 并发包 <code>java.util.concurrent</code> 中的许多同步工具类都是基于 <code>AbstractQueuedSynchronizer</code> (简称 AQS) 来实现的。AQS 是一个用于构建锁和同步器的框架，它使用一个 int 成员变量来表示同步状态，并提供了一种使用 CAS（Compare-and-Swap）设置同步状态的方式。以下是一些基于 AQS 实现的同步类：</p>
<ol>
<li><p><strong>ReentrantLock</strong>：重入锁，是一种互斥锁，它的特点是支持重入功能，也就是说，一个线程能够对已经获取到的锁再次获取，而不会发生死锁。</p>
</li>
<li><p><strong>ReentrantReadWriteLock</strong>：读写锁，它分为两个锁，一个是读锁，一个是写锁。多个读锁之间不会互斥，读锁与写锁互斥，写锁与写锁互斥。这是由jvm自己控制的，你只要上好相应的锁即可。</p>
</li>
<li><p><strong>Semaphore</strong>：信号量，内部维护了一组”许可”，线程可以申请许可（如果无可用许可则阻塞），也可以释放许可。信号量可用于实现资源池，或者对某个操作的并发线程数进行限制。</p>
</li>
<li><p><strong>CountDownLatch</strong>：倒计时门栓，它可以让一个或多个线程等待其他线程完成各自的工作后再执行。</p>
</li>
<li><p><strong>CyclicBarrier</strong>：循环栅栏，它允许一组线程互相等待，直到所有的线程都准备就绪后，所有的线程才能继续执行。</p>
</li>
<li><p><strong>FutureTask</strong>：一个实现了 <code>Future</code> 和 <code>Runnable</code> 接口的类，可以用来执行 <code>Callable</code> 任务，并且可以获取任务执行后的结果。</p>
</li>
</ol>
<p>这些类都通过自定义 AQS 来实现它们自己的同步语义。</p>
<h2 id="AQS数据结构原理"><a href="#AQS数据结构原理" class="headerlink" title="AQS数据结构原理"></a>AQS数据结构原理</h2><p>AQS（AbstractQueuedSynchronizer，抽象队列同步器）是Java中提供的一个抽象类，位于java.util.concurrent.locks包下</p>
<p>AQS的数据结构主要包括以下几个部分：</p>
<ol>
<li><p>两类FIFO（先进先出）的双向链表（同步队列和同步条件队列）</p>
<p>链表中的每个节点都是对线程的封装，如果线程竞争锁失败，就会被封装成一个Node节点加入AQS队列的尾部。当获取锁的线程释放锁之后，会从AQS中唤醒一个被阻塞的线程。</p>
<ol>
<li>同步队列通过addWaiter()方法添加到队列的尾部，通过acquire()方法退出同步队列</li>
<li>同步条件队列addConditionWaiter()方法添加到队列的尾部，通过doSignal()方法退出同步队列。AQS中的同步条件队列就是为Lock锁实现的一个基础同步器，只有在使用了Condition时会存在条件队列，并且一个线程可能存在多个条件队列</li>
</ol>
</li>
<li><p>头节点指针、尾节点指针</p>
<p>头节点指针指向的节点封装的线程会占用资源，同时会通过CAS的方式更新state变量、头&#x2F;尾节点指针的指针的指向。</p>
</li>
<li><p>用来标识状态的volatile修饰的变量state</p>
<p>AQS中使用getState()方法读取state变量的值，使用setState()（无法保证原子性）和compareAndSetState()方法（能够保证原子性）设置state变量的值</p>
</li>
<li><p>Node类，AQS实现的独占锁和共享锁是在其静态内部类Node中定义的</p>
<p>静态内部类Node是一个双向链表，节点中保存了当前的状态waitState和当前线程thread。通过SHARED和EXCLUSIVE定义共享或独占状态。</p>
<p>Node中有四个常量，是waitState变量的取值，waitState变量也是用volatile修饰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span><br><span class="hljs-comment">// 表示当前节点中的线程已被取消</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br><span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br><span class="hljs-comment">// 表示后继节点中的线程处于等待状态，需要被唤醒</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span><br><span class="hljs-comment">// 表示当前节点中的线程在等待某个条件，也就是当前节点处于condition队列中</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * waitStatus value to indicate the next acquireShared should</span><br><span class="hljs-comment"> * unconditionally propagate</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 表示在当前场景下能够执行后续的acquireShared操作</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="AQS底层对锁的支持"><a href="#AQS底层对锁的支持" class="headerlink" title="AQS底层对锁的支持"></a>AQS底层对锁的支持</h2><p>Java中java.util.concurrent包下的大部分工具类的实现都基于AQS（都extends Sync，而Sync extends AbstractQueuedSynchronizer）。基于AQS的工具类：</p>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230517221126607.png" alt="image-20230517221126607"></p>
<p>AQS底层支持独占锁和共享锁两种模式：</p>
<ol>
<li>独占锁同一时刻只能被一个线程占用，如ReentrantLock</li>
<li>共享锁同一时刻可以被多个线程占用，如CountDownLatch、Semaphore等</li>
<li>有的锁实现类同时实现了独占锁和共享锁两种模式：如ReentrantReadWriteLock</li>
</ol>
<h2 id="独占锁和共享锁的实现流程"><a href="#独占锁和共享锁的实现流程" class="headerlink" title="独占锁和共享锁的实现流程"></a>独占锁和共享锁的实现流程</h2><p><strong>独占锁模式下的加锁流程：</strong></p>
<p>独占锁加锁的入口是acquire()方法，当线程调用acquire()方法获取独占锁时，首先会调用tryAcquire()方法尝试获取锁资源，如果获取失败返回false，就会调用addWaiter()方法将当前线程封装为Node节点，添加到AQS队列的尾部。然后调用acquireQueued()方法在等待队列中排队，在acquireQueued()方法中进入一个循环逻辑：如果监测到前驱节点是head节点，就尝试获取锁，如果获取成功就将head指向当前Node节点；如果前驱节点不是head节点，就调用shouldParkAfterFailedAcquire()方法判断是否可以进入waiting状态，如果可以，就进入阻塞状态直到调用LockSupport的unpark()方法唤醒当前线程。</p>
<p><strong>独占锁模式下的解锁流程：</strong></p>
<p>独占锁模式中，释放锁的入口方法是release()，在release()方法中首先会调用tryRelease()方法尝试释放锁，如果返回true，并且head节点不为空且head节点的waitState状态不为0，会调用unparkSuccessor()方法唤醒队列最前面可以被唤醒的节点。</p>
<p><strong>共享锁模式下的加锁流程：</strong></p>
<p>共享锁加锁的入口是acquireShared()方法，当线程调用acquireShared()方法获取共享锁时，首先会调用tryAcquireShared()方法尝试获取锁资源，如果获取失败返回负数，就会调用doAcquireShared()方法将当前线程封装为Node节点，添加到AQS队列的尾部并阻塞。然后监测前驱节点是否是head节点，就尝试获取锁，如果获取成功就将head指向当前Node节点，如果同时还有剩余资源则继续唤醒队列中后面的线程；如果前驱节点不是head节点，就调用shouldParkAfterFailedAcquire()方法判断是否可以进入waiting状态，如果可以，就进入阻塞状态直到调用LockSupport的unpark()方法唤醒当前线程。</p>
<p><strong>共享锁模式下的解锁流程：</strong></p>
<p>共享锁模式中，释放锁的入口方法是releaseShared()，在release()方法中首先会调用tryReleaseShared()方法尝试释放锁，如果返回true，就执行doReleaseShared()方法唤醒队列后面的线程。</p>
<h1 id="CAS核心原理"><a href="#CAS核心原理" class="headerlink" title="CAS核心原理"></a>CAS核心原理</h1><h2 id="CAS的基本概念"><a href="#CAS的基本概念" class="headerlink" title="CAS的基本概念"></a>CAS的基本概念</h2><blockquote>
<p>将内存位置的内容与给定值进行比较，只有当它们相同时，才将该内存位置的内容修改为新的给定值</p>
</blockquote>
<p>CAS（Compare And Swap）是一种无锁编程算法，属于乐观锁。</p>
<p>CAS以原子性的方式更新共享变量的数据，能够保证线程安全。</p>
<p>CAS算法的使用包含以下步骤（假设新值是基于共享变量的旧值计算得到的，比如加1操作）：</p>
<ol>
<li>读取到的共享变量的值是prev</li>
<li>确定要修改的值是next（如next&#x3D;prev+1）</li>
<li>再次读取共享变量的值是cur，并比较prev和cur是否一样，即计算得到next的操作前后共享变量的值是否发生了改变。如果没有发生改变就更新共享变量的值为next；如果发生了改变，则重新从第一步开始执行，或者根据需要结束执行。</li>
</ol>
<p>AtomicInteger的getAndUpdate方法的实现就体现了这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndUpdate</span><span class="hljs-params">(IntUnaryOperator updateFunction)</span> &#123;<br>    <span class="hljs-type">int</span> prev, next;<br>    <span class="hljs-keyword">do</span> &#123;<br>        prev = get();<br>        next = updateFunction.applyAsInt(prev);<br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSet(prev, next));<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CAS的核心类Unsafe"><a href="#CAS的核心类Unsafe" class="headerlink" title="CAS的核心类Unsafe"></a>CAS的核心类Unsafe</h2><p>Unsafe类是Java中实现CAS操作的核心类，位于sun.misc包，在UnSafe类中提供了大量的native方法，通过JNI的方式调用JVM底层的C和C++实现的方法。java.util.concurrent.atomic包下提供的原子类底层操作都是基于Unsafe类实现的。</p>
<p>使用Unsafe的CAS方法实现count++：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CasCountIncrement</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">singleOneInstanceField</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            singleOneInstanceField.setAccessible(<span class="hljs-literal">true</span>);<br>            unsafe = (Unsafe) singleOneInstanceField.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> unsafe;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXECUTE_COUNT_EACH_THREAD</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">countOffset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countOffset = unsafe.objectFieldOffset(CasCountIncrement.class.getDeclaredField(<span class="hljs-string">&quot;count&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementCountByCas</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            oldCount = count;<br>        &#125; <span class="hljs-keyword">while</span> (!unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, countOffset, oldCount, oldCount + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CasCountIncrement</span> <span class="hljs-variable">casCountIncrement</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CasCountIncrement</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_COUNT);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_COUNT; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                IntStream.range(<span class="hljs-number">0</span>, EXECUTE_COUNT_EACH_THREAD).forEach((j) -&gt; &#123;<br>                    casCountIncrement.incrementCountByCas();<br>                &#125;);<br>                countDownLatch.countDown();<br>            &#125;).start();<br>        &#125;;<br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + casCountIncrement.count); <span class="hljs-comment">//count = 10000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ABA问题的解决方案"><a href="#ABA问题的解决方案" class="headerlink" title="ABA问题的解决方案"></a>ABA问题的解决方案</h2><p>java中的java.util.concurrent.atomic包下提供了AtomicStampedReference类和AtomicMarkableReference类来解决ABA问题。</p>
<p>区别是：</p>
<ol>
<li>AtomicStampedReference使用的是int类型的stamp，可以区分每一次的修改</li>
<li>AtomicMarkableReference使用的是boolean类型的mark，只能判断有没有修改过</li>
</ol>
<p>实现源码：</p>
<ol>
<li><p>AtomicStampedReference：在CAS的基础上增加了stamp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Params:</span><br><span class="hljs-comment">    expectedReference – the expected value of the reference </span><br><span class="hljs-comment">    newReference – the new value for the reference </span><br><span class="hljs-comment">    expectedStamp – the expected value of the stamp </span><br><span class="hljs-comment">    newStamp – the new value for the stamp</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V expectedReference,</span><br><span class="hljs-params">                             V newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> expectedStamp,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> newStamp)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newStamp == current.stamp) ||<br>         casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>AtomicMarkableReference：在CAS的基础上增加了mark</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Params:</span><br><span class="hljs-comment">    expectedReference – the expected value of the reference </span><br><span class="hljs-comment">    newReference – the new value for the reference </span><br><span class="hljs-comment">    expectedMark – the expected value of the mark </span><br><span class="hljs-comment">    newMark – the new value for the mark</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V expectedReference,</span><br><span class="hljs-params">                             V newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">boolean</span> expectedMark,</span><br><span class="hljs-params">                             <span class="hljs-type">boolean</span> newMark)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedMark == current.mark &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newMark == current.mark) ||<br>         casPair(current, Pair.of(newReference, newMark)));<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="同步集合"><a href="#同步集合" class="headerlink" title="同步集合"></a>同步集合</h1><p>同步集合指的是在对集合进行修改时，需要对整个集合加锁，保证修改的原子性和线程安全。</p>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>Vector实现了List接口，底层是数组，Vector类保证方法线程安全的方式是在方法上添加synchronized关键字。</p>
<h2 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h2><p>Stack 继承自 Vector 类，在此基础上还增加了一个栈数据结构（FILO），实现了线程安全的栈操作。</p>
<h2 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h2><p>Hashtable是一个散列表类，实现了线程安全的 key-value 操作。底层结构是数组+链表，数组是 <code>Hashtable</code> 的主体，链表则是为了解决哈希冲突而存在的。是线程安全的。</p>
<h2 id="同步包装器"><a href="#同步包装器" class="headerlink" title="同步包装器"></a>同步包装器</h2><p>如果要讲非线程安全的集合类，如ArrayList、HashMap转换成线程安全的类，则需要使用Java提供的同步包装器。</p>
<p>java.util包下的Collections类中的synchronizedXxx方法就是Java的同步包装器。</p>
<p>将ArrayList对象转为同步集合类的对象，使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Object&gt; synchronizedList = Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br></code></pre></td></tr></table></figure>

<h2 id="同步集合的缺陷"><a href="#同步集合的缺陷" class="headerlink" title="同步集合的缺陷"></a>同步集合的缺陷</h2><ol>
<li><p>性能问题</p>
<p>同步集合大量使用了synchroized关键字修饰整个方法，使用的是重量级锁，在部分场景下，如读多写少等，性能低。</p>
</li>
<li><p>竞态条件问题</p>
<p>同步集合可以保证每种方法单独操作的原子性，但是不能保证方法组合起来的复杂操作的原子性。当程序中出现复合操作时，有可能出现竞态条件问题。</p>
<blockquote>
<p>备注：</p>
<p>竞态条件（Race Condition）是指，当两个或多个线程对同一共享资源进行读写操作时，最终的结果取决于线程执行的相对速度和调度顺序，从而导致程序出现不确定性结果的问题。</p>
<p>一个经典的例子是，两个线程 T1 和 T2 同时对共享资源 X 进行读取和加 1 操作，如果 T1 先读取了 X 的值，然后进行加 1 操作，但在 T1 执行完加 1 操作前，T2 也读取了 X 的值并进行加 1 操作，然后 T1 再将自己的结果写入 X 中，这时候 X 的值就只加了 1 而不是 2，因此出现了不一致的情况。</p>
</blockquote>
<p>在使用同步集合进行复合操作时，对同步集合加锁，可以有效避免竞态条件问题。</p>
</li>
<li><p>使用迭代器遍历问题</p>
<p>使用迭代器遍历（本质上是复合操作）同步集合也会出现线程安全问题。比如两个启动线程，一个进行迭代读，另一个线程进行删除操作，就会抛出ConcurrentModificationException异常，说明在迭代读的过程中另一个线程执行了删除操作，所以，存在线程安全问题。</p>
<p>解决办法也是对同步集合加锁。</p>
</li>
</ol>
<h1 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h1><p>并发集合是指在对集合进行修改时，不需要对整个集合进行加锁的集合类的统称，可以支持高效的并发操作。</p>
<h2 id="并发List集合类"><a href="#并发List集合类" class="headerlink" title="并发List集合类"></a>并发List集合类</h2><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList采用了写时复制技术，即在写的时候复制一个副本。</p>
<p>CopyOnWriteArrayList的底层是一个数组，对数组的读操作会直接返回原数组中的值，对数组的写操作会首先获取ReentrantLock独占锁，然后复制一份原数组的副本，在数组的副本上进行写操作，在执行完毕后，再将s狐族的副本赋值给原数组的引用array。</p>
<p>可以看出，CopyOnWriteArrayList存在的缺陷有：</p>
<ol>
<li>写操作时时间、空间开销大，适合写少读多的场景。</li>
<li>不能保证数据的实时一致性，因为在修改数组的过程中的如果其它线程读，读到的是原数组的值，不一定是修改后的最新值。</li>
</ol>
<p>CopyOnWriteArrayList的优点有：</p>
<ol>
<li>读取数据的性能高</li>
</ol>
<p>在使用Iterator遍历CopyOnWriteArrayList时，实际上遍历的是array引用指向的原数组。</p>
<h2 id="并发Set集合类"><a href="#并发Set集合类" class="headerlink" title="并发Set集合类"></a>并发Set集合类</h2><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>CopyOnWriteArraySet的底层是基于CopyOnWriteArrayList实现的，所以特点和CopyOnWriteArrayList一样。</p>
<p>CopyOnWriteArraySet的add方法也是直接调用了CopyOnWriteArrayList的addIfAbsent方法。</p>
<h3 id="ConcurrentSkipListSet"><a href="#ConcurrentSkipListSet" class="headerlink" title="ConcurrentSkipListSet"></a>ConcurrentSkipListSet</h3><p>与CopyOnWriteArraySet不同的是，ConcurrentSkipListSet是有序的，并且底层不是基于CopyOnWriteArrayList，而是基于ConcurrentSkipListMap。Java1.7版本时加入。</p>
<p>ConcurrentSkipListSet的底层使用了跳表。跳表的实现方法是在链表的基础上加索引，每一级索引也是一个链表，通过增加索引的层级来提高查找数据的效率，并且高层索引中的节点会存在一个指向低层级索引节点的指针。使用跳表查找数据的时间复杂度是O(logn)。</p>
<h2 id="并发Map集合类"><a href="#并发Map集合类" class="headerlink" title="并发Map集合类"></a>并发Map集合类</h2><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p><strong>Java1.7的 ConcurrentHashMap</strong>：</p>
<p>Java1.7及之前的版本，ConcurrentHashMap使用的是Segment组、 HashEntry数组和链表实现的，结构见下图。在并发修改ConcurrentHashMap中的数据时，只会针对Segment数组中的对应元素加锁（Segment分段锁）。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java7_concurrenthashmap.png" alt="JDK1.7 的 ConcurrentHashMap"></p>
<p><strong>Java1.8的 ConcurrentHashMap</strong>：</p>
<p>Java1.8及之后的版本，ConcurrentHashMap不再使用Segment分段锁 方案，而使用和HashMap相同的结构，也就是Node 数组、链表 &#x2F; 红黑树的结构，见下图，并使用CAS+synchronized锁的方式保证线程安全。在并发修改ConcurrentHashMap中的数据时，只会针对Node（实际上是Node类的子类TreeBin）数组（对象名为table）中的对应元素加锁。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/java/collection/java8_concurrenthashmap.png"></p>
<p>table数组扩容的规则：</p>
<ol>
<li>当数组长度小于64，且链表长度大于或等于8时，进行数组扩容。</li>
<li>已使用数量&#x2F;总容量的比值达到负载因子（默认是0.75，可以在构造对象的时候传入其它值作为负载因子）后，进行数组扩容。</li>
</ol>
<p>链表转红黑树的规则：</p>
<ol>
<li>当数组长度大于或等于64，且链表长度大于或等于8时，链表会转换为红黑树。</li>
</ol>
<p>红黑树转链表的规则：</p>
<ol>
<li>当链表的长度小于等于6时，红黑树会转换为链表。</li>
</ol>
<p>ConcurrentHashMap的sizeCtl成员变量：</p>
<ol>
<li>在未初始化的阶段，sizeCtl记录了table数组的初始容量。</li>
<li>在初始化的过程中，或在table扩容过程中，sizeCtl会被通过CAS操作赋值为-1。</li>
<li>在初始化完成后，sizeCtl会记录当前table数组的扩容阈值。</li>
</ol>
<h3 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h3><p>ConcurrentSkipListMap底层使用了跳表数据结构，索引节点是Index类。key是有序的。关于链表的介绍见<a href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#ConcurrentSkipListSet">ConcurrentSkipListSet</a>。</p>
<h2 id="并发Queu集合类之阻塞队列"><a href="#并发Queu集合类之阻塞队列" class="headerlink" title="并发Queu集合类之阻塞队列"></a>并发Queu集合类之阻塞队列</h2><h3 id="并发阻塞队列概述"><a href="#并发阻塞队列概述" class="headerlink" title="并发阻塞队列概述"></a>并发阻塞队列概述</h3><p><strong>特性</strong></p>
<p>Java中的并发阻塞队列中对于支持有界队列（可以设置队列容量）的并发阻塞队列，当队列满时会阻塞执行添加操作的线程，直到队列数据被消费，执行添加操作的线程才会被唤醒。</p>
<p>当队列为空时并发阻塞队列会阻塞执行消费操作的线程，直到队列中添加了新数据，执行消费操作的线程才会被唤醒。</p>
<p>并发阻塞队列可以分为单端阻塞队列和双端阻塞队列。单端阻塞队列只能向队列的一端添加数据，且只能从另一端消费数据。双端阻塞队列可以分别在队列两端添加数据或者消费数据。</p>
<p>Java的除了LinkedTransferQueue（队列为空时会生成并添加一个null元素），其它所有并发阻塞队列的元素都不能为null。</p>
<p><strong>类的继承关系</strong></p>
<p>Java中的并发阻塞队列类都实现了BlockingQueue接口（LinkedTransferQueue和LinkedBlockingDeque是间接实现的，分别实现了TransferQueue和BlockingDeque接口，这些接口又继承了BlockingQueue接口），该接口规定了对于数据的添加、删除和获取有4钟不同的处理方式，分别为抛出异常、返回值、阻塞和限时返回：</p>
<table>
<thead>
<tr>
<th></th>
<th><em>Throws exception</em></th>
<th><em>Special value</em></th>
<th><em>Blocks</em></th>
<th><em>Times out</em></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Insert</strong></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#add-E-"><code>add(e)</code></a></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#offer-E-"><code>offer(e)</code></a></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#put-E-"><code>put(e)</code></a></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#offer-E-long-java.util.concurrent.TimeUnit-"><code>offer(e, time, unit)</code></a></td>
</tr>
<tr>
<td><strong>Remove</strong></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#remove-java.lang.Object-"><code>remove()</code></a></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#poll-long-java.util.concurrent.TimeUnit-"><code>poll()</code></a></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#take--"><code>take()</code></a></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/BlockingQueue.html#poll-long-java.util.concurrent.TimeUnit-"><code>poll(time, unit)</code></a></td>
</tr>
<tr>
<td><strong>Examine</strong></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#element--"><code>element()</code></a></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#peek--"><code>peek()</code></a></td>
<td><em>not applicable</em></td>
<td><em>not applicable</em></td>
</tr>
</tbody></table>
<p><strong>应用</strong></p>
<p>使用阻塞队列能够实现多个线程之间以线程安全的方式进行数据共享。</p>
<p>并发阻塞队列有两个典型的应用案例，一个是生产者-消费者模式，另一个是按周期执行定时任务。</p>
<ul>
<li>生产者-消费者模式可以使用并发阻塞队列实现。之所以是使用并发阻塞队列，而不是非并发阻塞队列，原因是，阻塞队列能够实现消费队列没有任务时消费者线程的阻塞，有任务之后消费者线程被唤醒；而非并发阻塞队列不存在阻塞和唤醒功能。</li>
<li>使用并发阻塞队列的DelayQueue可以非常方便地执行定时任务。</li>
</ul>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue是基于数组实现的，线程安全的<strong>有界</strong>阻塞队列，且仅支持有界，即所有构造函数都需要指定队列容量。</p>
<p><strong>支持公平和非公平两种线程访问方式。</strong></p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue是基于链表实现的，线程安全的阻塞队列。支持<strong>无界和有界</strong>队列。</p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue是基于堆实现的，带优先级的无界阻塞队列，元素按照比较规则进行排序。支持<strong>无界和有界</strong>队列。</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue是基于PriorityQueue（底层基于堆）实现的，支持延时获取数据的<strong>无界</strong>阻塞队列，元素按照过期时间进行排序。</p>
<p>添加到DelayQueue中的元素必须实现Delayed接口。</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue底层基于CAS实现的<strong>无界</strong>阻塞队列，内部不存储元素。对SynchronousQueue的添加操作必须等待其它线程执行删除操作，才能执行，同样的，对SynchronousQueue的删除操作也必须等待其它线程执行添加操作。</p>
<p><strong>支持公平和非公平两种线程访问方式。</strong></p>
<h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>LinkedTransferQueue是由链表实现的<strong>无界</strong>阻塞队列，实现了TransferQueue接口，TransferQueue接口继承了BlockingQueue接口，相比其它阻塞队列多了tryTransfer和transfer等方法。</p>
<p>LinkedTransferQueu采用预占模式读写数据。</p>
<p>在消费者线程从LinkedTransferQueue中获取数据时，如果LinkedTransferQueue中存在数据，则直接获取数据并返回。如果LinkedTransferQueue为空，就会生成一个元素为null的节点添加到LinkedTransferQueue中，并且消费者会在这个节点上阻塞等待；在后续生产者线程调用transfer方法时，不会将数据添加到LinkedTransferQueue中，而是将数据直接传递给消费者线程。</p>
<p>在生产者线程调用transfer方法时，如果未发现有在LinkedTransferQueue节点上等待的消费者线程，就会将数据添加到LinkedTransferQueue中，然后阻塞等待，直到有其他消费者线程获取添加的元素。</p>
<h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>LinkedBlockingDeque是一个基于双向链表实现的<strong>双向</strong>阻塞队列，能够从队列两端添加和删除数据，支持先进先出和先进后出。支持<strong>无界和有界</strong>队列。</p>
<p>创建LinkedBlockingDeque时可以指定容量，如果不指定，则默认队列的容量是Integer.MAX_VALUE。</p>
<h2 id="并发Queu集合类之非阻塞队列"><a href="#并发Queu集合类之非阻塞队列" class="headerlink" title="并发Queu集合类之非阻塞队列"></a>并发Queu集合类之非阻塞队列</h2><h3 id="并发非阻塞队列概述"><a href="#并发非阻塞队列概述" class="headerlink" title="并发非阻塞队列概述"></a>并发非阻塞队列概述</h3><p>并发阻塞队列的实现大都基于ReentrantLock锁，与并发阻塞队列不同的是，并发非阻塞队列是基于CAS自旋锁实现的，在并发非阻塞队列上读写数据时，线程不会阻塞。</p>
<p>并发非阻塞队列可以分为单端非阻塞队列和双端非阻塞队列。</p>
<p><strong>类的继承关系</strong></p>
<p>并发非阻塞队列都实现了Queue接口，并且都是基于链表实现的无界队列。</p>
<p>Java中的并发非阻塞队列类都实现了Queue接口（ConcurrentLinkedDeque是间接实现，ConcurrentLinkedDeque实现了Deque接口，该接口又继承了Queue接口），该接口规定了对于数据的添加、删除和获取有2钟不同的处理方式，分别为抛出异常和返回值：</p>
<table>
<thead>
<tr>
<th></th>
<th>Throws exception</th>
<th>Returns special value</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Insert</strong></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#add-E-"><code>add(e)</code></a></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#offer-E-"><code>offer(e)</code></a></td>
</tr>
<tr>
<td><strong>Remove</strong></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#remove--"><code>remove()</code></a></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#poll--"><code>poll()</code></a></td>
</tr>
<tr>
<td><strong>Examine</strong></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#element--"><code>element()</code></a></td>
<td><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html#peek--"><code>peek()</code></a></td>
</tr>
</tbody></table>
<h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue是基于链表实现的无界非阻塞队列，没有保存队列的元素数量，其size操作是通过遍历计算元素数量实现的。</p>
<h3 id="ConcurrentLinkedDeque"><a href="#ConcurrentLinkedDeque" class="headerlink" title="ConcurrentLinkedDeque"></a>ConcurrentLinkedDeque</h3><p>ConcurrentLinkedDeque是基于链表实现的无界非阻塞队列，没有保存队列的元素数量。</p>
<h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><p>并发工具类是一组用于帮助管理多线程并发操作的类。它们提供了例如线程同步、线程通信和控制线程执行的顺序等功能。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch能够实现一个或多个线程，等待其它所有线程完成某种操作后再执行。</p>
<p>CountDownLatch是基于AQS（AbstractQueuedSynchronizer）实现的，调用CountDownLatch的await方法的线程，会被加入到AQS的阻塞队列中等待。</p>
<p>CountDownLatch维护了一个计数器，记录未完成某种操作的线程数量，随构造函数传入初始值，调用countDown方法时计数器的值减1，当计数器的值减到0时，阻塞的线程会被唤醒。CountDownLatch的计数器值不能被重置。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchArrivalTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch countDownLatch;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatchArrivalTask</span><span class="hljs-params">(String name, CountDownLatch countDownLatch)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.countDownLatch = countDownLatch;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; has arrived.&quot;</span>);<br>        countDownLatch.countDown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchWaitingTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatchWaitingTask</span><span class="hljs-params">(String name, CountDownLatch countDownLatch)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.countDownLatch = countDownLatch;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(name + <span class="hljs-string">&quot; is waiting for tourists.&quot;</span>);<br>            countDownLatch.await();<br>            System.out.println(<span class="hljs-string">&quot;The tour can begin.&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatchWaitingTask</span>(<span class="hljs-string">&quot;Tourist guide&quot;</span>, countDownLatch)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatchArrivalTask</span>(<span class="hljs-string">&quot;Tourist Amy&quot;</span>, countDownLatch)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatchArrivalTask</span>(<span class="hljs-string">&quot;Tourist Sam&quot;</span>, countDownLatch)).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">运行输出：</span><br><span class="hljs-comment">Tourist Amy has arrived.</span><br><span class="hljs-comment">Tourist guide is waiting for tourists.</span><br><span class="hljs-comment">Tourist Sam has arrived.</span><br><span class="hljs-comment">The tour can begin.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">//&quot;The tour can begin.&quot;总是最后执行</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，有一个旅游团的导游和两个游客（CountDownLatch对象的计数器被初始化为2），导游需要等待所有游客到达（导游线程调用await方法）后才开始旅游，每个游客线程在到达后会调用countDown()方法来减少CountDownLatch对象的计数器，当计数器值减为0，await之后的代码继续执行。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CyclicBarrier的功能是对CountDownLatch工具类的增强。</p>
<p>CyclicBarrier的计数器可以被自动重置（在计数器减为0后，会自动重置为创建CyclicBarrier对象时的初始值），还能够实现多个线程之间互相的计数等待。</p>
<p>构造CyclicBarrier时，除了可以传入计数器的初始值，还可以传入一个实现了Runnable接口的类对象（有两种构造器），当计数器值减为0时，会自动调用Runnale接口对象的run方法。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String task;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CyclicBarrier cyclicBarrier;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrierTask</span><span class="hljs-params">(String task, CyclicBarrier cyclicBarrier)</span> &#123;<br>        <span class="hljs-built_in">this</span>.task = task;<br>        <span class="hljs-built_in">this</span>.cyclicBarrier = cyclicBarrier;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//模拟了三个任务</span><br>        IntStream.rangeClosed(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>).forEach((i) -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;完成&quot;</span> + task + <span class="hljs-string">&quot;的操作；&quot;</span>);<br>                cyclicBarrier.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">cyclicBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>, () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;当前提交订单、扣减库存完成&quot;</span>);<br>        &#125;);<br>        <span class="hljs-comment">//提交订单和扣减库存的操作会互相等待</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrierTask</span>(<span class="hljs-string">&quot;提交订单&quot;</span>, cyclicBarrier)).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrierTask</span>(<span class="hljs-string">&quot;扣减库存&quot;</span>, cyclicBarrier)).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，模拟了三个任务，每个任务都分别包含提交订单、扣减库存两个操作。如果使用CyclicBarrier，则只需要创建一个CyclicBarrier对象，每个任务执行完毕后CyclicBarrier会自动重置计数器的值，继续执行下一个任务。</p>
<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p>Phaser的功能类似于CountDownLatch和CyclicBarrier的集合。</p>
<p>Phaser适用于将一个大任务拆分为多个小任务，拆分后的每个小任务都可以并发执行，且上一个大任务完成才可以执行下一个大任务。这种场景使用CountDownLatch和CyclicBarrier也能实现，但是使用Phaser会更灵活。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhaserDinner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Phaser</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onAdvance</span><span class="hljs-params">(<span class="hljs-type">int</span> phase, <span class="hljs-type">int</span> registeredParties)</span> &#123;<br>        <span class="hljs-comment">//return if this phaser should terminate</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (phase) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> -&gt; allArrive();<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span> -&gt; allOrderedMeal();<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> -&gt; allOrderedDrink();<br>            <span class="hljs-keyword">default</span> -&gt; <span class="hljs-literal">true</span>;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">allOrderedDrink</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;所有人都点完了饮料&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">allOrderedMeal</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;所有人都点完了菜&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">allArrive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;所有人都到齐了&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhaserTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Phaser phaser;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String meal;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String drink;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PhaserTask</span><span class="hljs-params">(String name, Phaser phaser, String meal, String drink)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.phaser = phaser;<br>        <span class="hljs-built_in">this</span>.meal = meal;<br>        <span class="hljs-built_in">this</span>.drink = drink;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//到达聚餐地点</span><br>        System.out.println(name + <span class="hljs-string">&quot;到达聚餐地点&quot;</span>);<br>        phaser.arriveAndAwaitAdvance(); <span class="hljs-comment">//等待其它线程到达</span><br>        <span class="hljs-comment">//点菜</span><br>        System.out.println(name + <span class="hljs-string">&quot;点了一份&quot;</span> + meal);<br>        phaser.arriveAndAwaitAdvance();<br>        <span class="hljs-comment">//点饮料</span><br>        System.out.println(name + <span class="hljs-string">&quot;点了一份&quot;</span> + drink);<br>        phaser.arriveAndAwaitAdvance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PhaserTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">PhaserDinner</span> <span class="hljs-variable">phaserDinner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhaserDinner</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PhaserTask</span>(<span class="hljs-string">&quot;Amy&quot;</span>, phaserDinner, <span class="hljs-string">&quot;hamburg&quot;</span>, <span class="hljs-string">&quot;cola&quot;</span>)).start();<br>        phaserDinner.register();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PhaserTask</span>(<span class="hljs-string">&quot;Sam&quot;</span>, phaserDinner, <span class="hljs-string">&quot;sandwich&quot;</span>, <span class="hljs-string">&quot;coffee&quot;</span>)).start();<br>        phaserDinner.register();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">Amy到达聚餐地点</span><br><span class="hljs-comment">Sam到达聚餐地点</span><br><span class="hljs-comment">所有人都到齐了</span><br><span class="hljs-comment">Amy点了一份hamburg</span><br><span class="hljs-comment">Sam点了一份sandwich</span><br><span class="hljs-comment">所有人都点完了菜</span><br><span class="hljs-comment">Sam点了一份coffee</span><br><span class="hljs-comment">Amy点了一份cola</span><br><span class="hljs-comment">所有人都点完了饮料</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，场景是等待所有人到达后点菜，所有人点完蔡后点饮料，要开启下一阶段（到达 -&gt; 点菜 -&gt; 点饮料），需要所有线程都完成上一阶段。PhaserTask类定义了整个阶段每个阶段的任务，阶段之间使用phaser.arriveAndAwaitAdvance()等待所有线程执行完之前的代码，PhaserDinner类是Phaser接口的实现类，覆盖了onAdvance方法，定义了每个阶段完成后执行的操作以及返回是否继续使用Phaser（Phaser是否继续生效）。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore可以限制同时访问某一资源的线程数量，相当于一个共享锁，允许多个线程同时拥有一定数量的信号量许可（permits）。</p>
<p>Semaphore提供了公平信号量与非公平信号量两种模式。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore semaphore;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SemaphoreTask</span><span class="hljs-params">(Semaphore semaphore)</span> &#123;<br>        <span class="hljs-built_in">this</span>.semaphore = semaphore;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            semaphore.acquire(); <span class="hljs-comment">//获取信号量许可</span><br>            <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取到许可，执行时间为 &quot;</span> + LocalTime.now().format(formatter));<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            semaphore.release(); <span class="hljs-comment">//释放许可</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SemaphoreTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">//创建了一个信号量许可数量为2的非公平的Semaphore对象</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">threadNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(threadNum);<br>        IntStream.range(<span class="hljs-number">0</span>, threadNum).forEach((i) -&gt; &#123;<br>            threadPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SemaphoreTask</span>(semaphore));<br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">pool-1-thread-2 获取到许可，执行时间为 10:40:52</span><br><span class="hljs-comment">pool-1-thread-4 获取到许可，执行时间为 10:40:52</span><br><span class="hljs-comment">pool-1-thread-6 获取到许可，执行时间为 10:40:54</span><br><span class="hljs-comment">pool-1-thread-1 获取到许可，执行时间为 10:40:54</span><br><span class="hljs-comment">pool-1-thread-3 获取到许可，执行时间为 10:40:56</span><br><span class="hljs-comment">pool-1-thread-5 获取到许可，执行时间为 10:40:56</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，创建了一个信号量许可数量为2的非公平的Semaphore对象，和一个线程数为6的线程池，线程执行的是SemaphoreTask类实现的run方法，run方法中有一个两秒钟的睡眠，从输出结果中可以看到，每两秒的时间内只有两个线程能够执行。</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger能够实现两个线程之间的数据交换。当一个线程调用了Exchanger对象的exchange方法，就会进入阻塞状态，直到另一个线程也调用了exchange方法后，两个线程会交换数据，然后继续执行。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerTask</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    Exchanger&lt;T&gt; exchanger;<br>    T object;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ExchangerTask</span><span class="hljs-params">(Exchanger&lt;T&gt; exchanger, T object)</span> &#123;<br>        <span class="hljs-built_in">this</span>.exchanger = exchanger;<br>        <span class="hljs-built_in">this</span>.object = object;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">getFromExchanger</span> <span class="hljs-operator">=</span> exchanger.exchange(object);<br>            <span class="hljs-type">DateTimeFormatter</span> <span class="hljs-variable">formatter</span> <span class="hljs-operator">=</span> DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;HH:mm:ss&quot;</span>);<br>            System.out.println(getFromExchanger.toString() + <span class="hljs-string">&quot;完成的时间为 &quot;</span> + LocalTime.now().format(formatter));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExchangerTask</span>&lt;&gt;(exchanger, <span class="hljs-string">&quot;付款&quot;</span>)).start(); <span class="hljs-comment">//先启动了付款线程</span><br>        Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">//在付款和交付之间加入时间间隙，以验证Exchanger的作用</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExchangerTask</span>&lt;&gt;(exchanger, <span class="hljs-string">&quot;交付&quot;</span>)).start(); <span class="hljs-comment">//两秒后启动交付线程</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">付款完成的时间为 11:54:54</span><br><span class="hljs-comment">交付完成的时间为 11:54:54</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在这个示例中，使用了两个线程模拟了商品付款的交付的过程，使用了Exchanger实现了线程间的等待和数据交换。虽然付款线程最先启动，两秒后才启动交付线程，但是由于Exchanger的exchange机制，实现了两个线程共同执行完exchange，交换完毕数据之后，才继续后续任务。</p>
<h1 id="锁工具类"><a href="#锁工具类" class="headerlink" title="锁工具类"></a>锁工具类</h1><p>锁工具类是用于实现线程同步和互斥访问的工具。它们提供了一种机制，允许线程对共享资源进行独占访问，以确保数据的一致性和正确性。</p>
<h2 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h2><p>Lock接口是Java从1.5版本开始提供的显示锁接口。位于java.util.concurrent.locks包下：</p>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230517172627640.png" alt="image-20230517172627640"></p>
<p>Lock接口在声明了以下方法：</p>
<ul>
<li><p><code>void lock()</code>：无条件地获取锁。如果锁不可用，则当前线程会被阻塞，直到获取到锁为止。</p>
</li>
<li><p><code>void lockInterruptibly() throws InterruptedException</code>：获取锁，但是允许响应中断。如果锁不可用，当前线程会进入阻塞状态，直到获取到锁或者当前线程被中断。</p>
</li>
<li><p><code>boolean tryLock()</code>：尝试获取锁，如果锁可用，则立即获取锁，并返回<code>true</code>。如果锁不可用，则立即返回<code>false</code>，而不会阻塞当前线程。</p>
</li>
<li><p><code>boolean tryLock(long time, TimeUnit unit) throws InterruptedException</code>：在给定的时间范围内尝试获取锁。如果在指定时间内获取到锁，则返回<code>true</code>，否则返回<code>false</code>。如果获取锁超时，当前线程可能会被阻塞，直到获取到锁或者超时时间到达。</p>
</li>
<li><p><code>void unlock()</code>：释放锁。必须在获取锁之后才能调用此方法，否则会抛出<code>IllegalMonitorStateException</code>异常。</p>
</li>
<li><p><code>Condition newCondition()</code>：获取与锁关联的条件对象。可以使用条件对象进行线程的等待和通知。</p>
</li>
</ul>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230517173037786.png" alt="image-20230517173037786"></p>
<p><strong>Lock锁（继承了Lock接口的锁工具类的统称）比synchronized锁更灵活</strong></p>
<ol>
<li>Lock锁中的ReadWriteLock可以实现读读不互斥。</li>
<li>Lock锁可以实现在没有获取到锁的情况下直接返回。</li>
<li>Lock锁支持超时机制。</li>
<li>Lock锁支持可中断。</li>
<li>Lock锁支持公平锁。</li>
</ol>
<p>Lock锁的使用方法是，首先创建一个Lock对象，调用加锁方法进行加锁，然后在try代码块中实现业务代码，在catch代码块中处理异常，最后在finally代码块中释放锁资源。</p>
<p><strong>lock.lock()是写在try里面还是外面</strong></p>
<p>在使用 <code>Lock</code> 的时候，通常建议将 <code>lock.lock();</code> 写在 <code>try</code> 块的外面，然后在 <code>finally</code> 块中释放锁。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// access shared resources</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样做的原因是，如果获取锁（<code>lock.lock()</code>）失败抛出了异常，那么在 <code>finally</code> 块中就无需（也不能）去释放这个锁。如果将 <code>lock.lock();</code> 如果写在 <code>try</code> 块内部，当获取锁抛出异常时，<code>finally</code> 块仍然会执行，这可能会导致尝试释放一个实际上并未被当前线程持有的锁，从而引发 <code>IllegalMonitorStateException</code>。</p>
<p>然而，需要注意的是，这种模式主要适用于 <code>lock.lock()</code> 不会抛出受检异常的情况。在 <code>Lock</code> 接口中，<code>lock()</code> 方法正是不会抛出受检异常的。但如果你使用的锁实现可能会在 <code>lock()</code> 方法中抛出受检异常，那么你可能需要将 <code>lock()</code> 调用放入 <code>try</code> 块中，并在 <code>catch</code> 块中适当地处理异常。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    Lock lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LockTask</span><span class="hljs-params">(Lock lock)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程获取到锁&quot;</span>);<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程执行任务&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程释放锁&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>).forEach((i) -&gt; &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LockTask</span>(lock)).start();<br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">Thread-0线程获取到锁</span><br><span class="hljs-comment">Thread-0线程执行任务</span><br><span class="hljs-comment">Thread-0线程释放锁</span><br><span class="hljs-comment">Thread-2线程获取到锁</span><br><span class="hljs-comment">Thread-2线程执行任务</span><br><span class="hljs-comment">Thread-2线程释放锁</span><br><span class="hljs-comment">Thread-4线程获取到锁</span><br><span class="hljs-comment">Thread-4线程执行任务</span><br><span class="hljs-comment">Thread-4线程释放锁</span><br><span class="hljs-comment">Thread-3线程获取到锁</span><br><span class="hljs-comment">Thread-3线程执行任务</span><br><span class="hljs-comment">Thread-3线程释放锁</span><br><span class="hljs-comment">Thread-1线程获取到锁</span><br><span class="hljs-comment">Thread-1线程执行任务</span><br><span class="hljs-comment">Thread-1线程释放锁</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，创建了一个Runnable的实现类LockTask，LockTask中使用了Lock锁，确保了run方法中打印的顺序是以线程为单位的，同一时刻只有一个线程能访问临界区资源，并完整地执行完获取锁和释放锁。</p>
<h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><p>使用Condition接口的wait、signal和signalAll方法结合Lock锁使用可以实现线程间的等待与通知（即线程间的通信）。这种功能类似使用Java的Object类提供的wait、notify和notifyAll方法结合synchronized实现对象的等待和通知，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Object类j提供的wait、notify和notifyAll方法结合且必须结合synchronized实现对象的等待和通知</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">synchronized</span>(obj) &#123;<br>        obj.wait();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNotify</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        obj.notify();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testNotifyAll</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (obj) &#123;<br>        obj.notifyAll();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在使用Condition接口时，不会直接创建Condition接口的对象，而是通过Lock接口的newCondition()方法创建。调用Lock锁对象的newCondition()方法就能够生成与当前Lock锁绑定的Condition对象，然后使用Condition对象就可以实现线程的等待与通知机制。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Lock lock;<br>    <span class="hljs-keyword">private</span> Condition condition;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConditionTask</span><span class="hljs-params">(Lock lock, Condition condition)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>        <span class="hljs-built_in">this</span>.condition = condition;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;线程进入等待&quot;</span>);<br>            condition.await();<br>            System.out.println(<span class="hljs-string">&quot;线程被唤醒&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionTask</span>(lock, condition)).start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-comment">//主线程获取锁</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;唤醒等待的线程&quot;</span>);<br>            condition.signal();<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;唤醒等待的线程结束&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">线程进入等待</span><br><span class="hljs-comment">唤醒等待的线程</span><br><span class="hljs-comment">唤醒等待的线程结束</span><br><span class="hljs-comment">线程被唤醒</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，创建了一个执行condition.await()进入等待状态的线程，使用主线程执行condition.signal()唤醒等待的线程，主线程释放锁后进入等待状态的线程成功地被唤醒。</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是Java提供的一种可重入锁，一个线程可以多次通过ReentrantLock的lock()方法获取锁，所以要完全释放锁，必须要调用相同次数的unlock()释放锁的方法。底层的实现是，每获取一次锁，计数器就会加1，当线程释放锁时，重入的计数就会减少1。只有当重入的计数变为0时，锁才会真正被释放。</p>
<p>ReentrantLock支持公平和非公平两种模式。底层是ReentrantLock通过内部的两个抽象类，FairSync和NonfairSync，实现的。FairSync和NonfairSync分别表示公平锁和非公平锁模式，两者都继承了Sync类，而Sync类继承了AQS，所以ReentrantLock是基于AQS实现的。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Lock lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLockTask</span><span class="hljs-params">(Lock lock)</span> &#123;<br>        <span class="hljs-built_in">this</span>.lock = lock;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        System.out.println(threadName + <span class="hljs-string">&quot;线程第一次加锁&quot;</span>);<br>        lock.lock();<br>        System.out.println(threadName + <span class="hljs-string">&quot;线程第二次加锁&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(threadName + <span class="hljs-string">&quot;线程使用临界区资源&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(threadName + <span class="hljs-string">&quot;线程第一次解锁&quot;</span>);<br>            lock.unlock();<br>            System.out.println(threadName + <span class="hljs-string">&quot;线程第二次解锁&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>).forEach((i) -&gt; &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLockTask</span>(lock)).start();<br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">Thread-0线程第一次加锁</span><br><span class="hljs-comment">Thread-0线程第二次加锁</span><br><span class="hljs-comment">Thread-0线程使用临界区资源</span><br><span class="hljs-comment">Thread-0线程第一次解锁</span><br><span class="hljs-comment">Thread-0线程第二次解锁</span><br><span class="hljs-comment">Thread-1线程第一次加锁</span><br><span class="hljs-comment">Thread-1线程第二次加锁</span><br><span class="hljs-comment">Thread-1线程使用临界区资源</span><br><span class="hljs-comment">Thread-1线程第一次解锁</span><br><span class="hljs-comment">Thread-1线程第二次解锁</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，在ReentrantLockTask的run方法中演示了ReentrantLock的锁重入的使用方法。</p>
<h2 id="ReadWriteLock接口"><a href="#ReadWriteLock接口" class="headerlink" title="ReadWriteLock接口"></a>ReadWriteLock接口</h2><p>ReadWriteLock是Java提供的一种读写锁，ReadWriteLock锁声明了两个方法，分别用于获取读锁和写锁。</p>
<p>读写锁：</p>
<ul>
<li>共享锁（读锁）：读共享</li>
<li>排他锁（写锁）：写互斥</li>
</ul>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock是从Java1.5开始提供的ReadWriteLock的实现类。使用ReentrantReadWriteLock对象可以获取读锁和写锁。</p>
<p>ReentrantReadWriteLock也支持公平锁和非公平锁，底层也是通过ReentrantReadWriteLock内部的两个抽象类两个抽象类FairSync和NonfairSync实现的，所以也是基于AQS实现的。</p>
<p>ReentrantReadWriteLock内部还定义了两个读写类，分别是ReadLock和WriteLock。</p>
<p>ReentrantReadWriteLock支持锁降级，即获取写锁的线程可以获取读锁，锁降级后锁的级别会从写锁降为读锁。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadWriteLockTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> readWriteLock.readLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> readWriteLock.writeLock();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        readLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程获取到读锁&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程释放读锁&quot;</span>);<br>            readLock.unlock();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        writeLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程获取到写锁&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">500</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程释放写锁&quot;</span>);<br>            writeLock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ReadWriteLockTest</span> <span class="hljs-variable">readWriteLockTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadWriteLockTest</span>();<br>        IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>).forEach((i) -&gt; &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(readWriteLockTest::read).start();<br>        &#125;);<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>).forEach((i) -&gt; &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(readWriteLockTest::write).start();<br>        &#125;);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">Thread-0线程获取到读锁</span><br><span class="hljs-comment">Thread-1线程获取到读锁</span><br><span class="hljs-comment">Thread-2线程获取到读锁</span><br><span class="hljs-comment">Thread-0线程释放读锁</span><br><span class="hljs-comment">Thread-1线程释放读锁</span><br><span class="hljs-comment">Thread-2线程释放读锁</span><br><span class="hljs-comment">Thread-3线程获取到写锁</span><br><span class="hljs-comment">Thread-3线程释放写锁</span><br><span class="hljs-comment">Thread-5线程获取到写锁</span><br><span class="hljs-comment">Thread-5线程释放写锁</span><br><span class="hljs-comment">Thread-4线程获取到写锁</span><br><span class="hljs-comment">Thread-4线程释放写锁</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，创建了一个ReentrantReadWriteLock类的对象，并由这个对象获取到读锁跟写锁，分别开启多个使用读锁的线程和使用写锁的线程，可以看到看到读锁同一时刻可以被多个线程获取，验证了ReentrantReadWriteLock的读锁是共享的，可以看到写锁同一时刻只能被一个线程获取，线程释放写锁后其它线程才有机会获取，验证了ReentrantReadWriteLock的写锁是互斥的。</p>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>StampedLock是从Java1.8开始提供的读写锁，支持读锁（悲观读）、写锁、乐观读（OptimisticRead）。只支持非公平锁。不支持重入。支持锁的升级和降级。</p>
<p>StampedLock在获取读锁和写锁成功后都会返回一个Long型的返回值，在释放锁时需要传入这个返回值。</p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1252599548343744/1309138673991714">StampedLock的乐观读</a>：乐观读不加锁，使用乐观读期间允许获取写锁并执行写入操作，在读取之前会获取数据的版本号，读取完成后，通过validate()方法去验证版本号，如果版本号不变，则说明在读取过程中没有发生数据修改，否则说明发生了数据修改，就需要将乐观读升级为悲观读。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StampedLockTest</span> &#123;<br>    <span class="hljs-comment">//共享变量（临界区资源）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//StampedLock锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">stampedLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.writeLock();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;写线程修改共享变量的值开始&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            count += <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stampedLock.unlockWrite(stamp);<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;写线程修改共享变量的值结束&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">optimisticRead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampedLock.tryOptimisticRead();<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;检测共享变量是否被修改（没有被修改为true，被修改为false）：&quot;</span> + stampedLock.validate(stamp));<br>        <span class="hljs-keyword">try</span> &#123;<br>            TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程休眠两秒后再次检测共享变量的值是否被修改（没有被修改为true，被修改为false）：&quot;</span> + stampedLock.validate(stamp));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> count;<br>        <span class="hljs-keyword">if</span> (!stampedLock.validate(stamp)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;共享变量的值被修改，说明乐观读期间也允许获取写锁&quot;</span>);<br>            <span class="hljs-comment">//将乐观锁升级为悲观锁</span><br>            stamp = stampedLock.readLock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程将乐观读升级为悲观读&quot;</span>);<br>                result = count;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程从乐观读升级为悲观读后的共享变量的值：&quot;</span> + result);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                stampedLock.unlockRead(stamp);<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;线程读取到的最终的共享变量的值：&quot;</span> + result);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">StampedLockTest</span> <span class="hljs-variable">stampedLockTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLockTest</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(stampedLockTest::optimisticRead).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;一秒后启动写线程&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(stampedLockTest::write).start();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">Thread-0检测共享变量是否被修改（没有被修改为true，被修改为false）：true</span><br><span class="hljs-comment">一秒后启动写线程</span><br><span class="hljs-comment">Thread-1写线程修改共享变量的值开始</span><br><span class="hljs-comment">Thread-1写线程修改共享变量的值结束</span><br><span class="hljs-comment">Thread-0线程休眠两秒后再次检测共享变量的值是否被修改（没有被修改为true，被修改为false）：false</span><br><span class="hljs-comment">共享变量的值被修改，说明乐观读期间也允许获取写锁</span><br><span class="hljs-comment">Thread-0线程将乐观读升级为悲观读</span><br><span class="hljs-comment">Thread-0线程从乐观读升级为悲观读后的共享变量的值：1</span><br><span class="hljs-comment">Thread-0线程读取到的最终的共享变量的值：1</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，使用validate方法检测变量是否被修改，首先启动了乐观读线程，一秒后启动写线程，启动写线程后虽然乐观读线程没有退出，但是再次读取时可以检测到变量值被改变，说明乐观读期间也允许获取写锁。使用乐观读时如果检测到变量值修改了，就需要将乐观读升级为悲观读。</p>
<h1 id="无锁原子类"><a href="#无锁原子类" class="headerlink" title="无锁原子类"></a>无锁原子类</h1><p>无锁原子类全部位于util.concurrent.atomic包下：</p>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230517170045229.png" alt="image-20230517170045229"></p>
<ul>
<li><p><strong>基本类型原子类</strong></p>
<p>包括：AtomicInteger、AtomicLong、AtomicBoolean。</p>
<p>基本类型的原子类只能操作Java的基本类型数据，并且只能更新单个基本类型的变量。</p>
</li>
<li><p><strong>引用类型原子类</strong></p>
<p>包括：AtomicReference、AtomicStampedReference、AtomicMarkableReference。</p>
<p>这些引用类型原子类都是使用了泛型。</p>
<p>如果要同时操作多个变量，或者更新一个对象的多个属性，就需要使用引用类型原子类。</p>
<p>其中，AtomicReference是最基础的引用类型原子类，AtomicStampedReference是带有stamp戳记的引用原子类，AtomicMarkableReference是带有mark标志的引用原子类。</p>
</li>
<li><p><strong>字段类型原子类</strong></p>
<p>包括：AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、AtomicReferenceFieldUpdater。</p>
<p>如果只是想更新对象中的某个字段，则可以使用Java中专门操作字段类型的原子类。</p>
<p>使用字段类型原子类时，需要先调用各自类的newUpdater()方法来指定要更新的类和字段名称，如果使用的是AtomicReferenceFieldUpdater还需要指定字段的类型。</p>
<p>使用操作字段类型的原子类更新某个类中的字段时，部分类型的变量下不能实现原子性地更新：</p>
<ol>
<li>类的静态变量</li>
<li>父类的成员变量</li>
<li>不能被直接访问类的成员变量</li>
<li>被final关键字修饰类的成员变量</li>
<li>没有使用volatile关键字修饰的类的成员变量</li>
</ol>
</li>
<li><p><strong>数组类型原子类</strong></p>
<p>包括：AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray。</p>
</li>
<li><p><strong>累加器类型原子类</strong></p>
<p>包括：DoubleAccumulator、DoubleAddr、LongAccumulator、LongAddr。</p>
<p><strong>优化原理</strong>：为减少大量线程竞争资源，进行CAS更新变量时大量失败的现象，Java1.8中提供了累加器类型原子类，通过将一个变量分解为多个变量，让多个线程竞争同一资源的情况转变为多个线程竞争多个资源，提升了性能。</p>
<p>XxxAccumulator的功能比XxxAddr多，表现在：</p>
<ol>
<li>XxxAccumulator的初始值可以自定义</li>
<li>XxxAccumulator的运算规则可以自定义</li>
</ol>
<p><strong>累加器类型原子类的变量更新机制</strong>：使用累加器类型原子类更新变量时会维护一个Cell类型的数组，每个Cell类型的元素内部会维护一个double类型或者long类型的变量，初始值为0，线程会竞争数组中多个Cell类型的元素（如果一个线程竞争某个元素失败，不会在该元素上进行CAS自旋，而是会尝试对其它元素进行CAS操作）。在获取累加器类型原子类的变量值时，会将Cell数组中的所有元素的value值进行累加，再加上base变量的值后得到结果并返回。</p>
<p>在Cell类的定义上有@jdk.internal.vm.annotation.Contended注解，解决伪共享问题，提高性能。</p>
<blockquote>
<p><code>@jdk.internal.vm.annotation.Contended</code> 是 Java 中的一个注解，它的作用是用于解决伪共享（False Sharing）的问题。</p>
<p>伪共享是指多个线程同时访问不同的变量，但这些变量位于同一缓存行中。由于缓存行是处理器缓存的最小单位，当一个线程修改了缓存行中的一个变量，该缓存行会被标记为”脏”，其他线程在访问同一缓存行中的其他变量时，需要将该缓存行从其他处理器的缓存中读取到自己的缓存中，这个过程称为”缓存行的失效”（Cache Line Invalidation）。这种失效操作会导致性能下降，尤其在多核处理器中更为明显。</p>
<p><code>@jdk.internal.vm.annotation.Contended</code> 注解的作用就是通过在变量之间添加填充（Padding）来解决伪共享的问题。填充是在变量之间插入一些无意义的字段，使得它们位于不同的缓存行中，从而避免了伪共享导致的性能下降。</p>
</blockquote>
</li>
</ul>
<h1 id="锁核心原理"><a href="#锁核心原理" class="headerlink" title="锁核心原理"></a>锁核心原理</h1><h2 id="隐式锁和显示锁"><a href="#隐式锁和显示锁" class="headerlink" title="隐式锁和显示锁"></a>隐式锁和显示锁</h2><p>synchronized是隐式锁，Lock等是显示锁</p>
<ol>
<li>当调用synchronized修饰的代码时，并不需要显示的加锁和解锁的过程，所以称之为隐式锁</li>
<li>而Lock锁都是手动写代码去获取锁和释放锁的，所以也叫显示锁</li>
</ol>
<h2 id="公平锁和非公平锁的原理"><a href="#公平锁和非公平锁的原理" class="headerlink" title="公平锁和非公平锁的原理"></a>公平锁和非公平锁的原理</h2><p>公平锁中的线程在抢占锁时首先会判断等待队列是否为空，如果队列为空或者当前线程是队列的队首元素，则当前线程获取到锁资源，否则会被放入队列尾部等待获取锁</p>
<p>非公平锁中的线程在抢占锁时会先直接尝试抢占锁，如果抢占成功就继续执行程序的业务逻辑，如果抢占失败，才会进入等待队列中等待</p>
<p>ReentrantLock支持公平锁和非公平锁，在使用时公平锁和非公平锁的用法一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建公平锁实例</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 创建公平锁</span><br><span class="hljs-comment">// Lock lock = new ReentrantLock(false); // 创建非公平锁</span><br><span class="hljs-comment">// Lock lock = new ReentrantLock(); // 创建非公平锁</span><br><span class="hljs-keyword">try</span> &#123;<br>	lock.lock();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="悲观锁和乐观锁的原理"><a href="#悲观锁和乐观锁的原理" class="headerlink" title="悲观锁和乐观锁的原理"></a>悲观锁和乐观锁的原理</h2><p>悲观锁的核心思想是对数据是否被修改持有悲观态度，认为其他线程会修改数据，所以在线程每次获取数据时都会加锁。</p>
<p>乐观锁的核心思想是对数据是否被修改持有乐观态度，认为其他线程不会修改数据，所以在线程每次获取数据时都不会加锁。乐观锁适合读多写少的场景。</p>
<p>synchronized锁就是悲观锁</p>
<p>java.util.concurrent.atomic包下的原子类就是乐观锁</p>
<p>AtomicInteger类的用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(); <span class="hljs-comment">//创建原子类</span><br>atomicInteger.incrementAndGet(); <span class="hljs-comment">//加1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> atomicInteger.get(); <span class="hljs-comment">// get值</span><br></code></pre></td></tr></table></figure>

<h2 id="可中断锁和不可中断锁的原理"><a href="#可中断锁和不可中断锁的原理" class="headerlink" title="可中断锁和不可中断锁的原理"></a>可中断锁和不可中断锁的原理</h2><p>可中断锁指在多个线程抢占的过程中可以被中断的锁。</p>
<p>不可中断锁指在多个线程抢占的过程中不可以被中断的锁。</p>
<p>ReentrantLock，就是可中断锁，ReentrantLock支持两种可中断锁的使用方式，lockInterruptibly()和tryLock(long timeout, TimeUnit unit)，如果当前线程在抢占锁的过程中被中断，就会抛出InterruptedException()用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	lock.lockInterruptibly();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException) &#123;<br>	<span class="hljs-comment">// 抢占锁被中断</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>synchronized锁是不可中断锁，只能在抢占锁成功后被中断，不能在抢占锁的过程中被中断。</p>
<h2 id="独占锁和共享锁的原理"><a href="#独占锁和共享锁的原理" class="headerlink" title="独占锁和共享锁的原理"></a>独占锁和共享锁的原理</h2><p>按照加锁后的资源能否在被多个线程访问，可以将锁分为独占锁和共享锁</p>
<p>线程获取到独占锁后，其他线程如果想要获取该锁，只能等待。</p>
<p>线程获取到共享锁后，其他线程也可以获取到该锁，但是共享锁只允许对临界区的数据进行读取操作，不允许修改。也就是说，共享锁是针对读操作的锁。</p>
<p>synchronized锁、ReentrantLock锁、ReentrantReadWriteLock的写锁都是独占锁。</p>
<p>ReentrantReadWriteLock的读锁、Semaphore类、CountDownLatch类都是共享锁。</p>
<h2 id="LockSupport原理"><a href="#LockSupport原理" class="headerlink" title="LockSupport原理"></a>LockSupport原理</h2><p>LockSupport位于<code>java.util.concurrent.locks</code>包，是Java提供的创建锁和其他多线程工具的基础类库，主要作用就是阻塞和唤醒线程，底层是基于UnSafe类实现的。AQS 底层就是使用了<code>LockSupport</code>来实现线程的阻塞和唤醒。</p>
<p>LockSupport类提供的核心方法：</p>
<img src="./Java并发编程/image-20230518115147049.png" alt="image-20230518115147049" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>public static void park()</td>
<td>阻塞当前线程</td>
</tr>
<tr>
<td>public static void park(Object blocker)</td>
<td>使用指定的 blocker（锁对象）阻塞当前线程</td>
</tr>
<tr>
<td>public static void parkNanos(long nanos)</td>
<td>阻塞当前线程，并指定了最长阻塞的时间，单位是纳秒</td>
</tr>
<tr>
<td>public static void parkUntil(long deadline)</td>
<td>阻塞当前线程，并指定了deadline时间点</td>
</tr>
<tr>
<td>public static void parkNanos(Object blocker, long nanos)</td>
<td>阻塞当前线程，并指定了使用的 blocker（锁对象）、最长阻塞的时间，单位是纳秒</td>
</tr>
<tr>
<td>public static void parkUntil(Object blocker, long deadline)</td>
<td>阻塞当前线程，并指定了使用的 blocker（锁对象）、deadline时间点</td>
</tr>
<tr>
<td>public static void unpark(Thread thread)</td>
<td>解除指定已被park的线程的阻塞状态；如果线程已经启动但还未park，就取消下一次的park。</td>
</tr>
</tbody></table>
<p>在底层实现上，<code>LockSupport</code>使用了一种名为”许可（Permit）”的概念来控制阻塞和唤醒。Permit的数量最多为1。</p>
<p>如果线程已经拿到了Permit，则调用<code>LockSupport.park()</code>会立即返回；如果没有拿到Permit，<code>park()</code>方法会阻塞线程。调用<code>LockSupport.unpark(Thread)</code>方法会给指定的线程发放Permit。</p>
<p>unpark()可以先于park()调用：如果 <code>unpark(thread)</code> 在 <code>park()</code> 之前被调用，那么线程会获得一个Permit，当后续 <code>park()</code> 被调用时，线程可以立即消费掉这个Permit并继续执行，而不会阻塞。</p>
<p>如果调用者的线程被中断，park 将返回。</p>
<p>下面是一个简单的<code>LockSupport</code>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Child thread begin park!&quot;</span>);<br><br>            <span class="hljs-comment">// 调用park方法，挂起自己</span><br>            LockSupport.park();<br><br>            System.out.println(<span class="hljs-string">&quot;Child thread end park!&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br><br>        <span class="hljs-comment">// 主线程延迟2s</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Main thread begin unpark!&quot;</span>);<br><br>        <span class="hljs-comment">// 调用unpark方法让thread线程持有许可证，然后park方法返回</span><br>        LockSupport.unpark(thread);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，子线程通过调用<code>LockSupport.park()</code>方法阻塞自己，主线程在延迟2秒后调用<code>LockSupport.unpark(thread)</code>方法唤醒子线程。</p>
<h1 id="锁优化方案"><a href="#锁优化方案" class="headerlink" title="锁优化方案"></a>锁优化方案</h1><h2 id="减小锁的范围"><a href="#减小锁的范围" class="headerlink" title="减小锁的范围"></a>减小锁的范围</h2><p>缩小锁的范围就是缩短持有锁的时间，减轻阻塞。</p>
<p>最简单的做法是将一些不会产生线程安全问题的代码移到同步代码块之外，比如把不会产生线程安全问题的I&#x2F;O类耗时的操作，放在同步代码块之外。</p>
<h2 id="减小锁的粒度"><a href="#减小锁的粒度" class="headerlink" title="减小锁的粒度"></a>减小锁的粒度</h2><p>减小锁的粒度就是缩小锁定对象的范围，就能够减少锁的竞争。</p>
<p>做法是把对大对象的加锁转换为对小对象的加锁，比如一个类中的多个方法都是对this加锁，按照减小锁粒度的思路就可以转换为只对每个方法中用到的临界区对象加锁。</p>
<h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h2><p>锁分离就是把锁拆分为读锁和写锁，规则是读读不互斥、读写和写写互斥</p>
<p>锁分离最典型的应用是ReadWriteLock（读&#x2F;写锁）</p>
<h2 id="锁分段"><a href="#锁分段" class="headerlink" title="锁分段"></a>锁分段</h2><p>锁分段就是对一组对象上的锁进行分解，以减小锁的粒度。</p>
<p>锁分段的典型应用是ConcurrentHashMap，ConcurrentHashMap将数据按照不同的数据段进行存储（使用了一个包含16个锁的数组），并为每一个数据段分配一把锁（第N个数据交给第N%16把锁保护）。</p>
<h2 id="避免热点区域"><a href="#避免热点区域" class="headerlink" title="避免热点区域"></a>避免热点区域</h2><p>避免热点区域是对热点区域（经常被访问的临界区）进行优化。</p>
<p>避免热点区域典型的应用是ConcurrentHashMap的size，ConcurrentHashMap会给每个数据段分别维护size，而不是共用一个size，这些size由所在数据段的锁来维护，减小了size改变的竞争频率，要统计size长度时，会累加数据段的size。</p>
<h2 id="使用独占锁的替换方案"><a href="#使用独占锁的替换方案" class="headerlink" title="使用独占锁的替换方案"></a>使用独占锁的替换方案</h2><p>要保证线程安全，还可以根据需要使用下面的方案替换独占锁：</p>
<ol>
<li>并发容器</li>
<li>读&#x2F;写锁</li>
<li>乐观锁（如使用了CAS操作的原子类）</li>
<li>final关键字修饰的不可变对象（final修饰的的变量是不可变的，不存在线程安全问题）</li>
</ol>
<h2 id="JVM自带的锁优化"><a href="#JVM自带的锁优化" class="headerlink" title="JVM自带的锁优化"></a>JVM自带的锁优化</h2><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除的前提的JVM开启了逃逸分析，如果JVM通过逃逸分析发现对象只能被一个线程访问到，就可以不对这个对象加锁。即便程序中使用了同步锁，JVM也会将锁消除。</p>
<p>JVM参数：</p>
<ol>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>开启同步锁消除：-XX:+EliminateLocks</li>
</ol>
<p>如下代码，尽管StringBuffer的append()是被synchronized修饰的，但是不存在线程竞争，JVM会进行锁消除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//append()是被synchronized修饰的</span><br>    sb.append(<span class="hljs-string">&quot;2&quot;</span>);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>由于锁的竞争和释放开销比较大，如果代码中对锁进行了频繁的竞争和释放，那么JVM会进行优化，将锁的范围适当扩大。</p>
<p>如下代码，在循环内使用synchronized，JVM锁粗化后，会将锁范围扩大到循环外。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>粗化后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>      		...      <br>    	&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然JVM内部会进行优化，但是最好还是在代码里就优化了。</p>
<h1 id="分布式锁架构"><a href="#分布式锁架构" class="headerlink" title="分布式锁架构"></a>分布式锁架构</h1><h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h2><p>超卖问题的意思是系统售出的商品数量超出库存量，产生原因是多个线程同时拿到了同一商品的相同库存量，对同一商品的相同库存量进行了多次扣减。</p>
<p>下面给出模拟超卖问题的示例。</p>
<ol>
<li>使用SpringBoot和Redis搭建的会产生超卖问题的程序：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order/v1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverSoldV1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRODUCT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">STOCK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(String.valueOf(OverSold.class));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverSold</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>        stringRedisTemplate.opsForValue().set(PRODUCT_ID, STOCK_COUNT);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/submitOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submitOrder</span><span class="hljs-params">()</span> &#123;<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">stockString</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(PRODUCT_ID);<br>        <span class="hljs-keyword">if</span> (stockString == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(stockString.trim())) &#123;<br>            logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> Integer.parseInt(stockString);<br>        <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>            stock -= <span class="hljs-number">1</span>;<br>            stringRedisTemplate.opsForValue().set(PRODUCT_ID, String.valueOf(stock));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;库存扣减成功，当前库存为：&quot;</span> + stock;<br>            logger.info(info);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p>使用JMeter对接口进行并发测试，设置线程数为5，Ramp-up period是0，即5个线程会同时访问</p>
</li>
<li><p>运行JMeter测试任务，得到输出结果，可以看到存在对同一商品的相同库存进行了多次扣减的问题，即超卖问题。</p>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521092117804.png" alt="image-20230521092117804"></p>
</li>
</ol>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="分布式锁的实现方式"><a href="#分布式锁的实现方式" class="headerlink" title="分布式锁的实现方式"></a>分布式锁的实现方式</h3><p>Java提供的锁机制都是JVM级别的，只在JVM进程内部有效。但是不能解决分布式场景下的高并发问题，要解决分布式环境下的高并发问题，需要使用分布式锁。</p>
<p>实现分布式锁可以参照JVM锁的实现方式，JVM中多个线程在访问临界区资源时，会到统一的地方检查程序的临界区是否已经加锁，JVM在统一的地方使用加锁状态来标记是否进行了加锁操作，这个统一的地方可以是保存加锁状态的服务。</p>
<p>分布式锁的实现方法和JVM锁的实现方法类似，只是在实现JVM锁时，是将锁的状态保存在Java对象头中，而实现分布式锁时，是将锁的状态保存在一个外部服务中，这个外部服务可以使用数据库（如MySQL）、Redis、Zookeeper等数据存储服务实现。</p>
<p>具体实现方式：</p>
<ol>
<li><p>基于数据库的锁：这种方式通常是在数据库中创建一张锁表，需要获取锁的时候在这张表中插入一条记录，释放锁的时候则删除这条记录。这种方式实现简单，但是性能可能会受到影响。</p>
</li>
<li><p>基于Redis的锁：Redis提供了一些原子性的操作，比如<code>SETNX</code>，set if not exist， 可以利用这些特性来实现分布式锁。<code>SETNX</code>命令可以在键不存在的情况下设置键值对，如果键已经存在，则不做任何操作。这种方式性能较好，但是需要处理好锁的超时和续期问题。</p>
</li>
<li><p>基于Zookeeper的锁：Zookeeper提供了一种叫做顺序临时节点的机制，可以利用这个机制来实现分布式锁。要获取锁的线程创建一个临时节点，如果这个节点是所有节点中序号最小的，那么就认为这个线程获取了锁。这种方式性能较差，但是更加可靠，适合对一致性要求更高的场景。</p>
</li>
</ol>
<h3 id="分布式锁的基本要求"><a href="#分布式锁的基本要求" class="headerlink" title="分布式锁的基本要求"></a>分布式锁的基本要求</h3><p>要实现一个分布式锁，需要满足以下要求：</p>
<ol>
<li>支持互斥性：支持多个线程操作同一共享变量的互斥性。</li>
<li>支持阻塞与非阻塞：当线程获取分布式锁失败，分布式锁能够支持当前线程是阻塞或者非阻塞的特性。</li>
<li>支持可重入性：分布式锁能够支持同一线程同时多次获取同一个分布式锁的特性。</li>
<li>支持锁超时：为避免获取到分布式锁的线程意外退出，进而无法正常释放锁，导致其它线程无法正常获取到锁的情况，分布式锁需要支持超时机制，若加锁时长超过一定时间，锁就会自动释放。</li>
</ol>
<h3 id="CAP理论与分布式锁模型"><a href="#CAP理论与分布式锁模型" class="headerlink" title="CAP理论与分布式锁模型"></a>CAP理论与分布式锁模型</h3><p>CAP理论是分布式领域非常著名的理论，CAP理论由C、A、P三部分组成，每个字母的含义如下：</p>
<ol>
<li>C（Consistency）：一致性，表示在分布式环境下，所有节点在任意时刻都具有相同的数据。</li>
<li>A（Availability）：可用性，表示在分布式环境下，每个请求都能得到响应，但是不能保证能够获取到最新的数据。</li>
<li>P（Partition Tolerance）：分区容错性，表示在分布式环境下，当系统中的某个分区发生故障或通信中断时，其他分区可以继续运行，保持整个系统的正常工作。</li>
</ol>
<p>同时，CAP理论指出，在分布式环境下，不可能同时保证一致性、可用性和分区容错性，最多只能保证其中的两个特性。</p>
<p>在分布式系统中，必须保证分区容错性。</p>
<p>基于CAP理论可以进行分布式锁模型的设计，例如：</p>
<ol>
<li><p>基于Redis的AP架构模型</p>
<p>Redis先返回请求结果，再以异步的方式同步数据</p>
</li>
<li><p>基于Zookeeper的CP架构模型</p>
<p>当数据在大多数Zookeeper节点间同步完成后，才返回请求结果</p>
</li>
</ol>
<h3 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h3><p>在超卖问题的示例代码的基础上，进行优化得到可以确保如下条件的分布式锁：</p>
<ol>
<li><p>不会出现超卖</p>
<p>使用Redis的SETNX命令，该命令的返回结果是：</p>
<ul>
<li>1：Redis中不存在当前key，设置键值对成功</li>
<li>0：Redis中存在当前key，设置键值对失败</li>
</ul>
<p>使用该命令对应的函数存储当前获取锁的线程id，以是否返回1作为是否获取到锁的判断条件，可以确保每次只有一个线程获取到锁</p>
<p>同时为了保证可重入性，在每次获取锁之前先判断是否是自己持有的锁</p>
</li>
<li><p>不会因为线程异常退出导致锁无法释放</p>
<p>解决方法是</p>
<ol>
<li>引入try finally块</li>
<li>引入超时机制，为避免获取到锁之后没有执行设置超时机制，需要和SETNX命令共同以原子化的方式使用</li>
</ol>
</li>
</ol>
<p>修改后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order/v2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverSoldV2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRODUCT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">THREAD_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;THREAD_ID&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">STOCK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(String.valueOf(OverSoldV2.class));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverSoldV2</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>        stringRedisTemplate.opsForValue().set(PRODUCT_ID, STOCK_COUNT);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/submitOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submitOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> String.valueOf(Thread.currentThread().getId());<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLocked</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(THREAD_ID, threadId, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(isLocked)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;failure&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">stockString</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(PRODUCT_ID);<br>            <span class="hljs-keyword">if</span> (stockString == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(stockString.trim())) &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> Integer.parseInt(stockString);<br>            <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>                stock -= <span class="hljs-number">1</span>;<br>                stringRedisTemplate.opsForValue().set(PRODUCT_ID, String.valueOf(stock));<br>                <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;库存扣减成功，当前库存为：&quot;</span> + stock;<br>                logger.info(info);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stringRedisTemplate.delete(THREAD_ID);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行JMeter测试任务，得到输出结果，可以看到不再发生对库存重复扣减，超卖问题被解决。</p>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521143353323.png" alt="image-20230521143353323"></p>
<p>虽然超卖问题已经解决，但是每次获取锁失败就直接返回，没有实现锁的阻塞性，要实现锁的阻塞性，一种简单的实现方式是使用自旋：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order/v3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverSoldV3</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRODUCT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">THREAD_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;THREAD_ID&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">STOCK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(String.valueOf(OverSoldV3.class));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverSoldV3</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>        stringRedisTemplate.opsForValue().set(PRODUCT_ID, STOCK_COUNT);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/submitOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submitOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> String.valueOf(Thread.currentThread().getId());<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLocked</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(THREAD_ID, threadId, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(isLocked)) &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                isLocked = stringRedisTemplate.opsForValue().setIfAbsent(THREAD_ID, threadId, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>            &#125; <span class="hljs-keyword">while</span> (Boolean.FALSE.equals(isLocked));<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">stockString</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(PRODUCT_ID);<br>            <span class="hljs-keyword">if</span> (stockString == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(stockString.trim())) &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> Integer.parseInt(stockString);<br>            <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>                stock -= <span class="hljs-number">1</span>;<br>                stringRedisTemplate.opsForValue().set(PRODUCT_ID, String.valueOf(stock));<br>                <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;库存扣减成功，当前库存为：&quot;</span> + stock;<br>                logger.info(info);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stringRedisTemplate.delete(THREAD_ID);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用阻塞等待后，调整JMeter的请求数等于商品数（100），如果恰好消费完，说明锁的阻塞等待是有效的。</p>
<p>JMeter的线程参数配置如下图，开启了5个线程，每个线程循环20次，请求次数总共100次：</p>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521144244517.png" alt="image-20230521144244517"></p>
<p>运行JMeter测试任务，输出结果显示如下图：</p>
<p><img src="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/.././Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521144440514.png" alt="image-20230521144440514"></p>
<p>输出结果显示，确实是恰好消费完，说明锁的阻塞等待是有效的。</p>
<h1 id="分工问题的实现方式"><a href="#分工问题的实现方式" class="headerlink" title="分工问题的实现方式"></a>分工问题的实现方式</h1><p>Guarded Suspension模式</p>
<p>Thread-Pre-Message模式</p>
<p>生产者-消费者模式</p>
<p>两阶段终止模式</p>
<p>Worker-Thread模式</p>
<p>Balking模式</p>
<h1 id="ParallelStream"><a href="#ParallelStream" class="headerlink" title="ParallelStream"></a>ParallelStream</h1><p>ParallelStream 是 JDK 8 中新增的流式 API，它继承自 Java.util.stream.Stream 接口，并提供了并行流（Parallel Stream）处理能力。</p>
<p>与普通流不同的是，ParallelStream 可以利用多个线程（默认情况下是 ForkJoinPool 中的线程）来并行执行部分或全部流处理操作，以加速大容量数据的处理和分析。在并行流执行流处理操作时，它会将数据划分成多个小块，并分别交给不同的线程进行处理，在处理完成后再将结果合并返回。</p>
<p>ParallelStream 支持大部分 Stream 的 API 操作，例如 filter、map、reduce、sorted 等，只需要调用 parallel() 方法即可将一个普通流转换为并行流。需要注意的是，由于并行流涉及到多线程的协作，因此在使用 ParallelStream 时需要考虑线程安全和共享变量等问题，避免出现并发问题和数据异常。</p>
<p>以下是一个 ParallelStream 的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;scala&quot;</span>, <span class="hljs-string">&quot;ruby&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list.parallelStream().filter(str -&gt; str.length() &gt; <span class="hljs-number">4</span>).count();<br>System.out.println(count);<br></code></pre></td></tr></table></figure>

<p>以上代码演示了如何使用 ParallelStream 统计字符串列表中长度大于 4 的字符串数量。由于 ParallelStream 默认使用 ForkJoinPool 的线程池来执行并行计算，因此可以实现更高效的数据统计和分析。</p>
<h1 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JMH是一款由JVM团队开发的、专门对代码进行基准测试的工具类。</p>
<blockquote>
<p>备注：</p>
<p>基准测试（Benchmark）是一种评估程序性能的方法。通过设计和实现一组具有代表性的测试用例，来测量程序在给定硬件、操作系统和运行环境下的性能指标，如执行时间、内存占用、CPU 占用率等。</p>
<p>基准测试可以帮助开发人员发现和改正代码中的性能问题，以及比较不同程序或算法之间的性能差异。它也可以为程序优化提供指导，并且对于不同平台或环境下的性能比较也具有参考价值。</p>
</blockquote>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ol>
<li>导入依赖：使用JMH需要在项目中添加jmh-core和jmh-generator-annprocess依赖。</li>
<li>创建测试类，在测试类上添加注解@BenchmarkMode、@Warmup、@Measurement、@Threads 等。</li>
<li>在上一步创建的测试类中编写测试方法，在测试方法上添加注解@Benchmark。</li>
<li>运行测试方法，测试结果会以表格形式展示出来。</li>
</ol>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@Warmup(iterations = 3, time = 1)</span><br><span class="hljs-meta">@Measurement(iterations = 5, time = 1)</span><br><span class="hljs-meta">@Threads(8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBenchmark</span> &#123;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 测试代码</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为 <code>MyBenchmark</code> 的基准测试类，其中：</p>
<ul>
<li><code>@BenchmarkMode</code> 注解指定了测试模式为平均执行时间。</li>
<li><code>@Warmup</code> 注解指定了预热次数为 3 次，每次预热时间为 1 秒钟。</li>
<li><code>@Measurement</code> 注解指定了测试次数为 5 次，每次测试时间也为 1 秒钟。</li>
<li><code>@Threads</code> 注解指定了线程数量为 8。</li>
</ul>
<p>在方法上，我们使用 <code>@Benchmark</code> 注解来标注需要测试的方法，然后在测试代码中编写需要测试的逻辑。</p>
<h2 id="使用JMH进行吞吐量测试示例"><a href="#使用JMH进行吞吐量测试示例" class="headerlink" title="使用JMH进行吞吐量测试示例"></a>使用JMH进行吞吐量测试示例</h2><p>吞吐量（Throughput）指的是在一定时间内能够处理的事务或请求数量，通常用单位时间内完成的请求数量来衡量系统&#x2F;程序的性能。</p>
<p>JMH 的 Throughput 测试模式用于测试程序的吞吐量，即在给定时间段内程序能够处理的请求总数。</p>
<p>下面是一个简单的 JMH 吞吐量测试示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><br><span class="hljs-meta">@BenchmarkMode(Mode.Throughput)</span><br><span class="hljs-meta">@Warmup(iterations = 3, time = 1)</span><br><span class="hljs-meta">@Measurement(iterations = 5, time = 1)</span><br><span class="hljs-meta">@Threads(8)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBenchmark</span> &#123;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 测试代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了 <code>@BenchmarkMode</code> 注解来指定测试模式为 <code>Mode.Throughput</code>，表示通过统计每单位时间内执行的操作次数来评估程序性能。同时，我们仍然需要设置预热次数、测试次数和线程数量等参数，以确保测试结果的准确性。</p>
<h2 id="使用JMH进行QPS-x2F-TPS测试示例"><a href="#使用JMH进行QPS-x2F-TPS测试示例" class="headerlink" title="使用JMH进行QPS&#x2F;TPS测试示例"></a>使用JMH进行QPS&#x2F;TPS测试示例</h2><p>QPS（Queries Per Second）和 TPS（Transactions Per Second）都是指每秒钟能够处理的请求数或事务数量，是评估系统性能的重要指标。</p>
<p>JMH 中没有直接提供 QPS&#x2F;TPS 模式的测试，但通过计算每秒钟能够完成的迭代次数，我们也可以得出相应的指标。</p>
<p>下面是一个简单的 JMH QPS&#x2F;TPS 测试示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><br><span class="hljs-meta">@BenchmarkMode(Mode.Throughput)</span><br><span class="hljs-meta">@Warmup(iterations = 3, time = 1)</span><br><span class="hljs-meta">@Measurement(iterations = 5, time = 1)</span><br><span class="hljs-meta">@Threads(8)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.SECONDS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBenchmark</span> &#123;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 测试代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们同样使用了 <code>@BenchmarkMode</code> 注解来指定测试模式为 <code>Mode.Throughput</code>，并且设置了预热次数、测试次数和线程数量等参数。除此之外，我们还添加了 <code>@OutputTimeUnit</code> 注解来指定输出结果的时间单位为秒。</p>
<p>通过运行测试，并根据测试代码实际执行的操作计算得出每秒钟能够完成的操作次数，即可得到测试的 QPS&#x2F;TPS 值。最终的测试结果会以表格形式展示出来，包括平均值、方差、标准误差和置信区间等统计数据。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>冰河. 深入理解高并发编程: JDK核心技术. 北京: 电子工业出版社, 2022.6.</li>
<li>冰河. 深入理解高并发编程: 核心原理与案例实战. 北京: 电子工业出版社, 2023.2.</li>
<li>尼恩等. Java高并发核心编程:加强版. 卷2, 多线陈、锁、JMM、JUC、高并发设计模式. 北京: 清华大学出版社, 2022.10.</li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=2&vd_source=e229b568d11ab1ec4d7f50fb619a17b6">https://www.bilibili.com/video/BV1xK4y1C7aT?p=2&amp;vd_source=e229b568d11ab1ec4d7f50fb619a17b6</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html">https://docs.oracle.com/javase/8/docs/api/java/util/Queue.html</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io">Song Baoru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><div class="post_share"><div class="social-share" data-image="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&amp;riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&amp;ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img class="cover" src="https://th.bing.com/th/id/OIP.fekfR1FWtn_EXSMaueufagHaEK?pid=ImgDet&amp;rs=1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">Spring Cloud</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src="https://th.bing.com/th/id/R.826fae185d03cd7935cc5haf1cd1844c3?rik=9ONAxF3s06zoPg&amp;riu=http%3a%2f%2fpic5.bbzhi.com%2ffengjingbizhi%2fgaoqingziranfengjingbizhi%2fgaoqingziranfengjingbizhi_415690_15.jpg&amp;ehk=BbD3V6XWzCc5AJ7yXlMt4j5AU09Nk56syRdeDXFSvYY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">计算机网络</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Song Baoru</div><div class="author-info__description">锲而不舍，金石可镂</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SongBaoru"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">线程工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Thread%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">Thread类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">线程局部变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal"><span class="toc-number">1.2.1.</span> <span class="toc-text">ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InheritableThreadLocal"><span class="toc-number">1.2.2.</span> <span class="toc-text">InheritableThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-x2F-Join%E6%A1%86%E6%9E%B6"><span class="toc-number">1.3.</span> <span class="toc-text">Fork&#x2F;Join框架</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.</span> <span class="toc-text">线程池工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Executor%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.</span> <span class="toc-text">Executor接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Executor"><span class="toc-number">2.2.</span> <span class="toc-text">Executor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">2.3.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ExecutorService%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.4.</span> <span class="toc-text">ExecutorService接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AbstractExecutorService%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.5.</span> <span class="toc-text">AbstractExecutorService抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ScheduleExecutorService%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.6.</span> <span class="toc-text">ScheduleExecutorService接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">线程的创建方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.2.</span> <span class="toc-text">操作系统线程生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.3.</span> <span class="toc-text">Java线程的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">线程调度模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">线程方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.</span> <span class="toc-text">线程结束的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">3.7.</span> <span class="toc-text">上下文切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">3.8.</span> <span class="toc-text">线程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.9.</span> <span class="toc-text">用户线程和守护线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.1.</span> <span class="toc-text">线程池的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text">线程池的创建方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">线程池执行任务的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5"><span class="toc-number">4.4.</span> <span class="toc-text">线程池的拒绝策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%B3%E9%97%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">线程池的关闭方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E7%BA%BF%E7%A8%8B%E6%95%B0"><span class="toc-number">4.6.</span> <span class="toc-text">最佳线程数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#XXX%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">XXX程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.1.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%EF%BC%88%E7%BA%A4%E7%A8%8B%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">协程（纤程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">超线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">6.</span> <span class="toc-text">并发编程相关的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">6.1.</span> <span class="toc-text">临界区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">6.2.</span> <span class="toc-text">操作系统的互斥量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E3%80%81%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">6.3.</span> <span class="toc-text">用户态、内核态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">6.4.</span> <span class="toc-text">同步和异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E3%80%81%E9%A5%A5%E9%A5%BF%E3%80%81%E6%B4%BB%E9%94%81"><span class="toc-number">6.5.</span> <span class="toc-text">死锁、饥饿、活锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">6.6.</span> <span class="toc-text">死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A2%E6%88%90%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.6.1.</span> <span class="toc-text">形成死锁的必要条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2"><span class="toc-number">6.6.2.</span> <span class="toc-text">死锁的预防</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">6.7.</span> <span class="toc-text">自旋锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">7.</span> <span class="toc-text">原子性、可见性、有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">原子性核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E9%94%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">7.1.1.</span> <span class="toc-text">总线锁保证原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">7.1.2.</span> <span class="toc-text">互斥锁保证原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">7.1.3.</span> <span class="toc-text">CAS保证原子性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C%E6%9C%89%E5%BA%8F%E6%80%A7%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.</span> <span class="toc-text">可见性和有序性核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">7.2.1.</span> <span class="toc-text">缓存一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MESI%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.2.2.</span> <span class="toc-text">MESI协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.3.</span> <span class="toc-text">volatile核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8F%AF%E8%A7%81%E6%80%A7%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.3.1.</span> <span class="toc-text">保证可见性的核心原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%9C%89%E5%BA%8F%E6%80%A7%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">7.2.3.2.</span> <span class="toc-text">保证有序性的核心原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DCL%E5%8D%95%E4%BE%8B"><span class="toc-number">7.2.3.3.</span> <span class="toc-text">DCL单例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.2.4.</span> <span class="toc-text">Java内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JMM%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">7.2.4.1.</span> <span class="toc-text">JMM的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Happens-Before%E5%8E%9F%E5%88%99"><span class="toc-number">7.2.4.2.</span> <span class="toc-text">Happens-Before原则</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#synchronized"><span class="toc-number">8.</span> <span class="toc-text">synchronized</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E7%94%A8%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text">synchronized用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">8.2.</span> <span class="toc-text">Java对象结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JOL%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84"><span class="toc-number">8.3.</span> <span class="toc-text">使用JOL查看对象结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.4.</span> <span class="toc-text">synchronized底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monitor%E9%94%81%E5%8E%9F%E7%90%86"><span class="toc-number">8.5.</span> <span class="toc-text">Monitor锁原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">8.6.</span> <span class="toc-text">锁升级的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-number">8.7.</span> <span class="toc-text">锁降级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AQS%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">9.</span> <span class="toc-text">AQS核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8E%9F%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">AQS数据结构原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS%E5%BA%95%E5%B1%82%E5%AF%B9%E9%94%81%E7%9A%84%E6%94%AF%E6%8C%81"><span class="toc-number">9.2.</span> <span class="toc-text">AQS底层对锁的支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">9.3.</span> <span class="toc-text">独占锁和共享锁的实现流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#CAS%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">CAS核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">10.1.</span> <span class="toc-text">CAS的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CAS%E7%9A%84%E6%A0%B8%E5%BF%83%E7%B1%BBUnsafe"><span class="toc-number">10.2.</span> <span class="toc-text">CAS的核心类Unsafe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ABA%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">10.3.</span> <span class="toc-text">ABA问题的解决方案</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%9B%86%E5%90%88"><span class="toc-number">11.</span> <span class="toc-text">同步集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vector"><span class="toc-number">11.1.</span> <span class="toc-text">Vector</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stack"><span class="toc-number">11.2.</span> <span class="toc-text">Stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hashtable"><span class="toc-number">11.3.</span> <span class="toc-text">Hashtable</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">11.4.</span> <span class="toc-text">同步包装器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%9B%86%E5%90%88%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">11.5.</span> <span class="toc-text">同步集合的缺陷</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88"><span class="toc-number">12.</span> <span class="toc-text">并发集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91List%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">12.1.</span> <span class="toc-text">并发List集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">12.1.1.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91Set%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">并发Set集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CopyOnWriteArraySet"><span class="toc-number">12.2.1.</span> <span class="toc-text">CopyOnWriteArraySet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentSkipListSet"><span class="toc-number">12.2.2.</span> <span class="toc-text">ConcurrentSkipListSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91Map%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-number">12.3.</span> <span class="toc-text">并发Map集合类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">12.3.1.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentSkipListMap"><span class="toc-number">12.3.2.</span> <span class="toc-text">ConcurrentSkipListMap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91Queu%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8B%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">12.4.</span> <span class="toc-text">并发Queu集合类之阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0"><span class="toc-number">12.4.1.</span> <span class="toc-text">并发阻塞队列概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBlockingQueue"><span class="toc-number">12.4.2.</span> <span class="toc-text">ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedBlockingQueue"><span class="toc-number">12.4.3.</span> <span class="toc-text">LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PriorityBlockingQueue"><span class="toc-number">12.4.4.</span> <span class="toc-text">PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DelayQueue"><span class="toc-number">12.4.5.</span> <span class="toc-text">DelayQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SynchronousQueue"><span class="toc-number">12.4.6.</span> <span class="toc-text">SynchronousQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedTransferQueue"><span class="toc-number">12.4.7.</span> <span class="toc-text">LinkedTransferQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedBlockingDeque"><span class="toc-number">12.4.8.</span> <span class="toc-text">LinkedBlockingDeque</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91Queu%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8B%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">12.5.</span> <span class="toc-text">并发Queu集合类之非阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%9D%9E%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0"><span class="toc-number">12.5.1.</span> <span class="toc-text">并发非阻塞队列概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-number">12.5.2.</span> <span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentLinkedDeque"><span class="toc-number">12.5.3.</span> <span class="toc-text">ConcurrentLinkedDeque</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">13.</span> <span class="toc-text">并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#CountDownLatch"><span class="toc-number">13.1.</span> <span class="toc-text">CountDownLatch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">13.2.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Phaser"><span class="toc-number">13.3.</span> <span class="toc-text">Phaser</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Semaphore"><span class="toc-number">13.4.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exchanger"><span class="toc-number">13.5.</span> <span class="toc-text">Exchanger</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">14.</span> <span class="toc-text">锁工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.1.</span> <span class="toc-text">Lock接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Condition%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.2.</span> <span class="toc-text">Condition接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">14.3.</span> <span class="toc-text">ReentrantLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReadWriteLock%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.4.</span> <span class="toc-text">ReadWriteLock接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">14.5.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StampedLock"><span class="toc-number">14.6.</span> <span class="toc-text">StampedLock</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A0%E9%94%81%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">15.</span> <span class="toc-text">无锁原子类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">16.</span> <span class="toc-text">锁核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E9%94%81%E5%92%8C%E6%98%BE%E7%A4%BA%E9%94%81"><span class="toc-number">16.1.</span> <span class="toc-text">隐式锁和显示锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">16.2.</span> <span class="toc-text">公平锁和非公平锁的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E5%92%8C%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">16.3.</span> <span class="toc-text">悲观锁和乐观锁的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E5%92%8C%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">16.4.</span> <span class="toc-text">可中断锁和不可中断锁的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E9%94%81%E5%92%8C%E5%85%B1%E4%BA%AB%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">16.5.</span> <span class="toc-text">独占锁和共享锁的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LockSupport%E5%8E%9F%E7%90%86"><span class="toc-number">16.6.</span> <span class="toc-text">LockSupport原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">17.</span> <span class="toc-text">锁优化方案</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%8F%E5%B0%8F%E9%94%81%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-number">17.1.</span> <span class="toc-text">减小锁的范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%8F%E5%B0%8F%E9%94%81%E7%9A%84%E7%B2%92%E5%BA%A6"><span class="toc-number">17.2.</span> <span class="toc-text">减小锁的粒度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%88%86%E7%A6%BB"><span class="toc-number">17.3.</span> <span class="toc-text">锁分离</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%88%86%E6%AE%B5"><span class="toc-number">17.4.</span> <span class="toc-text">锁分段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E7%83%AD%E7%82%B9%E5%8C%BA%E5%9F%9F"><span class="toc-number">17.5.</span> <span class="toc-text">避免热点区域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8B%AC%E5%8D%A0%E9%94%81%E7%9A%84%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88"><span class="toc-number">17.6.</span> <span class="toc-text">使用独占锁的替换方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%87%AA%E5%B8%A6%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96"><span class="toc-number">17.7.</span> <span class="toc-text">JVM自带的锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4"><span class="toc-number">17.7.1.</span> <span class="toc-text">锁消除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96"><span class="toc-number">17.7.2.</span> <span class="toc-text">锁粗化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%9E%B6%E6%9E%84"><span class="toc-number">18.</span> <span class="toc-text">分布式锁架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98"><span class="toc-number">18.1.</span> <span class="toc-text">超卖问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">18.2.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">18.2.1.</span> <span class="toc-text">分布式锁的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E6%B1%82"><span class="toc-number">18.2.2.</span> <span class="toc-text">分布式锁的基本要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP%E7%90%86%E8%AE%BA%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">18.2.3.</span> <span class="toc-text">CAP理论与分布式锁模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ERedis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">18.2.4.</span> <span class="toc-text">基于Redis实现分布式锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E5%B7%A5%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">19.</span> <span class="toc-text">分工问题的实现方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ParallelStream"><span class="toc-number">20.</span> <span class="toc-text">ParallelStream</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JMH"><span class="toc-number">21.</span> <span class="toc-text">JMH</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">21.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">21.2.</span> <span class="toc-text">使用方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">21.3.</span> <span class="toc-text">使用示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JMH%E8%BF%9B%E8%A1%8C%E5%90%9E%E5%90%90%E9%87%8F%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">21.4.</span> <span class="toc-text">使用JMH进行吞吐量测试示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8JMH%E8%BF%9B%E8%A1%8CQPS-x2F-TPS%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">21.5.</span> <span class="toc-text">使用JMH进行QPS&#x2F;TPS测试示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">22.</span> <span class="toc-text">References</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法二刷（更新中）"><img src="https://th.bing.com/th/id/R.ee995d98e687b0896c006b16980e126b?rik=ZPHZfBPZDznIiw&amp;riu=http%3a%2f%2fimg.sj33.cn%2fuploads%2fallimg%2f200912%2f20091223150352964.jpg&amp;ehk=ETvV5eN%2fU0LZJE9ZbDxQN%2btQkl3ZWmIGnhIp8GzKzZs%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法二刷（更新中）"/></a><div class="content"><a class="title" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法二刷（更新中）">数据结构和算法二刷（更新中）</a><time datetime="2023-07-10T00:32:48.000Z" title="Created 2023-07-10 08:32:48">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/RocketMQ/" title="RocketMQ"><img src="https://desk-fd.zol-img.com.cn/t_s960x600c5/g5/M00/02/04/ChMkJlbKx9CIKZ-qABs7mJV2aP0AALH5ALBgd0AGzuw770.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/2023/05/24/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2023-05-24T08:13:44.000Z" title="Created 2023-05-24 16:13:44">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img src="https://th.bing.com/th/id/OIP.fekfR1FWtn_EXSMaueufagHaEK?pid=ImgDet&amp;rs=1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud">Spring Cloud</a><time datetime="2023-05-24T08:08:42.000Z" title="Created 2023-05-24 16:08:42">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程"><img src="https://th.bing.com/th/id/R.9316fccce50d6257f0ffb94c5ae6461a?rik=EDdsz%2f4EuNN2ig&amp;riu=http%3a%2f%2fpic1.bbzhi.com%2ffengjingbizhi%2fsijimeijingxiatian%2fnature_season_summer_23966_2.jpg&amp;ehk=ww8MI8P3WC8UIvjNAsOE50t9oRfkNst8LVUnJmhIK8A%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程"/></a><div class="content"><a class="title" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程">Java并发编程</a><time datetime="2023-05-07T13:39:13.000Z" title="Created 2023-05-07 21:39:13">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://th.bing.com/th/id/R.826fae185d03cd7935cc5haf1cd1844c3?rik=9ONAxF3s06zoPg&amp;riu=http%3a%2f%2fpic5.bbzhi.com%2ffengjingbizhi%2fgaoqingziranfengjingbizhi%2fgaoqingziranfengjingbizhi_415690_15.jpg&amp;ehk=BbD3V6XWzCc5AJ7yXlMt4j5AU09Nk56syRdeDXFSvYY%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-05-07T13:37:05.000Z" title="Created 2023-05-07 21:37:05">2023-05-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Song Baoru</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  Loading the Database</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>