<!DOCTYPE html><html lang="zh" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Spring | SBR Blog</title><meta name="author" content="Song Baoru"><meta name="copyright" content="Song Baoru"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Spring特性Spring基于J2EE技术实现了一套轻量的Java Web Service系统应用框架，有很多优秀的特性，包括，依赖注入（DI）、控制反转（IoC）、面向切面（AOP）、轻量、灵活  控制反转 指的是对象依赖的对象，将会在容器的初始化完成后会主动传递给对象，而不需要对象自己创建或查询其依赖的对象，实现了系统对象之间依赖的解耦 Spring通过依赖注入实现控制反转，依赖注入是一种设">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring">
<meta property="og:url" content="https://songbaoru.github.io/2023/05/05/Spring/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:description" content="Spring特性Spring基于J2EE技术实现了一套轻量的Java Web Service系统应用框架，有很多优秀的特性，包括，依赖注入（DI）、控制反转（IoC）、面向切面（AOP）、轻量、灵活  控制反转 指的是对象依赖的对象，将会在容器的初始化完成后会主动传递给对象，而不需要对象自己创建或查询其依赖的对象，实现了系统对象之间依赖的解耦 Spring通过依赖注入实现控制反转，依赖注入是一种设">
<meta property="og:locale">
<meta property="og:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/Spring.jpg">
<meta property="article:published_time" content="2023-05-05T13:02:38.000Z">
<meta property="article:modified_time" content="2023-09-21T02:09:48.041Z">
<meta property="article:author" content="Song Baoru">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/Spring.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://songbaoru.github.io/2023/05/05/Spring/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"UKZKRJW1EQ","apiKey":"09e7b62d6a2db1b01512a9dbbd24b91f","indexName":"sbr_blog","hits":{"per_page":10},"languages":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}.","hits_stats":"${hits} results found in ${time} ms"}},
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Spring',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-09-21 10:09:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="SBR Blog"><img class="site-icon" src="/img/favicon.png"/><span class="site-name">SBR Blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">Spring</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-05-05T13:02:38.000Z" title="Created 2023-05-05 21:02:38">2023-05-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-09-21T02:09:48.041Z" title="Updated 2023-09-21 10:09:48">2023-09-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/IT/">IT</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">8.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>27min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Spring"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="Spring特性"><a href="#Spring特性" class="headerlink" title="Spring特性"></a>Spring特性</h1><p>Spring基于J2EE技术实现了一套轻量的Java Web Service系统应用框架，有很多优秀的特性，包括，依赖注入（DI）、控制反转（IoC）、面向切面（AOP）、轻量、灵活</p>
<ol>
<li>控制反转<ol>
<li>指的是对象依赖的对象，将会在容器的初始化完成后会主动传递给对象，而不需要对象自己创建或查询其依赖的对象，实现了系统对象之间依赖的解耦</li>
<li>Spring通过依赖注入实现控制反转，依赖注入是一种设计模式，通过该模式，对象不再创建或管理它们所需要的其他对象或服务，而是由容器（例如Spring容器）负责创建和管理这些对象或服务，并注入到需要它们的对象中。</li>
</ol>
</li>
<li>面向切面<ol>
<li>面向切面是一种编程范式，用于将系统的横切关注点（如安全性、事务、日志记录等）与业务逻辑分离</li>
<li>面向切面通过将横切关注点划分为独立的模块，并在运行时动态地将这些模块植入到程序中，从而实现了对业务逻辑的无侵入式增强</li>
<li>Spring AOP通过使用动态代理技术来实现对目标对象的增强</li>
</ol>
</li>
<li>轻量<ol>
<li>spring-web-5.2.0.RELEASE.jar和spring-core-5.2.0.RELEASE.jar均仅有1.4M左右</li>
<li>只需要少量的操作系统资源</li>
</ol>
</li>
<li>灵活<ol>
<li>是模块化的，可以按需引入模块（以jar包依赖的方式引入）</li>
</ol>
</li>
</ol>
<h1 id="Spring的核心JAR包"><a href="#Spring的核心JAR包" class="headerlink" title="Spring的核心JAR包"></a>Spring的核心JAR包</h1><p>Spring是模块化实现的，每个模块对应不同的JAR包</p>
<p>Spring框架的所有JAR包：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>spring-aop</td>
<td>提供了Spring框架的面向切面编程（AOP）功能，用于在运行时动态地增强应用程序的功能。</td>
</tr>
<tr>
<td>spring-aspects</td>
<td>提供了Spring框架的切面库，包括对AspectJ切面的支持和一些通用切面的实现。</td>
</tr>
<tr>
<td>spring-beans</td>
<td>提供了Spring框架的BeanFactory和FactoryBean等工厂类，用于管理和配置应用程序中的对象。</td>
</tr>
<tr>
<td>spring-context</td>
<td>提供了Spring框架的应用上下文（ApplicationContext），用于管理应用程序中的Bean对象，以及Spring框架的事件驱动编程模型。</td>
</tr>
<tr>
<td>spring-context-indexer</td>
<td>提供了一个工具，用于在编译时为Spring应用程序生成索引文件，以提高应用程序启动的速度。</td>
</tr>
<tr>
<td>spring-context-support</td>
<td>提供了一些扩展类，用于在Spring应用程序中支持特定的应用场景，例如JPA、Velocity等。</td>
</tr>
<tr>
<td>spring-core</td>
<td>Spring框架的核心模块，提供了Spring框架的基本功能，如依赖注入、控制反转、Bean工厂等。</td>
</tr>
<tr>
<td>spring-expression</td>
<td>提供了Spring框架的表达式语言（SpEL），用于在应用程序中动态地访问和操作对象。</td>
</tr>
<tr>
<td>spring-instrument</td>
<td>提供了Spring框架的Instrumentation API支持，用于在运行时通过Java Agent来提供增强功能。</td>
</tr>
<tr>
<td>spring-instrument-tomcat</td>
<td>提供了Spring框架在Tomcat服务器中使用Instrumentation API的支持。</td>
</tr>
<tr>
<td>spring-jcl</td>
<td>提供了Spring框架的通用日志抽象库，可以在不同的日志实现之间进行切换。</td>
</tr>
<tr>
<td>spring-jdbc</td>
<td>提供了Spring框架的JDBC支持，包括对JdbcTemplate和NamedParameterJdbcTemplate等的封装。</td>
</tr>
<tr>
<td>spring-jms</td>
<td>提供了Spring框架的Java Message Service（JMS）支持，用于在应用程序中发送和接收消息。</td>
</tr>
<tr>
<td>spring-messaging</td>
<td>提供了Spring框架的消息处理功能，包括对WebSocket、STOMP、AMQP等协议的支持。</td>
</tr>
<tr>
<td>spring-orm</td>
<td>提供了Spring框架的对象关系映射（ORM）支持，包括对Hibernate、MyBatis等ORM框架的集成。</td>
</tr>
<tr>
<td>spring-oxm</td>
<td>提供了Spring框架的对象XML映射（OXM）支持，用于在Java对象和XML文档之间进行转换。</td>
</tr>
<tr>
<td>spring-test</td>
<td>提供了Spring框架的测试支持，包括对JUnit、TestNG等测试框架的集成，以及对Spring应用程序的集成测试支持。</td>
</tr>
<tr>
<td>spring-tx</td>
<td>提供了Spring框架对事务的支持，包括声明式事务管理、编程式事务管理、事务传播行为管理、事务隔离级别管理等功能。</td>
</tr>
</tbody></table>
<h1 id="Spring-IoC原理"><a href="#Spring-IoC原理" class="headerlink" title="Spring IoC原理"></a>Spring IoC原理</h1><h2 id="IoC简介"><a href="#IoC简介" class="headerlink" title="IoC简介"></a>IoC简介</h2><p>Spring IoC（Inversion of Control，控制反转）提供的功能包括，通过Java反射功能实例化Bean对象，建立Bean之间的依赖关系，Bean实例缓存管理、Bean生命周期管理等。</p>
<p>控制反转的含义：</p>
<ul>
<li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong>：控制权交给外部环境（Spring的IoC 容器）</li>
</ul>
<p><strong>控制反转怎么理解?：</strong> 举个例子：”对象 a 依赖了对象 b，当对象 a 需要使用 对象 b 的时候必须自己去创建。但是当系统引入了 IOC 容器后， 对象 a 和对象 b 之前就失去了直接的联系。这个时候，当对象 a 需要使用 对象 b 的时候， 我们可以指定 IOC 容器去创建一个对象 b 注入到对象 a 中”。 对象 a 获得依赖对象 b 的过程,由主动行为变为了被动行为，控制权反转，这就是控制反转名字的由来。</p>
<h2 id="Bean的装配流程"><a href="#Bean的装配流程" class="headerlink" title="Bean的装配流程"></a>Bean的装配流程</h2><p>Spring通过读取XML或注解获取Bean的配置信息，并在Bean容器中生成Bean配置注册表，然后根据配置注册表实例化Bean，将Bean实例载入Bean缓存池，业务程序就可以从Bean缓存池中获取Bean。</p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/core/beans/factory-scopes.html">Bean的作用域</a></h2><p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : Spring的IoC容器中只有唯一的 Bean 实例。Spring 中的 Bean 默认都是单例的。</li>
<li><strong>prototype</strong> : 每次获取Bean（调用 <code>getBean()</code> 方法）都会创建一个新的 Bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每次 HTTP 请求都会产生一个新的 Bean，该 Bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。</li>
<li><strong>application</strong> （仅 Web 应用可用）：同一个全局的Session共享一个Bean，一般用于Portlet环境。</li>
<li><strong>websocket</strong>（仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ul>
<p>除了以上几种标准作用域外，Spring 还支持自定义作用域。在 Spring 中，可以通过实现 Scope 接口并重写对应方法来实现自定义作用域。</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>Spring容器管理Bean，涉及对Bean的创建、初始化、调用、销毁等一系列的流程，这个流程就是Spring Bean的生命周期：</p>
<ul>
<li><strong>实例化</strong>（Instantiation）：当Spring容器启动时，它会根据配置元数据（XML配置、注解等）来实例化Bean对象。这是通过调用构造函数来完成的。</li>
<li><strong>设置属性</strong>（Populate Properties）：在实例化Bean后，Spring容器会通过调用setter方法或直接设置字段的方式，将配置的属性值注入到Bean中。</li>
<li><strong>Aware接口回调</strong>：如果Bean实现了特定的Aware接口，Spring容器会在属性设置后相应地回调相关的方法，例如BeanNameAware、BeanFactoryAware、ApplicationContextAware等。</li>
<li><strong>BeanPostProcessor的前置处理</strong>（PostProcess Before Initialization）：Spring容器中存在一种特殊类型的Bean称为BeanPostProcessor，它可以在Bean初始化前后执行一些自定义逻辑。对于所有Bean，这些BeanPostProcessor会在初始化前先执行。</li>
<li><strong>初始化</strong>(Initialization)：在Bean的所有属性设置完成后，Spring容器会调用Bean的初始化方法。可以通过@PostConstruct注解标记该方法。如果Bean实现了InitializingBean接口，容器还会调用它的afterPropertiesSet()方法。</li>
<li><strong>BeanPostProcessor的后置处理</strong>（PostProcess After Initialization）：在Bean初始化完成后，再次运行所有的BeanPostProcessor，但这次是在初始化后执行。</li>
<li><strong>使用</strong>(Bean ready for use)：此时，Bean已经初始化完成，可以被容器及其他Bean使用了。</li>
<li><strong>销毁</strong>(Destruction)：当Spring容器关闭时，会调用单例Bean的销毁方法。可以通过@PreDestroy注解标记该方法，或者实现DisposableBean接口来定义销毁逻辑。</li>
</ul>
<p>整个流程参考下图：</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20220224/4107856_1645694380479/7EF8F66C3DFA7434E4CA11B47CF8F1F7" alt="Spring Bean生命周期"></p>
<h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><p>BeanFactory是一个类工厂，与传统类工厂不同的是，BeanFactory是类的通用工厂，它可以创建并管理各种类的对象。这些可被创建和管理的对象本身没有什么特别之处，仅是一个POJO，Spring称这些被创建和管理的Java对象为Bean。并且，Spring中所说的Bean比JavaBean更为宽泛一些，所有可以被Spring容器实例化并管理的Java类都可以成为Bean。</p>
<p>BeanFactory是Spring容器的顶层接口，Spring为BeanFactory提供了多种实现，最常用的是XmlBeanFactory。但它在Spring 3.2中已被废弃，建议使用XmlBeanDefinitionReader、DefaultListableBeanFactory替代。BeanFactory最主要的方法就是 getBean(String beanName)，该方法从容器中返回特定名称的Bean。</p>
<h2 id="Bean定义相关注解"><a href="#Bean定义相关注解" class="headerlink" title="Bean定义相关注解"></a>Bean定义相关注解</h2><p>Spring的注解将Bean的定义和依赖关系从XML配置中解放出来，应用程序只要使用注解依赖注入即可</p>
<p>Bean具体的定义和依赖关系由Spring的自动装配完成。</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Component</code></td>
<td>用于标识一个类为Spring容器的组件（Bean）。通常作用于普通的Java类。</td>
</tr>
<tr>
<td><code>@Repository</code></td>
<td>用于标识一个类为数据访问层（DAO）的组件。通常用于与数据库交互的类。</td>
</tr>
<tr>
<td><code>@Service</code></td>
<td>用于标识一个类为业务逻辑层（Service）的组件。通常用于封装业务逻辑的类。</td>
</tr>
<tr>
<td><code>@Controller</code></td>
<td>用于标识一个类为控制器（Controller）的组件。通常用于处理用户请求和返回视图的类。</td>
</tr>
<tr>
<td><code>@Configuration</code></td>
<td>用于标识一个类为配置类，其中包含了Bean的定义和配置信息。通常与<code>@Bean</code>注解一起使用。</td>
</tr>
<tr>
<td><code>@Profile</code></td>
<td>用于基于不同的应用程序环境选择Bean定义，可以与@Conditional一起使用。</td>
</tr>
<tr>
<td><code>@Scope</code></td>
<td>用于定义Bean对象的作用域，包括Singleton、Prototype、Request、Session等。</td>
</tr>
</tbody></table>
<h2 id="注入Bean的注解"><a href="#注入Bean的注解" class="headerlink" title="注入Bean的注解"></a>注入Bean的注解</h2><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>
<table>
<thead>
<tr>
<th>Annotaion</th>
<th>Package</th>
<th>Source</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Autowired</code></td>
<td><code>org.springframework.bean.factory</code></td>
<td>Spring 2.5+</td>
</tr>
<tr>
<td><code>@Resource</code></td>
<td><code>javax.annotation</code></td>
<td>Java JSR-250</td>
</tr>
<tr>
<td><code>@Inject</code></td>
<td><code>javax.inject</code></td>
<td>Java JSR-330</td>
</tr>
</tbody></table>
<hr>
<p><strong>@Autowired 和 @Resource 的区别：</strong></p>
<p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配）。这存在的问题是， 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写），建议通过 <code>@Qualifier</code> 注解来显式指定名称而不是依赖变量的名称。</p>
<p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>，可以通过 <code>name</code> 属性来显式指定名称。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p>
<h1 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h1><h2 id="Spring-AOP简介"><a href="#Spring-AOP简介" class="headerlink" title="Spring AOP简介"></a>Spring AOP简介</h2><p>Spring AOP通过面向切面技术，将与业务无关或被业务模块共用的代码封装起来，便于减少系统的重复代码，降低模块间的耦合度。</p>
<h2 id="Spring-AOP-的核心概念"><a href="#Spring-AOP-的核心概念" class="headerlink" title="Spring AOP 的核心概念"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-aop-%E7%9A%84%E4%BA%86%E8%A7%A3">Spring AOP 的核心概念</a></h2><table>
<thead>
<tr>
<th>术语</th>
<th>翻译</th>
<th>概念</th>
</tr>
</thead>
<tbody><tr>
<td>Aspect</td>
<td>切面</td>
<td>包含切入点（Pointcut）和通知（Advice）的类。</td>
</tr>
<tr>
<td>Join point</td>
<td>连接点</td>
<td>目标对象的所属类中，定义的所有方法均为连接点。</td>
</tr>
<tr>
<td>Pointcut</td>
<td>切入点</td>
<td>被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）。</td>
</tr>
<tr>
<td>Advice</td>
<td>通知</td>
<td>增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情。</td>
</tr>
<tr>
<td>Target object</td>
<td>目标</td>
<td>被通知的对象。</td>
</tr>
<tr>
<td>AOP proxy</td>
<td>代理</td>
<td>向目标对象应用通知之后创建的代理对象。</td>
</tr>
<tr>
<td>Weaving</td>
<td>织入</td>
<td>将通知应用到目标对象，进而生成代理对象的过程动作。</td>
</tr>
</tbody></table>
<h2 id="Spring-AOP的5种通知类型"><a href="#Spring-AOP的5种通知类型" class="headerlink" title="Spring AOP的5种通知类型"></a>Spring AOP的5种通知类型</h2><p>Spring AOP 提供了以下五种类型的通知：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>翻译</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>Before advice</td>
<td>前置通知</td>
<td>在切入点之前运行的建议，但不能阻止执行流程继续到切入点（除非它抛出异常）。</td>
</tr>
<tr>
<td>After (finally) advice</td>
<td>后置通知</td>
<td>无论切入点以何种方式退出（正常或异常返回），都要运行的建议。</td>
</tr>
<tr>
<td>Around advice</td>
<td>环绕通知</td>
<td>在切入点前后都执行。</td>
</tr>
<tr>
<td>After throwing advice</td>
<td>异常通知</td>
<td>在方法通过抛出异常退出时运行的建议。</td>
</tr>
<tr>
<td>After returning advice</td>
<td>返回通知</td>
<td>在切入点正常完成后运行的建议（例如，如果方法返回而不抛出异常）。</td>
</tr>
</tbody></table>
<h2 id="Spring-AOP通知类型的应用例子"><a href="#Spring-AOP通知类型的应用例子" class="headerlink" title="Spring AOP通知类型的应用例子"></a>Spring AOP通知类型的应用例子</h2><table>
<thead>
<tr>
<th>应用场景</th>
<th>切面类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>日志记录</td>
<td>前置通知（Before）</td>
<td>在用户登录时记录登录时间和 IP 地址</td>
</tr>
<tr>
<td>安全控制</td>
<td>前置通知（Before）</td>
<td>在访问受保护的资源时检查用户的身份和权限信息</td>
</tr>
<tr>
<td>性能监控</td>
<td>环绕通知（Around）</td>
<td>在对数据库进行查询时统计查询时间和资源占用情况</td>
</tr>
<tr>
<td>事务管理</td>
<td>环绕通知（Around）</td>
<td>在对数据库进行更新操作时开启和提交事务</td>
</tr>
<tr>
<td>异常处理</td>
<td>异常通知（AfterThrowing）</td>
<td>在文件上传时捕获文件格式不正确等异常信息，并进行相应的处理</td>
</tr>
</tbody></table>
<h2 id="Spring-AOP相关注解"><a href="#Spring-AOP相关注解" class="headerlink" title="Spring AOP相关注解"></a>Spring AOP相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Aspect</td>
<td>切面定义</td>
<td>用于将类定义为切面，可以在其中定义切点和通知。</td>
</tr>
<tr>
<td>@Pointcut</td>
<td>切点定义</td>
<td>用于定义切点，指定切入点的匹配规则。</td>
</tr>
<tr>
<td>@Before</td>
<td>前置通知</td>
<td>在方法执行之前执行通知。</td>
</tr>
<tr>
<td>@After</td>
<td>后置通知</td>
<td>在方法执行之后执行通知。</td>
</tr>
<tr>
<td>@Around</td>
<td>环绕通知</td>
<td>在方法执行之前和之后都可以执行通知。</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>异常通知</td>
<td>在方法执行时抛出异常后执行通知。</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>返回通知</td>
<td>在方法执行之后返回结果后执行通知。</td>
</tr>
</tbody></table>
<h2 id="Spring-AOP和AspectJ-AOP的区别"><a href="#Spring-AOP和AspectJ-AOP的区别" class="headerlink" title="Spring AOP和AspectJ AOP的区别"></a>Spring AOP和AspectJ AOP的区别</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<blockquote>
<p>AspectJ是由Xerox PARC（帕洛阿尔托研究中心）的Gregor Kiczales等人开发的。AspectJ最初是一门编程语言，它扩展了Java语言，引入了面向切面编程的概念，并在语言级别上提供了对AOP的支持。后来，AspectJ逐渐发展成为一个功能强大的AOP框架，它可以与Java语言集成，用于实现更高级的横切关注点处理。</p>
</blockquote>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
<h2 id="多个切面的执行顺序控制"><a href="#多个切面的执行顺序控制" class="headerlink" title="多个切面的执行顺序控制"></a>多个切面的执行顺序控制</h2><p>多个切面执行顺序的控制方法有：</p>
<ol>
<li>使用<code>@Order</code> 注解直接定义切面顺序</li>
<li>实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法</li>
</ol>
<h1 id="Spring-MVC原理"><a href="#Spring-MVC原理" class="headerlink" title="Spring MVC原理"></a>Spring MVC原理</h1><h2 id="Spring-MVC简介"><a href="#Spring-MVC简介" class="headerlink" title="Spring MVC简介"></a><a target="_blank" rel="noopener" href="https://www.javatpoint.com/spring-mvc-tutorial">Spring MVC简介</a></h2><p>Spring MVC 是一个用于构建 Web 应用程序的 Java 框架。它遵循模型-视图-控制器设计模式。</p>
<h2 id="Spring-MVC-的核心组件"><a href="#Spring-MVC-的核心组件" class="headerlink" title="Spring MVC 的核心组件"></a>Spring MVC 的核心组件</h2><ul>
<li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li>
<li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li>
<li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li>
<li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li>
</ul>
<h2 id="SpringMVC的执行流程"><a href="#SpringMVC的执行流程" class="headerlink" title="SpringMVC的执行流程"></a>SpringMVC的执行流程</h2><p>SpringMVC 的工作流程主要包括以下几个步骤：</p>
<ol>
<li><p><strong>客户端发送请求</strong>：客户端向服务器发送请求，请求可以是一个 URL 地址、一个表单提交或者一个 AJAX 请求。</p>
</li>
<li><p><strong>DispatcherServlet接收请求</strong>：DispatcherServlet 是 SpringMVC 框架的核心控制器，它负责接收客户端发送的请求，并将请求转发给HandlerMapping查找对应的处理器，然后再将。</p>
</li>
<li><p><strong>HandlerMapping查找处理器</strong>：HandlerMapping 负责根据请求 URL 查找对应的处理器，处理器可以是一个 Controller 或者一个 Restful Web Service。</p>
</li>
<li><p><strong>HandlerAdapter调用处理器</strong>：HandlerAdapter 负责调用处理器，将请求传递给处理器进行处理，并获取处理器的处理结果。</p>
</li>
<li><p><strong>处理器处理请求</strong>：处理器根据请求的类型和参数，进行相应的业务处理，并返回一个 ModelAndView 对象。</p>
</li>
<li><p><strong>视图解析器解析视图</strong>：视图解析器（ViewResolver）根据 ModelAndView 中的视图名，将其解析成对应的视图对象，视图可以是一个 JSP 页面、一个 Thymeleaf 模板或者一个 HTML 片段等。</p>
</li>
<li><p><strong>渲染视图</strong>：视图对象根据数据模型和视图模板，生成 HTML 内容，并将其返回给客户端。</p>
</li>
<li><p><strong>返回响应</strong>：DispatcherServlet 将视图渲染的结果返回给客户端，客户端可以是一个浏览器、一个移动应用或者一个 API 调用。</p>
</li>
</ol>
<p>流程图如下：</p>
<p><img src="/2023/05/05/Spring/.././Spring/de6d2b213f112297298f3e223bf08f28.png" alt="SpringMVC工作流程图|https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/de6d2b213f112297298f3e223bf08f28.png"></p>
<p>总之，SpringMVC 的工作流程涉及到多个组件之间的协作，其中 DispatcherServlet 负责接收请求和控制流程，HandlerMapping 负责查找处理器，HandlerAdapter 负责调用处理器，视图解析器负责解析视图，视图对象负责渲染视图，最终将响应返回给客户端。</p>
<h2 id="常用的Web注解"><a href="#常用的Web注解" class="headerlink" title="常用的Web注解"></a>常用的Web注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Controller</td>
<td>控制器</td>
<td>用于将类定义为Spring MVC的控制器，处理HTTP请求并返回响应结果。</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>响应体</td>
<td>用于指示处理方法的返回值应直接序列化到HTTP响应的响应体中，而不是被解释为视图名称并由视图解析程序解析以生成HTML或其他类型的响应</td>
</tr>
<tr>
<td>@RestController</td>
<td>REST控制器</td>
<td>与@Controller类似，但多了@ResponseBody注解，默认情况下返回JSON或XML格式的响应结果。</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>路径变量</td>
<td>将HTTP请求URL中的参数绑定到处理方法的参数上，用于从URL路径中的占位符（通常使用花括号{}包裹）中提取参数。</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>请求映射</td>
<td>用于将HTTP请求映射到处理方法上，并指定请求的URL、请求方法、请求参数等。</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>GET请求映射</td>
<td>用于将HTTP GET请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>POST请求映射</td>
<td>用于将HTTP POST请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PutMapping</td>
<td>PUT请求映射</td>
<td>用于将HTTP PUT请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@DeleteMapping</td>
<td>DELETE请求映射</td>
<td>用于将HTTP DELETE请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PatchMapping</td>
<td>PATCH请求映射</td>
<td>用于将HTTP PATCH请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>请求参数</td>
<td>将HTTP请求URL中的参数绑定到处理方法的参数上，用于从请求的URL中提取查询参数（Query Parameter），查询参数是出现在URL问号后面的键值对。</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>请求体</td>
<td>将HTTP请求体中的数据绑定到处理方法的参数上，用于从HTTP请求体（Body）中提取数据，通常用于处理POST或PUT请求中的数据。</td>
</tr>
</tbody></table>
<h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><h2 id="Spring的事务管理用法"><a href="#Spring的事务管理用法" class="headerlink" title="Spring的事务管理用法"></a>Spring的事务管理用法</h2><p>Spring为事务管理提供了一致的编程模板，在高层次上建立了统一的事务抽象。也就是说，不管是选择MyBatis、Hibernate、JPA还是Spring JDBC，<strong>Spring都可以让用户以统一的编程模型进行事务管理</strong>。</p>
<p>Spring支持两种事务编程模型：</p>
<ol>
<li><p>编程式事务</p>
<p>Spring提供了TransactionTemplate模板，利用该模板我们可以通过编程的方式实现事务管理，而无需关注资源获取、复用、释放、事务同步及异常处理等操作。相对于声明式事务来说，这种方式相对麻烦一些，但是好在<strong>更为灵活</strong>，我们可以将事务管理的范围控制的更为精确。</p>
</li>
<li><p>声明式事务</p>
<p>Spring事务管理的亮点在于声明式事务管理，它允许我们通过声明的方式，在IoC配置中指定事务的边界和事务属性，Spring会自动在指定的事务边界上应用事务属性。相对于编程式事务来说，这种方式十分的方便，只需要在需要做事务管理的方法上，增加@Transactional注解，以声明事务特征即可，<strong>可以使用isolation属性声明事务的隔离级别，使用propagation属性声明事务的传播方式</strong>。</p>
<p>@Transactional注解可以标注在类或者方法上。</p>
<ul>
<li>当它标注在类上时，代表这个类所有公共（public）非静态的方法都将启用事务功能。</li>
<li>当它标注在方法上时，代表这个方法将启用事务功能。</li>
</ul>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904096747503629">@Transactional注解可以作用于哪些地方？</a></p>
<p>@Transactional 可以作用在<code>接口</code>、<code>类</code>、<code>类方法</code>。</p>
<ul>
<li><strong>作用于接口</strong>：接口上定义的事务属性将被应用于实现类中的方法。当通过接口调用实现类的方法时，事务将会生效。不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效，这因为CGLIB代理是通过继承实现的，而不是基于接口的。</li>
<li><strong>作用于类</strong>：当把@Transactional 注解放在类上时，表示所有该类的<code>public</code>方法都配置相同的事务属性信息。类的<code>@Transactional</code>注解可以覆盖接口的事务配置信息。</li>
<li><strong>作用于方法</strong>：当类配置了@Transactional，方法也配置了@Transactional，方法的<code>@Transactional</code>注解会覆盖类的事务配置信息。</li>
</ul>
<h2 id="Spring的事务传播方式"><a href="#Spring的事务传播方式" class="headerlink" title="Spring的事务传播方式"></a><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/transaction/annotation/Propagation.html">Spring的事务传播方式</a></h2><p><strong>发生嵌套调用事务方法（非事务方法或事务方法内部调用事务方法）的时候，就要设置方法（调用方法）和嵌套调用的事务方法（被调用的事务方法）之间的Spring的事务传播方式。</strong></p>
<p>设置方法是给<strong>被调用的事务（可以称为，子事务）</strong>的@Transactional注解中设置propagation属性。</p>
<p>Spring在<strong>Propagation枚举类</strong>中给出了7种类型的事务传播方式，它们<strong>规定了事务方法发生嵌套调用时如何进行传播</strong>，如下表：</p>
<table>
<thead>
<tr>
<th>事务传播方式类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED</td>
<td>如果当前存在一个事务，则加入该事务；如果没有事务，则创建一个新事务。这是最常用的传播行为。</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>如果当前存在一个事务，则加入该事务；如果没有事务，则以非事务方式执行。</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>如果当前存在一个事务，则加入该事务；如果没有事务，则抛出异常。</td>
</tr>
<tr>
<td>REQUIRES_NEW</td>
<td>创建一个新事务，并挂起当前的事务（如果存在）。新事务独立于当前事务执行。</td>
</tr>
<tr>
<td>NOT_SUPPORTED</td>
<td>以非事务方式执行，并挂起当前的事务（如果存在）。</td>
</tr>
<tr>
<td>NEVER</td>
<td>以非事务方式执行，如果当前存在事务，则抛出异常。</td>
</tr>
<tr>
<td>NESTED</td>
<td>如果当前事务存在，则在嵌套事务中执行，否则行为类似于 REQUIRED。</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Propagation;<br><span class="hljs-keyword">import</span> org.springframework.transaction.annotation.Transactional;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserRepository userRepository;<br><br>    <span class="hljs-comment">//outerMethod方法内发生了嵌套调用事务方法innerMethod</span><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">outerMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Some business logic</span><br>        userRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;John&quot;</span>));<br>        <br>        <span class="hljs-comment">// Calling the innerMethod</span><br>        innerMethod();<br>    &#125;<br><br>    <span class="hljs-comment">//给子事务的@Transactional设置propagation属性</span><br>    <span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">innerMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Some business logic</span><br>        userRepository.save(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Alice&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Spring的事务隔离级别"><a href="#Spring的事务隔离级别" class="headerlink" title="Spring的事务隔离级别"></a><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D">Spring的事务隔离级别</a></h2><p>Spring在<strong>Isolation枚举类</strong>中给出了5种类型的事务隔离级别，它们<strong>规定了多个事务在并发访问数据库时，彼此之间的执行顺序</strong>，如下：</p>
<table>
<thead>
<tr>
<th>事务传播方式类型</th>
<th>翻译</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ISOLATION_DEFAULT</td>
<td>默认的隔离级别</td>
<td>使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别。</td>
</tr>
<tr>
<td>ISOLATION_READ_UNCOMMITTED</td>
<td>读未提交</td>
<td>最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></td>
</tr>
<tr>
<td>ISOLATION_READ_COMMITTED</td>
<td>读已提交</td>
<td>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></td>
</tr>
<tr>
<td>ISOLATION_REPEATABLE_READ</td>
<td>可重复读</td>
<td>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></td>
</tr>
<tr>
<td>ISOLATION_SERIALIZABLE</td>
<td>可串行化</td>
<td>最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</td>
</tr>
</tbody></table>
<h2 id="Transactional-rollbackFor-x3D-Exception-class-注解"><a href="#Transactional-rollbackFor-x3D-Exception-class-注解" class="headerlink" title="@Transactional(rollbackFor &#x3D; Exception.class)注解"></a>@Transactional(rollbackFor &#x3D; Exception.class)注解</h2><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。</p>
<p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性，那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>，可以让事务在遇到非运行时异常时也回滚。</p>
<h2 id="Transactional失效场景"><a href="#Transactional失效场景" class="headerlink" title="@Transactional失效场景"></a>@Transactional失效场景</h2><ol>
<li><p>@Transactional 应用在非 public 修饰的方法上</p>
<p>如果<code>Transactional</code>注解应用在非<code>public</code> 修饰的方法上，Transactional将会失效。</p>
<p>之所以会失效是因为在Spring AOP 代理时，如上图所示 <code>TransactionInterceptor</code> （事务拦截器）在目标方法执行前后进行拦截，<code>DynamicAdvisedInterceptor</code>（CglibAopProxy 的内部类）的 intercept 方法或 <code>JdkDynamicAopProxy</code> 的 invoke 方法会间接调用 <code>AbstractFallbackTransactionAttributeSource</code>的 <code>computeTransactionAttribute</code> 方法，获取Transactional 注解的事务配置信息。</p>
<p>此方法会检查目标方法的修饰符是否为 public，不是 public则不会获取@Transactional 的属性配置信息。</p>
<p><strong>注意：<code>protected</code>、<code>private</code> 修饰的方法上使用 <code>@Transactional</code> 注解，虽然事务无效，但不会有任何报错，这是我们很容犯错的一点。</strong></p>
</li>
<li><p>@Transactional 注解属性 propagation 设置错误</p>
<p>这种失效是由于配置错误，若是错误的配置以下三种 propagation，事务将不会发生回滚。</p>
<p><code>TransactionDefinition.PROPAGATION_SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 <code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 <code>TransactionDefinition.PROPAGATION_NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</p>
</li>
<li><p>@Transactional 注解属性 rollbackFor 设置错误</p>
<p><code>rollbackFor</code> 可以<strong>指定能够触发事务回滚的异常类型</strong>。Spring默认抛出了未检查<code>unchecked</code>异常（继承自 <code>RuntimeException</code> 的异常）或者 <code>Error</code>才回滚事务；其他异常不会触发回滚事务。如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定 <strong>rollbackFor</strong>属性。</p>
<p>若在目标方法中抛出的异常是 <code>rollbackFor</code> 指定的异常的子类，事务同样会回滚。</p>
</li>
<li><p>事务被同一个类中的方法调用</p>
<p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B（不论方法B是用public还是private修饰），但<strong>方法A没有声明注解事务</strong>，而B方法有。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p>
<p>那为啥会出现这种情况？其实这还是由于使用<code>Spring AOP</code>代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由<code>Spring</code>生成的代理对象来管理。</p>
</li>
<li><p>事务的异常被catch了</p>
<p>这种情况是最常见的一种@Transactional注解失效场景。如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务不能正常回滚。</p>
<p>因为当<code>ServiceB</code>中抛出了一个异常以后，<code>ServiceB</code>标识当前事务需要<code>rollback</code>。但是<code>ServiceA</code>中由于手动地捕获这个异常并进行处理，<code>ServiceA</code>认为当前事务应该正常<code>commit</code>。此时就出现了前后不一致，也就是因为这样，抛出了前面的<code>UnexpectedRollbackException</code>异常。</p>
<p>Spring的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行<code>commit</code> or <code>rollback</code>，事务是否执行回滚取决于是否抛出<code>runtime异常</code>。如果抛出<code>runtime exception</code> 并在你的业务方法中没有catch到的话，事务会回滚。</p>
<p>在业务方法中一般不需要catch异常，如果非要catch一定要抛出<code>throw new RuntimeException()</code>，或者注解中指定抛异常类型<code>@Transactional(rollbackFor=Exception.class)</code>，否则会导致事务失效，数据commit造成数据不一致，所以有些时候try catch反倒会画蛇添足。</p>
</li>
<li><p>数据库引擎不支持事务</p>
</li>
</ol>
<h1 id="Spring-Boot启动流程"><a href="#Spring-Boot启动流程" class="headerlink" title="Spring Boot启动流程"></a>Spring Boot启动流程</h1><p>每一个SpringBoot项目都有一个主入口，这个主入口就是Application启动类中的main方法，而main方法中又会调用run方法，run方法完成了Spring Boot的整个启动流程：</p>
<p>首先，Spring Boot项目创建完成会默认生成一个名为 Application的入口类，通过该类的main方法启动Spring Boot项目，在main方法中会调用run方法，进行SpringApplication类的实例化操作，然后再针对实例化对象调用另外一个run方法来完成整个项目的初始化和启动。</p>
<p>SpringApplication调用的run方法的大致流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>	<span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>	<span class="hljs-type">DefaultBootstrapContext</span> <span class="hljs-variable">bootstrapContext</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.createBootstrapContext();<br>	<span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>	<span class="hljs-built_in">this</span>.configureHeadlessProperty();<br>	<span class="hljs-comment">//获取SpringApplicationListener监听器</span><br>	<span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getRunListeners(args);<br>	<span class="hljs-comment">//启动所获取到的所有监听器</span><br>	listeners.starting(bootstrapContext, <span class="hljs-built_in">this</span>.mainApplicationClass);<br><br>	<span class="hljs-keyword">try</span> &#123;<br>		<span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationArguments</span>(args);<br>		<span class="hljs-comment">//准备环境</span><br>		<span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>		<span class="hljs-built_in">this</span>.configureIgnoreBeanInfo(environment);<br>		<span class="hljs-comment">//打印Banner图标</span><br>		<span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.printBanner(environment);<br>		<span class="hljs-comment">//创建IoC容器</span><br>		context = <span class="hljs-built_in">this</span>.createApplicationContext();<br>		context.setApplicationStartup(<span class="hljs-built_in">this</span>.applicationStartup);<br>		<span class="hljs-comment">//准备IoC容器</span><br>		<span class="hljs-built_in">this</span>.prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>		<span class="hljs-comment">//刷新IoC容器</span><br>		<span class="hljs-built_in">this</span>.refreshContext(context);<br>		<span class="hljs-built_in">this</span>.afterRefresh(context, applicationArguments);<br>		<span class="hljs-type">Duration</span> <span class="hljs-variable">timeTakenToStartup</span> <span class="hljs-operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);<br>		<span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>			(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass)).logStarted(<span class="hljs-built_in">this</span>.getApplicationLog(), timeTakenToStartup);<br>		&#125;<br>		<span class="hljs-comment">//通知监听器，IoC容器启动完成</span><br>		listeners.started(context, timeTakenToStartup);<br>		<span class="hljs-comment">//执行ApplicationRunner和CommandLineRunner实现类中定义的runner方法（可自定义）</span><br>		<span class="hljs-built_in">this</span>.callRunners(context, applicationArguments);<br>	&#125; <span class="hljs-keyword">catch</span> (Throwable var12) &#123;<br>		<span class="hljs-built_in">this</span>.handleRunFailure(context, var12, listeners);<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(var12);<br>	&#125;<br><br>	<span class="hljs-keyword">try</span> &#123;<br>		<span class="hljs-type">Duration</span> <span class="hljs-variable">timeTakenToReady</span> <span class="hljs-operator">=</span> Duration.ofNanos(System.nanoTime() - startTime);<br>		listeners.ready(context, timeTakenToReady);<br>		<span class="hljs-comment">//返回IoC容器</span><br>		<span class="hljs-keyword">return</span> context;<br>	&#125; <span class="hljs-keyword">catch</span> (Throwable var11) &#123;<br>		<span class="hljs-built_in">this</span>.handleRunFailure(context, var11, (SpringApplicationRunListeners)<span class="hljs-literal">null</span>);<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(var11);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Spring用到的设计模式"><a href="#Spring用到的设计模式" class="headerlink" title="Spring用到的设计模式"></a>Spring用到的设计模式</h1><ul>
<li><strong>依赖倒置原则</strong>：Spring IoC的依赖注入实现了这一设计模式。</li>
<li><strong>代理模式</strong>：Spring AOP使用了动态代理，会创建代理对象。</li>
<li><strong>单例模式</strong>：Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>JdbcTemplate</code>、<code>HibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>观察者模式:</strong> 观察者模式是一种对象行为型模式。它表示的是一种对象与对象之间具有依赖关系，当一个对象发生改变的时候，依赖这个对象的所有对象也会做出反应。Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>工厂模式</strong>：Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>适配器模式</strong>：适配器模式(Adapter Pattern) 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作。Spring AOP 的增强或通知(Advice)使用到了适配器模式，与之相关的接口是<code>AdvisorAdapter</code>。</li>
<li>……</li>
</ul>
<h1 id="Spring怎样解决循环依赖问题"><a href="#Spring怎样解决循环依赖问题" class="headerlink" title="Spring怎样解决循环依赖问题"></a>Spring怎样解决循环依赖问题</h1><h2 id="循环依赖是什么"><a href="#循环依赖是什么" class="headerlink" title="循环依赖是什么"></a><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/84267654">循环依赖是什么</a></h2><p>Spring中的循环依赖指的是类与类之间出现了循环依赖，比如类A依赖了类B，类B又依赖的类A，或者比较特殊的类A依赖了自己。</p>
<h2 id="Spring是如何解决循环依赖的"><a href="#Spring是如何解决循环依赖的" class="headerlink" title="Spring是如何解决循环依赖的"></a><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3485347/circular-dependency-in-spring">Spring是如何解决循环依赖的</a></h2><p><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/docs/3.0.x/spring-framework-reference/html/beans.html#d0e2299">Spring参考手册</a>解释了如何解决循环依赖。 Bean 首先被实例化，然后相互注入。</p>
<h2 id="什么情况下循环依赖可以被处理"><a href="#什么情况下循环依赖可以被处理" class="headerlink" title="什么情况下循环依赖可以被处理"></a>什么情况下循环依赖可以被处理</h2><p>单例的Setter注入。</p>
<h2 id="Spring三级缓存"><a href="#Spring三级缓存" class="headerlink" title="Spring三级缓存"></a><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000023647227">Spring三级缓存</a></h2><p>Spring解决循环依赖的核心思想在于‘提前曝光’：</p>
<ol>
<li>通过构建函数创建A对象（A对象是半成品，还没注入属性和调用init方法）。</li>
<li>A对象需要注入B对象，发现缓存里还没有B对象，将<code>半成品对象A</code>放入<code>半成品缓存</code>。</li>
<li>通过构建函数创建B对象（B对象是半成品，还没注入属性和调用init方法）。</li>
<li>B对象需要注入A对象，从<code>半成品缓存</code>里取到<code>半成品对象A</code>。</li>
<li>B对象继续注入其他属性和初始化，之后将<code>完成品B对象</code>放入<code>完成品缓存</code>。</li>
<li>A对象继续注入属性，从<code>完成品缓存</code>中取到<code>完成品B对象</code>并注入。</li>
<li>A对象继续注入其他属性和初始化，之后将<code>完成品A对象</code>放入<code>完成品缓存</code>。</li>
</ol>
<p>其中缓存有三级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Cache of singleton objects: bean name to bean instance. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">256</span>);<br><br><span class="hljs-comment">/** Cache of early singleton objects: bean name to bean instance. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br><br><br><span class="hljs-comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>缓存</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>singletonObjects</td>
<td>第一级缓存，存放可用的<code>成品Bean</code>。</td>
</tr>
<tr>
<td>earlySingletonObjects</td>
<td>第二级缓存，存放<code>半成品的Bean</code>，<code>半成品的Bean</code>是已创建对象，但是未注入属性和初始化。用以解决循环依赖。</td>
</tr>
<tr>
<td>singletonFactories</td>
<td>第三级缓存，存的是<code>Bean工厂对象</code>，用来生成<code>半成品的Bean</code>并放入到二级缓存中。用以解决循环依赖。</td>
</tr>
</tbody></table>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li>王磊. Offer来了:Java面试核心知识点精讲. 北京: 电子工业出版社.</li>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.nowcoder.com/issue/tutorial?tutorialId=94&uuid=267c9e9807174a559975edf9901aa8e2">https://www.nowcoder.com/issue/tutorial?tutorialId=94&amp;uuid=267c9e9807174a559975edf9901aa8e2</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io">Song Baoru</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://songbaoru.github.io/2023/05/05/Spring/">https://songbaoru.github.io/2023/05/05/Spring/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Spring/">Spring</a></div><div class="post_share"><div class="social-share" data-image="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/Spring.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/06/MySQL/" title="MySQL"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/MySQL.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">MySQL</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/03/JVM%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" title="JVM底层原理"><img class="cover" src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/JVM%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">JVM底层原理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Song Baoru</div><div class="author-info__description">锲而不舍，金石可镂</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">10</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">10</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/SongBaoru"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">Spring特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E7%9A%84%E6%A0%B8%E5%BF%83JAR%E5%8C%85"><span class="toc-number">2.</span> <span class="toc-text">Spring的核心JAR包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-IoC%E5%8E%9F%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">Spring IoC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IoC%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">IoC简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E8%A3%85%E9%85%8D%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">Bean的装配流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">3.3.</span> <span class="toc-text">Bean的作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.4.</span> <span class="toc-text">Bean的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BeanFactory"><span class="toc-number">3.5.</span> <span class="toc-text">BeanFactory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bean%E5%AE%9A%E4%B9%89%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.6.</span> <span class="toc-text">Bean定义相关注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%85%A5Bean%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">3.7.</span> <span class="toc-text">注入Bean的注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-AOP%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">Spring AOP原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">Spring AOP简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">4.2.</span> <span class="toc-text">Spring AOP 的核心概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E7%9A%845%E7%A7%8D%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">Spring AOP的5种通知类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">4.4.</span> <span class="toc-text">Spring AOP通知类型的应用例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.5.</span> <span class="toc-text">Spring AOP相关注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-AOP%E5%92%8CAspectJ-AOP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.6.</span> <span class="toc-text">Spring AOP和AspectJ AOP的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E5%88%87%E9%9D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">4.7.</span> <span class="toc-text">多个切面的执行顺序控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-MVC%E5%8E%9F%E7%90%86"><span class="toc-number">5.</span> <span class="toc-text">Spring MVC原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC%E7%AE%80%E4%BB%8B"><span class="toc-number">5.1.</span> <span class="toc-text">Spring MVC简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring-MVC-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">5.2.</span> <span class="toc-text">Spring MVC 的核心组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringMVC%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">5.3.</span> <span class="toc-text">SpringMVC的执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84Web%E6%B3%A8%E8%A7%A3"><span class="toc-number">5.4.</span> <span class="toc-text">常用的Web注解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E4%BA%8B%E5%8A%A1"><span class="toc-number">6.</span> <span class="toc-text">Spring事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E7%94%A8%E6%B3%95"><span class="toc-number">6.1.</span> <span class="toc-text">Spring的事务管理用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">Spring的事务传播方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text">Spring的事务隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional-rollbackFor-x3D-Exception-class-%E6%B3%A8%E8%A7%A3"><span class="toc-number">6.4.</span> <span class="toc-text">@Transactional(rollbackFor &#x3D; Exception.class)注解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transactional%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF"><span class="toc-number">6.5.</span> <span class="toc-text">@Transactional失效场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Boot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">Spring Boot启动流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E7%94%A8%E5%88%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">Spring用到的设计模式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98"><span class="toc-number">9.</span> <span class="toc-text">Spring怎样解决循环依赖问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">9.1.</span> <span class="toc-text">循环依赖是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E7%9A%84"><span class="toc-number">9.2.</span> <span class="toc-text">Spring是如何解决循环依赖的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%A4%84%E7%90%86"><span class="toc-number">9.3.</span> <span class="toc-text">什么情况下循环依赖可以被处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="toc-number">9.4.</span> <span class="toc-text">Spring三级缓存</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#References"><span class="toc-number">10.</span> <span class="toc-text">References</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法二刷"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构和算法二刷"/></a><div class="content"><a class="title" href="/2023/07/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/" title="数据结构和算法二刷">数据结构和算法二刷</a><time datetime="2023-07-10T00:32:48.000Z" title="Created 2023-07-10 08:32:48">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/RocketMQ/" title="RocketMQ"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/RocketMQ.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RocketMQ"/></a><div class="content"><a class="title" href="/2023/05/24/RocketMQ/" title="RocketMQ">RocketMQ</a><time datetime="2023-05-24T08:13:44.000Z" title="Created 2023-05-24 16:13:44">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/SpringCloud.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Spring Cloud"/></a><div class="content"><a class="title" href="/2023/05/24/Spring-Cloud/" title="Spring Cloud">Spring Cloud</a><time datetime="2023-05-24T08:08:42.000Z" title="Created 2023-05-24 16:08:42">2023-05-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发编程"/></a><div class="content"><a class="title" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="Java并发编程">Java并发编程</a><time datetime="2023-05-07T13:39:13.000Z" title="Created 2023-05-07 21:39:13">2023-05-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img src="https://note-1259153703.cos.ap-nanjing.myqcloud.com/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络"/></a><div class="content"><a class="title" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络">计算机网络</a><time datetime="2023-05-07T13:37:05.000Z" title="Created 2023-05-07 21:37:05">2023-05-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Song Baoru</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/algoliasearch-lite.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>