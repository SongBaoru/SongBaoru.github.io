<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"songbaoru.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.15.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="SBR Blog">
<meta property="og:url" content="https://songbaoru.github.io/index.html">
<meta property="og:site_name" content="SBR Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SBR">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://songbaoru.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>SBR Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">SBR Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">SBR</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/07/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" class="post-title-link" itemprop="url">Java并发编程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-07 21:39:13" itemprop="dateCreated datePublished" datetime="2023-05-07T21:39:13+08:00">2023-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" class="post-title-link" itemprop="url">计算机网络</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-07 21:37:05" itemprop="dateCreated datePublished" datetime="2023-05-07T21:37:05+08:00">2023-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/06/MyBatis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/06/MyBatis/" class="post-title-link" itemprop="url">MyBatis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-05-06 11:04:46 / Modified: 11:09:08" itemprop="dateCreated datePublished" datetime="2023-05-06T11:04:46+08:00">2023-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="MyBatis缓存"><a href="#MyBatis缓存" class="headerlink" title="MyBatis缓存"></a>MyBatis缓存</h1><p>MyBatis的缓存分为一级缓存和二级缓存，一级缓存是默认开启的，而且不能关闭</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/06/Kafka/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/06/Kafka/" class="post-title-link" itemprop="url">Kafka</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-06 11:03:13" itemprop="dateCreated datePublished" datetime="2023-05-06T11:03:13+08:00">2023-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/06/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/06/Redis/" class="post-title-link" itemprop="url">Redis</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-06 11:03:01" itemprop="dateCreated datePublished" datetime="2023-05-06T11:03:01+08:00">2023-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/06/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/06/MySQL/" class="post-title-link" itemprop="url">MySQL</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-05-06 11:02:46 / Modified: 11:04:49" itemprop="dateCreated datePublished" datetime="2023-05-06T11:02:46+08:00">2023-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/05/Spring%E6%BA%90%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/05/Spring%E6%BA%90%E7%A0%81/" class="post-title-link" itemprop="url">Spring源码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-05 21:02:38" itemprop="dateCreated datePublished" datetime="2023-05-05T21:02:38+08:00">2023-05-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 21:49:07" itemprop="dateModified" datetime="2023-05-07T21:49:07+08:00">2023-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Spring特性"><a href="#Spring特性" class="headerlink" title="Spring特性"></a>Spring特性</h1><p>Spring基于J2EE技术实现了一套轻量的Java Web Service系统应用框架，有很多优秀的特性，包括，依赖注入（DI）、控制反转（IoC）、面向切面（AOP）、轻量、灵活</p>
<ol>
<li>控制反转<ol>
<li>指的是对象依赖的对象，将会在容器的初始化完成后会主动传递给对象，而不需要对象自己创建或查询其依赖的对象，实现了系统对象之间依赖的解耦</li>
<li>Spring通过依赖注入实现控制反转，依赖注入是一种设计模式，通过该模式，对象不再创建或管理它们所需要的其他对象或服务，而是由容器（例如Spring容器）负责创建和管理这些对象或服务，并注入到需要它们的对象中。</li>
</ol>
</li>
<li>面向切面<ol>
<li>面向切面是一种编程范式，用于将系统的横切关注点（如安全性、事务、日志记录等）与业务逻辑分离</li>
<li>面向切面通过将横切关注点划分为独立的模块，并在运行时动态地将这些模块植入到程序中，从而实现了对业务逻辑的无侵入式增强</li>
<li>Spring AOP通过使用动态代理技术来实现对目标对象的增强</li>
</ol>
</li>
<li>轻量<ol>
<li>spring-web-5.2.0.RELEASE.jar和spring-core-5.2.0.RELEASE.jar均仅有1.4M左右</li>
<li>只需要少量的操作系统资源</li>
</ol>
</li>
<li>灵活<ol>
<li>是模块化的，可以按需引入模块（以jar包依赖的方式引入）</li>
</ol>
</li>
</ol>
<h1 id="Spring的核心JAR包"><a href="#Spring的核心JAR包" class="headerlink" title="Spring的核心JAR包"></a>Spring的核心JAR包</h1><p>Spring是模块化实现的，每个模块对应不同的JAR包</p>
<p>Spring框架的所有JAR包：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>spring-aop</td>
<td>提供了Spring框架的面向切面编程（AOP）功能，用于在运行时动态地增强应用程序的功能。</td>
</tr>
<tr>
<td>spring-aspects</td>
<td>提供了Spring框架的切面库，包括对AspectJ切面的支持和一些通用切面的实现。</td>
</tr>
<tr>
<td>spring-beans</td>
<td>提供了Spring框架的BeanFactory和FactoryBean等工厂类，用于管理和配置应用程序中的对象。</td>
</tr>
<tr>
<td>spring-context</td>
<td>提供了Spring框架的应用上下文（ApplicationContext），用于管理应用程序中的Bean对象，以及Spring框架的事件驱动编程模型。</td>
</tr>
<tr>
<td>spring-context-indexer</td>
<td>提供了一个工具，用于在编译时为Spring应用程序生成索引文件，以提高应用程序启动的速度。</td>
</tr>
<tr>
<td>spring-context-support</td>
<td>提供了一些扩展类，用于在Spring应用程序中支持特定的应用场景，例如JPA、Velocity等。</td>
</tr>
<tr>
<td>spring-core</td>
<td>Spring框架的核心模块，提供了Spring框架的基本功能，如依赖注入、控制反转、Bean工厂等。</td>
</tr>
<tr>
<td>spring-expression</td>
<td>提供了Spring框架的表达式语言（SpEL），用于在应用程序中动态地访问和操作对象。</td>
</tr>
<tr>
<td>spring-instrument</td>
<td>提供了Spring框架的Instrumentation API支持，用于在运行时通过Java Agent来提供增强功能。</td>
</tr>
<tr>
<td>spring-instrument-tomcat</td>
<td>提供了Spring框架在Tomcat服务器中使用Instrumentation API的支持。</td>
</tr>
<tr>
<td>spring-jcl</td>
<td>提供了Spring框架的通用日志抽象库，可以在不同的日志实现之间进行切换。</td>
</tr>
<tr>
<td>spring-jdbc</td>
<td>提供了Spring框架的JDBC支持，包括对JdbcTemplate和NamedParameterJdbcTemplate等的封装。</td>
</tr>
<tr>
<td>spring-jms</td>
<td>提供了Spring框架的Java Message Service（JMS）支持，用于在应用程序中发送和接收消息。</td>
</tr>
<tr>
<td>spring-messaging</td>
<td>提供了Spring框架的消息处理功能，包括对WebSocket、STOMP、AMQP等协议的支持。</td>
</tr>
<tr>
<td>spring-orm</td>
<td>提供了Spring框架的对象关系映射（ORM）支持，包括对Hibernate、MyBatis等ORM框架的集成。</td>
</tr>
<tr>
<td>spring-oxm</td>
<td>提供了Spring框架的对象XML映射（OXM）支持，用于在Java对象和XML文档之间进行转换。</td>
</tr>
<tr>
<td>spring-test</td>
<td>提供了Spring框架的测试支持，包括对JUnit、TestNG等测试框架的集成，以及对Spring应用程序的集成测试支持。</td>
</tr>
<tr>
<td>spring-tx</td>
<td>提供了Spring框</td>
</tr>
</tbody></table>
<h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><p>Spring的注解将Bean的定义和依赖关系从XML配置中解放出来，应用程序只要使用注解依赖注入即可</p>
<p>Bean具体的定义和依赖关系由Spring的自动装配完成</p>
<h2 id="依赖注入相关注解"><a href="#依赖注入相关注解" class="headerlink" title="依赖注入相关注解"></a>依赖注入相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Autowired</td>
<td>自动注入</td>
<td>根据类型进行自动注入，如果有多个符合条件的Bean，可以通过指定名称或限定符来进行注入。</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>限定符</td>
<td>与@Autowired一起使用，指定Bean的名称或限定符，以便进行注入。</td>
</tr>
<tr>
<td>@Resource</td>
<td>资源注入</td>
<td>根据名称进行自动注入，可以与指定类型或名称的方式进行限定。</td>
</tr>
<tr>
<td>@Value</td>
<td>属性注入</td>
<td>用于注入常量或表达式计算的结果值。</td>
</tr>
<tr>
<td>@Inject</td>
<td>JSR-330注解</td>
<td>与@Autowired类似，但具有更加灵活的限定符支持。</td>
</tr>
</tbody></table>
<h2 id="Bean定义相关注解"><a href="#Bean定义相关注解" class="headerlink" title="Bean定义相关注解"></a>Bean定义相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Component</td>
<td>通用组件</td>
<td>用于将类定义为Spring组件，并且可以与其他注解一起使用，如@Controller、@Service、@Repository等。</td>
</tr>
<tr>
<td>@Configuration</td>
<td>配置类</td>
<td>用于定义Spring应用程序的配置类，并且可以通过@Bean方法定义Bean对象。</td>
</tr>
<tr>
<td>@Bean</td>
<td>Bean定义</td>
<td>用于在配置类中定义Bean对象，并将其添加到Spring容器中。</td>
</tr>
<tr>
<td>@Profile</td>
<td>环境选择</td>
<td>用于基于不同的应用程序环境选择Bean定义，可以与@Conditional一起使用。</td>
</tr>
<tr>
<td>@Scope</td>
<td>Bean作用域</td>
<td>用于定义Bean对象的作用域，包括Singleton、Prototype、Request、Session等。</td>
</tr>
</tbody></table>
<h2 id="AOP相关注解"><a href="#AOP相关注解" class="headerlink" title="AOP相关注解"></a>AOP相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Aspect</td>
<td>切面定义</td>
<td>用于将类定义为切面，可以在其中定义切点和通知。</td>
</tr>
<tr>
<td>@Pointcut</td>
<td>切点定义</td>
<td>用于定义切点，指定连接点的匹配规则。</td>
</tr>
<tr>
<td>@Before</td>
<td>前置通知</td>
<td>在方法执行之前执行通知。</td>
</tr>
<tr>
<td>@After</td>
<td>后置通知</td>
<td>在方法执行之后执行通知。</td>
</tr>
<tr>
<td>@AfterReturning</td>
<td>返回通知</td>
<td>在方法执行之后返回结果后执行通知。</td>
</tr>
<tr>
<td>@AfterThrowing</td>
<td>异常通知</td>
<td>在方法执行时抛出异常后执行通知。</td>
</tr>
<tr>
<td>@Around</td>
<td>环绕通知</td>
<td>在方法执行之前和之后都可以执行通知。</td>
</tr>
</tbody></table>
<h2 id="Web相关注解"><a href="#Web相关注解" class="headerlink" title="Web相关注解"></a>Web相关注解</h2><table>
<thead>
<tr>
<th>注解</th>
<th>翻译名称</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>@Controller</td>
<td>控制器</td>
<td>用于将类定义为Spring MVC的控制器，处理HTTP请求并返回响应结果。</td>
</tr>
<tr>
<td>@RestController</td>
<td>REST控制器</td>
<td>与@Controller类似，但默认情况下返回JSON或XML格式的响应结果。</td>
</tr>
<tr>
<td>@RequestMapping</td>
<td>请求映射</td>
<td>用于将HTTP请求映射到处理方法上，并指定请求的URL、请求方法、请求参数等。</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>GET请求映射</td>
<td>用于将HTTP GET请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>POST请求映射</td>
<td>用于将HTTP POST请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PutMapping</td>
<td>PUT请求映射</td>
<td>用于将HTTP PUT请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@DeleteMapping</td>
<td>DELETE请求映射</td>
<td>用于将HTTP DELETE请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PatchMapping</td>
<td>PATCH请求映射</td>
<td>用于将HTTP PATCH请求映射到处理方法上，简化了@RequestMapping的用法。</td>
</tr>
<tr>
<td>@PathVariable</td>
<td>路径变量</td>
<td>用于将URI中的变量绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>请求参数</td>
<td>用于将HTTP请求中的参数绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>请求体</td>
<td>用于将HTTP请求体中的数据绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@RequestHeader</td>
<td>请求头</td>
<td>用于将HTTP请求头中的数据绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@CookieValue</td>
<td>Cookie值</td>
<td>用于将HTTP Cookie中的值绑定到处理方法的参数上。</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>响应体</td>
<td>用于将处理方法的返回值作为HTTP响应体返回给客户端。</td>
</tr>
<tr>
<td>@ResponseStatus</td>
<td>响应状态码</td>
<td>用于指定处理方法的返回状态码。</td>
</tr>
<tr>
<td>@SessionAttributes</td>
<td>会话属性</td>
<td>用于在会话中存储处理方法的模型属性。</td>
</tr>
<tr>
<td>@ModelAttribute</td>
<td>模型属性</td>
<td>用于将请求参数绑定到模型属性上。</td>
</tr>
<tr>
<td>@InitBinder</td>
<td>初始化绑定器</td>
<td>用于初始化WebDataBinder，用于数据绑定和格式化等操作。</td>
</tr>
<tr>
<td>@ExceptionHandler</td>
<td>异常处理</td>
<td>用于处理控制器中抛出的异常。</td>
</tr>
<tr>
<td>@CrossOrigin</td>
<td>跨域资源共享</td>
<td>用于处理跨域请求，允许指定允许跨域请求的来源、方法和头信息等。</td>
</tr>
</tbody></table>
<h1 id="Spring-IoC原理"><a href="#Spring-IoC原理" class="headerlink" title="Spring IoC原理"></a>Spring IoC原理</h1><h2 id="IoC简介"><a href="#IoC简介" class="headerlink" title="IoC简介"></a>IoC简介</h2><p>Spring IoC通过Java反射功能实例化并建立Bean之间的依赖关系</p>
<p>Spring IoC在完成这些底层工作的基础上，还提供了Bean实例缓存管理、Bean生命周期管理、Bean实例代理、事件发布和资源装载等高级服务</p>
<h2 id="Bean的装配流程"><a href="#Bean的装配流程" class="headerlink" title="Bean的装配流程"></a>Bean的装配流程</h2><p>Spring通过读取XML或注解获取Bean的配置信息，并在Bean容器中生成Bean配置注册表，然后根据配置注册表实例化Bean，将Bean实例载入Bean缓存池，业务程序就可以从Bean缓存池中获取Bean</p>
<h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p>Bean有五种作用域：</p>
<ul>
<li>Singleton：单例作用域，表示在 Spring IoC 容器中只存在一个 Bean 对象实例，所有对该 Bean 的请求都将返回该唯一实例。</li>
<li>Prototype：原型作用域，每次对该 Bean 的请求都将创建一个新的 Bean 实例。每次使用时都会创建新的对象。</li>
<li>Request：请求作用域，每个 HTTP 请求都将创建一个新的 Bean 实例，该 Bean 仅在当前 HTTP 请求中有效。</li>
<li>Session：会话作用域，每个 HTTP 会话都将创建一个新的 Bean 实例，该 Bean 仅在当前 HTTP 会话中有效。</li>
<li>GlobalSession：全局会话作用域，仅适用于使用基于 Portlet 的 web 应用。它是在一个全局的 Portlet 会话中共享的 Bean 实例。</li>
</ul>
<p>除了这五种标准作用域外，Spring 还支持自定义作用域。在 Spring 中，我们可以通过实现 Scope 接口并重写对应方法来实现自定义作用域。这样可以让我们更加灵活地管理 Bean 的生命周期，以满足应用程序的特定需求。</p>
<h2 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h2><p>Spring Bean 的生命周期是 Spring IoC 容器管理的重要部分，它由一系列的回调函数来控制。在 Spring 容器创建 Bean 实例对象时，会经历以下阶段：</p>
<ol>
<li><p>Bean 实例化：Spring IoC 容器通过反射机制实例化一个 Bean 对象，通常是使用默认的构造函数来创建 Bean 实例。</p>
</li>
<li><p>属性注入：Spring IoC 容器通过 setter 方法或者直接访问 Bean 属性来注入 Bean 的属性。</p>
</li>
<li><p>BeanPostProcessor 前置处理器：在 Bean 实例化之后，Spring IoC 容器会自动检测是否有实现了 BeanPostProcessor 接口的类，并调用它们的 postProcessBeforeInitialization() 方法来对 Bean 进行前置处理。</p>
</li>
<li><p>初始化：Spring IoC 容器调用 Bean 实现 InitializingBean 接口或者配置的 init-method 方法，执行 Bean 的初始化操作。</p>
</li>
<li><p>BeanPostProcessor 后置处理器：在 Bean 初始化之后，Spring IoC 容器会自动检测是否有实现了 BeanPostProcessor 接口的类，并调用它们的 postProcessAfterInitialization() 方法来对 Bean 进行后置处理。</p>
</li>
<li><p>使用：Bean 实例化完成并初始化后，就可以在应用程序中使用它了。</p>
</li>
<li><p>销毁：当 Spring IoC 容器关闭时，它会调用 Bean 实现 DisposableBean 接口或者配置的 destroy-method 方法，执行 Bean 的销毁操作。</p>
</li>
</ol>
<p>此外，Spring Bean 的生命周期可以被定制化，我们可以自定义 BeanPostProcessor 实现类或者配置 init-method 和 destroy-method 方法，来在 Bean 的生命周期中加入自己的逻辑处理。</p>
<p>BeanPostProcessor 前置处理器是 Spring IoC 容器中的一个扩展点，用于在 Bean 的初始化前进行额外的处理，可以对 Bean 对象进行修改或增强。BeanPostProcessor 接口定义了两个方法：</p>
<ol>
<li><p>postProcessBeforeInitialization(Object bean, String beanName)：在 Bean 初始化之前调用该方法，可以对 Bean 对象进行一些修改或增强操作。</p>
</li>
<li><p>postProcessAfterInitialization(Object bean, String beanName)：在 Bean 初始化之后调用该方法，可以对 Bean 对象进行一些修改或增强操作。</p>
</li>
</ol>
<p>在 Spring IoC 容器中，当一个 Bean 实例化完成后，会检查是否有实现了 BeanPostProcessor 接口的类，如果有，则会依次调用它们的 postProcessBeforeInitialization() 方法，然后进行 Bean 的初始化操作，最后再依次调用实现了 BeanPostProcessor 接口的类的 postProcessAfterInitialization() 方法。通过实现 BeanPostProcessor 接口，我们可以在 Bean 实例化前后进行一些自定义的操作，例如：</p>
<ol>
<li><p>为 Bean 注入日志处理、事务处理等公共的功能。</p>
</li>
<li><p>在 Bean 初始化前后进行性能监控、安全检查等操作。</p>
</li>
<li><p>对 Bean 进行代理，实现 AOP 的功能。</p>
</li>
</ol>
<p>需要注意的是，在实现 BeanPostProcessor 接口时，必须小心处理，以免破坏 Bean 的正常生命周期。同时，也应该尽量保持 BeanPostProcessor 的轻量级，避免对系统性能产生过大的影响。</p>
<p>总之，BeanPostProcessor 前置处理器是 Spring IoC 容器中的一个重要扩展点，通过实现该接口，可以在 Bean 实例化前后进行一些自定义的操作，从而增强 Bean 的功能和灵活性。</p>
<h1 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h1><h2 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h2><p>Spring AOP通过面向切面技术，将与业务无关或被业务模块共用的代码封装起来，以提高代码的复用度，降低模块间的耦合度</p>
<h2 id="AOP-的核心概念"><a href="#AOP-的核心概念" class="headerlink" title="AOP 的核心概念"></a>AOP 的核心概念</h2><table>
<thead>
<tr>
<th>概念</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>切面（Aspect）</td>
<td>对一个或多个横切关注点的封装，它包含了切点、通知和切点表达式等元素。切面定义了何时、何地以及如何将横切关注点织入到目标对象中。</td>
</tr>
<tr>
<td>切点（Pointcut）</td>
<td>目标对象中的一组方法或者类，它们将被织入到横切关注点中。切点通常由切点表达式和其他过滤条件组成。</td>
</tr>
<tr>
<td>通知（Advice）</td>
<td>在织入横切关注点时要执行的逻辑代码，它包括了前置通知、后置通知、环绕通知、异常通知和最终通知等不同类型。</td>
</tr>
<tr>
<td>切点表达式（Pointcut Expression）</td>
<td>一种指定切点的语法规则，它可以根据方法名、返回值类型、方法参数等多种条件进行切点匹配。</td>
</tr>
<tr>
<td>连接点（Join Point）</td>
<td>程序执行过程中的某个特定位置，例如方法调用、方法执行、异常抛出等。连接点是织入横切关注点的具体执行位置。</td>
</tr>
<tr>
<td>织入（Weaving）</td>
<td>将横切关注点应用到目标对象的过程，它可以通过代理模式实现。在 Spring AOP 中，织入分为编译期织入、类装载期织入和运行期织入三种方式。</td>
</tr>
</tbody></table>
<p>上述概念是 Spring AOP 技术中的核心要素，了解这些概念对于掌握和使用 Spring AOP 技术非常重要。切面、切点、通知和切点表达式是定义 AOP 配置的基础，连接点则表示切点匹配到的具体执行位置，织入则是实现 AOP 功能的核心机制。</p>
<h2 id="AOP横切关注点"><a href="#AOP横切关注点" class="headerlink" title="AOP横切关注点"></a>AOP横切关注点</h2><p>Srping将应用分为核心关注点和横切关注点两部分</p>
<ul>
<li><p>核心关注点（Core Concerns）是指应用程序的基本业务逻辑，例如数据访问、业务逻辑处理等。核心关注点是应用程序的主要功能，通常是由应用程序开发人员直接实现的。</p>
</li>
<li><p>横切关注点（Cross-Cutting Concerns）是指应用程序中与核心业务逻辑无关的横切问题，例如日志记录、事务管理、安全控制等。</p>
</li>
</ul>
<p>在 Spring AOP 中，横切关注点可以通过定义切面（Aspect）来实现。通常情况下，切面是一个 Java 类，其中包含了一些切点（Pointcut）、通知（Advice）和切点表达式（Pointcut Expression）等元素。</p>
<ul>
<li>切点（Pointcut）：用于定义一个或多个目标对象中哪些方法需要被织入横切关注点。</li>
<li>通知（Advice）：定义了横切关注点在目标对象中何时被执行以及执行的逻辑。</li>
<li>切点表达式（Pointcut Expression）：用于指定切点的匹配规则。</li>
</ul>
<p>Spring AOP 的实现是基于代理模式的，它通过创建代理对象来织入切面逻辑。Spring AOP 支持两种代理方式：JDK 动态代理和 CGLIB 代理。对于实现了接口的类，Spring AOP 将使用 JDK 动态代理来创建代理对象；对于没有实现接口的类，Spring AOP 将使用 CGLIB 代理来创建代理对象。</p>
<h2 id="AOP的5种通知类型"><a href="#AOP的5种通知类型" class="headerlink" title="AOP的5种通知类型"></a>AOP的5种通知类型</h2><p>Spring AOP 提供了以下五种类型的通知：</p>
<ul>
<li>前置通知（Before Advice）：在目标方法执行前执行。</li>
<li>后置通知（After Returning Advice）：在目标方法返回后执行。</li>
<li>环绕通知（Around Advice）：在目标方法执行前后都执行。</li>
<li>异常通知（After Throwing Advice）：在目标方法抛出异常时执行。</li>
<li>最终通知（After Advice）：无论目标方法是否正常执行完成，最终通知都会被执行。</li>
</ul>
<h2 id="AOP的应用"><a href="#AOP的应用" class="headerlink" title="AOP的应用"></a>AOP的应用</h2><table>
<thead>
<tr>
<th>应用场景</th>
<th>切面类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>日志记录</td>
<td>前置通知（Before）</td>
<td>在用户登录时记录登录时间和 IP 地址</td>
</tr>
<tr>
<td>性能监控</td>
<td>环绕通知（Around）</td>
<td>在对数据库进行查询时统计查询时间和资源占用情况</td>
</tr>
<tr>
<td>安全控制</td>
<td>前置通知（Before）</td>
<td>在访问受保护的资源时检查用户的身份和权限信息</td>
</tr>
<tr>
<td>事务管理</td>
<td>环绕通知（Around）</td>
<td>在对数据库进行更新操作时开启和提交事务</td>
</tr>
<tr>
<td>异常处理</td>
<td>异常通知（AfterThrowing）</td>
<td>在文件上传时捕获文件格式不正确等异常信息，并进行相应的处理</td>
</tr>
</tbody></table>
<h1 id="Spring-MVC原理"><a href="#Spring-MVC原理" class="headerlink" title="Spring MVC原理"></a>Spring MVC原理</h1><h2 id="MVC简介"><a href="#MVC简介" class="headerlink" title="MVC简介"></a>MVC简介</h2><p>Spring的MVC即模型-视图-控制器，该框架围绕DispatcherServlet设计而成，DispatcherServlet会把请求分发给各个处理器</p>
<p>SpringMVC 的工作流程主要包括以下几个步骤：</p>
<ol>
<li><p>客户端发送请求：客户端向服务器发送请求，请求可以是一个 URL 地址、一个表单提交或者一个 AJAX 请求。</p>
</li>
<li><p>DispatcherServlet 接收请求：DispatcherServlet 是 SpringMVC 框架的核心控制器，它负责接收客户端发送的请求，并将请求转发给对应的处理器。</p>
</li>
<li><p>HandlerMapping 查找处理器：HandlerMapping 负责根据请求 URL 查找对应的处理器，处理器可以是一个 Controller 或者一个 Restful Web Service。</p>
</li>
<li><p>HandlerAdapter 调用处理器：HandlerAdapter 负责调用处理器，将请求传递给处理器进行处理，并获取处理器的处理结果。</p>
</li>
<li><p>处理器处理请求：处理器根据请求的类型和参数，进行相应的业务处理，并返回一个 ModelAndView 对象。</p>
</li>
<li><p>视图解析器解析视图：视图解析器根据 ModelAndView 中的视图名，将其解析成对应的视图对象，视图可以是一个 JSP 页面、一个 Thymeleaf 模板或者一个 HTML 片段等。</p>
</li>
<li><p>渲染视图：视图对象根据数据模型和视图模板，生成 HTML 内容，并将其返回给客户端。</p>
</li>
<li><p>返回响应：DispatcherServlet 将视图渲染的结果返回给客户端，客户端可以是一个浏览器、一个移动应用或者一个 API 调用。</p>
</li>
</ol>
<p>总之，SpringMVC 的工作流程涉及到多个组件之间的协作，其中 DispatcherServlet 负责接收请求和控制流程，HandlerMapping 负责查找处理器，HandlerAdapter 负责调用处理器，视图解析器负责解析视图，视图对象负责渲染视图，最终将响应返回给客户端。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/05/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/05/%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE/" class="post-title-link" itemprop="url">秒杀项目</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>
      

      <time title="Created: 2023-05-05 20:55:32 / Modified: 21:00:17" itemprop="dateCreated datePublished" datetime="2023-05-05T20:55:32+08:00">2023-05-05</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><p>SpringBoot项目会以自动化的配置的形式自动加载到项目对应的工程当中</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/03/JVM%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/03/JVM%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">JVM底层原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-03 09:21:36" itemprop="dateCreated datePublished" datetime="2023-05-03T09:21:36+08:00">2023-05-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-08 12:18:49" itemprop="dateModified" datetime="2023-05-08T12:18:49+08:00">2023-05-08</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>JVM（Java Virtual Machine）用于运行Java字节码</p>
</blockquote>
<h1 id="JVM结构规范和执行流程"><a href="#JVM结构规范和执行流程" class="headerlink" title="JVM结构规范和执行流程"></a>JVM结构规范和执行流程</h1><h2 id="JVM的结构及其作用"><a href="#JVM的结构及其作用" class="headerlink" title="JVM的结构及其作用"></a>JVM的结构及其作用</h2><p>JVM 主要由以下部分组成：类加载器、运行时数据区、执行引擎和本地方法接口</p>
<ol>
<li><p>类加载器：类加载器负责将类文件（.class 文件）加载到 JVM 中，并生成对应的 Class 对象。类加载器是 JVM 的一个重要组成部分，它将类文件加载到 JVM 中，并根据需要进行链接、验证和初始化。类加载器按照类文件的位置、来源和访问权限等进行分类，通常分为三种类型：引导类加载器、扩展类加载器和应用程序类加载器。</p>
</li>
<li><p>运行时数据区：运行时数据区即 JVM 内存，存储JVM在运行过程中产生的数据，它由多个不同的数据区域组成，包括方法区、堆、虚拟机栈、本地方法栈和程序计数器等。</p>
<p>每个线程都有自己的虚拟机栈和本地方法栈，用于存储方法的参数、局部变量和返回值等信息。堆用于存储对象实例，方法区用于存储类信息、常量、静态变量和编译器生成的代码等。虚拟机栈用于管理Java方法的调用。而本地方法栈则用于管理native方法（例如Thread.start()）的调用</p>
</li>
<li><p>执行引擎：Execution Engine 是 JVM 的核心组件，它负责执行在 JVM 中加载的字节码指令。它包括解释器和即时编译器两种执行方式。此外还包含垃圾回收器，用于内存管理，可以自动释放不再使用的内存空间</p>
</li>
<li><p>本地方法接口：Native Method Interface 允许 Java 程序与底层的本地系统交互，例如调用 C&#x2F;C++ 等语言编写的库</p>
</li>
</ol>
<h2 id="HotSpot-JVM内存模型"><a href="#HotSpot-JVM内存模型" class="headerlink" title="HotSpot JVM内存模型"></a>HotSpot JVM内存模型</h2><p>HotSpot JVM的JVM结构（可以划分为三类）：</p>
<p>线程私有区域</p>
<ul>
<li><p>Java虚拟机栈</p>
<p>“栈内存”通常指的就是这里的Java虚拟机栈</p>
<p>线程内存模型（栈帧）：存储了局部变量表、操作数栈、动态链接、方法出口等信息</p>
<ol>
<li>局部变量表存储的信息<ol>
<li>基本数据类型：局部变量表存储了基本数据类型的值，包括 int、long、float、double、byte、short 和 char。</li>
<li>对象引用：局部变量表还存储了对象引用，即指向对象实例在Java堆中的指针。对于类实例和数组，这些引用通常是指向堆内存中的对象实例的指针。</li>
<li>returnAddress类型：returnAddress类型用于存储字节码指令的地址。当Java虚拟机执行到一个方法调用指令时，它会将下一条要执行的指令的地址保存到局部变量表。当方法执行完毕后，Java虚拟机通过局部变量表中保存的returnAddress返回到调用者的代码中继续执行。</li>
</ol>
</li>
<li>局部变量表的容量以局部变量槽（Local Variable Slot）为单位进行度量。一个局部变量槽可以存储一个32位的数据类型（如int、float、reference和returnAddress），而64位的数据类型（如long和double）则需要两个连续的局部变量槽来存储。</li>
</ol>
<p>处理动态链接方法的返回值和异常处理分派</p>
<p>记录了方法的执行过程</p>
</li>
<li><p>本地方法栈</p>
<p>本地方法栈和Java虚拟机栈唯一的不同是，本地方法栈存储的是Native方法的数据，Java虚拟机栈存储的是Java方法的数据</p>
</li>
<li><p>程序计数器</p>
<p>如果该线程执行的是Native方法，则程序计数器的值为空</p>
</li>
</ul>
<p>线程共享区域：</p>
<ul>
<li><p>Java堆</p>
<p>JVM运行过程中创建的对象几乎都会被存储在堆中。</p>
<p>是垃圾收集器管理的内存区域，又称“GC堆”。由于JVM采用分代回收算法，Java 堆从GC（Garbage Collection）的角度还可以细分为新生代（Eden、SurvivorTo、SurvivorFrom）、老年代</p>
</li>
<li><p>方法区（元空间）</p>
<p>常量、静态变量、即时编译器编译后的代码、类型信息缓存等数据</p>
</li>
</ul>
<p>直接内存</p>
<p>又称“堆外内存”，NIO（New Input&#x2F;Output）类引入了一种基于通道（Channel）和缓冲区（Buffer）的I&#x2F;O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，避免在Java堆和Native堆中来回复制数据。</p>
<h2 id="JVM执行Java程序的流程"><a href="#JVM执行Java程序的流程" class="headerlink" title="JVM执行Java程序的流程"></a>JVM执行Java程序的流程</h2><ol>
<li>编译源代码文件：Java源代码需要通过编译器（如Javac）编译成字节码文件，文件扩展名为.class。编译器会检查源代码文件中的语法错误，并将源代码转换为可以在Java虚拟机上运行的字节码。</li>
<li>加载字节码文件：Java虚拟机（JVM）通过类加载器加载字节码文件。类加载器是JVM的组成部分，它的主要作用是动态地将Java类加载到内存中。</li>
<li>验证字节码文件：字节码文件需要经过验证来确保其符合Java虚拟机规范。验证过程主要涉及字节码文件的格式和内容是否正确、是否包含非法代码等。</li>
<li>解释字节码文件：Java虚拟机会解释字节码文件，并将其转换为机器可以理解的指令。</li>
<li>执行程序：最后，Java虚拟机会执行字节码文件中的指令，运行程序。</li>
</ol>
<h1 id="垃圾回收理论"><a href="#垃圾回收理论" class="headerlink" title="垃圾回收理论"></a>垃圾回收理论</h1><h2 id="判断一个对象是否存活的算法"><a href="#判断一个对象是否存活的算法" class="headerlink" title="判断一个对象是否存活的算法"></a>判断一个对象是否存活的算法</h2><ul>
<li>引用计数算法</li>
<li>可达性分析算法</li>
</ul>
<h2 id="分代回收理论"><a href="#分代回收理论" class="headerlink" title="分代回收理论"></a>分代回收理论</h2><p>分代收集理论建立在两个假说之上，分别是弱分代假说和强分代假说</p>
<p>根据对象的生命周期将内存分为新生代和老年代两个部分。优先回收新生代中的对象，减少全局垃圾回收的次数，提高效率。  回收效率高，不容易产生内存碎片。缺点是需要对内存进行分代管理，增加了复杂性。</p>
<h2 id="Apple式回收"><a href="#Apple式回收" class="headerlink" title="Apple式回收"></a>Apple式回收</h2><p>Apple式回收（基于分代收集理论和标记复制算法）：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上。然后直接清理掉Eden和已经使用过的那块Survivor。当存储存活对象的Survivor不足以容纳所有的存活对象，Apple式回收就使用其他内存区域（大多是老年代）进行分配担保。</p>
<h2 id="垃圾回收类型"><a href="#垃圾回收类型" class="headerlink" title="垃圾回收类型"></a>垃圾回收类型</h2><ul>
<li>部分收集<ul>
<li>新生代收集（Minor GC）</li>
<li>老年代收集（Major GC）</li>
</ul>
</li>
<li>整堆收集（Full GC）</li>
</ul>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><p>判断对象是否“存活”的方法有引用计数算法和可达性分析法。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>时间</th>
<th>基本原理</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>标记-清除算法</td>
<td>20世纪50年代</td>
<td>标记所有活动对象，然后清除所有未标记的对象。 也可以反过来。 是最基础的垃圾收集算法，后续的回收算法大都是以标记-清除算法为基础，对其缺点进行改进得到的。</td>
<td>简单易懂，可处理循环引用的情况。</td>
<td>效率不稳定，容易产生内存碎片。</td>
<td>由于，不需要内存移动，所以再内存回收时延迟低，关注延迟的CMS收集器则是基于标记-清除算法的，不过CMS收集器面临空间碎片过多时，会采用标记-整理算法清除一次。（用于老年代）</td>
</tr>
<tr>
<td>标记-复制算法</td>
<td>20世纪60年代</td>
<td>将内存分成已使用（From）和空闲（To）区域。在垃圾回收时，将存活的对象从 From 区域复制到 To 区域，然后清空 From 区域。现在的商业虚拟机都采用这种收集算法来回收新生代。</td>
<td>不容易产生内存碎片。</td>
<td>浪费一半内存空间。如果多数对象都是存活的，就会产生大量内存间的复制开销</td>
<td>由于，如果多数对象都是可回收的，需要复制的只是占少数的存活对象。所以适合新生代。现在的商用虚拟机大多优先采用这种算法回收新生代。（用于新生代）</td>
</tr>
<tr>
<td>标记-整理算法</td>
<td>20世纪60年代</td>
<td>其标记过程仍然和标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向内存空间的一端移动，然后直接清理掉边界外的内存。</td>
<td>不容易产生内存碎片。</td>
<td>需要移动对象，可能会造成较长的停顿时间。</td>
<td>由于，是否移动内存是优缺点并存的，移动则内存回收时会耗时，不移动则内存分配时会耗时。如果不移动内存，即使垃圾收集器的效率提高一些，则因为内存分配和访问比垃圾收集频率要高得多，这部分耗时增加，总的吞吐量仍然会下降。所以，关注吞吐量的Parallel Old是基于标记-整理算法的。（用于老年代）</td>
</tr>
</tbody></table>
<h2 id="HotSpot垃圾回收算法实现细节"><a href="#HotSpot垃圾回收算法实现细节" class="headerlink" title="HotSpot垃圾回收算法实现细节"></a>HotSpot垃圾回收算法实现细节</h2><p>根节点</p>
<p>安全点</p>
<p>并发可达性分析</p>
<h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><p>Java 的垃圾回收器有多种实现方式，每种垃圾回收器都有其独特的特点和适用场景。</p>
<h2 id="垃圾收集器下的并行和并发"><a href="#垃圾收集器下的并行和并发" class="headerlink" title="垃圾收集器下的并行和并发"></a>垃圾收集器下的并行和并发</h2><ul>
<li>并行：描述的是多条垃圾收集器线程之间的关系</li>
<li>并发：描述的是垃圾收集器和用户线程之间的关系</li>
</ul>
<h2 id="经典垃圾回收器"><a href="#经典垃圾回收器" class="headerlink" title="经典垃圾回收器"></a>经典垃圾回收器</h2><p>这里讨论的经典垃圾收集器是JDK7 Update4之后，JDK11正式发布之前，OracleJDK和HotSpot虚拟机所包含的全部可用的垃圾收集器。</p>
<h3 id="新生代垃圾回收器"><a href="#新生代垃圾回收器" class="headerlink" title="新生代垃圾回收器"></a>新生代垃圾回收器</h3><p>所有的新生代的垃圾回收器都是复制算法</p>
<table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th>优点</th>
<th>缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Serial</td>
<td>新生代，复制算法</td>
<td>单线程</td>
<td>所有收集器中内存消耗最小的</td>
<td>用户线程停顿时间长</td>
<td>单线程强调的是它在垃圾收集时，必须暂停其他所有工作线程，知道它收集完成。是HotSpot虚拟机运行在客户端模式下默认新生代收集器。适合处理器核心较少的环境。</td>
</tr>
<tr>
<td>ParNew</td>
<td>新生代，复制算法</td>
<td>并行的多线程收集器</td>
<td>只有ParNew能和CMS配合使用。有自适应的调节策略</td>
<td></td>
<td>实际上是Serial的多线程版本，除了同时使用多条线程进行垃圾收集外，其余都和Serial一样。默认开启和处理器核心数量相同的线程数，在目前服务器CPU往往达到32核核环境下，可以适用-XX:ParallelGCThreads参数来限制。</td>
</tr>
<tr>
<td>Parallel Scavenge</td>
<td>新生代，复制算法</td>
<td>并行的多线程收集器</td>
<td>吞吐量高</td>
<td></td>
<td>Parallel Scavenge的特点是它的关注点和其它收集器不同，Parallel Scavenge关注点是吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间和处理器总消耗时间的比值。其合适的搭配是Parallel Old</td>
</tr>
</tbody></table>
<h3 id="老年代垃圾收集器"><a href="#老年代垃圾收集器" class="headerlink" title="老年代垃圾收集器"></a>老年代垃圾收集器</h3><p>老年代会有两种算法，标记整理算法 和 标记清除算法</p>
<table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th>优点</th>
<th>缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Serial Old</td>
<td>老年代，标记整理算法</td>
<td>单线程</td>
<td></td>
<td></td>
<td>是Serial的老年代版本</td>
</tr>
<tr>
<td>Parallel Old</td>
<td>老年代，标记整理算法</td>
<td>并行的多线程收集器</td>
<td></td>
<td></td>
<td>是Parallel Scavenge的老年代版本</td>
</tr>
<tr>
<td>CMS</td>
<td>老年代，标记清除算法</td>
<td>并行与并发收集器</td>
<td>是一种以获取最短用户线程停顿时间为目标的收集器，适合关注服务响应速度的场景</td>
<td>内存碎片：标记清除的回收方法会导致内存碎片，影响大对象分配。 CPU资源消耗：并发执行需占用额外CPU资源，可能影响总体性能。 浮动垃圾：无法处理并发标记阶段产生的新垃圾，可能导致内存浪费。 预测性能不稳定：基于触发条件，设置不合理时可能导致停顿时间过长。 长时间Full GC：某些情况下，CMS无法回收足够空间，触发Full GC，导致停顿。 实现复杂：相对其他收集器，CMS实现复杂，维护困难，可能出现错误或性能问题。</td>
<td>运作过程相对复杂，整个过程分为四步：初始标记、并发标记、重新标记、并发清除。</td>
</tr>
</tbody></table>
<h3 id="全功能垃圾收集器"><a href="#全功能垃圾收集器" class="headerlink" title="全功能垃圾收集器"></a>全功能垃圾收集器</h3><table>
<thead>
<tr>
<th><strong>收集器</strong></th>
<th><strong>收集对象和算法</strong></th>
<th><strong>收集器类型</strong></th>
<th>优点</th>
<th>缺点</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>G1</td>
<td>跨新生代和老年代；化整为零</td>
<td>并行与并发收集器</td>
<td>回收的最小单元不再是固定大小的新生代和老年代，而是Region，进而采用具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</td>
<td></td>
<td>开创了面向局部收集的设计思路和基于Region的内存布局形式，不再以固定大小及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一杠Region根据需要，扮演新生代的Eden空间、Survior区间，或者老年代空间。并对不同角色的Region采用不同的策略去处理。Region中还有一类特殊的区域，Humongous，用来存储大对象。G1在大内存应用上表现好，CMS在小内存应用上表现优于G1。G1 垃圾收集器是 JDK 9 及其之后版本的默认垃圾收集器。</td>
</tr>
</tbody></table>
<h2 id="低延迟垃圾回收器"><a href="#低延迟垃圾回收器" class="headerlink" title="低延迟垃圾回收器"></a>低延迟垃圾回收器</h2><p>Shenandoah （<em>ˌʃɛnənˈdoʊə</em>）和ZGC两款垃圾收集器在几乎整个工作时间里都是并发的，而CMS和G1在回收新生代的垃圾时必须挂起用户线程。并且这两款垃圾收集器可以在任意可管理的堆容量下实现垃圾收集的停顿不超过十毫秒。</p>
<p>Shenandoah垃圾回收器是一款只有OpenJDK才会包含，而OracleJDK里不存在的收集器，Shenandoah和G1有着相似的堆内存布局，是基于G1开发的，并对G1的一些不足进行了改进</p>
<p>ZGC是一款基于Region内存布局的，使用了读屏障、染色体指针和内存多重映射等技术来实现可并发的标记-整理算法，以低延迟为首要目标的垃圾收集器</p>
<h2 id="不进行垃圾回收的垃圾收集器"><a href="#不进行垃圾回收的垃圾收集器" class="headerlink" title="不进行垃圾回收的垃圾收集器"></a>不进行垃圾回收的垃圾收集器</h2><p>Epsilon 垃圾回收器是一款以不进行垃圾回收的垃圾回收器，只复责分配和释放内存空间、与解释器协作、与编译器协作等简单的内存管理任务。</p>
<p>在实际生产环境中是有用武之地的，比如以下两种情景：</p>
<ol>
<li>如果应用只需要运行数分钟或数秒，只要Java虚拟机能正确的分配内存，在堆耗尽之前就会退出，那显然没有任何回收行为的Epsilon就很合适。</li>
<li>需要剥离垃圾回收器影响的性能测试和压力测试</li>
</ol>
<h2 id="Java引用类型和垃圾回收的关系"><a href="#Java引用类型和垃圾回收的关系" class="headerlink" title="Java引用类型和垃圾回收的关系"></a>Java引用类型和垃圾回收的关系</h2><p>在Java中，引用类型可以分为四种：强引用、软引用、弱引用和虚引用。它们主要在对象的生命周期和垃圾回收方面有所区别。</p>
<ol>
<li>强引用（Strong Reference）：<br>当一个对象被强引用指向时，它不会被垃圾回收器回收。只有当强引用不再指向该对象时，该对象才有可能被回收。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>软引用（Soft Reference）：<br>当一个对象只被软引用指向时，它在内存不足时会被垃圾回收器回收。软引用主要用于实现缓存功能。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.SoftReference;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// obj 是一个强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj); <span class="comment">// softReference 是一个软引用</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>弱引用（Weak Reference）：<br>当一个对象只被弱引用指向时，它在下一次垃圾回收时就会被回收，而不考虑内存是否充足。弱引用主要用于实现弱映射（WeakHashMap）等数据结构。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.WeakReference;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>虚引用（Phantom Reference）：<br>当一个对象只被虚引用指向时，它可以被垃圾回收器回收。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.ref.PhantomReference;</span><br><span class="line"><span class="keyword">import</span> java.lang.ref.ReferenceQueue;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">PhantomReference&lt;Object&gt; phantomReference = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, referenceQueue);</span><br></pre></td></tr></table></figure>

<p>注：弱引用（Weak Reference）是比虚引用（Phantom Reference）更强的引用类型，因为它可以影响目标对象的生命周期。当一个对象只有弱引用指向它时，垃圾回收器会在下一次垃圾回收时回收这个对象，不考虑内存是否充足。而虚引用则完全不影响目标对象的生命周期，只是用于跟踪对象是否被回收。虚引用通常与<code>ReferenceQueue</code>一起使用，用于在目标对象被垃圾回收时得到通知，以便执行一些特定的清理操作。虚引用的存在不会阻止目标对象被回收，垃圾回收器会根据对象的其他引用类型（如强引用、软引用、弱引用）来决定是否回收目标对象。</p>
<p>总之，根据不同的引用类型，垃圾回收器会以不同的方式处理被引用的对象。强引用可以确保对象不被回收，而软引用、弱引用和虚引用则允许垃圾回收器在满足一定条件时回收对象。</p>
<h1 id="JVM的参数配置"><a href="#JVM的参数配置" class="headerlink" title="JVM的参数配置"></a>JVM的参数配置</h1><h2 id="JVM的参数"><a href="#JVM的参数" class="headerlink" title="JVM的参数"></a>JVM的参数</h2><table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
<th>使用示例</th>
</tr>
</thead>
<tbody><tr>
<td>-Xmx</td>
<td>设置JVM最大可用内存</td>
<td><code>java -Xmx2g MyApp</code> 将最大可用内存设置为2GB</td>
</tr>
<tr>
<td>-Xms</td>
<td>设置JVM最小可用内存</td>
<td><code>java -Xms512m MyApp</code> 将最小可用内存设置为512MB</td>
</tr>
<tr>
<td>-XX:MaxDirectMemorySize</td>
<td>设置JVM可以使用的最大堆外内存大小，其默认值等于JVM的最大堆大小（即<code>-Xmx</code>的值）</td>
<td><code>java -XX:MaxDirectMemorySize=1g -jar MyApp</code>设置JVM的最大堆外内存大小为1GB</td>
</tr>
<tr>
<td>-Xmn</td>
<td>指定了 JVM 中新生代的最大可用空间，它的默认值是整个堆空间的1&#x2F;4，即 <code>-Xmx</code> 的1&#x2F;4。当新生代的大小达到了 <code>-Xmn</code> 指定的大小后，如果新生代中仍然有存活的对象，它们将被晋升到老年代。</td>
<td><code>java -Xmn256m MyApp</code> 将新生代大小设置为256MB，</td>
</tr>
<tr>
<td>-XX:NewSize</td>
<td>设置新生代初始大小</td>
<td><code>java -XX:NewSize=256m Main</code>将新生代的大小设置为256MB</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>设置老年代初始大小</td>
<td><code>java -XX:PermSize=128m MyApp</code> 将永久代初始大小设置为128MB</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>设置老年代最大大小</td>
<td><code>java -XX:MaxPermSize=256m MyApp</code> 将永久代最大大小设置为256MB</td>
</tr>
<tr>
<td>-XX:NewRatio</td>
<td>设置新生代和老年代的比例</td>
<td><code>java -XX:NewRatio=2 MyApp</code> 将新生代和老年代的比例设置为1:2</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>设置新生代中eden区和survivor区的比例</td>
<td><code>java -XX:SurvivorRatio=8 MyApp</code> 将eden区和survivor区的比例设置为8:1</td>
</tr>
<tr>
<td>-XX:MetaspaceSize</td>
<td>设置元空间大小</td>
<td><code>java -XX:MetaspaceSize=256m MyApp</code> 将元空间大小设置为256MB</td>
</tr>
<tr>
<td>-XX:+UseG1GC</td>
<td>启用G1垃圾回收器</td>
<td><code>java -XX:+UseG1GC MyApp</code> 启用G1垃圾回收器</td>
</tr>
<tr>
<td>-XX:+UseConcMarkSweepGC</td>
<td>启用CMS垃圾回收器</td>
<td><code>java -XX:+UseConcMarkSweepGC MyApp</code> 启用CMS垃圾回收器</td>
</tr>
<tr>
<td>-XX:+HeapDumpOnOutOfMemoryError</td>
<td>当发生OOM异常时，自动生成堆转储文件（heap dump），以便在之后进行分析</td>
<td><code>java -XX:+HeapDumpOnOutOfMemoryError</code>当发生OOM异常时打印日志</td>
</tr>
<tr>
<td>-XX:HeapDumpPath&#x3D;path</td>
<td>指定生成堆转储文件的路径</td>
<td><code>-XX:HeapDumpPath=path=dump.log</code>指定OOM日志存储信息</td>
</tr>
<tr>
<td>-XX:+PrintGC</td>
<td>输出GC（垃圾回收）日志</td>
<td><code>-XX:+PrintGC</code></td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>输出GC详细信息</td>
<td><code>-XX:+PrintGCDetails</code></td>
</tr>
<tr>
<td>-XX:+PrintHeapAtGC</td>
<td>在每次GC后打印堆的详细信息</td>
<td><code>-XX:+PrintHeapAtGC</code></td>
</tr>
</tbody></table>
<h2 id="JVM参数设置示例"><a href="#JVM参数设置示例" class="headerlink" title="JVM参数设置示例"></a>JVM参数设置示例</h2><p>8G内存服务器上运行了start.jar和Netty，JVM参数设置示例如下</p>
<p>其中2GB留给操作系统，其余6GB分配给应用程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java -server #JVM运行在服务器模式下</span><br><span class="line">-XX:MaxDirectMemorySize #直接内存大小为2GB（Netty服务在运行时会使用直接内存，需要保证既有足够的直接内存满足Netty服务高效运行，又要在和虚拟机内存大小直接取得平衡）</span><br><span class="line">-Xmx3g -Xms3g #Java堆的大小为3GB</span><br><span class="line">--XX:NewSize #新生代占用堆1GB</span><br><span class="line">-XX:MetaspaceSize=128m #元空间的大小为128MB</span><br><span class="line">-XX:+UseG1GC #启用G1垃圾回收器</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError #发生OOM时打印日志</span><br><span class="line">-XX:HeapDumpPath=path=dump.log #指定OOM日志存储信息</span><br><span class="line">-XX:+PrintGCDetails #输出GC详细信息</span><br><span class="line">-XX:+PrintHeapAtGC #每次GC后打印堆的详细信息</span><br></pre></td></tr></table></figure>

<p>参数的含义如下：</p>
<ul>
<li><code>-server</code>：JVM运行在服务器模式下，以优化长时间运行的性能。</li>
<li><code>-Xmx6g</code>：设置JVM的最大堆大小为6GB。这个值可以根据应用程序的需要进行调整。</li>
<li><code>-Xms6g</code>：设置JVM的初始堆大小为6GB。这个值应该与 <code>-Xmx</code> 相同，以避免堆大小的动态调整。</li>
<li><code>-Xmn3g</code>：设置JVM的新生代大小为3GB，这个值可以根据应用程序的内存需求和垃圾收集策略来进行调整。</li>
<li><code>-XX:MetaspaceSize=512m</code>：设置JVM的元数据空间的初始大小为512MB。</li>
<li><code>-XX:MaxMetaspaceSize=512m</code>：设置JVM的元数据空间的最大大小为512MB，这个值可以根据应用程序的需要进行调整。</li>
<li><code>-XX:+UseG1GC</code>：使用 G1 垃圾收集器。G1 垃圾收集器是 JDK 9 及其之后版本的默认垃圾收集器，它以可预测的停顿时间和高效的内存回收著称。</li>
</ul>
<p>这些参数的设置应该根据具体的应用程序和系统配置进行调整，以获得最佳性能和稳定性。另外，可以使用一些诊断工具，如 jstat 和 jmap 等来监测 JVM 的运行状态和内存使用情况，以帮助优化 JVM 的性能和稳定性</p>
<h2 id="JVM性能分析工具（调优工具）"><a href="#JVM性能分析工具（调优工具）" class="headerlink" title="JVM性能分析工具（调优工具）"></a>JVM性能分析工具（调优工具）</h2><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="类加载阶段"><a href="#类加载阶段" class="headerlink" title="类加载阶段"></a>类加载阶段</h2><p>Java虚拟机（JVM）的类加载机制是Java程序运行时将.class文件加载到内存的过程。类加载主要分为五个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）和初始化（Initialization）。</p>
<ol>
<li><p>加载（Loading）: 在这个阶段，JVM将从文件系统或网络中查找指定的.class文件，然后将其二进制数据加载到内存中，创建一个Class对象来表示这个类。类加载器主要有三个：引导类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用类加载器（Application ClassLoader）。</p>
</li>
<li><p>验证（Verification）: JVM会对已加载的二进制数据进行校验，确保其符合Java语言规范和JVM规范。这个过程包括：文件格式验证、元数据验证、字节码验证和符号引用验证。验证阶段的目的是确保加载的类文件不会对JVM产生不良影响。</p>
</li>
<li><p>准备（Preparation）: 在这个阶段，JVM会为类的静态变量分配内存，并赋予默认值。注意这里的默认值不是程序员在代码中指定的初始值，而是基本类型的零值或引用类型的null值。</p>
<p>而对于final类型的静态变量，如果它们在编译时可以确定值（即编译时常量），JVM会在准备阶段直接为它们分配内存并赋予程序员在代码中指定的初始值。这是因为final变量的值在程序运行期间是不可变的，所以可以提前赋值。然而，如果一个final类型的静态变量不能在编译时确定值（例如，它的值是通过方法调用得到的），那么这个变量在准备阶段仍然会被赋予默认值，然后在初始化阶段由程序员指定的值替换。</p>
</li>
<li><p>解析（Resolution）: 解析阶段主要是将类、接口、字段和方法等符号引用替换为直接引用。这个过程可能会触发其他类的加载。</p>
<p>在Java程序中，类、接口、字段和方法等元素在源代码中的表示形式通常是符号引用（Symbolic Reference）。符号引用是一种依赖于符号（如类名、方法名和字段名等）的引用形式。然而，为了在运行时更高效地访问这些元素，JVM需要将这些符号引用替换为直接引用（Direct Reference）。</p>
<p>直接引用是一种可以直接指向内存地址或者间接指向内存地址的引用。在JVM中，直接引用可以是指向方法区（Method Area）中类和接口数据结构的指针、指向实例变量和类变量的内存地址的偏移量，或者是指向常量池中某个常量的索引。</p>
<p>符号引用和直接引用的区别在于，符号引用需要在运行时通过查找和解析得到实际的内存地址，而直接引用已经包含了实际的内存地址信息，可以直接访问目标元素。因此，使用直接引用可以提高程序运行时的访问速度。</p>
<p>在类加载的解析阶段，JVM负责将类、接口、字段和方法等符号引用替换为直接引用。这个过程可能会触发其他类的加载。需要注意的是，并非所有的符号引用都会在解析阶段被替换为直接引用，有些符号引用会在程序运行时进行动态解析。这通常发生在反射和动态代理等场景下。</p>
</li>
<li><p>初始化（Initialization）: 在这个阶段，JVM会根据程序员在代码中指定的初始值，为类的静态变量赋予正确的值。此外，如果类有静态代码块，JVM会执行这些代码块。初始化阶段是类加载过程中的最后一个阶段。</p>
</li>
</ol>
<h2 id="父子类加载和初始化顺序关系"><a href="#父子类加载和初始化顺序关系" class="headerlink" title="父子类加载和初始化顺序关系"></a>父子类加载和初始化顺序关系</h2><p>在JVM类加载阶段，父子类关系表现在加载和初始化过程。加载子类时，所有父类被加载。初始化时，父类先于子类初始化，确保子类使用父类静态字段和方法时，父类已初始化。</p>
<h2 id="类加载器和双亲委派模型"><a href="#类加载器和双亲委派模型" class="headerlink" title="类加载器和双亲委派模型"></a>类加载器和双亲委派模型</h2><p>JVM类加载器（Class Loader）负责将.class文件加载到内存，主要有四种：</p>
<ol>
<li>引导类加载器（Bootstrap ClassLoader）：负责加载位于%Java_HOME%&#x2F;lib下的Java核心类库，如java.util等</li>
<li>扩展类加载器（Extension ClassLoader）：负责加载位于%Java_HOME%&#x2F;jre&#x2F;lib&#x2F;ext目录下Java扩展库，或通过java.ext.dirs系统变量加载指定路径下的类库</li>
<li>应用类加载器（Application ClassLoader）：负责加载用户程序的类路径（classpath）下的类</li>
<li>自定义类加载器（User ClassLoader）：通过继承java.lang.ClassLoader类并重写 findClass 方法实现</li>
</ol>
<p>类加载器采用双亲委派模型（Parent-Delegation Model）。当加载类时，先请求父加载器加载；父加载器无法加载时，当前加载器尝试加载。这保证了Java核心类库安全与一致性，避免应用程序覆盖核心类库。</p>
<h2 id="OSGI"><a href="#OSGI" class="headerlink" title="OSGI"></a>OSGI</h2><p>OSGI（Open Service Gateway Initiative）是一个用于实现模块化和动态组件系统的开放标准框架。它允许在一个Java虚拟机（JVM）实例中创建和管理多个模块化组件，这些组件被称为“bundles”。OSGI提供了一种将Java应用程序分解为更小、更易于管理和维护的模块的方法，从而提高了开发人员的生产力和代码的可重用性。</p>
<p>OSGI的主要特点如下：</p>
<ol>
<li><p>模块化：OSGI框架支持将Java应用程序划分为多个模块，每个模块都可以独立开发、部署和更新，从而降低了开发复杂性和维护成本。</p>
</li>
<li><p>动态：OSGI支持动态加载、卸载和更新模块，这意味着在不重启整个应用程序的情况下，可以热部署模块，提高了系统的灵活性和可扩展性。</p>
</li>
<li><p>服务注册和发现：OSGI提供了一个服务注册表，允许模块之间通过服务接口进行通信，而不是直接依赖于其他模块的具体实现。这有助于降低模块间的耦合度，提高代码的可维护性和可重用性。</p>
</li>
<li><p>版本管理：OSGI允许同一个JVM中存在不同版本的模块，这样可以在升级或修复某个模块时避免对其他模块产生影响。</p>
</li>
</ol>
<p>OSGI已被广泛应用于各种Java项目中，例如Eclipse IDE（集成开发环境）就是基于OSGI构建的</p>
<p>OSGI不遵循双亲委派模型，在安全上有所牺牲</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://songbaoru.github.io/2023/05/02/Java%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="SBR">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="SBR Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | SBR Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/05/02/Java%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Java基础</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-05-02 21:23:04" itemprop="dateCreated datePublished" datetime="2023-05-02T21:23:04+08:00">2023-05-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2023-05-07 21:35:48" itemprop="dateModified" datetime="2023-05-07T21:35:48+08:00">2023-05-07</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h1><h2 id="字节流和字符流"><a href="#字节流和字符流" class="headerlink" title="字节流和字符流"></a>字节流和字符流</h2><blockquote>
<p>根据数据流向的方向不同，分为输入流和输出流</p>
</blockquote>
<p>IO流的输入\出源有控制台、文件、网络、数据库…</p>
<p>常用的IO流：分字节流（以字节，8bit为单位对数据进行读写操作）和字符流（以字符为单位，一个字符占2个字节）</p>
<p>输入字节流包含：文件（File）、对象（Object）、字节数组（ByteArray）、管道（Pipe）、过滤器（Filter）、缓冲字符串、顺序输入流（InputStream），都是InputStream（抽象类）的子类</p>
<p>输出字节流包含：文件（File）、对象（Object）、字节数组（ByteArray）、管道（Pipe）、过滤器（Filter）输出流（OutputStream），都是OutputStream（抽象类）的子类</p>
<p>输入字符流包含：字符数组（CharArray）、字符串（String）、其他输入流的缓冲区（Buffered）、管道（Piped）、过滤器（Filter）、将字节输入流转换为字符输入流（InputStream）Reader，都是Reader的子类（Reader是所有字符输入流的父类）</p>
<p>输出字符流包含：字符数组（CharArray）、字符串（String）、其他输出流的缓冲区（Buffered）、管道（Piped）、过滤器（Filter）、将字节输入流转换为字符输入流（InputStream）Writer，都是Writer的子类（Writer是所有字符输出流的父类）</p>
<h2 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h2><p>节点流是低级流，直接与数据源相连，并且进行读写；处理流是高级流，不直接和数据源相连（采用装饰器模式对节点流进行封装），主要用于消除不同节点实现上的差异。</p>
<p>节点流包含：FileInputStream、FileOutputStream、FileReader、FileWriter</p>
<p>处理流包含：BufferInputStream（<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/7/docs/api/java/io/FilterInputStream.html">FilterInputStream</a>的实现类）、BufferOutputStream、BufferReader、BufferWriter</p>
<p>处理流相比节点流的优点：通过增加缓存提高了数据输入和输出的效率、封装了一系列高级方法来完成一次性大批量数据的输入和输出</p>
<h2 id="内存映射文件技术"><a href="#内存映射文件技术" class="headerlink" title="内存映射文件技术"></a>内存映射文件技术</h2><p>含义：操作系统利用虚拟内存将文件映射到内存中，然后，这个文件就可以被当作内存数据来访问</p>
<p>关键技术优势：</p>
<ul>
<li>让操作系统负责文件的读写，应用程序只需要处理内存数据，就可以实现IO操作；</li>
<li>可以实现共享内存，内存映射文件可以被多个进程同时访问；内存映射文件技术涉及的内存在Java的堆空间之外；</li>
<li>大幅提升文件数据的输入输出速度</li>
</ul>
<p>Java的NIO包支持内存映射技术，实现方式是通过<strong>MapperdBytyBuffer</strong>读写内存</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SBR</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
