---
title: JVM底层原理
date: 2023-05-03 09:21:36
tags: JVM
---

> JVM（Java Virtual Machine）用于运行Java字节码

# JVM结构规范和执行流程

## JVM的结构及其作用

JVM 主要由以下部分组成：类加载器、运行时数据区、执行引擎和本地方法接口

1. 类加载器：类加载器负责将类文件（.class 文件）加载到 JVM 中，并生成对应的 Class 对象。类加载器是 JVM 的一个重要组成部分，它将类文件加载到 JVM 中，并根据需要进行链接、验证和初始化。类加载器按照类文件的位置、来源和访问权限等进行分类，通常分为三种类型：引导类加载器、扩展类加载器和应用程序类加载器。

2. 运行时数据区：运行时数据区即 JVM 内存，存储JVM在运行过程中产生的数据，它由多个不同的数据区域组成，包括方法区、堆、虚拟机栈、本地方法栈和程序计数器等。

   每个线程都有自己的虚拟机栈和本地方法栈，用于存储方法的参数、局部变量和返回值等信息。堆用于存储对象实例，方法区用于存储类信息、常量、静态变量和编译器生成的代码等。虚拟机栈用于管理Java方法的调用。而本地方法栈则用于管理native方法（例如Thread.start()）的调用

3. 执行引擎：Execution Engine 是 JVM 的核心组件，它负责执行在 JVM 中加载的字节码指令。它包括解释器和即时编译器两种执行方式。此外还包含垃圾回收器，用于内存管理，可以自动释放不再使用的内存空间

4. 本地方法接口：Native Method Interface 允许 Java 程序与底层的本地系统交互，例如调用 C/C++ 等语言编写的库

## HotSpot JVM内存模型

HotSpot JVM的JVM结构（可以划分为三类）：

线程私有区域

- Java虚拟机栈

  “栈内存”通常指的就是这里的Java虚拟机栈

  线程内存模型（栈帧）：存储了局部变量表、操作数栈、动态链接、方法出口等信息

  1. 局部变量表存储的信息
     1. 基本数据类型：局部变量表存储了基本数据类型的值，包括 int、long、float、double、byte、short 和 char。
     2. 对象引用：局部变量表还存储了对象引用，即指向对象实例在Java堆中的指针。对于类实例和数组，这些引用通常是指向堆内存中的对象实例的指针。
     3. returnAddress类型：returnAddress类型用于存储字节码指令的地址。当Java虚拟机执行到一个方法调用指令时，它会将下一条要执行的指令的地址保存到局部变量表。当方法执行完毕后，Java虚拟机通过局部变量表中保存的returnAddress返回到调用者的代码中继续执行。
  2. 局部变量表的容量以局部变量槽（Local Variable Slot）为单位进行度量。一个局部变量槽可以存储一个32位的数据类型（如int、float、reference和returnAddress），而64位的数据类型（如long和double）则需要两个连续的局部变量槽来存储。

  处理动态链接方法的返回值和异常处理分派

  记录了方法的执行过程

- 本地方法栈

  本地方法栈和Java虚拟机栈唯一的不同是，本地方法栈存储的是Native方法的数据，Java虚拟机栈存储的是Java方法的数据

- 程序计数器

  如果该线程执行的是Native方法，则程序计数器的值为空

线程共享区域：

- Java堆

  JVM运行过程中创建的对象几乎都会被存储在堆中。

  是垃圾收集器管理的内存区域，又称“GC堆”。由于JVM采用分代回收算法，Java 堆从GC（Garbage Collection）的角度还可以细分为新生代（Eden、SurvivorTo、SurvivorFrom）、老年代

- 方法区（元空间）

  常量、静态变量、即时编译器编译后的代码、类型信息缓存等数据

直接内存

又称“堆外内存”，NIO（New Input/Output）类引入了一种基于通道（Channel）和缓冲区（Buffer）的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作，避免在Java堆和Native堆中来回复制数据。

## JVM执行Java程序的流程

运行一个Java程序时，JVM执行以下步骤：

1. 编译：首先，Java源代码（.java文件）需要被编译成字节码（.class文件）。编译过程由Java编译器（javac）完成。编译器会将Java源代码转换成与平台无关的字节码文件。

2. 类加载阶段
   1. 加载：在程序运行时，JVM负责加载字节码文件。这一过程由类加载器（ClassLoader）负责。类加载器首先查找并加载类文件，然后将字节码转换为JVM内部的数据结构。

   2. 验证：字节码文件加载后，JVM会对其进行验证，确保代码是安全和符合规范的。验证过程包括检查字节码的结构、数据类型、操作数栈等。若字节码不符合规范，JVM将拒绝执行。

   3. 准备：验证通过后，JVM为类中的静态变量分配内存并设置默认值。这一过程确保在初始化阶段为静态变量赋值时已有可用的内存。

   4. 解析：JVM对类的符号引用进行解析，将它们替换为实际的内存地址。这包括将类、字段、方法等的引用转换为具体的内存地址或偏移量。

   5. 初始化：在解析完成后，JVM执行类的初始化代码。这包括执行静态初始化块和为静态变量赋值。初始化阶段确保类在使用前已经被正确初始化。

3. 解释执行：JVM开始执行字节码。字节码由JVM的解释器逐条解释执行，或通过即时编译器（JIT）编译成本地代码后执行。JVM管理内存、线程、异常处理等，确保程序能够在一个独立的运行时环境中运行。

4. 垃圾回收：在程序运行过程中，JVM负责管理内存。当对象不再被引用时，垃圾回收器（Garbage Collector）会自动回收其占用的内存，确保内存的有效利用。

5. 结束：当程序执行完成或遇到异常时，JVM将执行结束操作。这包括释放内存、关闭资源、销毁线程等。最后，JVM退出并结束运行。

# 垃圾回收理论

## 判断一个对象是否存活的算法

- 引用计数算法
- 可达性分析算法

## 分代回收理论

分代收集理论建立在两个假说之上，分别是弱分代假说和强分代假说

根据对象的生命周期将内存分为新生代和老年代两个部分。优先回收新生代中的对象，减少全局垃圾回收的次数，提高效率。  回收效率高，不容易产生内存碎片。缺点是需要对内存进行分代管理，增加了复杂性。

## Apple式回收

Apple式回收（基于分代收集理论和标记复制算法）：把新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和一块Survivor。发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上。然后直接清理掉Eden和已经使用过的那块Survivor。当存储存活对象的Survivor不足以容纳所有的存活对象，Apple式回收就使用其他内存区域（大多是老年代）进行分配担保。

## 垃圾回收类型

- 部分收集
  - 新生代收集（Minor GC）
  - 老年代收集（Major GC）
- 整堆收集（Full GC）

## 垃圾回收算法

判断对象是否“存活”的方法有引用计数算法和可达性分析法。

| 名称          | 时间         | 基本原理                                                     | 优点                             | 缺点                                                         | 适用场景                                                     |
| ------------- | ------------ | ------------------------------------------------------------ | -------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 标记-清除算法 | 20世纪50年代 | 标记所有活动对象，然后清除所有未标记的对象。 也可以反过来。 是最基础的垃圾收集算法，后续的回收算法大都是以标记-清除算法为基础，对其缺点进行改进得到的。 | 简单易懂，可处理循环引用的情况。 | 效率不稳定，容易产生内存碎片。                               | 由于，不需要内存移动，所以再内存回收时延迟低，关注延迟的CMS收集器则是基于标记-清除算法的，不过CMS收集器面临空间碎片过多时，会采用标记-整理算法清除一次。（用于老年代） |
| 标记-复制算法 | 20世纪60年代 | 将内存分成已使用（From）和空闲（To）区域。在垃圾回收时，将存活的对象从 From 区域复制到 To 区域，然后清空 From 区域。现在的商业虚拟机都采用这种收集算法来回收新生代。 | 不容易产生内存碎片。             | 浪费一半内存空间。如果多数对象都是存活的，就会产生大量内存间的复制开销 | 由于，如果多数对象都是可回收的，需要复制的只是占少数的存活对象。所以适合新生代。现在的商用虚拟机大多优先采用这种算法回收新生代。（用于新生代） |
| 标记-整理算法 | 20世纪60年代 | 其标记过程仍然和标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向内存空间的一端移动，然后直接清理掉边界外的内存。 | 不容易产生内存碎片。             | 需要移动对象，可能会造成较长的停顿时间。                     | 由于，是否移动内存是优缺点并存的，移动则内存回收时会耗时，不移动则内存分配时会耗时。如果不移动内存，即使垃圾收集器的效率提高一些，则因为内存分配和访问比垃圾收集频率要高得多，这部分耗时增加，总的吞吐量仍然会下降。所以，关注吞吐量的Parallel Old是基于标记-整理算法的。（用于老年代） |

## HotSpot垃圾回收算法实现细节

根节点

安全点

并发可达性分析

# 垃圾回收器

Java 的垃圾回收器有多种实现方式，每种垃圾回收器都有其独特的特点和适用场景。

## 垃圾收集器下的并行和并发

- 并行：描述的是多条垃圾收集器线程之间的关系
- 并发：描述的是垃圾收集器和用户线程之间的关系

## 经典垃圾回收器

这里讨论的经典垃圾收集器是JDK7 Update4之后，JDK11正式发布之前，OracleJDK和HotSpot虚拟机所包含的全部可用的垃圾收集器。

### 新生代垃圾回收器

所有的新生代的垃圾回收器都是复制算法

| **收集器**        | **收集对象和算法** | **收集器类型**     | 优点                                          | 缺点               | 描述                                                         |
| ----------------- | ------------------ | ------------------ | --------------------------------------------- | ------------------ | ------------------------------------------------------------ |
| Serial            | 新生代，复制算法   | 单线程             | 所有收集器中内存消耗最小的                    | 用户线程停顿时间长 | 单线程强调的是它在垃圾收集时，必须暂停其他所有工作线程，知道它收集完成。是HotSpot虚拟机运行在客户端模式下默认新生代收集器。适合处理器核心较少的环境。 |
| ParNew            | 新生代，复制算法   | 并行的多线程收集器 | 只有ParNew能和CMS配合使用。有自适应的调节策略 |                    | 实际上是Serial的多线程版本，除了同时使用多条线程进行垃圾收集外，其余都和Serial一样。默认开启和处理器核心数量相同的线程数，在目前服务器CPU往往达到32核核环境下，可以适用-XX:ParallelGCThreads参数来限制。 |
| Parallel Scavenge | 新生代，复制算法   | 并行的多线程收集器 | 吞吐量高                                      |                    | Parallel Scavenge的特点是它的关注点和其它收集器不同，Parallel Scavenge关注点是吞吐量，所谓吞吐量就是处理器用于运行用户代码的时间和处理器总消耗时间的比值。其合适的搭配是Parallel Old |

### 老年代垃圾收集器

老年代会有两种算法，标记整理算法 和 标记清除算法

| **收集器**   | **收集对象和算法**   | **收集器类型**     | 优点                                                         | 缺点                                                         | 描述                                                         |
| ------------ | -------------------- | ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| Serial Old   | 老年代，标记整理算法 | 单线程             |                                                              |                                                              | 是Serial的老年代版本                                         |
| Parallel Old | 老年代，标记整理算法 | 并行的多线程收集器 |                                                              |                                                              | 是Parallel Scavenge的老年代版本                              |
| CMS          | 老年代，标记清除算法 | 并行与并发收集器   | 是一种以获取最短用户线程停顿时间为目标的收集器，适合关注服务响应速度的场景 | 内存碎片：标记清除的回收方法会导致内存碎片，影响大对象分配。 CPU资源消耗：并发执行需占用额外CPU资源，可能影响总体性能。 浮动垃圾：无法处理并发标记阶段产生的新垃圾，可能导致内存浪费。 预测性能不稳定：基于触发条件，设置不合理时可能导致停顿时间过长。 长时间Full GC：某些情况下，CMS无法回收足够空间，触发Full GC，导致停顿。 实现复杂：相对其他收集器，CMS实现复杂，维护困难，可能出现错误或性能问题。 | 运作过程相对复杂，整个过程分为四步：初始标记、并发标记、重新标记、并发清除。 |

### 全功能垃圾收集器

| **收集器** | **收集对象和算法**         | **收集器类型**   | 优点                                                         | 缺点 | 描述                                                         |
| ---------- | -------------------------- | ---------------- | ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| G1         | 跨新生代和老年代；化整为零 | 并行与并发收集器 | 回收的最小单元不再是固定大小的新生代和老年代，而是Region，进而采用具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。 |      | 开创了面向局部收集的设计思路和基于Region的内存布局形式，不再以固定大小及固定数量的分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一杠Region根据需要，扮演新生代的Eden空间、Survior区间，或者老年代空间。并对不同角色的Region采用不同的策略去处理。Region中还有一类特殊的区域，Humongous，用来存储大对象。G1在大内存应用上表现好，CMS在小内存应用上表现优于G1。G1 垃圾收集器是 JDK 9 及其之后版本的默认垃圾收集器。 |

## 低延迟垃圾回收器

Shenandoah （*ˌʃɛnənˈdoʊə*）和ZGC两款垃圾收集器在几乎整个工作时间里都是并发的，而CMS和G1在回收新生代的垃圾时必须挂起用户线程。并且这两款垃圾收集器可以在任意可管理的堆容量下实现垃圾收集的停顿不超过十毫秒。

Shenandoah垃圾回收器是一款只有OpenJDK才会包含，而OracleJDK里不存在的收集器，Shenandoah和G1有着相似的堆内存布局，是基于G1开发的，并对G1的一些不足进行了改进

ZGC是一款基于Region内存布局的，使用了读屏障、染色体指针和内存多重映射等技术来实现可并发的标记-整理算法，以低延迟为首要目标的垃圾收集器

## 不进行垃圾回收的垃圾收集器

Epsilon 垃圾回收器是一款以不进行垃圾回收的垃圾回收器，只复责分配和释放内存空间、与解释器协作、与编译器协作等简单的内存管理任务。

在实际生产环境中是有用武之地的，比如以下两种情景：

1. 如果应用只需要运行数分钟或数秒，只要Java虚拟机能正确的分配内存，在堆耗尽之前就会退出，那显然没有任何回收行为的Epsilon就很合适。
2. 需要剥离垃圾回收器影响的性能测试和压力测试

## Java引用类型和垃圾回收的关系

在Java中，引用类型可以分为四种：强引用、软引用、弱引用和虚引用。它们主要在对象的生命周期和垃圾回收方面有所区别。

1. 强引用（Strong Reference）：
当一个对象被强引用指向时，它不会被垃圾回收器回收。只有当强引用不再指向该对象时，该对象才有可能被回收。

```java
Object obj = new Object();
```

2. 软引用（Soft Reference）：
当一个对象只被软引用指向时，它在内存不足时会被垃圾回收器回收。软引用主要用于实现缓存功能。

```java
import java.lang.ref.SoftReference;
Object obj = new Object(); // obj 是一个强引用
SoftReference<Object> softReference = new SoftReference<>(obj); // softReference 是一个软引用
```

3. 弱引用（Weak Reference）：
  当一个对象只被弱引用指向时，可以被垃圾回收器回收，而不考虑内存是否充足。弱引用主要用于实现弱映射（WeakHashMap）等数据结构，如ThreadLocal的实现就使用了弱引用。若是强引用，即使tl=null ，但key的引用依然指向ThreadLocal对象，所以会有内存泄漏，而使用弱引用则不会。具体来说，`ThreadLocal`由一个名为`ThreadLocal.ThreadLocalMap`的内部类来保存。在`ThreadLocalMap`中，set到`ThreadLocal`对象的值作为值（value），`ThreadLocal`对象作为键（key），并且key是一个弱引用。这意味着，如果`ThreadLocal`对象没有其他强引用存在，那么这个`ThreadLocal`对象就可能在下一次垃圾回收时被回收。但还是有内存泄漏存在，ThreadLocal被回收，key的值变成null，则导致整个value再也无法被访问到，因此依然存在内存泄漏，所以还是需要remve()这个key。

```java
import java.lang.ref.WeakReference;
Object obj = new Object();
WeakReference<Object> weakReference = new WeakReference<>(obj);
```

4. 虚引用（Phantom Reference）：
当一个对象只被虚引用指向时，它只是用于跟踪对象是否被回收，可以被垃圾回收器回收。主要用于管理堆外内存，通常和ReferenceQueue结合使用，当DirectByteBuffer对象被回收时，就向ReferenceQueue对象中添加数据，垃圾回收器可以通过检测ReferenceQueue对象得到到这一变化，然后清理堆外内存。和弱引用的区别是弱引用中的对象可以被弱引用变量get到，但是虚引用引用的变量不能被get到。

```java
import java.lang.ref.PhantomReference;
import java.lang.ref.ReferenceQueue;
Object obj = new Object();
ReferenceQueue<Object> referenceQueue = new ReferenceQueue<>();
PhantomReference<Object> phantomReference = new PhantomReference<>(obj, referenceQueue);
```

# JVM的参数配置

## JVM的参数

| 参数名                          | 描述                                                         | 使用示例                                                     |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| -Xmx                            | 设置JVM最大可用内存                                          | `java -Xmx2g MyApp` 将最大可用内存设置为2GB                  |
| -Xms                            | 设置JVM最小可用内存                                          | `java -Xms512m MyApp` 将最小可用内存设置为512MB              |
| -XX:MaxDirectMemorySize         | 设置JVM可以使用的最大堆外内存大小，其默认值等于JVM的最大堆大小（即`-Xmx`的值） | `java -XX:MaxDirectMemorySize=1g -jar MyApp`设置JVM的最大堆外内存大小为1GB |
| -Xmn                            | 指定了 JVM 中新生代的最大可用空间，它的默认值是整个堆空间的1/4，即 `-Xmx` 的1/4。当新生代的大小达到了 `-Xmn` 指定的大小后，如果新生代中仍然有存活的对象，它们将被晋升到老年代。 | `java -Xmn256m MyApp` 将新生代大小设置为256MB，              |
| -XX:NewSize                     | 设置新生代初始大小                                           | `java -XX:NewSize=256m Main`将新生代的大小设置为256MB        |
| -XX:PermSize                    | 设置老年代初始大小                                           | `java -XX:PermSize=128m MyApp` 将永久代初始大小设置为128MB   |
| -XX:MaxPermSize                 | 设置老年代最大大小                                           | `java -XX:MaxPermSize=256m MyApp` 将永久代最大大小设置为256MB |
| -XX:NewRatio                    | 设置新生代和老年代的比例                                     | `java -XX:NewRatio=2 MyApp` 将新生代和老年代的比例设置为1:2  |
| -XX:SurvivorRatio               | 设置新生代中eden区和survivor区的比例                         | `java -XX:SurvivorRatio=8 MyApp` 将eden区和survivor区的比例设置为8:1 |
| -XX:MetaspaceSize               | 设置元空间大小                                               | `java -XX:MetaspaceSize=256m MyApp` 将元空间大小设置为256MB  |
| -XX:+UseG1GC                    | 启用G1垃圾回收器                                             | `java -XX:+UseG1GC MyApp` 启用G1垃圾回收器                   |
| -XX:+UseConcMarkSweepGC         | 启用CMS垃圾回收器                                            | `java -XX:+UseConcMarkSweepGC MyApp` 启用CMS垃圾回收器       |
| -XX:+HeapDumpOnOutOfMemoryError | 当发生OOM异常时，自动生成堆转储文件（heap dump），以便在之后进行分析 | `java -XX:+HeapDumpOnOutOfMemoryError`当发生OOM异常时打印日志 |
| -XX:HeapDumpPath=path           | 指定生成堆转储文件的路径                                     | `-XX:HeapDumpPath=path=dump.log`指定OOM日志存储信息          |
| -XX:+PrintGC                    | 输出GC（垃圾回收）日志                                       | `-XX:+PrintGC`                                               |
| -XX:+PrintGCDetails             | 输出GC详细信息                                               | `-XX:+PrintGCDetails`                                        |
| -XX:+PrintHeapAtGC              | 在每次GC后打印堆的详细信息                                   | `-XX:+PrintHeapAtGC`                                         |



## JVM参数设置示例

8G内存服务器上运行了start.jar和Netty，JVM参数设置示例如下

其中2GB留给操作系统，其余6GB分配给应用程序

```shell
java -server #JVM运行在服务器模式下
-XX:MaxDirectMemorySize #直接内存大小为2GB（Netty服务在运行时会使用直接内存，需要保证既有足够的直接内存满足Netty服务高效运行，又要在和虚拟机内存大小直接取得平衡）
-Xmx3g -Xms3g #Java堆的大小为3GB
--XX:NewSize #新生代占用堆1GB
-XX:MetaspaceSize=128m #元空间的大小为128MB
-XX:+UseG1GC #启用G1垃圾回收器
-XX:+HeapDumpOnOutOfMemoryError #发生OOM时打印日志
-XX:HeapDumpPath=path=dump.log #指定OOM日志存储信息
-XX:+PrintGCDetails #输出GC详细信息
-XX:+PrintHeapAtGC #每次GC后打印堆的详细信息
```

参数的含义如下：

- `-server`：JVM运行在服务器模式下，以优化长时间运行的性能。
- `-Xmx6g`：设置JVM的最大堆大小为6GB。这个值可以根据应用程序的需要进行调整。
- `-Xms6g`：设置JVM的初始堆大小为6GB。这个值应该与 `-Xmx` 相同，以避免堆大小的动态调整。
- `-Xmn3g`：设置JVM的新生代大小为3GB，这个值可以根据应用程序的内存需求和垃圾收集策略来进行调整。
- `-XX:MetaspaceSize=512m`：设置JVM的元数据空间的初始大小为512MB。
- `-XX:MaxMetaspaceSize=512m`：设置JVM的元数据空间的最大大小为512MB，这个值可以根据应用程序的需要进行调整。
- `-XX:+UseG1GC`：使用 G1 垃圾收集器。G1 垃圾收集器是 JDK 9 及其之后版本的默认垃圾收集器，它以可预测的停顿时间和高效的内存回收著称。

这些参数的设置应该根据具体的应用程序和系统配置进行调整，以获得最佳性能和稳定性。另外，可以使用一些诊断工具，如 jstat 和 jmap 等来监测 JVM 的运行状态和内存使用情况，以帮助优化 JVM 的性能和稳定性

## JVM性能分析工具（调优工具）

常用的工具有jps、jinfo、jstat、jstack、jmap等，这些工具包含在JDK（Java Development Kit）的`bin`目录中，因此需要安装JDK才能使用

### jps

用于查看正在运行的Java进程及其相关信息（进程id、虚拟机参数如端口号和可用内存大小、jar包名称）

`jps`的基本语法如下：

```shell
jps [options] [hostid]
```

`options`表示可选的参数，`hostid`表示远程主机的ID，如果不指定则默认为本地主机。以下是一些常用的`jps`选项：

- `-l`：显示完整的包名和主类名。
- `-m`：显示传递给Java进程的参数。
- `-v`：显示传递给JVM的参数。
- `-q`：仅显示Java进程的ID，不显示类名、JAR名称和传递给Java进程的参数。

### jinfo

`jinfo`（Java Configuration Info Tool）是一个Java命令行工具，用于获取Java虚拟机（JVM）进程的配置信息，如系统属性和JVM参数

`jinfo`的基本语法如下：

```
jinfo [option] pid
```

- `option`：表示可选的参数，如获取系统属性、JVM参数等。
- `pid`：表示要获取配置信息的Java虚拟机进程的ID。

以下是一些常用的`jinfo`选项：

- `-flag`：显示或修改指定的JVM参数。
- `-sysprops`：显示Java系统属性。
- `-flags`：显示JVM参数。

举个例子，要获取一个Java进程（假设其进程ID为12345）的Java系统属性，可以运行以下命令：

```shell
jinfo -sysprops 12345
```

这个命令会输出Java进程的所有Java系统属性，如`java.version`、`java.vendor`、`java.home`等。您可以根据这些信息了解Java进程的运行环境和配置。

另一个例子，要查看一个Java进程（假设其进程ID为12345）的JVM参数，可以运行以下命令：

```shell
jinfo -flags 12345
```

这个命令会输出Java进程的所有JVM参数，如`-Xmx`、`-Xms`、`-XX:+UseParallelGC`等。您可以根据这些信息了解和优化Java进程的JVM配置。

### jstat

用于监控JVM内存使用情况和垃圾回收情况

`jstat`的基本语法如下：

```shell
jstat [option] [vmid] [interval] [count]
```

- `option`：表示要收集的统计信息类型，如垃圾回收、类加载等。
- `vmid`：表示要监控的Java虚拟机进程的ID。
- `interval`：表示数据收集的时间间隔（以毫秒为单位），可选参数。
- `count`：表示要收集的数据点数目，可选参数。

以下是一些常用的`jstat`选项：

- `-class`：显示关于类加载器的统计信息。
- `-compiler`：显示关于即时编译的统计信息。
- `-gc`：显示关于垃圾回收的统计信息。
- `-gccapacity`：显示关于垃圾回收的各个内存区域的容量。
- `-gcutil`：显示关于垃圾回收的各个内存区域的使用情况。
- `-gcnew`：显示关于新生代垃圾回收的统计信息。
- `-gcold`：显示关于老年代垃圾回收的统计信息。

举个例子，要收集一个Java进程（假设其进程ID为12345）的垃圾回收统计信息，每隔1000毫秒收集一次，总共收集10次，可以运行以下命令：

```shell
jstat -gc 12345 1000 10
```

这个命令会输出一系列关于垃圾回收的统计信息，如内存区域的大小、已使用空间、垃圾回收次数等。

### jstack

用于生成虚拟机当前时刻的线程快照，目的通常是定位线程出现长时间停顿的原因。对于诊断Java应用程序的线程问题、锁竞争和死锁等问题非常有用。

`jstack`的基本语法如下：

```
jstack [option] pid
```

- `option`：表示可选的参数，如打印锁信息等。
- `pid`：表示要获取堆栈跟踪信息的Java虚拟机进程的ID。

以下是一些常用的`jstack`选项：

- `-l`：显示关于锁的附加信息，如已拥有的锁、等待的锁等。
- `-m`：显示关于本地方法的堆栈跟踪信息（仅适用于部分平台）。
- `-F`：强制执行堆栈跟踪，当正常执行失败时使用（仅适用于部分平台）。

举个例子，要获取一个Java进程（假设其进程ID为12345）的线程堆栈跟踪信息，可以运行以下命令：

```shell
jstack 12345
```

这个命令会输出Java进程的所有线程的堆栈跟踪信息，包括线程ID、线程状态、调用栈等。您可以根据这些信息诊断和解决应用程序中的线程问题。



### jmap

`jmap`（Java Memory Map Tool）是一个Java命令行工具，用于获取Java虚拟机（JVM）进程的内存映射信息。它可以帮助您分析Java堆（heap）、永久代（PermGen，仅JDK 7及更早版本）或元空间（Metaspace，JDK 8及更高版本）的使用情况，从而诊断和解决内存泄漏、内存溢出等问题

`jmap`的基本语法如下：

```
jmap [option] pid
```

- `option`：表示要执行的操作，如获取堆信息、生成堆转储文件等。
- `pid`：表示要获取内存映射信息的Java虚拟机进程的ID。

以下是一些常用的`jmap`选项：

- `-dump`：生成堆转储文件（heap dump），可以使用内存分析工具（如Eclipse MAT）对其进行进一步分析。
- `-histo`：显示堆中对象的实例数量、内存占用和类名等信息的直方图。
- `-heap`：显示堆的摘要信息，如使用的垃圾回收器、内存区域的大小和使用情况等。
- `-permstat`：显示永久代（PermGen）的类加载器、内存占用和类名等信息的统计信息（仅适用于JDK 7及更早版本）。
- `-clstats`：显示类加载器和系统类的统计信息。
- `-finalizerinfo`：显示在队列中等待执行的终结器方法的对象的信息。

举个例子，要为一个Java进程（假设其进程ID为12345）生成堆转储文件，并将其保存到当前目录下的`heapdump.hprof`文件中，可以运行以下命令：

```shell
jmap -dump:format=b,file=heapdump.hprof 12345
```

这个命令会生成一个堆转储文件，其中包含了Java进程的内存使用情况。您可以使用内存分析工具（如Eclipse MAT）对其进行进一步分析，以诊断和解决内存相关问题。

# 类加载机制

## 类加载阶段

Java虚拟机（JVM）的类加载机制是Java程序运行时将.class文件加载到内存的过程。类加载主要分为五个阶段：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）和初始化（Initialization）。

1. 加载（Loading）: 在这个阶段，JVM将从文件系统或网络中查找指定的.class文件，然后将其二进制数据加载到内存中，创建一个Class对象来表示这个类。类加载器主要有三个：引导类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用类加载器（Application ClassLoader）。

2. 验证（Verification）: JVM会对已加载的二进制数据进行校验，确保其符合Java语言规范和JVM规范。这个过程包括：文件格式验证、元数据验证、字节码验证和符号引用验证。验证阶段的目的是确保加载的类文件不会对JVM产生不良影响。

3. 准备（Preparation）: 在这个阶段，JVM会为类的静态变量分配内存，并赋予默认值。注意这里的默认值不是程序员在代码中指定的初始值，而是基本类型的零值或引用类型的null值。

   而对于final类型的静态变量，如果它们在编译时可以确定值（即编译时常量），JVM会在准备阶段直接为它们分配内存并赋予程序员在代码中指定的初始值。这是因为final变量的值在程序运行期间是不可变的，所以可以提前赋值。然而，如果一个final类型的静态变量不能在编译时确定值（例如，它的值是通过方法调用得到的），那么这个变量在准备阶段仍然会被赋予默认值，然后在初始化阶段由程序员指定的值替换。

4. 解析（Resolution）: 解析阶段主要是将类、接口、字段和方法等符号引用替换为直接引用。这个过程可能会触发其他类的加载。

   在Java程序中，类、接口、字段和方法等元素在源代码中的表示形式通常是符号引用（Symbolic Reference）。符号引用是一种依赖于符号（如类名、方法名和字段名等）的引用形式。然而，为了在运行时更高效地访问这些元素，JVM需要将这些符号引用替换为直接引用（Direct Reference）。

   直接引用是一种可以直接指向内存地址或者间接指向内存地址的引用。在JVM中，直接引用可以是指向方法区（Method Area）中类和接口数据结构的指针、指向实例变量和类变量的内存地址的偏移量，或者是指向常量池中某个常量的索引。

   符号引用和直接引用的区别在于，符号引用需要在运行时通过查找和解析得到实际的内存地址，而直接引用已经包含了实际的内存地址信息，可以直接访问目标元素。因此，使用直接引用可以提高程序运行时的访问速度。

   在类加载的解析阶段，JVM负责将类、接口、字段和方法等符号引用替换为直接引用。这个过程可能会触发其他类的加载。需要注意的是，并非所有的符号引用都会在解析阶段被替换为直接引用，有些符号引用会在程序运行时进行动态解析。这通常发生在反射和动态代理等场景下。

5. 初始化（Initialization）: 在这个阶段，JVM会根据程序员在代码中指定的初始值，为类的静态变量赋予正确的值。此外，如果类有静态代码块，JVM会执行这些代码块。初始化阶段是类加载过程中的最后一个阶段。

## 父子类加载和初始化顺序关系

在JVM类加载阶段，父子类关系表现在加载和初始化过程。加载子类时，所有父类被加载。初始化时，父类先于子类初始化，确保子类使用父类静态字段和方法时，父类已初始化。

## 类加载器和双亲委派模型

JVM类加载器（Class Loader）负责将.class文件加载到内存，主要有四种：

1. 引导类加载器（Bootstrap ClassLoader）：负责加载位于%Java_HOME%/lib下的Java核心类库，如java.util等
2. 扩展类加载器（Extension ClassLoader）：负责加载位于%Java_HOME%/jre/lib/ext目录下Java扩展库，或通过java.ext.dirs系统变量加载指定路径下的类库
3. 应用类加载器（Application ClassLoader）：负责加载用户程序的类路径（classpath）下的类
4. 自定义类加载器（User ClassLoader）：通过继承java.lang.ClassLoader类并重写 findClass 方法实现

类加载器采用双亲委派模型（Parent-Delegation Model）。当加载类时，先请求父加载器加载；父加载器无法加载时，当前加载器尝试加载。这保证了Java核心类库安全与一致性，避免应用程序覆盖核心类库。

## OSGI

OSGI（Open Service Gateway Initiative）是一个用于实现模块化和动态组件系统的开放标准框架。它允许在一个Java虚拟机（JVM）实例中创建和管理多个模块化组件，这些组件被称为“bundles”。OSGI提供了一种将Java应用程序分解为更小、更易于管理和维护的模块的方法，从而提高了开发人员的生产力和代码的可重用性。

OSGI的主要特点如下：

1. 模块化：OSGI框架支持将Java应用程序划分为多个模块，每个模块都可以独立开发、部署和更新，从而降低了开发复杂性和维护成本。

2. 动态：OSGI支持动态加载、卸载和更新模块，这意味着在不重启整个应用程序的情况下，可以热部署模块，提高了系统的灵活性和可扩展性。

3. 服务注册和发现：OSGI提供了一个服务注册表，允许模块之间通过服务接口进行通信，而不是直接依赖于其他模块的具体实现。这有助于降低模块间的耦合度，提高代码的可维护性和可重用性。

4. 版本管理：OSGI允许同一个JVM中存在不同版本的模块，这样可以在升级或修复某个模块时避免对其他模块产生影响。

OSGI已被广泛应用于各种Java项目中，例如Eclipse IDE（集成开发环境）就是基于OSGI构建的

OSGI不遵循双亲委派模型，在安全上有所牺牲
